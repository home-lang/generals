// C&C Generals Zero Hour - Home Port
// In-Game HUD (Heads-Up Display)
//
// Original: InGameUI.cpp, ControlBar.cpp (Westwood Studios/EA)
// Ported to Home with C&C Generals HUD layout

import basics/allocator
import ui/ui_framework
import game/unit
import game/building
import game/economy

// HUD layout constants (based on 1024x768 resolution)
const HUD_HEIGHT: i32 = 180
const COMMAND_PANEL_WIDTH: i32 = 400
const RESOURCE_BAR_HEIGHT: i32 = 40
const PORTRAIT_SIZE: i32 = 140

// Command button types
enum CommandButtonType {
    None
    ProduceUnit
    BuildStructure
    UpgradeTech
    SpecialPower
    SetRallyPoint
    Sell
    Repair
    Stop
    AttackMove
    Guard
    Formation
    Stance
}

// Command button
struct CommandButton {
    button: Button
    command_type: CommandButtonType
    unit_type: ?UnitType
    building_type: ?BuildingType
    hotkey: string
    cost: i32
    build_time: f32

    // State
    is_available: bool
    is_building: bool
    build_progress: f32

    fn init(allocator: Allocator, command_type: CommandButtonType): CommandButton {
        return CommandButton {
            button: Button.init(allocator, 0, "")
            command_type: command_type
            unit_type: null
            building_type: null
            hotkey: ""
            cost: 0
            build_time: 0.0
            is_available: true
            is_building: false
            build_progress: 0.0
        }
    }

    fn set_unit_production(mut self, unit_type: UnitType, cost: i32, build_time: f32, hotkey: string) {
        self.unit_type = unit_type
        self.cost = cost
        self.build_time = build_time
        self.hotkey = hotkey
        self.button.window.text = get_unit_name(unit_type)
    }

    fn set_building_construction(mut self, building_type: BuildingType, cost: i32, build_time: f32, hotkey: string) {
        self.building_type = building_type
        self.cost = cost
        self.build_time = build_time
        self.hotkey = hotkey
        self.button.window.text = get_building_name(building_type)
    }
}

// In-game HUD
struct InGameHUD {
    root: *Window

    // Resource display (top)
    resource_panel: *Panel
    supplies_label: *Label
    power_label: *Label
    income_label: *Label

    // Control bar (bottom)
    control_bar: *Panel

    // Command panel (bottom right)
    command_panel: *Panel
    command_buttons: [15]*CommandButton  // 3x5 grid
    command_button_count: usize

    // Unit portrait (bottom left)
    portrait_panel: *Panel
    unit_name_label: *Label
    unit_health_bar: *Panel
    veterancy_stars: *Panel

    // Selected units list (left of portrait)
    selection_panel: *Panel
    selection_icons: [12]*Panel  // 3x4 grid of unit icons

    // Minimap (bottom left corner)
    minimap_panel: *Panel

    // Build queue (bottom center)
    build_queue_panel: *Panel
    build_queue_slots: [5]*Panel

    // Message log (top left)
    message_log: *Panel
    messages: [10]string
    message_count: usize

    // Context menu (right click)
    context_menu: ?*Panel

    allocator: Allocator

    fn init(allocator: Allocator, window_mgr: *WindowManager): InGameHUD {
        let mut hud = InGameHUD {
            root: window_mgr.create_window("HUDRoot", 0, 0, 1024, 768).?
            resource_panel: null
            supplies_label: null
            power_label: null
            income_label: null
            control_bar: null
            command_panel: null
            command_buttons: [
                null, null, null, null, null,
                null, null, null, null, null,
                null, null, null, null, null
            ]
            command_button_count: 0
            portrait_panel: null
            unit_name_label: null
            unit_health_bar: null
            veterancy_stars: null
            selection_panel: null
            selection_icons: [
                null, null, null, null,
                null, null, null, null,
                null, null, null, null
            ]
            minimap_panel: null
            build_queue_panel: null
            build_queue_slots: [null, null, null, null, null]
            message_log: null
            messages: ["", "", "", "", "", "", "", "", "", ""]
            message_count: 0
            context_menu: null
            allocator: allocator
        }

        hud.create_hud_layout()
        return hud
    }

    fn create_hud_layout(mut self) {
        // Resource bar (top)
        let resource_pnl = Panel.init(self.allocator, 1)
        resource_pnl.window.set_position(0, 0)
        resource_pnl.window.set_size(1024, RESOURCE_BAR_HEIGHT)
        self.resource_panel = &resource_pnl
        self.root.add_child(&resource_pnl.window)

        // Supplies label
        let supplies_lbl = Label.init(self.allocator, 2, "$10,000")
        supplies_lbl.window.set_position(50, 10)
        supplies_lbl.window.set_size(150, 25)
        self.supplies_label = &supplies_lbl
        resource_pnl.window.add_child(&supplies_lbl.window)

        // Power label
        let power_lbl = Label.init(self.allocator, 3, "Power: 10/10")
        power_lbl.window.set_position(220, 10)
        power_lbl.window.set_size(150, 25)
        self.power_label = &power_lbl
        resource_pnl.window.add_child(&power_lbl.window)

        // Income label
        let income_lbl = Label.init(self.allocator, 4, "+$50/sec")
        income_lbl.window.set_position(390, 10)
        income_lbl.window.set_size(150, 25)
        self.income_label = &income_lbl
        resource_pnl.window.add_child(&income_lbl.window)

        // Control bar (bottom)
        let ctrl_bar = Panel.init(self.allocator, 5)
        ctrl_bar.window.set_position(0, 768 - HUD_HEIGHT)
        ctrl_bar.window.set_size(1024, HUD_HEIGHT)
        self.control_bar = &ctrl_bar
        self.root.add_child(&ctrl_bar.window)

        // Minimap (bottom left)
        let minimap_pnl = Panel.init(self.allocator, 6)
        minimap_pnl.window.set_position(10, 10)
        minimap_pnl.window.set_size(180, 160)
        self.minimap_panel = &minimap_pnl
        ctrl_bar.window.add_child(&minimap_pnl.window)

        // Selection panel (left of portrait)
        let sel_pnl = Panel.init(self.allocator, 7)
        sel_pnl.window.set_position(200, 10)
        sel_pnl.window.set_size(140, 160)
        self.selection_panel = &sel_pnl
        ctrl_bar.window.add_child(&sel_pnl.window)

        // Create selection icon slots (3x4 grid)
        for row in 0..4 {
            for col in 0..3 {
                let icon_pnl = Panel.init(self.allocator, @intCast(u32, 100 + row * 3 + col))
                icon_pnl.window.set_position(
                    @intCast(i32, col) * 45 + 5,
                    @intCast(i32, row) * 40 + 5
                )
                icon_pnl.window.set_size(40, 35)
                self.selection_icons[row * 3 + col] = &icon_pnl
                sel_pnl.window.add_child(&icon_pnl.window)
            }
        }

        // Portrait panel (center-left)
        let portrait_pnl = Panel.init(self.allocator, 8)
        portrait_pnl.window.set_position(350, 10)
        portrait_pnl.window.set_size(PORTRAIT_SIZE, PORTRAIT_SIZE)
        self.portrait_panel = &portrait_pnl
        ctrl_bar.window.add_child(&portrait_pnl.window)

        // Unit name label
        let name_lbl = Label.init(self.allocator, 9, "Ranger")
        name_lbl.window.set_position(10, 5)
        name_lbl.window.set_size(120, 20)
        self.unit_name_label = &name_lbl
        portrait_pnl.window.add_child(&name_lbl.window)

        // Health bar
        let health_bar = Panel.init(self.allocator, 10)
        health_bar.window.set_position(10, 120)
        health_bar.window.set_size(120, 10)
        self.unit_health_bar = &health_bar
        portrait_pnl.window.add_child(&health_bar.window)

        // Build queue (center)
        let queue_pnl = Panel.init(self.allocator, 11)
        queue_pnl.window.set_position(500, 50)
        queue_pnl.window.set_size(350, 70)
        self.build_queue_panel = &queue_pnl
        ctrl_bar.window.add_child(&queue_pnl.window)

        // Create build queue slots
        for i in 0..5 {
            let slot_pnl = Panel.init(self.allocator, @intCast(u32, 200 + i))
            slot_pnl.window.set_position(@intCast(i32, i) * 70 + 5, 5)
            slot_pnl.window.set_size(60, 60)
            self.build_queue_slots[i] = &slot_pnl
            queue_pnl.window.add_child(&slot_pnl.window)
        }

        // Command panel (bottom right)
        let cmd_pnl = Panel.init(self.allocator, 12)
        cmd_pnl.window.set_position(1024 - COMMAND_PANEL_WIDTH - 10, 10)
        cmd_pnl.window.set_size(COMMAND_PANEL_WIDTH, 160)
        self.command_panel = &cmd_pnl
        ctrl_bar.window.add_child(&cmd_pnl.window)

        // Create command button grid (3x5)
        self.create_command_buttons()

        // Message log (top left, above minimap when needed)
        let msg_pnl = Panel.init(self.allocator, 13)
        msg_pnl.window.set_position(10, 50)
        msg_pnl.window.set_size(400, 200)
        msg_pnl.window.hide()  // Hidden by default
        self.message_log = &msg_pnl
        self.root.add_child(&msg_pnl.window)
    }

    fn create_command_buttons(mut self) {
        let button_width: i32 = 75
        let button_height: i32 = 50
        let button_spacing: i32 = 5

        for row in 0..3 {
            for col in 0..5 {
                let index = row * 5 + col
                let cmd_btn = CommandButton.init(self.allocator, CommandButtonType.None)

                cmd_btn.button.window.set_position(
                    @intCast(i32, col) * (button_width + button_spacing) + 10,
                    @intCast(i32, row) * (button_height + button_spacing) + 10
                )
                cmd_btn.button.window.set_size(button_width, button_height)
                cmd_btn.button.window.hide()  // Hidden until command is set

                self.command_buttons[index] = &cmd_btn
                self.command_panel.window.add_child(&cmd_btn.button.window)
            }
        }
    }

    fn update(mut self, delta_time: f32) {
        // Update resource displays
        self.update_resource_display()

        // Update selected unit portrait
        self.update_unit_portrait()

        // Update build queue
        self.update_build_queue()

        // Update command buttons
        self.update_command_buttons()
    }

    fn update_resource_display(mut self) {
        // Get player economy
        let economy = get_player_economy(0)  // Local player
        if !economy {
            return
        }

        // Format supplies with commas
        self.supplies_label.window.text = format_money(economy.?.supplies)

        // Format power
        let power_used = economy.?.power_consumption
        let power_available = economy.?.power_production
        self.power_label.window.text = format_power(power_used, power_available)

        // Format income
        self.income_label.window.text = format_income(economy.?.income_rate)
    }

    fn update_unit_portrait(mut self) {
        // TODO: Get selected unit
        // Update portrait image, name, health bar, veterancy
    }

    fn update_build_queue(mut self) {
        // TODO: Get production queue from selected building
        // Update queue slot displays with progress
    }

    fn update_command_buttons(mut self) {
        // Hide all buttons first
        for i in 0..15 {
            self.command_buttons[i].button.window.hide()
        }

        // Show buttons based on selection
        // TODO: Get selected units/buildings
        // Configure appropriate command buttons
    }

    fn set_barracks_commands(mut self) {
        // Infantry production buttons
        self.set_command_button(0, CommandButtonType.ProduceUnit)
        self.command_buttons[0].set_unit_production(UnitType.Ranger, 200, 5.0, "Q")

        self.set_command_button(1, CommandButtonType.ProduceUnit)
        self.command_buttons[1].set_unit_production(UnitType.Missile_Defender, 300, 7.0, "W")

        // Common buttons
        self.set_common_building_buttons(10)  // Start at index 10
    }

    fn set_war_factory_commands(mut self) {
        // Vehicle production buttons
        self.set_command_button(0, CommandButtonType.ProduceUnit)
        self.command_buttons[0].set_unit_production(UnitType.Crusader_Tank, 900, 15.0, "Q")

        self.set_command_button(1, CommandButtonType.ProduceUnit)
        self.command_buttons[1].set_unit_production(UnitType.Paladin_Tank, 1200, 20.0, "W")

        self.set_common_building_buttons(10)
    }

    fn set_common_building_buttons(mut self, start_index: usize) {
        // Sell button
        self.set_command_button(start_index, CommandButtonType.Sell)
        self.command_buttons[start_index].button.window.text = "Sell"
        self.command_buttons[start_index].hotkey = "Z"

        // Repair button
        self.set_command_button(start_index + 1, CommandButtonType.Repair)
        self.command_buttons[start_index + 1].button.window.text = "Repair"
        self.command_buttons[start_index + 1].hotkey = "X"
    }

    fn set_command_button(mut self, index: usize, cmd_type: CommandButtonType) {
        if index >= 15 {
            return
        }

        self.command_buttons[index].command_type = cmd_type
        self.command_buttons[index].is_available = true
        self.command_buttons[index].button.window.show()
    }

    fn add_message(mut self, message: string) {
        // Add to message log
        if self.message_count >= 10 {
            // Shift messages up
            for i in 0..9 {
                self.messages[i] = self.messages[i + 1]
            }
            self.messages[9] = message
        } else {
            self.messages[self.message_count] = message
            self.message_count += 1
        }

        // Show message log temporarily
        self.message_log.window.show()
        // TODO: Auto-hide after 10 seconds
    }

    fn show_context_menu(mut self, x: i32, y: i32) {
        // Create context menu at mouse position
        // TODO: Implement context menu
    }

    fn hide_context_menu(mut self) {
        if self.context_menu {
            self.context_menu.?.hide()
        }
    }
}

// Helper formatting functions

fn format_money(amount: i32): string {
    // Format with dollar sign and commas
    // TODO: Proper formatting
    return "$" + int_to_string(amount)
}

fn format_power(used: i32, available: i32): string {
    return "Power: " + int_to_string(used) + "/" + int_to_string(available)
}

fn format_income(rate: f32): string {
    let amount = @floatToInt(i32, rate)
    if amount >= 0 {
        return "+$" + int_to_string(amount) + "/sec"
    } else {
        return "-$" + int_to_string(-amount) + "/sec"
    }
}

fn int_to_string(value: i32): string {
    // TODO: Implement proper int to string conversion
    return "0"
}

fn get_unit_name(unit_type: UnitType): string {
    match unit_type {
        UnitType.Ranger => "Ranger"
        UnitType.Missile_Defender => "Missile Defender"
        UnitType.Crusader_Tank => "Crusader Tank"
        UnitType.Paladin_Tank => "Paladin Tank"
        _ => "Unknown"
    }
}

fn get_building_name(building_type: BuildingType): string {
    match building_type {
        BuildingType.Barracks => "Barracks"
        BuildingType.War_Factory => "War Factory"
        BuildingType.Command_Center => "Command Center"
        _ => "Unknown"
    }
}

// Global HUD
var g_ingame_hud: ?InGameHUD = null

export fn init_ingame_hud(allocator: Allocator, window_mgr: *WindowManager) {
    g_ingame_hud = InGameHUD.init(allocator, window_mgr)
}

export fn update_hud(delta_time: f32) {
    if g_ingame_hud {
        g_ingame_hud.?.update(delta_time)
    }
}

export fn hud_add_message(message: string) {
    if g_ingame_hud {
        g_ingame_hud.?.add_message(message)
    }
}

export fn show_hud() {
    if g_ingame_hud {
        g_ingame_hud.?.root.show()
    }
}

export fn hide_hud() {
    if g_ingame_hud {
        g_ingame_hud.?.root.hide()
    }
}
