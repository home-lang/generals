// C&C Generals Zero Hour - Home Port
// Physics & Collision System
//
// Original: CollisionDetection.cpp, PhysicsUpdate.cpp (Westwood Studios/EA)
// Ported to Home with modern collision detection

import basics/allocator
import engine/math
import graphics/mesh

// Collision shapes
enum CollisionShape {
    Sphere
    Box
    Capsule
    Mesh
}

// Sphere collider
struct SphereCollider {
    center: Vec3
    radius: f32

    fn init(center: Vec3, radius: f32): SphereCollider {
        return SphereCollider {
            center: center
            radius: radius
        }
    }

    fn contains_point(self, point: Vec3): bool {
        let dist_sq = vec3_distance_squared(self.center, point)
        return dist_sq <= (self.radius * self.radius)
    }
}

// Box collider (Axis-Aligned Bounding Box)
struct BoxCollider {
    min: Vec3
    max: Vec3

    fn init(min: Vec3, max: Vec3): BoxCollider {
        return BoxCollider {
            min: min
            max: max
        }
    }

    fn from_center_size(center: Vec3, size: Vec3): BoxCollider {
        let half_size = vec3_mul(size, 0.5)
        return BoxCollider {
            min: vec3_sub(center, half_size)
            max: vec3_add(center, half_size)
        }
    }

    fn center(self): Vec3 {
        return Vec3 {
            x: (self.min.x + self.max.x) * 0.5
            y: (self.min.y + self.max.y) * 0.5
            z: (self.min.z + self.max.z) * 0.5
        }
    }

    fn size(self): Vec3 {
        return vec3_sub(self.max, self.min)
    }

    fn contains_point(self, point: Vec3): bool {
        return point.x >= self.min.x and point.x <= self.max.x and
               point.y >= self.min.y and point.y <= self.max.y and
               point.z >= self.min.z and point.z <= self.max.z
    }

    fn expand(mut self, point: Vec3) {
        if point.x < self.min.x { self.min.x = point.x }
        if point.y < self.min.y { self.min.y = point.y }
        if point.z < self.min.z { self.min.z = point.z }

        if point.x > self.max.x { self.max.x = point.x }
        if point.y > self.max.y { self.max.y = point.y }
        if point.z > self.max.z { self.max.z = point.z }
    }
}

// Capsule collider (for units)
struct CapsuleCollider {
    start: Vec3
    end: Vec3
    radius: f32

    fn init(start: Vec3, end: Vec3, radius: f32): CapsuleCollider {
        return CapsuleCollider {
            start: start
            end: end
            radius: radius
        }
    }
}

// Ray for raycasting
struct Ray {
    origin: Vec3
    direction: Vec3

    fn init(origin: Vec3, direction: Vec3): Ray {
        return Ray {
            origin: origin
            direction: direction.normalize()
        }
    }

    fn point_at(self, distance: f32): Vec3 {
        return vec3_add(self.origin, vec3_mul(self.direction, distance))
    }
}

// Ray hit information
struct RayHit {
    hit: bool
    distance: f32
    point: Vec3
    normal: Vec3
}

// Collision detection functions

fn sphere_sphere_collision(a: SphereCollider, b: SphereCollider): bool {
    let dist_sq = vec3_distance_squared(a.center, b.center)
    let radius_sum = a.radius + b.radius
    return dist_sq <= (radius_sum * radius_sum)
}

fn box_box_collision(a: BoxCollider, b: BoxCollider): bool {
    // AABB vs AABB collision
    if a.max.x < b.min.x or a.min.x > b.max.x {
        return false
    }
    if a.max.y < b.min.y or a.min.y > b.max.y {
        return false
    }
    if a.max.z < b.min.z or a.min.z > b.max.z {
        return false
    }
    return true
}

fn sphere_box_collision(sphere: SphereCollider, box: BoxCollider): bool {
    // Find closest point on box to sphere center
    let closest = Vec3 {
        x: clamp(sphere.center.x, box.min.x, box.max.x)
        y: clamp(sphere.center.y, box.min.y, box.max.y)
        z: clamp(sphere.center.z, box.min.z, box.max.z)
    }

    let dist_sq = vec3_distance_squared(closest, sphere.center)
    return dist_sq <= (sphere.radius * sphere.radius)
}

fn ray_sphere_intersection(ray: Ray, sphere: SphereCollider): RayHit {
    let oc = vec3_sub(ray.origin, sphere.center)
    let a = ray.direction.dot(ray.direction)
    let b = 2.0 * oc.dot(ray.direction)
    let c = oc.dot(oc) - sphere.radius * sphere.radius
    let discriminant = b * b - 4.0 * a * c

    if discriminant < 0.0 {
        return RayHit {
            hit: false
            distance: 0.0
            point: Vec3.init(0.0, 0.0, 0.0)
            normal: Vec3.init(0.0, 1.0, 0.0)
        }
    }

    let t = (-b - @sqrt(discriminant)) / (2.0 * a)
    if t < 0.0 {
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    let hit_point = ray.point_at(t)
    let normal = vec3_sub(hit_point, sphere.center).normalize()

    return RayHit {
        hit: true
        distance: t
        point: hit_point
        normal: normal
    }
}

fn ray_box_intersection(ray: Ray, box: BoxCollider): RayHit {
    // Slab method for ray-AABB intersection
    let inv_dir = Vec3 {
        x: 1.0 / ray.direction.x
        y: 1.0 / ray.direction.y
        z: 1.0 / ray.direction.z
    }

    let t1 = (box.min.x - ray.origin.x) * inv_dir.x
    let t2 = (box.max.x - ray.origin.x) * inv_dir.x
    let t3 = (box.min.y - ray.origin.y) * inv_dir.y
    let t4 = (box.max.y - ray.origin.y) * inv_dir.y
    let t5 = (box.min.z - ray.origin.z) * inv_dir.z
    let t6 = (box.max.z - ray.origin.z) * inv_dir.z

    let tmin = max_f32(max_f32(min_f32(t1, t2), min_f32(t3, t4)), min_f32(t5, t6))
    let tmax = min_f32(min_f32(max_f32(t1, t2), max_f32(t3, t4)), max_f32(t5, t6))

    // Ray doesn't intersect AABB
    if tmax < 0.0 or tmin > tmax {
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    let t = if tmin < 0.0 { tmax } else { tmin }
    let hit_point = ray.point_at(t)

    // Calculate normal (simplified)
    let normal = Vec3.init(0.0, 1.0, 0.0)  // TODO: Calculate actual normal

    return RayHit {
        hit: true
        distance: t
        point: hit_point
        normal: normal
    }
}

fn ray_plane_intersection(ray: Ray, plane_point: Vec3, plane_normal: Vec3): RayHit {
    let denom = ray.direction.dot(plane_normal)

    if @abs(denom) < EPSILON {
        // Ray is parallel to plane
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    let t = vec3_sub(plane_point, ray.origin).dot(plane_normal) / denom

    if t < 0.0 {
        // Intersection behind ray origin
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    let hit_point = ray.point_at(t)

    return RayHit {
        hit: true
        distance: t
        point: hit_point
        normal: plane_normal
    }
}

// Spatial partitioning - Quadtree for RTS game (2D on ground plane)
struct QuadtreeNode {
    bounds: BoxCollider
    entities: []u32  // Entity IDs
    entity_count: usize
    children: ?[4]*QuadtreeNode
    max_entities: usize
    max_depth: usize
    depth: usize
    allocator: Allocator

    fn init(allocator: Allocator, bounds: BoxCollider, max_entities: usize, max_depth: usize, depth: usize): QuadtreeNode {
        return QuadtreeNode {
            bounds: bounds
            entities: allocator.alloc(u32, max_entities)
            entity_count: 0
            children: null
            max_entities: max_entities
            max_depth: max_depth
            depth: depth
            allocator: allocator
        }
    }

    fn insert(mut self, entity_id: u32, position: Vec3): bool {
        if !self.bounds.contains_point(position) {
            return false
        }

        // If we have space and no children, add here
        if self.entity_count < self.max_entities and !self.children {
            self.entities[self.entity_count] = entity_id
            self.entity_count += 1
            return true
        }

        // Subdivide if needed
        if !self.children and self.depth < self.max_depth {
            self.subdivide()
        }

        // Insert into children
        if self.children {
            for i in 0..4 {
                if self.children.?[i].insert(entity_id, position) {
                    return true
                }
            }
        }

        return false
    }

    fn subdivide(mut self) {
        let center = self.bounds.center()
        let half_size = vec3_mul(self.bounds.size(), 0.5)

        let children_arr = self.allocator.alloc(QuadtreeNode, 4)

        // Create 4 child nodes (NW, NE, SW, SE)
        children_arr[0] = QuadtreeNode.init(
            self.allocator,
            BoxCollider {
                min: Vec3 { x: self.bounds.min.x, y: self.bounds.min.y, z: self.bounds.min.z }
                max: Vec3 { x: center.x, y: self.bounds.max.y, z: center.z }
            },
            self.max_entities,
            self.max_depth,
            self.depth + 1
        )

        // TODO: Create other 3 children

        self.children = children_arr
    }

    fn query_range(self, range: BoxCollider, results: *[]u32, count: *usize, max_results: usize) {
        if !box_box_collision(self.bounds, range) {
            return
        }

        // Check entities in this node
        for i in 0..self.entity_count {
            if count.* < max_results {
                results.*[count.*] = self.entities[i]
                count.* += 1
            }
        }

        // Recursively check children
        if self.children {
            for i in 0..4 {
                self.children.?[i].query_range(range, results, count, max_results)
            }
        }
    }

    fn deinit(mut self) {
        if self.children {
            for i in 0..4 {
                self.children.?[i].deinit()
            }
            self.allocator.free(self.children.?)
        }
        self.allocator.free(self.entities)
    }
}

// Utility math functions
fn min_f32(a: f32, b: f32): f32 {
    return if a < b { a } else { b }
}

fn max_f32(a: f32, b: f32): f32 {
    return if a > b { a } else { b }
}

// Global physics state (simplified)
struct PhysicsWorld {
    gravity: Vec3
    quadtree: QuadtreeNode

    fn init(allocator: Allocator, world_bounds: BoxCollider): PhysicsWorld {
        return PhysicsWorld {
            gravity: Vec3.init(0.0, -9.81, 0.0)
            quadtree: QuadtreeNode.init(allocator, world_bounds, 16, 8, 0)
        }
    }

    fn raycast(self, ray: Ray): RayHit {
        // TODO: Raycast against entities in quadtree
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    fn deinit(mut self) {
        self.quadtree.deinit()
    }
}

var g_physics_world: ?PhysicsWorld = null

export fn init_physics(allocator: Allocator) {
    let world_bounds = BoxCollider {
        min: Vec3.init(-1000.0, 0.0, -1000.0)
        max: Vec3.init(1000.0, 100.0, 1000.0)
    }

    g_physics_world = PhysicsWorld.init(allocator, world_bounds)
}

export fn shutdown_physics() {
    if g_physics_world {
        g_physics_world.?.deinit()
        g_physics_world = null
    }
}

export fn physics_raycast(origin: Vec3, direction: Vec3): RayHit {
    if g_physics_world {
        let ray = Ray.init(origin, direction)
        return g_physics_world.?.raycast(ray)
    }
    return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
}
