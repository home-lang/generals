// C&C Generals Zero Hour - Home Port
// Camera System
//
// Original: Camera.cpp (Westwood Studios/EA)
// Ported to Home with modern camera controls

import graphics/mesh

// Camera projection types
enum CameraProjection {
    Perspective
    Orthographic
}

// Camera movement modes
enum CameraMode {
    FreeCam      // Free movement (dev mode)
    RTS          // RTS camera (main game mode)
    Cinematic    // Scripted camera movement
}

// 4x4 Matrix for transformations
struct Mat4 {
    m: [16]f32

    fn identity(): Mat4 {
        return Mat4 {
            m: [16]f32{
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0
            }
        }
    }

    fn perspective(fov: f32, aspect: f32, near: f32, far: f32): Mat4 {
        let mut result = Mat4.identity()

        let tan_half_fov = @tan(fov * 0.5)

        result.m[0] = 1.0 / (aspect * tan_half_fov)
        result.m[5] = 1.0 / tan_half_fov
        result.m[10] = -(far + near) / (far - near)
        result.m[11] = -1.0
        result.m[14] = -(2.0 * far * near) / (far - near)
        result.m[15] = 0.0

        return result
    }

    fn orthographic(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32): Mat4 {
        let mut result = Mat4.identity()

        result.m[0] = 2.0 / (right - left)
        result.m[5] = 2.0 / (top - bottom)
        result.m[10] = -2.0 / (far - near)
        result.m[12] = -(right + left) / (right - left)
        result.m[13] = -(top + bottom) / (top - bottom)
        result.m[14] = -(far + near) / (far - near)

        return result
    }

    fn look_at(eye: Vec3, center: Vec3, up: Vec3): Mat4 {
        let mut result = Mat4.identity()

        // Calculate forward vector
        let f = Vec3 {
            x: center.x - eye.x
            y: center.y - eye.y
            z: center.z - eye.z
        }.normalize()

        // Calculate right vector
        let r = f.cross(up).normalize()

        // Calculate up vector
        let u = r.cross(f)

        result.m[0] = r.x
        result.m[4] = r.y
        result.m[8] = r.z

        result.m[1] = u.x
        result.m[5] = u.y
        result.m[9] = u.z

        result.m[2] = -f.x
        result.m[6] = -f.y
        result.m[10] = -f.z

        result.m[12] = -r.dot(eye)
        result.m[13] = -u.dot(eye)
        result.m[14] = f.dot(eye)

        return result
    }

    fn multiply(self, other: Mat4): Mat4 {
        let mut result = Mat4.identity()

        for i in 0..4 {
            for j in 0..4 {
                let mut sum: f32 = 0.0
                for k in 0..4 {
                    sum += self.m[i * 4 + k] * other.m[k * 4 + j]
                }
                result.m[i * 4 + j] = sum
            }
        }

        return result
    }
}

// Frustum planes for culling
struct Frustum {
    planes: [6]Plane  // Left, Right, Bottom, Top, Near, Far
}

struct Plane {
    normal: Vec3
    distance: f32

    fn distance_to_point(self, point: Vec3): f32 {
        return self.normal.dot(point) + self.distance
    }
}

// Camera structure
struct Camera {
    // Position and orientation
    position: Vec3
    target: Vec3  // Look-at target
    up: Vec3
    forward: Vec3
    right: Vec3

    // Projection parameters
    projection_type: CameraProjection
    fov: f32  // Field of view (radians)
    aspect_ratio: f32
    near_plane: f32
    far_plane: f32

    // Orthographic bounds
    ortho_left: f32
    ortho_right: f32
    ortho_bottom: f32
    ortho_top: f32

    // Camera mode
    mode: CameraMode

    // RTS camera specific
    zoom: f32  // Distance from ground
    pitch: f32  // Angle from ground
    yaw: f32    // Rotation around up axis
    min_zoom: f32
    max_zoom: f32

    // Movement speed
    move_speed: f32
    rotate_speed: f32
    zoom_speed: f32

    // Matrices
    view_matrix: Mat4
    projection_matrix: Mat4
    view_projection_matrix: Mat4

    // Frustum
    frustum: Frustum

    fn init(position: Vec3, target: Vec3): Camera {
        return Camera {
            position: position
            target: target
            up: Vec3.init(0.0, 1.0, 0.0)
            forward: Vec3.init(0.0, 0.0, 1.0)
            right: Vec3.init(1.0, 0.0, 0.0)
            projection_type: CameraProjection.Perspective
            fov: 1.0472  // 60 degrees in radians
            aspect_ratio: 16.0 / 9.0
            near_plane: 0.1
            far_plane: 10000.0
            ortho_left: -100.0
            ortho_right: 100.0
            ortho_bottom: -100.0
            ortho_top: 100.0
            mode: CameraMode.RTS
            zoom: 50.0
            pitch: 0.785  // 45 degrees
            yaw: 0.0
            min_zoom: 10.0
            max_zoom: 200.0
            move_speed: 50.0
            rotate_speed: 2.0
            zoom_speed: 10.0
            view_matrix: Mat4.identity()
            projection_matrix: Mat4.identity()
            view_projection_matrix: Mat4.identity()
            frustum: Frustum { planes: [6]Plane{} }
        }
    }

    fn update_rts(mut self, delta_time: f32) {
        // RTS camera orbits around a ground target point
        // Calculate position based on zoom, pitch, and yaw

        let x = self.zoom * @cos(self.pitch) * @sin(self.yaw)
        let y = self.zoom * @sin(self.pitch)
        let z = self.zoom * @cos(self.pitch) * @cos(self.yaw)

        self.position = Vec3 {
            x: self.target.x + x
            y: self.target.y + y
            z: self.target.z + z
        }

        self.update_matrices()
    }

    fn update_free_cam(mut self, delta_time: f32) {
        // Free camera uses forward/right vectors for movement
        self.update_matrices()
    }

    fn update_matrices(mut self) {
        // Update view matrix
        self.view_matrix = Mat4.look_at(self.position, self.target, self.up)

        // Update projection matrix
        match self.projection_type {
            CameraProjection.Perspective => {
                self.projection_matrix = Mat4.perspective(
                    self.fov,
                    self.aspect_ratio,
                    self.near_plane,
                    self.far_plane
                )
            }
            CameraProjection.Orthographic => {
                self.projection_matrix = Mat4.orthographic(
                    self.ortho_left,
                    self.ortho_right,
                    self.ortho_bottom,
                    self.ortho_top,
                    self.near_plane,
                    self.far_plane
                )
            }
        }

        // Combine matrices
        self.view_projection_matrix = self.projection_matrix.multiply(self.view_matrix)

        // Update frustum
        self.update_frustum()
    }

    fn update_frustum(mut self) {
        // Extract frustum planes from view-projection matrix
        // TODO: Implement frustum extraction from matrix
    }

    fn move_forward(mut self, amount: f32) {
        match self.mode {
            CameraMode.RTS => {
                // Move target forward in xz plane
                let forward_xz = Vec3 {
                    x: @sin(self.yaw)
                    y: 0.0
                    z: @cos(self.yaw)
                }.normalize()

                self.target.x += forward_xz.x * amount
                self.target.z += forward_xz.z * amount
            }
            CameraMode.FreeCam => {
                self.position.x += self.forward.x * amount
                self.position.y += self.forward.y * amount
                self.position.z += self.forward.z * amount
            }
            _ => {}
        }
    }

    fn move_right(mut self, amount: f32) {
        match self.mode {
            CameraMode.RTS => {
                let right_xz = Vec3 {
                    x: @cos(self.yaw)
                    y: 0.0
                    z: -@sin(self.yaw)
                }.normalize()

                self.target.x += right_xz.x * amount
                self.target.z += right_xz.z * amount
            }
            CameraMode.FreeCam => {
                self.position.x += self.right.x * amount
                self.position.y += self.right.y * amount
                self.position.z += self.right.z * amount
            }
            _ => {}
        }
    }

    fn rotate(mut self, yaw_delta: f32, pitch_delta: f32) {
        match self.mode {
            CameraMode.RTS => {
                self.yaw += yaw_delta
                self.pitch += pitch_delta

                // Clamp pitch for RTS camera
                const MIN_PITCH: f32 = 0.1  // ~6 degrees
                const MAX_PITCH: f32 = 1.48  // ~85 degrees

                if self.pitch < MIN_PITCH {
                    self.pitch = MIN_PITCH
                }
                if self.pitch > MAX_PITCH {
                    self.pitch = MAX_PITCH
                }
            }
            CameraMode.FreeCam => {
                // TODO: Update forward/right vectors for free cam
            }
            _ => {}
        }
    }

    fn zoom(mut self, amount: f32) {
        self.zoom += amount

        if self.zoom < self.min_zoom {
            self.zoom = self.min_zoom
        }
        if self.zoom > self.max_zoom {
            self.zoom = self.max_zoom
        }
    }

    fn set_aspect_ratio(mut self, width: u32, height: u32) {
        self.aspect_ratio = @intToFloat(f32, width) / @intToFloat(f32, height)
    }

    fn is_box_in_frustum(self, bbox: BoundingBox): bool {
        // Check if bounding box is inside frustum
        // TODO: Implement frustum culling test
        return true
    }

    fn screen_to_world_ray(self, screen_x: f32, screen_y: f32): Ray {
        // Convert screen coordinates to world-space ray
        // TODO: Implement ray casting from screen
        return Ray {
            origin: self.position
            direction: self.forward
        }
    }
}

struct Ray {
    origin: Vec3
    direction: Vec3
}

// Global camera instance
var g_camera: ?Camera = null

export fn init_camera(position: Vec3, target: Vec3) {
    g_camera = Camera.init(position, target)
}

export fn update_camera(delta_time: f32) {
    if g_camera {
        match g_camera.?.mode {
            CameraMode.RTS => {
                g_camera.?.update_rts(delta_time)
            }
            CameraMode.FreeCam => {
                g_camera.?.update_free_cam(delta_time)
            }
            _ => {}
        }
    }
}

export fn get_camera(): ?*Camera {
    if g_camera {
        return &g_camera.?
    }
    return null
}

export fn get_view_matrix(): Mat4 {
    if g_camera {
        return g_camera.?.view_matrix
    }
    return Mat4.identity()
}

export fn get_projection_matrix(): Mat4 {
    if g_camera {
        return g_camera.?.projection_matrix
    }
    return Mat4.identity()
}

export fn get_view_projection_matrix(): Mat4 {
    if g_camera {
        return g_camera.?.view_projection_matrix
    }
    return Mat4.identity()
}
