// C&C Generals Zero Hour - Home Port
// Combat System
//
// Original: Weapon.cpp, DamageCalc.cpp (Westwood Studios/EA)
// Ported to Home with modern damage calculation

import basics/allocator
import engine/ecs
import engine/math
import engine/physics

// Damage types
enum DamageType {
    Kinetic      // Bullets, shells
    Explosive    // Rockets, bombs
    Fire         // Flamethrowers, napalm
    Toxin        // Chemical weapons
    Radiation    // Nuclear
    Laser        // Energy weapons
    EMP          // Electromagnetic pulse
}

// Armor types
enum ArmorType {
    None
    Light        // Infantry
    Medium       // Light vehicles
    Heavy        // Tanks
    Structure    // Buildings
    Aircraft     // Flying units
}

// Weapon behavior
enum WeaponBehavior {
    Direct       // Instant hit (bullets)
    Projectile   // Ballistic (rockets)
    Beam         // Continuous (laser)
    AOE          // Area of effect (explosions)
}

// Targeting priority
enum TargetPriority {
    None
    Closest
    Weakest
    Strongest
    Infantry
    Vehicles
    Aircraft
    Structures
}

// Weapon definition
struct WeaponDefinition {
    name: string

    // Damage
    damage: f32
    damage_type: DamageType
    radius: f32  // For AOE weapons

    // Range & accuracy
    min_range: f32
    max_range: f32
    accuracy: f32  // 0.0 to 1.0

    // Timing
    reload_time: f32
    fire_rate: f32  // Shots per second
    wind_up_time: f32  // Delay before first shot

    // Ammo
    magazine_size: u32
    infinite_ammo: bool

    // Behavior
    behavior: WeaponBehavior
    projectile_speed: f32
    projectile_arc: f32  // For ballistic weapons
    beam_duration: f32  // For beam weapons

    // Targeting
    can_fire_while_moving: bool
    requires_line_of_sight: bool
    target_priority: TargetPriority
    can_target_ground: bool
    can_target_air: bool

    // Effects
    has_tracer: bool
    muzzle_flash: bool
    impact_effect: string
    sound_fire: string
    sound_impact: string

    fn init(): WeaponDefinition {
        return WeaponDefinition {
            name: "Default Weapon"
            damage: 10.0
            damage_type: DamageType.Kinetic
            radius: 0.0
            min_range: 0.0
            max_range: 10.0
            accuracy: 0.9
            reload_time: 2.0
            fire_rate: 1.0
            wind_up_time: 0.0
            magazine_size: 30
            infinite_ammo: false
            behavior: WeaponBehavior.Direct
            projectile_speed: 100.0
            projectile_arc: 0.0
            beam_duration: 0.0
            can_fire_while_moving: true
            requires_line_of_sight: true
            target_priority: TargetPriority.Closest
            can_target_ground: true
            can_target_air: false
            has_tracer: true
            muzzle_flash: true
            impact_effect: "bullet_impact"
            sound_fire: "rifle_fire"
            sound_impact: "bullet_hit"
        }
    }
}

// Active weapon instance
struct Weapon {
    definition: *WeaponDefinition
    owner: Entity

    // State
    current_ammo: u32
    time_until_reload: f32
    time_until_next_shot: f32
    is_reloading: bool
    is_firing: bool

    // Current target
    target: ?Entity
    target_position: Vec3
    has_target: bool

    fn init(definition: *WeaponDefinition, owner: Entity): Weapon {
        return Weapon {
            definition: definition
            owner: owner
            current_ammo: definition.magazine_size
            time_until_reload: 0.0
            time_until_next_shot: 0.0
            is_reloading: false
            is_firing: false
            target: null
            target_position: Vec3.init(0.0, 0.0, 0.0)
            has_target: false
        }
    }

    fn update(mut self, delta_time: f32, owner_position: Vec3) {
        // Update timers
        if self.time_until_reload > 0.0 {
            self.time_until_reload -= delta_time

            if self.time_until_reload <= 0.0 {
                self.complete_reload()
            }
        }

        if self.time_until_next_shot > 0.0 {
            self.time_until_next_shot -= delta_time
        }

        // Try to fire if we have a target
        if self.has_target and self.can_fire() {
            self.fire(owner_position)
        }
    }

    fn can_fire(self): bool {
        if self.is_reloading {
            return false
        }

        if self.time_until_next_shot > 0.0 {
            return false
        }

        if !self.definition.infinite_ammo and self.current_ammo == 0 {
            return false
        }

        if !self.has_target {
            return false
        }

        return true
    }

    fn fire(mut self, owner_position: Vec3) {
        // Consume ammo
        if !self.definition.infinite_ammo {
            self.current_ammo -= 1

            if self.current_ammo == 0 {
                self.start_reload()
                return
            }
        }

        // Set fire cooldown
        self.time_until_next_shot = 1.0 / self.definition.fire_rate

        // Calculate if shot hits (accuracy check)
        let hits = check_accuracy(self.definition.accuracy)

        if hits {
            match self.definition.behavior {
                WeaponBehavior.Direct => {
                    self.fire_direct(owner_position)
                }
                WeaponBehavior.Projectile => {
                    self.fire_projectile(owner_position)
                }
                WeaponBehavior.Beam => {
                    self.fire_beam(owner_position)
                }
                WeaponBehavior.AOE => {
                    self.fire_aoe(owner_position)
                }
            }
        }

        // Play effects
        // TODO: Spawn muzzle flash
        // TODO: Play fire sound
    }

    fn fire_direct(self, owner_position: Vec3) {
        // Instant hit (hitscan)
        if self.target {
            let target_entity = self.target.?

            // Apply damage directly
            apply_damage(target_entity, self.definition.damage, self.definition.damage_type, self.owner)

            // TODO: Spawn impact effect at target
        }
    }

    fn fire_projectile(self, owner_position: Vec3) {
        // Spawn projectile entity
        // TODO: Create projectile with physics
        // Projectile will check for hits during its flight
    }

    fn fire_beam(self, owner_position: Vec3) {
        // Continuous beam (laser)
        // TODO: Create beam visual effect
        // Apply damage over beam duration
    }

    fn fire_aoe(self, owner_position: Vec3) {
        // Area of effect damage
        let impact_pos = if self.has_target { self.target_position } else { Vec3.init(0.0, 0.0, 0.0) }

        // Find all entities in radius
        // TODO: Query physics for entities in sphere
        // Apply damage to all found entities
    }

    fn start_reload(mut self) {
        self.is_reloading = true
        self.time_until_reload = self.definition.reload_time

        // TODO: Play reload animation/sound
    }

    fn complete_reload(mut self) {
        self.is_reloading = false
        self.current_ammo = self.definition.magazine_size

        // TODO: Play reload complete sound
    }

    fn set_target(mut self, target: Entity, position: Vec3) {
        self.target = target
        self.target_position = position
        self.has_target = true
    }

    fn clear_target(mut self) {
        self.target = null
        self.has_target = false
    }

    fn get_ammo_percentage(self): f32 {
        if self.definition.infinite_ammo {
            return 1.0
        }

        return @intToFloat(f32, self.current_ammo) / @intToFloat(f32, self.definition.magazine_size)
    }
}

// Damage calculation with armor
fn calculate_damage(base_damage: f32, damage_type: DamageType, armor_type: ArmorType, armor_value: f32): f32 {
    // Damage type vs armor type effectiveness matrix
    let effectiveness = get_damage_effectiveness(damage_type, armor_type)

    // Apply armor reduction
    let armor_reduction = armor_value / (armor_value + 100.0)
    let damage_after_armor = base_damage * (1.0 - armor_reduction)

    // Apply effectiveness multiplier
    let final_damage = damage_after_armor * effectiveness

    return final_damage
}

fn get_damage_effectiveness(damage_type: DamageType, armor_type: ArmorType): f32 {
    // Damage effectiveness matrix (simplified)
    match damage_type {
        DamageType.Kinetic => {
            match armor_type {
                ArmorType.Light => 1.5      // Very effective vs infantry
                ArmorType.Medium => 1.0     // Normal vs light vehicles
                ArmorType.Heavy => 0.5      // Weak vs tanks
                ArmorType.Structure => 0.3  // Very weak vs buildings
                ArmorType.Aircraft => 0.8
                _ => 1.0
            }
        }
        DamageType.Explosive => {
            match armor_type {
                ArmorType.Light => 2.0      // Devastating vs infantry
                ArmorType.Medium => 1.5     // Very effective vs vehicles
                ArmorType.Heavy => 1.0      // Normal vs tanks
                ArmorType.Structure => 1.0  // Normal vs buildings
                ArmorType.Aircraft => 1.2
                _ => 1.0
            }
        }
        DamageType.Fire => {
            match armor_type {
                ArmorType.Light => 2.5      // Extremely effective vs infantry
                ArmorType.Medium => 0.8
                ArmorType.Heavy => 0.3      // Weak vs tanks
                ArmorType.Structure => 1.2
                ArmorType.Aircraft => 0.5
                _ => 1.0
            }
        }
        DamageType.Toxin => {
            match armor_type {
                ArmorType.Light => 3.0      // Lethal vs infantry
                ArmorType.Medium => 0.1     // Ineffective vs vehicles
                ArmorType.Heavy => 0.1
                ArmorType.Structure => 0.0  // No effect on buildings
                ArmorType.Aircraft => 0.0
                _ => 1.0
            }
        }
        _ => 1.0
    }
}

fn check_accuracy(accuracy: f32): bool {
    // TODO: Use proper random number generator
    // For now, simple threshold check
    let random_value = 0.8  // Placeholder

    return random_value <= accuracy
}

fn apply_damage(target: Entity, damage: f32, damage_type: DamageType, attacker: Entity) {
    let world = get_world()
    if !world {
        return
    }

    // Get target health component
    let health = world.?.get_health(target)
    if !health {
        return
    }

    // TODO: Get target armor type and value
    let armor_type = ArmorType.Medium
    let armor_value = 50.0

    // Calculate final damage
    let final_damage = calculate_damage(damage, damage_type, armor_type, armor_value)

    // Apply damage
    health.?.current -= final_damage

    if health.?.current <= 0.0 {
        health.?.current = 0.0

        // Target killed
        on_unit_killed(target, attacker)
    }
}

fn on_unit_killed(victim: Entity, killer: Entity) {
    // Award experience to killer
    // TODO: Get killer's unit component and add XP

    // TODO: Play death animation
    // TODO: Spawn death effect
    // TODO: Remove entity from world after delay
}

// Line of sight checking
fn has_line_of_sight(from: Vec3, to: Vec3): bool {
    let direction = vec3_sub(to, from).normalize()
    let distance = vec3_distance(from, to)

    // Raycast from shooter to target
    let hit = physics_raycast(from, direction)

    if hit.hit {
        // Check if we hit the target or something in between
        return hit.distance >= distance
    }

    return true  // No obstacles
}

// Target selection
fn find_best_target(position: Vec3, range: f32, team_id: u32, priority: TargetPriority): ?Entity {
    // TODO: Query all enemy entities in range
    // TODO: Apply target priority filter
    // TODO: Return best target based on priority

    return null
}

// Veterancy bonuses
fn apply_veterancy_bonuses(entity: Entity, level: u32) {
    let world = get_world()
    if !world {
        return
    }

    // Each veterancy level grants:
    // - +25% health
    // - +25% damage
    // - +10% speed
    // - -10% reload time

    let multiplier = 1.0 + (0.25 * @intToFloat(f32, level))

    // TODO: Apply bonuses to unit stats
}

// Global combat statistics
struct CombatStats {
    total_damage_dealt: f32
    total_kills: u32
    shots_fired: u32
    shots_hit: u32
    units_lost: u32

    fn init(): CombatStats {
        return CombatStats {
            total_damage_dealt: 0.0
            total_kills: 0
            shots_fired: 0
            shots_hit: 0
            units_lost: 0
        }
    }

    fn get_accuracy(self): f32 {
        if self.shots_fired == 0 {
            return 0.0
        }

        return @intToFloat(f32, self.shots_hit) / @intToFloat(f32, self.shots_fired)
    }

    fn get_kill_death_ratio(self): f32 {
        if self.units_lost == 0 {
            return @intToFloat(f32, self.total_kills)
        }

        return @intToFloat(f32, self.total_kills) / @intToFloat(f32, self.units_lost)
    }
}

var g_combat_stats: CombatStats = CombatStats.init()

export fn get_combat_stats(): CombatStats {
    return g_combat_stats
}

export fn reset_combat_stats() {
    g_combat_stats = CombatStats.init()
}
