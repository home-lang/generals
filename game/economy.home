// C&C Generals Zero Hour - Home Port
// Economy & Resource System
//
// Original: Supply.cpp, PlayerResources.cpp (Westwood Studios/EA)
// Ported to Home with C&C Generals supply system

import basics/allocator
import engine/ecs
import engine/math

// Resource types (C&C Generals only uses supplies/money)
enum ResourceType {
    Supplies    // Money/credits
    Power       // Electricity
}

// Supply source types
enum SupplySourceType {
    SupplyDock      // USA/China supply docks
    SupplyStash     // GLA supply stash
    TechBuilding    // Capturable tech buildings
    General_Power   // General's powers (cash drop, etc.)
}

// Supply dock state
enum SupplyDockState {
    Empty
    Gathering
    Full
    Returning
}

// Player economy state
struct PlayerEconomy {
    player_id: u32

    // Resources
    supplies: i32
    max_supplies: i32  // Bank limit

    // Income
    income_rate: f32  // Supplies per second
    total_income: i32  // Lifetime income

    // Spending
    total_spent: i32
    current_spending_rate: f32  // Supplies/sec being spent on production

    // Power
    power_production: i32
    power_consumption: i32
    power_surplus: i32
    is_low_power: bool

    // Supply collection
    supply_docks: []Entity
    supply_dock_count: usize
    active_collectors: u32

    fn init(player_id: u32, starting_supplies: i32): PlayerEconomy {
        return PlayerEconomy {
            player_id: player_id
            supplies: starting_supplies
            max_supplies: 100000  // Default bank limit
            income_rate: 0.0
            total_income: starting_supplies
            total_spent: 0
            current_spending_rate: 0.0
            power_production: 0
            power_consumption: 0
            power_surplus: 0
            is_low_power: false
            supply_docks: []
            supply_dock_count: 0
            active_collectors: 0
        }
    }

    fn update(mut self, delta_time: f32) {
        // Calculate income from all sources
        self.calculate_income()

        // Add income
        let income_this_frame = @floatToInt(i32, self.income_rate * delta_time)
        self.add_supplies(income_this_frame)

        // Update power status
        self.update_power()
    }

    fn calculate_income(mut self) {
        // Base income rate
        self.income_rate = 0.0

        // Income from supply docks
        // Each active collector provides income based on dock's supply amount
        self.income_rate += @intToFloat(f32, self.active_collectors) * 2.0  // $2/sec per collector

        // TODO: Add income from other sources (tech buildings, etc.)
    }

    fn update_power(mut self) {
        self.power_surplus = self.power_production - self.power_consumption

        if self.power_surplus < 0 {
            self.is_low_power = true
            // Buildings will operate at reduced efficiency
        } else {
            self.is_low_power = false
        }
    }

    fn add_supplies(mut self, amount: i32) {
        self.supplies += amount

        if self.supplies > self.max_supplies {
            self.supplies = self.max_supplies
        }

        if amount > 0 {
            self.total_income += amount
        }
    }

    fn spend_supplies(mut self, amount: i32): bool {
        if self.supplies < amount {
            return false  // Not enough money
        }

        self.supplies -= amount
        self.total_spent += amount
        return true
    }

    fn can_afford(self, cost: i32): bool {
        return self.supplies >= cost
    }

    fn add_power_production(mut self, amount: i32) {
        self.power_production += amount
        self.update_power()
    }

    fn remove_power_production(mut self, amount: i32) {
        self.power_production -= amount
        if self.power_production < 0 {
            self.power_production = 0
        }
        self.update_power()
    }

    fn add_power_consumption(mut self, amount: i32) {
        self.power_consumption += amount
        self.update_power()
    }

    fn remove_power_consumption(mut self, amount: i32) {
        self.power_consumption -= amount
        if self.power_consumption < 0 {
            self.power_consumption = 0
        }
        self.update_power()
    }

    fn get_supplies_percentage(self): f32 {
        return @intToFloat(f32, self.supplies) / @intToFloat(f32, self.max_supplies)
    }

    fn get_power_percentage(self): f32 {
        if self.power_production == 0 {
            return 0.0
        }

        return @intToFloat(f32, self.power_consumption) / @intToFloat(f32, self.power_production)
    }
}

// Supply collector (worker unit gathering supplies)
struct SupplyCollector {
    entity: Entity
    owner_player: u32

    // State
    state: SupplyDockState
    current_load: i32
    max_load: i32

    // Assigned dock
    assigned_dock: ?Entity
    dock_position: Vec3

    // Movement
    return_position: Vec3  // Where to return supplies (Command Center)
    is_moving_to_dock: bool
    is_moving_to_base: bool

    // Timing
    gather_time: f32  // Time to fill up at dock
    time_gathering: f32

    fn init(entity: Entity, player_id: u32): SupplyCollector {
        return SupplyCollector {
            entity: entity
            owner_player: player_id
            state: SupplyDockState.Empty
            current_load: 0
            max_load: 1000  // $1000 per load
            assigned_dock: null
            dock_position: Vec3.init(0.0, 0.0, 0.0)
            return_position: Vec3.init(0.0, 0.0, 0.0)
            is_moving_to_dock: false
            is_moving_to_base: false
            gather_time: 5.0  // 5 seconds to gather
            time_gathering: 0.0
        }
    }

    fn update(mut self, delta_time: f32, current_position: Vec3) {
        match self.state {
            SupplyDockState.Empty => {
                // Move to supply dock
                if !self.is_moving_to_dock and self.assigned_dock {
                    self.is_moving_to_dock = true
                    // TODO: Issue move command to dock
                }

                // Check if reached dock
                if vec3_distance(current_position, self.dock_position) < 2.0 {
                    self.state = SupplyDockState.Gathering
                    self.is_moving_to_dock = false
                }
            }
            SupplyDockState.Gathering => {
                self.time_gathering += delta_time

                if self.time_gathering >= self.gather_time {
                    // Fully loaded
                    self.current_load = self.max_load
                    self.state = SupplyDockState.Full
                    self.time_gathering = 0.0
                }
            }
            SupplyDockState.Full => {
                // Move back to base
                if !self.is_moving_to_base {
                    self.is_moving_to_base = true
                    // TODO: Issue move command to return position
                }

                // Check if reached base
                if vec3_distance(current_position, self.return_position) < 2.0 {
                    self.deliver_supplies()
                    self.state = SupplyDockState.Empty
                    self.is_moving_to_base = false
                }
            }
            _ => {}
        }
    }

    fn deliver_supplies(mut self) {
        // Add supplies to player economy
        // TODO: Get player economy and add supplies
        self.current_load = 0
    }

    fn assign_dock(mut self, dock: Entity, position: Vec3) {
        self.assigned_dock = dock
        self.dock_position = position
    }

    fn set_return_position(mut self, position: Vec3) {
        self.return_position = position
    }
}

// Supply dock (supply source building)
struct SupplyDock {
    entity: Entity
    owner_player: u32
    source_type: SupplySourceType

    // Supply amount
    current_supplies: i32
    max_supplies: i32
    is_depleted: bool
    regenerates: bool
    regen_rate: i32  // Supplies per second

    // Visual
    supply_boxes_visible: u32  // How many supply boxes to show (8 max for USA/China)

    fn init(entity: Entity, player_id: u32, source_type: SupplySourceType): SupplyDock {
        let max = match source_type {
            SupplySourceType.SupplyDock => 10000  // USA/China docks start with $10000
            SupplySourceType.SupplyStash => 5000  // GLA stashes start with $5000
            SupplySourceType.TechBuilding => 20000  // Tech buildings are rich
            _ => 5000
        }

        return SupplyDock {
            entity: entity
            owner_player: player_id
            source_type: source_type
            current_supplies: max
            max_supplies: max
            is_depleted: false
            regenerates: false
            regen_rate: 0
            supply_boxes_visible: 8
        }
    }

    fn update(mut self, delta_time: f32) {
        // Regenerate supplies if enabled
        if self.regenerates and !self.is_depleted {
            let regen_amount = @floatToInt(i32, @intToFloat(f32, self.regen_rate) * delta_time)
            self.current_supplies += regen_amount

            if self.current_supplies > self.max_supplies {
                self.current_supplies = self.max_supplies
            }
        }

        // Update visual supply boxes
        self.update_visual_state()

        // Check if depleted
        if self.current_supplies <= 0 {
            self.is_depleted = true
        }
    }

    fn update_visual_state(mut self) {
        // Calculate how many supply boxes should be visible
        let percentage = @intToFloat(f32, self.current_supplies) / @intToFloat(f32, self.max_supplies)
        self.supply_boxes_visible = @floatToInt(u32, percentage * 8.0)

        if self.supply_boxes_visible > 8 {
            self.supply_boxes_visible = 8
        }
    }

    fn collect_supplies(mut self, amount: i32): i32 {
        if self.is_depleted {
            return 0
        }

        let collected = if amount > self.current_supplies { self.current_supplies } else { amount }
        self.current_supplies -= collected

        return collected
    }

    fn get_supply_percentage(self): f32 {
        return @intToFloat(f32, self.current_supplies) / @intToFloat(f32, self.max_supplies)
    }
}

// Economy manager for all players
struct EconomyManager {
    player_economies: []PlayerEconomy
    player_count: usize

    supply_docks: []SupplyDock
    supply_dock_count: usize

    collectors: []SupplyCollector
    collector_count: usize

    allocator: Allocator

    fn init(allocator: Allocator, max_players: usize): EconomyManager {
        return EconomyManager {
            player_economies: allocator.alloc(PlayerEconomy, max_players)
            player_count: 0
            supply_docks: allocator.alloc(SupplyDock, 256)
            supply_dock_count: 0
            collectors: allocator.alloc(SupplyCollector, 256)
            collector_count: 0
            allocator: allocator
        }
    }

    fn create_player_economy(mut self, player_id: u32, starting_supplies: i32) {
        if self.player_count < self.player_economies.len {
            self.player_economies[self.player_count] = PlayerEconomy.init(player_id, starting_supplies)
            self.player_count += 1
        }
    }

    fn get_player_economy(self, player_id: u32): ?*PlayerEconomy {
        for i in 0..self.player_count {
            if self.player_economies[i].player_id == player_id {
                return &self.player_economies[i]
            }
        }
        return null
    }

    fn create_supply_dock(mut self, entity: Entity, player_id: u32, source_type: SupplySourceType) {
        if self.supply_dock_count < self.supply_docks.len {
            self.supply_docks[self.supply_dock_count] = SupplyDock.init(entity, player_id, source_type)
            self.supply_dock_count += 1
        }
    }

    fn create_collector(mut self, entity: Entity, player_id: u32) {
        if self.collector_count < self.collectors.len {
            self.collectors[self.collector_count] = SupplyCollector.init(entity, player_id)
            self.collector_count += 1
        }
    }

    fn update(mut self, delta_time: f32) {
        // Update all player economies
        for i in 0..self.player_count {
            self.player_economies[i].update(delta_time)
        }

        // Update supply docks
        for i in 0..self.supply_dock_count {
            self.supply_docks[i].update(delta_time)
        }

        // Update collectors
        for i in 0..self.collector_count {
            // TODO: Get collector position from transform component
            let position = Vec3.init(0.0, 0.0, 0.0)
            self.collectors[i].update(delta_time, position)
        }
    }

    fn deinit(mut self) {
        self.allocator.free(self.player_economies)
        self.allocator.free(self.supply_docks)
        self.allocator.free(self.collectors)
    }
}

// Global economy manager
var g_economy_manager: ?EconomyManager = null

export fn init_economy(allocator: Allocator, max_players: usize) {
    g_economy_manager = EconomyManager.init(allocator, max_players)
}

export fn shutdown_economy() {
    if g_economy_manager {
        g_economy_manager.?.deinit()
        g_economy_manager = null
    }
}

export fn create_player_economy(player_id: u32, starting_supplies: i32) {
    if g_economy_manager {
        g_economy_manager.?.create_player_economy(player_id, starting_supplies)
    }
}

export fn get_player_supplies(player_id: u32): i32 {
    if g_economy_manager {
        let economy = g_economy_manager.?.get_player_economy(player_id)
        if economy {
            return economy.?.supplies
        }
    }
    return 0
}

export fn spend_supplies(player_id: u32, amount: i32): bool {
    if g_economy_manager {
        let economy = g_economy_manager.?.get_player_economy(player_id)
        if economy {
            return economy.?.spend_supplies(amount)
        }
    }
    return false
}

export fn update_economy(delta_time: f32) {
    if g_economy_manager {
        g_economy_manager.?.update(delta_time)
    }
}
