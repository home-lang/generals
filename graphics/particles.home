// C&C Generals Zero Hour - Home Port
// Particle System
//
// Original: EA's particle system for explosions, smoke, fire, etc.
// Ported to Home with modern GPU particle rendering
//
// EA's particle system features:
// - Emitters with lifetime and spawn rate
// - Particle physics (velocity, gravity, drag)
// - Texture animation
// - Color/alpha fading
// - Billboard rendering
// - Priority-based culling (from LOD system)
//
// Usage:
// ```
// let emitter = ParticleEmitter.create("Explosion")
// emitter.position = Vec3.new(100.0, 0.0, 100.0)
// emitter.emit_count = 100
// emitter.start()
// ```

import basics/allocator
import engine/math
import engine/object_pool

const MAX_PARTICLES_PER_EMITTER: u32 = 10000
const MAX_EMITTERS: u32 = 256

// Particle priority (for LOD culling)
enum ParticlePriority {
    Critical   // Always render (explosions, important effects)
    High       // Usually render (smoke, fire)
    Medium     // Render if performance allows
    Low        // First to be culled (ambient effects)
}

// Single particle
struct Particle {
    position: Vec3
    velocity: Vec3
    acceleration: Vec3

    rotation: f32
    angular_velocity: f32

    size: f32
    size_velocity: f32  // For growing/shrinking

    color: Vec4
    color_velocity: Vec4  // For fading

    lifetime: f32
    age: f32

    texture_frame: u32  // For animated textures

    is_alive: bool

    fn init(): Particle {
        return Particle {
            position: Vec3.zero()
            velocity: Vec3.zero()
            acceleration: Vec3.zero()
            rotation: 0.0
            angular_velocity: 0.0
            size: 1.0
            size_velocity: 0.0
            color: Vec4.new(1.0, 1.0, 1.0, 1.0)
            color_velocity: Vec4.zero()
            lifetime: 1.0
            age: 0.0
            texture_frame: 0
            is_alive: false
        }
    }

    fn update(mut self, delta_time: f32) {
        if !self.is_alive {
            return
        }

        self.age += delta_time

        // Check if particle should die
        if self.age >= self.lifetime {
            self.is_alive = false
            return
        }

        // Update physics
        self.velocity = Vec3.add(self.velocity, Vec3.scale(self.acceleration, delta_time))
        self.position = Vec3.add(self.position, Vec3.scale(self.velocity, delta_time))

        // Update rotation
        self.rotation += self.angular_velocity * delta_time

        // Update size
        self.size += self.size_velocity * delta_time

        // Update color (fading)
        self.color.r += self.color_velocity.r * delta_time
        self.color.g += self.color_velocity.g * delta_time
        self.color.b += self.color_velocity.b * delta_time
        self.color.a += self.color_velocity.a * delta_time

        // Clamp color
        self.color.r = clamp(self.color.r, 0.0, 1.0)
        self.color.g = clamp(self.color.g, 0.0, 1.0)
        self.color.b = clamp(self.color.b, 0.0, 1.0)
        self.color.a = clamp(self.color.a, 0.0, 1.0)

        // Update texture animation
        // TODO: Animate texture frame based on age
    }
}

// Particle emitter
struct ParticleEmitter {
    name: string
    position: Vec3
    priority: ParticlePriority

    // Emission settings
    emit_rate: f32          // Particles per second
    emit_count: u32         // Total particles to emit (0 = infinite)
    burst_count: u32        // Particles to emit in burst

    // Particle properties
    particle_lifetime_min: f32
    particle_lifetime_max: f32

    particle_size_min: f32
    particle_size_max: f32

    particle_velocity_min: Vec3
    particle_velocity_max: Vec3

    start_color: Vec4
    end_color: Vec4

    gravity: Vec3

    // Rendering
    texture_id: u32
    blend_mode: BlendMode

    // State
    particles: []Particle
    particle_count: u32
    active_particle_count: u32

    emit_accumulator: f32
    total_emitted: u32

    is_active: bool
    is_looping: bool

    allocator: Allocator

    fn create(allocator: Allocator, name: string, max_particles: u32): ParticleEmitter {
        let particles = allocator.alloc_array<Particle>(max_particles)

        for i in 0..max_particles {
            particles[i] = Particle.init()
        }

        return ParticleEmitter {
            name: name
            position: Vec3.zero()
            priority: ParticlePriority.Medium
            emit_rate: 10.0
            emit_count: 0
            burst_count: 0
            particle_lifetime_min: 1.0
            particle_lifetime_max: 2.0
            particle_size_min: 1.0
            particle_size_max: 2.0
            particle_velocity_min: Vec3.new(-1.0, 0.0, -1.0)
            particle_velocity_max: Vec3.new(1.0, 5.0, 1.0)
            start_color: Vec4.new(1.0, 1.0, 1.0, 1.0)
            end_color: Vec4.new(1.0, 1.0, 1.0, 0.0)
            gravity: Vec3.new(0.0, -9.8, 0.0)
            texture_id: 0
            blend_mode: BlendMode.Alpha
            particles: particles
            particle_count: max_particles
            active_particle_count: 0
            emit_accumulator: 0.0
            total_emitted: 0
            is_active: false
            is_looping: true
            allocator: allocator
        }
    }

    fn start(mut self) {
        self.is_active = true
        self.total_emitted = 0
        self.emit_accumulator = 0.0

        // Emit burst if specified
        if self.burst_count > 0 {
            for i in 0..self.burst_count {
                self.emit_particle()
            }
        }
    }

    fn stop(mut self) {
        self.is_active = false
    }

    fn update(mut self, delta_time: f32) {
        // Update all active particles
        self.active_particle_count = 0

        for i in 0..self.particle_count {
            if self.particles[i].is_alive {
                self.particles[i].update(delta_time)

                if self.particles[i].is_alive {
                    self.active_particle_count += 1
                }
            }
        }

        // Emit new particles
        if self.is_active {
            self.emit_accumulator += delta_time

            let particles_to_emit = @floatToInt(u32, self.emit_accumulator * self.emit_rate)
            self.emit_accumulator -= @intToFloat(f32, particles_to_emit) / self.emit_rate

            for i in 0..particles_to_emit {
                // Check if we've hit emit count limit
                if self.emit_count > 0 and self.total_emitted >= self.emit_count {
                    if !self.is_looping {
                        self.stop()
                    }
                    break
                }

                self.emit_particle()
            }
        }
    }

    fn emit_particle(mut self) {
        // Find free particle
        for i in 0..self.particle_count {
            if !self.particles[i].is_alive {
                self.particles[i].is_alive = true
                self.particles[i].age = 0.0

                // Randomize particle properties
                self.particles[i].position = self.position
                self.particles[i].lifetime = random_range(self.particle_lifetime_min, self.particle_lifetime_max)
                self.particles[i].size = random_range(self.particle_size_min, self.particle_size_max)

                self.particles[i].velocity = Vec3.random_range(self.particle_velocity_min, self.particle_velocity_max)
                self.particles[i].acceleration = self.gravity

                self.particles[i].color = self.start_color

                // Calculate color fade velocity
                let color_diff = Vec4.sub(self.end_color, self.start_color)
                self.particles[i].color_velocity = Vec4.scale(color_diff, 1.0 / self.particles[i].lifetime)

                self.total_emitted += 1
                break
            }
        }
    }

    fn render(self, camera: *Camera) {
        // TODO: Render particles as billboards

        // For each active particle:
        // 1. Calculate billboard orientation (face camera)
        // 2. Render quad with particle texture
        // 3. Apply color/alpha blending
    }
}

// Blend modes
enum BlendMode {
    Alpha      // Standard alpha blending
    Additive   // Additive blending (for glows, fire)
    Multiply   // Multiplicative blending
}

// Particle system manager
struct ParticleSystem {
    emitters: [MAX_EMITTERS]ParticleEmitter
    emitter_count: u32

    allocator: Allocator

    fn init(allocator: Allocator): ParticleSystem {
        return ParticleSystem {
            emitters: [ParticleEmitter.create(allocator, "", 0); MAX_EMITTERS]
            emitter_count: 0
            allocator: allocator
        }
    }

    fn create_emitter(mut self, name: string, max_particles: u32): ?*ParticleEmitter {
        if self.emitter_count >= MAX_EMITTERS {
            println("ParticleSystem: Cannot create emitter - max limit reached")
            return null
        }

        self.emitters[self.emitter_count] = ParticleEmitter.create(self.allocator, name, max_particles)
        let emitter = &self.emitters[self.emitter_count]
        self.emitter_count += 1

        return emitter
    }

    fn update(mut self, delta_time: f32) {
        for i in 0..self.emitter_count {
            self.emitters[i].update(delta_time)
        }
    }

    fn render(self, camera: *Camera) {
        for i in 0..self.emitter_count {
            if self.emitters[i].active_particle_count > 0 {
                self.emitters[i].render(camera)
            }
        }
    }
}

// Math helpers
struct Vec3 {
    x: f32
    y: f32
    z: f32

    fn zero(): Vec3 {
        return Vec3 { x: 0.0, y: 0.0, z: 0.0 }
    }

    fn new(x: f32, y: f32, z: f32): Vec3 {
        return Vec3 { x: x, y: y, z: z }
    }

    fn add(a: Vec3, b: Vec3): Vec3 {
        return Vec3 { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }
    }

    fn sub(a: Vec3, b: Vec3): Vec3 {
        return Vec3 { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }
    }

    fn scale(v: Vec3, s: f32): Vec3 {
        return Vec3 { x: v.x * s, y: v.y * s, z: v.z * s }
    }

    fn random_range(min: Vec3, max: Vec3): Vec3 {
        return Vec3 {
            x: random_range_f32(min.x, max.x)
            y: random_range_f32(min.y, max.y)
            z: random_range_f32(min.z, max.z)
        }
    }
}

struct Vec4 {
    r: f32
    g: f32
    b: f32
    a: f32

    fn new(r: f32, g: f32, b: f32, a: f32): Vec4 {
        return Vec4 { r: r, g: g, b: b, a: a }
    }

    fn zero(): Vec4 {
        return Vec4 { r: 0.0, g: 0.0, b: 0.0, a: 0.0 }
    }

    fn sub(a: Vec4, b: Vec4): Vec4 {
        return Vec4 { r: a.r - b.r, g: a.g - b.g, b: a.b - b.b, a: a.a - b.a }
    }

    fn scale(v: Vec4, s: f32): Vec4 {
        return Vec4 { r: v.r * s, g: v.g * s, b: v.b * s, a: v.a * s }
    }
}

struct Camera {}

fn random_range(min: f32, max: f32): f32 {
    // TODO: Random number generation
    return min
}

fn random_range_f32(min: f32, max: f32): f32 {
    return random_range(min, max)
}

fn clamp(value: f32, min: f32, max: f32): f32 {
    if value < min {
        return min
    }
    if value > max {
        return max
    }
    return value
}

// Global particle system
var g_particle_system: ?ParticleSystem = null

export fn init_particle_system(allocator: Allocator) {
    g_particle_system = ParticleSystem.init(allocator)
    println("ParticleSystem: Initialized")
}

export fn shutdown_particle_system() {
    g_particle_system = null
    println("ParticleSystem: Shutdown")
}

export fn create_particle_emitter(name: string, max_particles: u32): ?*ParticleEmitter {
    if !g_particle_system {
        return null
    }

    return g_particle_system.?.create_emitter(name, max_particles)
}

export fn update_particle_system(delta_time: f32) {
    if !g_particle_system {
        return
    }

    g_particle_system.?.update(delta_time)
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
