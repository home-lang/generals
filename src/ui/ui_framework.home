// C&C Generals Zero Hour - Home Port
// UI Framework (Window system and widgets)
//
// Original: GameWindow.cpp, GameWindowManager.cpp (Westwood Studios/EA)
// Ported to Home with modern UI architecture

import basics/allocator
import basics/string
import engine/math
import platform/input

// UI Constants
const MAX_WINDOWS: usize = 576
const MAX_TOOLTIP_LENGTH: usize = 64
const DOUBLE_CLICK_TIME: f32 = 0.3  // Seconds
const TOOLTIP_DELAY: f32 = 0.5      // Seconds

// Window status flags (from EA's WIN_STATUS_* enum)
enum WindowStatus {
    None
    Active          // At top of window list
    Enabled         // Can receive input
    Hidden          // Not visible
    Draggable       // Can be dragged
    Image           // Drawn with images
    Border          // Has border
    NoInput         // Does not take input
    NoFocus         // Does not take focus
    TabStop         // Can be tabbed to
    RightClick      // Responds to right click
    Toggle          // Toggle button
    CheckLike       // Checkbox-style button
    Flashing        // Flashing animation
    Destroyed       // Marked for deletion
}

// Window message types (from EA's GameWindowMessage)
enum WindowMessage {
    None
    Create
    Destroy
    Activate
    Enable
    LeftDown
    LeftUp
    LeftDoubleClick
    LeftDrag
    RightDown
    RightUp
    RightDoubleClick
    RightDrag
    MiddleDown
    MiddleUp
    MouseEntering
    MouseLeaving
    MousePos
    WheelUp
    WheelDown
    Char
    InputFocus
}

// Window colors
struct WindowColors {
    background: Color
    border: Color
    text: Color
    text_border: Color
}

// Color helper
struct Color {
    r: f32
    g: f32
    b: f32
    a: f32
}

// Rectangle
struct Rect {
    x: i32
    y: i32
    width: i32
    height: i32
}

// Window callback function types
type WindowInputCallback = fn(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool
type WindowDrawCallback = fn(window: *Window)
type WindowUpdateCallback = fn(window: *Window, delta_time: f32)

// Base window class (from EA's GameWindow)
struct Window {
    id: u32
    name: string
    rect: Rect
    screen_rect: Rect  // Cached screen coordinates
    status_flags: u32
    is_visible: bool
    is_enabled: bool
    is_focused: bool
    is_hovered: bool
    enabled_colors: WindowColors
    disabled_colors: WindowColors
    hilite_colors: WindowColors
    text: string
    font_size: u32
    tooltip: string
    tooltip_delay: f32
    time_hovered: f32
}

// Button widget
struct Button {
    window: Window
    is_pressed: bool
    is_toggle: bool
    is_checked: bool
}

// Button input handler
fn button_input_handler(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    // Get button from window user data
    let button = @ptrCast(*Button, window.user_data)

    match msg {
        WindowMessage.LeftDown => {
            button.is_pressed = true
            return true
        }
        WindowMessage.LeftUp => {
            if (button.is_pressed) {
                button.is_pressed = false

                if (button.is_toggle) {
                    button.is_checked = !button.is_checked
                }

                // TODO: Fire click event
                return true
            }
        }
        WindowMessage.MouseLeaving => {
            button.is_pressed = false
        }
        _ => {}
    }

    return false
}

// Button draw handler
fn button_draw_handler(window: *Window) {
    let button = @ptrCast(*Button, window.user_data)

    // TODO: Draw button background, border, text
    // This would use the graphics API
}

// Label widget (static text)
struct Label {
    window: Window
}

fn label_draw_handler(window: *Window) {
    // TODO: Draw text
}

// Panel widget (container)
struct Panel {
    window: Window
}

fn panel_draw_handler(window: *Window) {
    // TODO: Draw panel background
}

// Slider widget
struct Slider {
    window: Window
    value: f32       // 0.0 to 1.0
    min_value: f32
    max_value: f32
    is_dragging: bool
}

fn slider_input_handler(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    let slider = @ptrCast(*Slider, window.user_data)

    match msg {
        WindowMessage.LeftDown => {
            slider.is_dragging = true
            return true
        }
        WindowMessage.LeftUp => {
            slider.is_dragging = false
            return true
        }
        WindowMessage.MousePos => {
            if (slider.is_dragging) {
                // Calculate value from mouse position
                let mouse_x = @intCast(i32, data1)
                let local_x = mouse_x - window.screen_rect.x
                slider.value = @intToFloat(f32, local_x) / @intToFloat(f32, window.rect.width)
                slider.value = clamp(slider.value, 0.0, 1.0)
                return true
            }
        }
        _ => {}
    }

    return false
}

fn slider_draw_handler(window: *Window) {
    // TODO: Draw slider track and thumb
}

// Window Manager (from EA's GameWindowManager)
struct WindowManager {
    window_count: usize
    next_window_id: u32
    mouse_x: i32
    mouse_y: i32
    last_click_time: f32
    last_click_x: i32
    last_click_y: i32
    allocator: Allocator
}

// Helper functions

fn clamp(value: f32, min: f32, max: f32): f32 {
    if (value < min) { return min }
    if (value > max) { return max }
    return value
}

// Global window manager
var g_window_manager: ?WindowManager = null

export fn init_ui_framework(allocator: Allocator) {
    g_window_manager = WindowManager.init(allocator)
}

export fn shutdown_ui_framework() {
    if (g_window_manager) {
        g_window_manager.?.deinit()
        g_window_manager = null
    }
}

export fn update_ui(delta_time: f32) {
    if (g_window_manager) {
        g_window_manager.?.update(delta_time)
    }
}

export fn draw_ui() {
    if (g_window_manager) {
        g_window_manager.?.draw()
    }
}

export fn ui_handle_mouse_move(x: i32, y: i32) {
    if (g_window_manager) {
        g_window_manager.?.handle_mouse_move(x, y)
    }
}

export fn ui_handle_mouse_button(button: MouseButton, is_down: bool) {
    if (g_window_manager) {
        g_window_manager.?.handle_mouse_button(button, is_down)
    }
}
