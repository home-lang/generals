// C&C Generals Zero Hour - Home Port
// UI Framework (Window system and widgets)
//
// Original: GameWindow.cpp, GameWindowManager.cpp (Westwood Studios/EA)
// Ported to Home with modern UI architecture

import basics/allocator
import basics/string
import engine/math
import platform/input

// UI Constants
const MAX_WINDOWS: usize = 576
const MAX_TOOLTIP_LENGTH: usize = 64
const DOUBLE_CLICK_TIME: f32 = 0.3  // Seconds
const TOOLTIP_DELAY: f32 = 0.5      // Seconds

// Window status flags (from EA's WIN_STATUS_* enum)
enum WindowStatus {
    None
    Active          // At top of window list
    Enabled         // Can receive input
    Hidden          // Not visible
    Draggable       // Can be dragged
    Image           // Drawn with images
    Border          // Has border
    NoInput         // Does not take input
    NoFocus         // Does not take focus
    TabStop         // Can be tabbed to
    RightClick      // Responds to right click
    Toggle          // Toggle button
    CheckLike       // Checkbox-style button
    Flashing        // Flashing animation
    Destroyed       // Marked for deletion
}

// Window message types (from EA's GameWindowMessage)
enum WindowMessage {
    None
    Create
    Destroy
    Activate
    Enable
    LeftDown
    LeftUp
    LeftDoubleClick
    LeftDrag
    RightDown
    RightUp
    RightDoubleClick
    RightDrag
    MiddleDown
    MiddleUp
    MouseEntering
    MouseLeaving
    MousePos
    WheelUp
    WheelDown
    Char
    InputFocus
}

// Window colors
struct WindowColors {
    background: Color
    border: Color
    text: Color
    text_border: Color

    fn init(): WindowColors {
        return WindowColors {
            background: Color.init(0.2, 0.2, 0.2, 1.0)
            border: Color.init(0.4, 0.4, 0.4, 1.0)
            text: Color.init(1.0, 1.0, 1.0, 1.0)
            text_border: Color.init(0.0, 0.0, 0.0, 1.0)
        }
    }
}

// Color helper
struct Color {
    r: f32
    g: f32
    b: f32
    a: f32

    fn init(r: f32, g: f32, b: f32, a: f32): Color {
        return Color { r: r, g: g, b: b, a: a }
    }

    fn to_u32(&self): u32 {
        let r = @floatToInt(u32, self.r * 255.0)
        let g = @floatToInt(u32, self.g * 255.0)
        let b = @floatToInt(u32, self.b * 255.0)
        let a = @floatToInt(u32, self.a * 255.0)
        return (a << 24) | (r << 16) | (g << 8) | b
    }
}

// Rectangle
struct Rect {
    x: i32
    y: i32
    width: i32
    height: i32

    fn init(x: i32, y: i32, width: i32, height: i32): Rect {
        return Rect { x: x, y: y, width: width, height: height }
    }

    fn contains(&self, px: i32, py: i32): bool {
        return px >= self.x and px < (self.x + self.width) and
               py >= self.y and py < (self.y + self.height)
    }

    fn intersects(&self, other: Rect): bool {
        return self.x < other.x + other.width and
               self.x + self.width > other.x and
               self.y < other.y + other.height and
               self.y + self.height > other.y
    }
}

// Window callback function types
type WindowInputCallback = fn(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool
type WindowDrawCallback = fn(window: *Window)
type WindowUpdateCallback = fn(window: *Window, delta_time: f32)

// Base window class (from EA's GameWindow)
struct Window {
    id: u32
    name: string

    // Hierarchy
    parent: ?*Window
    first_child: ?*Window
    next_sibling: ?*Window
    prev_sibling: ?*Window

    // Position & size
    rect: Rect
    screen_rect: Rect  // Cached screen coordinates

    // Status
    status_flags: u32
    is_visible: bool
    is_enabled: bool
    is_focused: bool
    is_hovered: bool

    // Appearance
    enabled_colors: WindowColors
    disabled_colors: WindowColors
    hilite_colors: WindowColors

    // Text
    text: string
    font_size: u32

    // Tooltip
    tooltip: string
    tooltip_delay: f32
    time_hovered: f32

    // Callbacks
    on_input: ?WindowInputCallback
    on_draw: ?WindowDrawCallback
    on_update: ?WindowUpdateCallback

    // User data
    user_data: ?*void

    fn init(allocator: Allocator, id: u32, name: string): Window {
        return Window {
            id: id
            name: name
            parent: null
            first_child: null
            next_sibling: null
            prev_sibling: null
            rect: Rect.init(0, 0, 100, 100)
            screen_rect: Rect.init(0, 0, 100, 100)
            status_flags: 0
            is_visible: true
            is_enabled: true
            is_focused: false
            is_hovered: false
            enabled_colors: WindowColors.init()
            disabled_colors: WindowColors.init()
            hilite_colors: WindowColors.init()
            text: ""
            font_size: 14
            tooltip: ""
            tooltip_delay: TOOLTIP_DELAY
            time_hovered: 0.0
            on_input: null
            on_draw: null
            on_update: null
            user_data: null
        }
    }

    fn set_position(mut self, x: i32, y: i32) {
        self.rect.x = x
        self.rect.y = y
        self.update_screen_rect()
    }

    fn set_size(mut self, width: i32, height: i32) {
        self.rect.width = width
        self.rect.height = height
        self.update_screen_rect()
    }

    fn update_screen_rect(mut self) {
        // Calculate screen coordinates based on parent
        if self.parent {
            let parent = self.parent.?
            self.screen_rect.x = parent.screen_rect.x + self.rect.x
            self.screen_rect.y = parent.screen_rect.y + self.rect.y
        } else {
            self.screen_rect.x = self.rect.x
            self.screen_rect.y = self.rect.y
        }

        self.screen_rect.width = self.rect.width
        self.screen_rect.height = self.rect.height

        // Update children
        let mut child = self.first_child
        while child {
            child.?.update_screen_rect()
            child = child.?.next_sibling
        }
    }

    fn add_child(mut self, child: *Window) {
        child.parent = self

        // Add to linked list
        if !self.first_child {
            self.first_child = child
        } else {
            let mut last = self.first_child.?
            while last.next_sibling {
                last = last.next_sibling.?
            }
            last.next_sibling = child
            child.prev_sibling = last
        }

        child.update_screen_rect()
    }

    fn remove_child(mut self, child: *Window) {
        if child.prev_sibling {
            child.prev_sibling.?.next_sibling = child.next_sibling
        } else {
            self.first_child = child.next_sibling
        }

        if child.next_sibling {
            child.next_sibling.?.prev_sibling = child.prev_sibling
        }

        child.parent = null
        child.prev_sibling = null
        child.next_sibling = null
    }

    fn point_in_window(&self, x: i32, y: i32): bool {
        return self.screen_rect.contains(x, y)
    }

    fn find_child_at_point(&self, x: i32, y: i32): ?*Window {
        // Check children in reverse order (top to bottom)
        let mut child = self.first_child
        let mut last_child: ?*Window = null

        // Find last child
        while child {
            last_child = child
            child = child.?.next_sibling
        }

        // Iterate backwards
        child = last_child
        while child {
            if child.?.is_visible and child.?.point_in_window(x, y) {
                // Check if any grandchildren contain the point
                let grandchild = child.?.find_child_at_point(x, y)
                if grandchild {
                    return grandchild
                }
                return child
            }
            child = child.?.prev_sibling
        }

        return null
    }

    fn send_message(mut self, msg: WindowMessage, data1: u32, data2: u32): bool {
        if self.on_input {
            return self.on_input.?(self, msg, data1, data2)
        }
        return false
    }

    fn update(mut self, delta_time: f32) {
        // Update hover time for tooltip
        if self.is_hovered {
            self.time_hovered += delta_time
        } else {
            self.time_hovered = 0.0
        }

        // Call update callback
        if self.on_update {
            self.on_update.?(self, delta_time)
        }

        // Update children
        let mut child = self.first_child
        while child {
            if child.?.is_visible {
                child.?.update(delta_time)
            }
            child = child.?.next_sibling
        }
    }

    fn draw(&self) {
        if !self.is_visible {
            return
        }

        // Call draw callback
        if self.on_draw {
            self.on_draw.?(self)
        }

        // Draw children
        let mut child = self.first_child
        while child {
            child.?.draw()
            child = child.?.next_sibling
        }
    }

    fn show(mut self) {
        self.is_visible = true
    }

    fn hide(mut self) {
        self.is_visible = false
    }

    fn enable(mut self) {
        self.is_enabled = true
    }

    fn disable(mut self) {
        self.is_enabled = false
    }

    fn should_show_tooltip(&self): bool {
        return self.is_hovered and self.time_hovered >= self.tooltip_delay and self.tooltip.len > 0
    }
}

// Button widget
struct Button {
    window: Window
    is_pressed: bool
    is_toggle: bool
    is_checked: bool

    fn init(allocator: Allocator, id: u32, text: string): Button {
        let mut button = Button {
            window: Window.init(allocator, id, "Button")
            is_pressed: false
            is_toggle: false
            is_checked: false
        }

        button.window.text = text
        button.window.on_input = button_input_handler
        button.window.on_draw = button_draw_handler

        return button
    }

    fn set_toggle(mut self, is_toggle: bool) {
        self.is_toggle = is_toggle
    }

    fn set_checked(mut self, checked: bool) {
        if self.is_toggle {
            self.is_checked = checked
        }
    }
}

// Button input handler
fn button_input_handler(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    // Get button from window user data
    let button = @ptrCast(*Button, window.user_data)

    match msg {
        WindowMessage.LeftDown => {
            button.is_pressed = true
            return true
        }
        WindowMessage.LeftUp => {
            if button.is_pressed {
                button.is_pressed = false

                if button.is_toggle {
                    button.is_checked = !button.is_checked
                }

                // TODO: Fire click event
                return true
            }
        }
        WindowMessage.MouseLeaving => {
            button.is_pressed = false
        }
        _ => {}
    }

    return false
}

// Button draw handler
fn button_draw_handler(window: *Window) {
    let button = @ptrCast(*Button, window.user_data)

    // TODO: Draw button background, border, text
    // This would use the graphics API
}

// Label widget (static text)
struct Label {
    window: Window

    fn init(allocator: Allocator, id: u32, text: string): Label {
        let mut label = Label {
            window: Window.init(allocator, id, "Label")
        }

        label.window.text = text
        label.window.on_draw = label_draw_handler
        label.window.status_flags |= @enumToInt(WindowStatus.NoInput)

        return label
    }
}

fn label_draw_handler(window: *Window) {
    // TODO: Draw text
}

// Panel widget (container)
struct Panel {
    window: Window

    fn init(allocator: Allocator, id: u32): Panel {
        let mut panel = Panel {
            window: Window.init(allocator, id, "Panel")
        }

        panel.window.on_draw = panel_draw_handler

        return panel
    }
}

fn panel_draw_handler(window: *Window) {
    // TODO: Draw panel background
}

// Slider widget
struct Slider {
    window: Window
    value: f32       // 0.0 to 1.0
    min_value: f32
    max_value: f32
    is_dragging: bool

    fn init(allocator: Allocator, id: u32): Slider {
        let mut slider = Slider {
            window: Window.init(allocator, id, "Slider")
            value: 0.5
            min_value: 0.0
            max_value: 1.0
            is_dragging: false
        }

        slider.window.on_input = slider_input_handler
        slider.window.on_draw = slider_draw_handler

        return slider
    }

    fn get_value(&self): f32 {
        return self.min_value + (self.max_value - self.min_value) * self.value
    }

    fn set_value(mut self, value: f32) {
        let normalized = (value - self.min_value) / (self.max_value - self.min_value)
        self.value = clamp(normalized, 0.0, 1.0)
    }
}

fn slider_input_handler(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    let slider = @ptrCast(*Slider, window.user_data)

    match msg {
        WindowMessage.LeftDown => {
            slider.is_dragging = true
            return true
        }
        WindowMessage.LeftUp => {
            slider.is_dragging = false
            return true
        }
        WindowMessage.MousePos => {
            if slider.is_dragging {
                // Calculate value from mouse position
                let mouse_x = @intCast(i32, data1)
                let local_x = mouse_x - window.screen_rect.x
                slider.value = @intToFloat(f32, local_x) / @intToFloat(f32, window.rect.width)
                slider.value = clamp(slider.value, 0.0, 1.0)
                return true
            }
        }
        _ => {}
    }

    return false
}

fn slider_draw_handler(window: *Window) {
    // TODO: Draw slider track and thumb
}

// Window Manager (from EA's GameWindowManager)
struct WindowManager {
    windows: []Window
    window_count: usize

    root_window: ?*Window
    focused_window: ?*Window
    hovered_window: ?*Window
    captured_window: ?*Window

    next_window_id: u32

    // Mouse state
    mouse_x: i32
    mouse_y: i32
    last_click_time: f32
    last_click_x: i32
    last_click_y: i32

    allocator: Allocator

    fn init(allocator: Allocator): WindowManager {
        return WindowManager {
            windows: allocator.alloc(Window, MAX_WINDOWS)
            window_count: 0
            root_window: null
            focused_window: null
            hovered_window: null
            captured_window: null
            next_window_id: 1
            mouse_x: 0
            mouse_y: 0
            last_click_time: 0.0
            last_click_x: 0
            last_click_y: 0
            allocator: allocator
        }
    }

    fn create_window(mut self, name: string, x: i32, y: i32, width: i32, height: i32): ?*Window {
        if self.window_count >= MAX_WINDOWS {
            return null
        }

        let id = self.next_window_id
        self.next_window_id += 1

        self.windows[self.window_count] = Window.init(self.allocator, id, name)
        let window = &self.windows[self.window_count]
        self.window_count += 1

        window.set_position(x, y)
        window.set_size(width, height)

        return window
    }

    fn update(mut self, delta_time: f32) {
        // Update all windows
        if self.root_window {
            self.root_window.?.update(delta_time)
        }

        // Update last click time for double-click detection
        self.last_click_time += delta_time
    }

    fn draw(&self) {
        // Draw from root
        if self.root_window {
            self.root_window.?.draw()
        }

        // Draw tooltips on top
        self.draw_tooltips()
    }

    fn draw_tooltips(&self) {
        if self.hovered_window {
            if self.hovered_window.?.should_show_tooltip() {
                // TODO: Draw tooltip near mouse cursor
            }
        }
    }

    fn handle_mouse_move(mut self, x: i32, y: i32) {
        self.mouse_x = x
        self.mouse_y = y

        // Update hovered window
        let old_hovered = self.hovered_window
        self.hovered_window = null

        if self.root_window {
            self.hovered_window = self.root_window.?.find_child_at_point(x, y)
        }

        // Send mouse entering/leaving messages
        if old_hovered != self.hovered_window {
            if old_hovered {
                old_hovered.?.is_hovered = false
                old_hovered.?.send_message(WindowMessage.MouseLeaving, 0, 0)
            }

            if self.hovered_window {
                self.hovered_window.?.is_hovered = true
                self.hovered_window.?.send_message(WindowMessage.MouseEntering, 0, 0)
            }
        }

        // Send mouse position to captured window or hovered window
        let target = if self.captured_window { self.captured_window } else { self.hovered_window }
        if target {
            target.?.send_message(WindowMessage.MousePos, @intCast(u32, x), @intCast(u32, y))
        }
    }

    fn handle_mouse_button(mut self, button: MouseButton, is_down: bool) {
        let target = if self.captured_window { self.captured_window } else { self.hovered_window }

        if !target {
            return
        }

        let msg = match button {
            MouseButton.Left => if is_down { WindowMessage.LeftDown } else { WindowMessage.LeftUp }
            MouseButton.Right => if is_down { WindowMessage.RightDown } else { WindowMessage.RightUp }
            MouseButton.Middle => if is_down { WindowMessage.MiddleDown } else { WindowMessage.MiddleUp }
        }

        // Check for double-click
        if is_down and button == MouseButton.Left {
            let dx = self.mouse_x - self.last_click_x
            let dy = self.mouse_y - self.last_click_y
            let dist_sq = dx * dx + dy * dy

            if self.last_click_time < DOUBLE_CLICK_TIME and dist_sq < 16 {
                // Double click
                target.?.send_message(WindowMessage.LeftDoubleClick, 0, 0)
                self.last_click_time = 1000.0  // Reset to prevent triple click
            } else {
                target.?.send_message(msg, 0, 0)
                self.last_click_time = 0.0
                self.last_click_x = self.mouse_x
                self.last_click_y = self.mouse_y
            }
        } else {
            target.?.send_message(msg, 0, 0)
        }
    }

    fn set_focus(mut self, window: ?*Window) {
        if self.focused_window == window {
            return
        }

        if self.focused_window {
            self.focused_window.?.is_focused = false
        }

        self.focused_window = window

        if self.focused_window {
            self.focused_window.?.is_focused = true
            self.focused_window.?.send_message(WindowMessage.InputFocus, 1, 0)
        }
    }

    fn deinit(mut self) {
        self.allocator.free(self.windows)
    }
}

// Helper functions

fn clamp(value: f32, min: f32, max: f32): f32 {
    if value < min { return min }
    if value > max { return max }
    return value
}

// Global window manager
var g_window_manager: ?WindowManager = null

export fn init_ui_framework(allocator: Allocator) {
    g_window_manager = WindowManager.init(allocator)
}

export fn shutdown_ui_framework() {
    if g_window_manager {
        g_window_manager.?.deinit()
        g_window_manager = null
    }
}

export fn update_ui(delta_time: f32) {
    if g_window_manager {
        g_window_manager.?.update(delta_time)
    }
}

export fn draw_ui() {
    if g_window_manager {
        g_window_manager.?.draw()
    }
}

export fn ui_handle_mouse_move(x: i32, y: i32) {
    if g_window_manager {
        g_window_manager.?.handle_mouse_move(x, y)
    }
}

export fn ui_handle_mouse_button(button: MouseButton, is_down: bool) {
    if g_window_manager {
        g_window_manager.?.handle_mouse_button(button, is_down)
    }
}
