// C&C Generals Zero Hour - Home Port
// Main Menu System
//
// Original: MainMenuLogic.cpp, Shell.cpp (Westwood Studios/EA)
// Ported to Home with C&C Generals menu structure

import basics/allocator
import ui/ui_framework
import network/lobby

// Menu states
enum MenuState {
    MainMenu
    SinglePlayer
    Multiplayer
    Skirmish
    Campaign
    Options
    Credits
    Quit
}

// Main menu layout
struct MainMenu {
    // Root window
    root: *Window

    // Current state
    current_state: MenuState
    previous_state: MenuState

    // Main menu buttons
    btn_single_player: *Button
    btn_multiplayer: *Button
    btn_options: *Button
    btn_replay_theater: *Button
    btn_credits: *Button
    btn_quit: *Button

    // Background
    background_window: *Window

    // Version label
    version_label: *Label

    allocator: Allocator

    fn init(allocator: Allocator, window_mgr: *WindowManager): MainMenu {
        let mut menu = MainMenu {
            root: window_mgr.create_window("MainMenuRoot", 0, 0, 1024, 768).?
            current_state: MenuState.MainMenu
            previous_state: MenuState.MainMenu
            btn_single_player: null
            btn_multiplayer: null
            btn_options: null
            btn_replay_theater: null
            btn_credits: null
            btn_quit: null
            background_window: null
            version_label: null
            allocator: allocator
        }

        menu.create_main_menu_layout()
        return menu
    }

    fn create_main_menu_layout(mut self) {
        // Background
        self.background_window = g_window_manager.?.create_window("Background", 0, 0, 1024, 768).?
        self.root.add_child(self.background_window)

        // C&C Generals style: vertical button layout on right side
        let button_x: i32 = 700
        let button_y_start: i32 = 250
        let button_width: i32 = 250
        let button_height: i32 = 50
        let button_spacing: i32 = 10

        // Single Player button
        self.btn_single_player = self.create_menu_button(
            "Single Player",
            button_x,
            button_y_start,
            button_width,
            button_height
        )
        self.btn_single_player.window.on_input = on_single_player_clicked

        // Multiplayer button
        self.btn_multiplayer = self.create_menu_button(
            "Multiplayer",
            button_x,
            button_y_start + (button_height + button_spacing) * 1,
            button_width,
            button_height
        )
        self.btn_multiplayer.window.on_input = on_multiplayer_clicked

        // Options button
        self.btn_options = self.create_menu_button(
            "Options",
            button_x,
            button_y_start + (button_height + button_spacing) * 2,
            button_width,
            button_height
        )
        self.btn_options.window.on_input = on_options_clicked

        // Replay Theater button
        self.btn_replay_theater = self.create_menu_button(
            "Replay Theater",
            button_x,
            button_y_start + (button_height + button_spacing) * 3,
            button_width,
            button_height
        )
        self.btn_replay_theater.window.on_input = on_replay_theater_clicked

        // Credits button
        self.btn_credits = self.create_menu_button(
            "Credits",
            button_x,
            button_y_start + (button_height + button_spacing) * 4,
            button_width,
            button_height
        )
        self.btn_credits.window.on_input = on_credits_clicked

        // Quit button
        self.btn_quit = self.create_menu_button(
            "Quit",
            button_x,
            button_y_start + (button_height + button_spacing) * 5,
            button_width,
            button_height
        )
        self.btn_quit.window.on_input = on_quit_clicked

        // Version label (bottom left)
        let version_button = Button.init(self.allocator, 100, "Version 1.0")
        self.version_label = @ptrCast(*Label, &version_button)
        self.version_label.window.set_position(10, 740)
        self.version_label.window.set_size(200, 20)
        self.root.add_child(&self.version_label.window)
    }

    fn create_menu_button(mut self, text: string, x: i32, y: i32, width: i32, height: i32): *Button {
        let button = Button.init(self.allocator, self.get_next_id(), text)
        button.window.set_position(x, y)
        button.window.set_size(width, height)
        self.root.add_child(&button.window)
        return &button
    }

    fn get_next_id(mut self): u32 {
        // TODO: Proper ID generation
        return 1
    }

    fn transition_to(mut self, new_state: MenuState) {
        self.previous_state = self.current_state
        self.current_state = new_state

        // Hide/show appropriate screens
        match new_state {
            MenuState.MainMenu => {
                self.show_main_menu()
            }
            MenuState.Skirmish => {
                self.show_skirmish_menu()
            }
            MenuState.Multiplayer => {
                self.show_multiplayer_menu()
            }
            MenuState.Options => {
                self.show_options_menu()
            }
            _ => {}
        }
    }

    fn show_main_menu(mut self) {
        // Show main menu buttons
        self.btn_single_player.window.show()
        self.btn_multiplayer.window.show()
        self.btn_options.window.show()
        self.btn_replay_theater.window.show()
        self.btn_credits.window.show()
        self.btn_quit.window.show()
    }

    fn hide_main_menu(mut self) {
        self.btn_single_player.window.hide()
        self.btn_multiplayer.window.hide()
        self.btn_options.window.hide()
        self.btn_replay_theater.window.hide()
        self.btn_credits.window.hide()
        self.btn_quit.window.hide()
    }

    fn show_skirmish_menu(mut self) {
        self.hide_main_menu()
        // TODO: Show skirmish setup screen
    }

    fn show_multiplayer_menu(mut self) {
        self.hide_main_menu()
        // TODO: Show multiplayer lobby browser
    }

    fn show_options_menu(mut self) {
        self.hide_main_menu()
        // TODO: Show options screen
    }
}

// Skirmish setup menu
struct SkirmishMenu {
    root: *Window

    // Map selection
    map_list: *Panel
    selected_map: string

    // Player slots
    player_slots: [8]*PlayerSlotWidget
    player_count: usize

    // Game settings
    starting_money_slider: *Slider
    game_speed_dropdown: *Panel  // TODO: Proper dropdown widget
    allow_superweapons_checkbox: *Button

    // Buttons
    btn_start_game: *Button
    btn_back: *Button

    allocator: Allocator

    fn init(allocator: Allocator, window_mgr: *WindowManager): SkirmishMenu {
        let mut menu = SkirmishMenu {
            root: window_mgr.create_window("SkirmishRoot", 0, 0, 1024, 768).?
            map_list: null
            selected_map: "Tournament Desert"
            player_slots: [null, null, null, null, null, null, null, null]
            player_count: 2
            starting_money_slider: null
            game_speed_dropdown: null
            allow_superweapons_checkbox: null
            btn_start_game: null
            btn_back: null
            allocator: allocator
        }

        menu.create_skirmish_layout()
        return menu
    }

    fn create_skirmish_layout(mut self) {
        // Map list on left
        let map_panel = Panel.init(self.allocator, 1)
        map_panel.window.set_position(20, 20)
        map_panel.window.set_size(300, 600)
        self.map_list = &map_panel
        self.root.add_child(&self.map_list.window)

        // Player slots in center
        let slot_x: i32 = 350
        let slot_y: i32 = 50
        let slot_height: i32 = 80

        for i in 0..8 {
            let slot = PlayerSlotWidget.init(self.allocator, @intCast(u8, i))
            slot.window.set_position(slot_x, slot_y + @intCast(i32, i) * slot_height)
            slot.window.set_size(600, 70)
            self.player_slots[i] = &slot
            self.root.add_child(&slot.window)
        }

        // Game settings on right
        let settings_x: i32 = 700

        // Starting money slider
        let money_slider = Slider.init(self.allocator, 10)
        money_slider.window.set_position(settings_x, 100)
        money_slider.window.set_size(200, 30)
        money_slider.min_value = 5000.0
        money_slider.max_value = 50000.0
        money_slider.set_value(10000.0)
        self.starting_money_slider = &money_slider
        self.root.add_child(&money_slider.window)

        // Superweapons checkbox
        let sw_checkbox = Button.init(self.allocator, 11, "Allow Superweapons")
        sw_checkbox.set_toggle(true)
        sw_checkbox.set_checked(true)
        sw_checkbox.window.set_position(settings_x, 150)
        sw_checkbox.window.set_size(200, 30)
        self.allow_superweapons_checkbox = &sw_checkbox
        self.root.add_child(&sw_checkbox.window)

        // Start button
        let start_btn = Button.init(self.allocator, 12, "Start Game")
        start_btn.window.set_position(800, 700)
        start_btn.window.set_size(200, 50)
        start_btn.window.on_input = on_start_skirmish_clicked
        self.btn_start_game = &start_btn
        self.root.add_child(&start_btn.window)

        // Back button
        let back_btn = Button.init(self.allocator, 13, "Back")
        back_btn.window.set_position(580, 700)
        back_btn.window.set_size(200, 50)
        back_btn.window.on_input = on_back_clicked
        self.btn_back = &back_btn
        self.root.add_child(&back_btn.window)
    }

    fn set_player_slot(mut self, slot_index: usize, player_name: string, faction: string, team: u8) {
        if slot_index < 8 {
            self.player_slots[slot_index].set_player(player_name, faction, team)
        }
    }

    fn set_ai_slot(mut self, slot_index: usize, difficulty: string, faction: string, team: u8) {
        if slot_index < 8 {
            self.player_slots[slot_index].set_ai(difficulty, faction, team)
        }
    }
}

// Player slot widget (for skirmish/multiplayer setup)
struct PlayerSlotWidget {
    window: Window
    slot_index: u8

    // Components
    name_label: *Label
    faction_button: *Button
    team_button: *Button
    color_indicator: *Panel

    // State
    is_human: bool
    player_name: string
    faction: string
    team: u8
    color: Color

    fn init(allocator: Allocator, slot_index: u8): PlayerSlotWidget {
        let mut widget = PlayerSlotWidget {
            window: Window.init(allocator, @intCast(u32, slot_index), "PlayerSlot")
            slot_index: slot_index
            name_label: null
            faction_button: null
            team_button: null
            color_indicator: null
            is_human: false
            player_name: "Empty"
            faction: "USA"
            team: 0
            color: Color.init(1.0, 0.0, 0.0, 1.0)
        }

        // Create sub-widgets
        let name_lbl = Label.init(allocator, 1, "Empty")
        name_lbl.window.set_position(10, 10)
        name_lbl.window.set_size(200, 30)
        widget.name_label = &name_lbl
        widget.window.add_child(&name_lbl.window)

        let faction_btn = Button.init(allocator, 2, "USA")
        faction_btn.window.set_position(220, 10)
        faction_btn.window.set_size(100, 30)
        widget.faction_button = &faction_btn
        widget.window.add_child(&faction_btn.window)

        let team_btn = Button.init(allocator, 3, "Team 1")
        team_btn.window.set_position(330, 10)
        team_btn.window.set_size(100, 30)
        widget.team_button = &team_btn
        widget.window.add_child(&team_btn.window)

        return widget
    }

    fn set_player(mut self, name: string, faction: string, team: u8) {
        self.is_human = true
        self.player_name = name
        self.faction = faction
        self.team = team

        self.name_label.window.text = name
        self.faction_button.window.text = faction
        self.team_button.window.text = format_team_name(team)
    }

    fn set_ai(mut self, difficulty: string, faction: string, team: u8) {
        self.is_human = false
        self.player_name = format_ai_name(difficulty)
        self.faction = faction
        self.team = team

        self.name_label.window.text = self.player_name
        self.faction_button.window.text = faction
        self.team_button.window.text = format_team_name(team)
    }
}

// Options menu
struct OptionsMenu {
    root: *Window

    // Video options
    resolution_dropdown: *Panel
    fullscreen_checkbox: *Button
    vsync_checkbox: *Button
    graphics_quality_slider: *Slider

    // Audio options
    master_volume_slider: *Slider
    music_volume_slider: *Slider
    sfx_volume_slider: *Slider

    // Game options
    auto_save_checkbox: *Button
    show_fps_checkbox: *Button

    // Buttons
    btn_apply: *Button
    btn_cancel: *Button

    allocator: Allocator

    fn init(allocator: Allocator, window_mgr: *WindowManager): OptionsMenu {
        let mut menu = OptionsMenu {
            root: window_mgr.create_window("OptionsRoot", 0, 0, 800, 600).?
            resolution_dropdown: null
            fullscreen_checkbox: null
            vsync_checkbox: null
            graphics_quality_slider: null
            master_volume_slider: null
            music_volume_slider: null
            sfx_volume_slider: null
            auto_save_checkbox: null
            show_fps_checkbox: null
            btn_apply: null
            btn_cancel: null
            allocator: allocator
        }

        menu.create_options_layout()
        return menu
    }

    fn create_options_layout(mut self) {
        // Video section
        let fullscreen_cb = Button.init(self.allocator, 1, "Fullscreen")
        fullscreen_cb.set_toggle(true)
        fullscreen_cb.window.set_position(50, 50)
        fullscreen_cb.window.set_size(200, 30)
        self.fullscreen_checkbox = &fullscreen_cb
        self.root.add_child(&fullscreen_cb.window)

        // VSync checkbox
        let vsync_cb = Button.init(self.allocator, 2, "VSync")
        vsync_cb.set_toggle(true)
        vsync_cb.window.set_position(50, 90)
        vsync_cb.window.set_size(200, 30)
        self.vsync_checkbox = &vsync_cb
        self.root.add_child(&vsync_cb.window)

        // Graphics quality slider
        let gfx_slider = Slider.init(self.allocator, 3)
        gfx_slider.window.set_position(50, 140)
        gfx_slider.window.set_size(300, 30)
        gfx_slider.min_value = 0.0
        gfx_slider.max_value = 3.0  // Low, Medium, High, Ultra
        self.graphics_quality_slider = &gfx_slider
        self.root.add_child(&gfx_slider.window)

        // Audio section (right side)
        // Master volume
        let master_vol = Slider.init(self.allocator, 4)
        master_vol.window.set_position(450, 50)
        master_vol.window.set_size(300, 30)
        self.master_volume_slider = &master_vol
        self.root.add_child(&master_vol.window)

        // Music volume
        let music_vol = Slider.init(self.allocator, 5)
        music_vol.window.set_position(450, 90)
        music_vol.window.set_size(300, 30)
        self.music_volume_slider = &music_vol
        self.root.add_child(&music_vol.window)

        // SFX volume
        let sfx_vol = Slider.init(self.allocator, 6)
        sfx_vol.window.set_position(450, 130)
        sfx_vol.window.set_size(300, 30)
        self.sfx_volume_slider = &sfx_vol
        self.root.add_child(&sfx_vol.window)

        // Bottom buttons
        let apply_btn = Button.init(self.allocator, 7, "Apply")
        apply_btn.window.set_position(500, 520)
        apply_btn.window.set_size(120, 40)
        self.btn_apply = &apply_btn
        self.root.add_child(&apply_btn.window)

        let cancel_btn = Button.init(self.allocator, 8, "Cancel")
        cancel_btn.window.set_position(650, 520)
        cancel_btn.window.set_size(120, 40)
        self.btn_cancel = &cancel_btn
        self.root.add_child(&cancel_btn.window)
    }
}

// Button click handlers

fn on_single_player_clicked(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    if msg == WindowMessage.LeftUp {
        // TODO: Transition to campaign/skirmish selection
        return true
    }
    return false
}

fn on_multiplayer_clicked(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    if msg == WindowMessage.LeftUp {
        // TODO: Transition to multiplayer lobby
        return true
    }
    return false
}

fn on_options_clicked(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    if msg == WindowMessage.LeftUp {
        // TODO: Show options menu
        return true
    }
    return false
}

fn on_replay_theater_clicked(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    if msg == WindowMessage.LeftUp {
        // TODO: Show replay browser
        return true
    }
    return false
}

fn on_credits_clicked(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    if msg == WindowMessage.LeftUp {
        // TODO: Show credits screen
        return true
    }
    return false
}

fn on_quit_clicked(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    if msg == WindowMessage.LeftUp {
        // TODO: Show quit confirmation
        request_quit()
        return true
    }
    return false
}

fn on_start_skirmish_clicked(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    if msg == WindowMessage.LeftUp {
        // TODO: Start skirmish game with current settings
        return true
    }
    return false
}

fn on_back_clicked(window: *Window, msg: WindowMessage, data1: u32, data2: u32): bool {
    if msg == WindowMessage.LeftUp {
        // TODO: Return to previous menu
        return true
    }
    return false
}

// Helper functions

fn format_team_name(team: u8): string {
    match team {
        0 => "Observer"
        1 => "Team 1"
        2 => "Team 2"
        3 => "Team 3"
        4 => "Team 4"
        _ => "Team ?"
    }
}

fn format_ai_name(difficulty: string): string {
    return "AI (" + difficulty + ")"
}

fn request_quit() {
    // TODO: Set quit flag
}

// Global menu state
var g_main_menu: ?MainMenu = null
var g_skirmish_menu: ?SkirmishMenu = null
var g_options_menu: ?OptionsMenu = null

export fn init_main_menu(allocator: Allocator, window_mgr: *WindowManager) {
    g_main_menu = MainMenu.init(allocator, window_mgr)
}

export fn init_skirmish_menu(allocator: Allocator, window_mgr: *WindowManager) {
    g_skirmish_menu = SkirmishMenu.init(allocator, window_mgr)
}

export fn init_options_menu(allocator: Allocator, window_mgr: *WindowManager) {
    g_options_menu = OptionsMenu.init(allocator, window_mgr)
}

export fn show_main_menu() {
    if g_main_menu {
        g_main_menu.?.root.show()
    }
}

export fn hide_main_menu() {
    if g_main_menu {
        g_main_menu.?.root.hide()
    }
}
