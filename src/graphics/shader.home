// C&C Generals Zero Hour - Home Port
// Shader System
//
// Original: EA's shader system for DirectX 8/9
// Enhanced with modern shader support (HLSL/GLSL/Metal/SPIR-V)
//
// Shader pipeline:
// 1. Write shaders in HLSL (DirectX-style, most portable)
// 2. Cross-compile to target APIs:
//    - DirectX 12: HLSL → DXIL
//    - Vulkan: HLSL → SPIR-V (via DXC)
//    - Metal: HLSL → MSL (via spirv-cross)
//    - OpenGL: HLSL → GLSL (via spirv-cross)
//
// Usage:
// ```
// let shader = Shader.load("shaders/terrain.hlsl")
// shader.set_uniform("u_ModelMatrix", model_matrix)
// shader.set_uniform("u_ViewProjMatrix", view_proj)
// shader.bind()
// renderer.draw(mesh)
// ```

import basics/allocator
import basics/string

const MAX_SHADERS: u32 = 512
const MAX_UNIFORMS_PER_SHADER: u32 = 64
const MAX_SHADER_SOURCE_SIZE: u32 = 1048576  // 1MB

// Shader type
enum ShaderType {
    Vertex
    Fragment  // Pixel shader
    Geometry
    Compute
}

// Shader stage
struct ShaderStage {
    shader_type: ShaderType
    source_code: string
    entry_point: string  // "main" or "VSMain", "PSMain", etc.

    // Compiled bytecode (API-specific)
    bytecode: []u8
    bytecode_size: u32

    fn init(shader_type: ShaderType): ShaderStage {
        return ShaderStage {
            shader_type: shader_type
            source_code: ""
            entry_point: "main"
            bytecode: []
            bytecode_size: 0
        }
    }
}

// Shader uniform type
enum UniformType {
    Float
    Vec2
    Vec3
    Vec4
    Mat3
    Mat4
    Texture2D
    TextureCube
    Int
    Bool
}

// Shader uniform
struct ShaderUniform {
    name: string
    uniform_type: UniformType
    location: i32  // Binding location/register
    size: u32      // Array size (1 for non-arrays)

    fn init(name: string, uniform_type: UniformType): ShaderUniform {
        return ShaderUniform {
            name: name
            uniform_type: uniform_type
            location: -1
            size: 1
        }
    }
}

// Complete shader program
struct Shader {
    name: string
    id: u32

    vertex_stage: ShaderStage
    fragment_stage: ShaderStage
    geometry_stage: ?ShaderStage
    compute_stage: ?ShaderStage

    uniforms: [MAX_UNIFORMS_PER_SHADER]ShaderUniform
    uniform_count: u32

    // API-specific handle
    native_handle: u64  // ID3D12PipelineState*, VkPipeline, etc.

    is_compiled: bool

    fn init(name: string, id: u32): Shader {
        return Shader {
            name: name
            id: id
            vertex_stage: ShaderStage.init(ShaderType.Vertex)
            fragment_stage: ShaderStage.init(ShaderType.Fragment)
            geometry_stage: null
            compute_stage: null
            uniforms: [ShaderUniform.init("", UniformType.Float); MAX_UNIFORMS_PER_SHADER]
            uniform_count: 0
            native_handle: 0
            is_compiled: false
        }
    }

    fn compile(mut self, renderer_api: RendererAPI): bool {
        println("Compiling shader: {self.name}")

        // Compile vertex shader
        if !self.compile_stage(&self.vertex_stage, renderer_api) {
            println("  Failed to compile vertex shader")
            return false
        }

        // Compile fragment shader
        if !self.compile_stage(&self.fragment_stage, renderer_api) {
            println("  Failed to compile fragment shader")
            return false
        }

        // Compile geometry shader (if present)
        if self.geometry_stage {
            if !self.compile_stage(self.geometry_stage.?, renderer_api) {
                println("  Failed to compile geometry shader")
                return false
            }
        }

        // Link shader program (API-specific)
        self.native_handle = link_shader_program(self, renderer_api)

        if self.native_handle == 0 {
            println("  Failed to link shader program")
            return false
        }

        self.is_compiled = true
        println("  ✓ Shader compiled successfully")

        return true
    }

    fn compile_stage(self, stage: *ShaderStage, renderer_api: RendererAPI): bool {
        // TODO: Call platform-specific shader compiler
        // For DirectX 12: Use DXC
        // For Vulkan: Use DXC → SPIR-V
        // For Metal: Use spirv-cross → MSL
        // For OpenGL: Use spirv-cross → GLSL

        // Placeholder - assume success
        return true
    }

    fn add_uniform(mut self, name: string, uniform_type: UniformType) {
        if self.uniform_count >= MAX_UNIFORMS_PER_SHADER {
            println("Shader: Cannot add uniform '{name}' - max limit reached")
            return
        }

        self.uniforms[self.uniform_count] = ShaderUniform.init(name, uniform_type)
        self.uniform_count += 1
    }

    fn get_uniform_location(self, name: string): i32 {
        for i in 0..self.uniform_count {
            if self.uniforms[i].name == name {
                return self.uniforms[i].location
            }
        }

        return -1  // Not found
    }

    fn set_uniform_float(self, name: string, value: f32) {
        let location = self.get_uniform_location(name)
        if location >= 0 {
            // TODO: Set uniform via renderer API
        }
    }

    fn set_uniform_vec3(self, name: string, value: Vec3) {
        let location = self.get_uniform_location(name)
        if location >= 0 {
            // TODO: Set uniform via renderer API
        }
    }

    fn set_uniform_mat4(self, name: string, value: Mat4) {
        let location = self.get_uniform_location(name)
        if location >= 0 {
            // TODO: Set uniform via renderer API
        }
    }

    fn bind(self) {
        if !self.is_compiled {
            println("Shader: Cannot bind uncompiled shader '{self.name}'")
            return
        }

        // TODO: Bind shader via renderer API
        // For DirectX 12: SetPipelineState()
        // For Vulkan: vkCmdBindPipeline()
        // For Metal: setRenderPipelineState()
        // For OpenGL: glUseProgram()
    }
}

// Shader manager
struct ShaderManager {
    shaders: [MAX_SHADERS]Shader
    shader_count: u32
    next_shader_id: u32

    allocator: Allocator

    fn init(allocator: Allocator): ShaderManager {
        return ShaderManager {
            shaders: [Shader.init("", 0); MAX_SHADERS]
            shader_count: 0
            next_shader_id: 1
            allocator: allocator
        }
    }

    fn load_shader(mut self, name: string, vertex_path: string, fragment_path: string, renderer_api: RendererAPI): ?*Shader {
        if self.shader_count >= MAX_SHADERS {
            println("ShaderManager: Cannot load shader - max limit reached")
            return null
        }

        // Read shader source files
        let vertex_source = read_file(vertex_path)
        if !vertex_source {
            println("ShaderManager: Failed to read vertex shader: {vertex_path}")
            return null
        }

        let fragment_source = read_file(fragment_path)
        if !fragment_source {
            println("ShaderManager: Failed to read fragment shader: {fragment_path}")
            return null
        }

        // Create shader
        let shader_id = self.next_shader_id
        self.next_shader_id += 1

        self.shaders[self.shader_count] = Shader.init(name, shader_id)
        self.shaders[self.shader_count].vertex_stage.source_code = vertex_source.?
        self.shaders[self.shader_count].fragment_stage.source_code = fragment_source.?

        // Compile shader
        if !self.shaders[self.shader_count].compile(renderer_api) {
            println("ShaderManager: Failed to compile shader: {name}")
            return null
        }

        let shader = &self.shaders[self.shader_count]
        self.shader_count += 1

        println("ShaderManager: Loaded shader '{name}' (ID: {shader_id})")

        return shader
    }

    fn get_shader(mut self, name: string): ?*Shader {
        for i in 0..self.shader_count {
            if self.shaders[i].name == name {
                return &self.shaders[i]
            }
        }

        return null
    }

    fn reload_shader(mut self, name: string, renderer_api: RendererAPI): bool {
        let shader = self.get_shader(name)
        if !shader {
            return false
        }

        println("ShaderManager: Reloading shader '{name}'")

        // Recompile
        return shader.?.compile(renderer_api)
    }
}

// Renderer API enum
enum RendererAPI {
    DirectX12
    Vulkan
    Metal
    OpenGL
}

// Platform-specific shader linking
fn link_shader_program(shader: Shader, renderer_api: RendererAPI): u64 {
    // TODO: Platform-specific shader program linking
    // This would create the pipeline state object

    return 1  // Placeholder - return fake handle
}

// Read shader source file
fn read_file(path: string): ?string {
    // TODO: Read file
    return null
}

// Math types (minimal definitions for shader uniforms)
struct Vec3 {
    x: f32
    y: f32
    z: f32
}

struct Mat4 {
    m: [16]f32
}

// Global shader manager
var g_shader_manager: ?ShaderManager = null

export fn init_shader_manager(allocator: Allocator) {
    g_shader_manager = ShaderManager.init(allocator)
    println("ShaderManager: Initialized")
}

export fn shutdown_shader_manager() {
    g_shader_manager = null
    println("ShaderManager: Shutdown")
}

export fn load_shader(name: string, vertex_path: string, fragment_path: string, renderer_api: RendererAPI): ?*Shader {
    if !g_shader_manager {
        return null
    }

    return g_shader_manager.?.load_shader(name, vertex_path, fragment_path, renderer_api)
}

export fn get_shader(name: string): ?*Shader {
    if !g_shader_manager {
        return null
    }

    return g_shader_manager.?.get_shader(name)
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
