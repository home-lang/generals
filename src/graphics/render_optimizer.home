// C&C Generals Zero Hour - Home Port
// Rendering Optimization System
//
// Original: EA's WW3D renderer with scene culling
// Enhanced with modern optimization techniques
//
// EA's optimization strategies:
// - Frustum culling (don't render off-screen objects)
// - LOD system (lower detail for distant objects)
// - Occlusion culling (don't render hidden objects)
// - Draw call batching (reduce API calls)
// - Texture atlasing (reduce texture switches)
// - Particle culling by priority
//
// Optimizations added in this port:
// - Automatic draw call batching
// - Spatial hash grid for fast visibility queries
// - Distance-based culling
// - Mesh instancing for repeated objects (tanks, soldiers)
//
// Usage:
// ```
// let optimizer = RenderOptimizer.init(allocator)
//
// // Add objects to scene
// optimizer.add_renderable(tank_mesh, transform, material)
//
// // Cull and batch
// optimizer.update_visibility(camera)
// let draw_calls = optimizer.get_batched_draw_calls()
//
// // Submit to GPU
// for call in draw_calls {
//     renderer.draw(call)
// }
// ```

import basics/allocator
import basics/string
import engine/math

const MAX_RENDERABLES: u32 = 10000
const MAX_DRAW_CALLS: u32 = 2048
const MAX_INSTANCES_PER_BATCH: u32 = 512

// Renderable object
struct Renderable {
    id: u32
    mesh_id: u32
    material_id: u32

    transform: Mat4
    bounding_sphere: BoundingSphere

    is_visible: bool
    distance_to_camera: f32

    fn init(id: u32): Renderable {
        return Renderable {
            id: id
            mesh_id: 0
            material_id: 0
            transform: Mat4.identity()
            bounding_sphere: BoundingSphere {
                center: Vec3.zero()
                radius: 1.0
            }
            is_visible: true
            distance_to_camera: 0.0
        }
    }
}

// Bounding sphere for frustum culling
struct BoundingSphere {
    center: Vec3
    radius: f32

    fn intersects_frustum(self, frustum: *Frustum): bool {
        // Check sphere against all 6 frustum planes
        for i in 0..6 {
            let plane = &frustum.planes[i]
            let distance = Vec3.dot(self.center, plane.normal) + plane.distance

            if distance < -self.radius {
                return false  // Outside frustum
            }
        }

        return true
    }
}

// Frustum for culling
struct Plane {
    normal: Vec3
    distance: f32
}

struct Frustum {
    planes: [6]Plane  // Left, Right, Top, Bottom, Near, Far

    fn init(): Frustum {
        return Frustum {
            planes: [Plane {
                normal: Vec3.zero()
                distance: 0.0
            }; 6]
        }
    }

    fn extract_from_matrix(mut self, view_proj: Mat4) {
        // Extract frustum planes from view-projection matrix
        // Left plane
        self.planes[0].normal.x = view_proj.m[3] + view_proj.m[0]
        self.planes[0].normal.y = view_proj.m[7] + view_proj.m[4]
        self.planes[0].normal.z = view_proj.m[11] + view_proj.m[8]
        self.planes[0].distance = view_proj.m[15] + view_proj.m[12]

        // Right plane
        self.planes[1].normal.x = view_proj.m[3] - view_proj.m[0]
        self.planes[1].normal.y = view_proj.m[7] - view_proj.m[4]
        self.planes[1].normal.z = view_proj.m[11] - view_proj.m[8]
        self.planes[1].distance = view_proj.m[15] - view_proj.m[12]

        // TODO: Extract other planes (Top, Bottom, Near, Far)

        // Normalize planes
        for i in 0..6 {
            let len = Vec3.length(self.planes[i].normal)
            if len > 0.0 {
                self.planes[i].normal = Vec3.scale(self.planes[i].normal, 1.0 / len)
                self.planes[i].distance /= len
            }
        }
    }
}

// Draw call batch (instanced rendering)
struct DrawCall {
    mesh_id: u32
    material_id: u32

    instance_transforms: [MAX_INSTANCES_PER_BATCH]Mat4
    instance_count: u32

    // Sort key for state sorting
    sort_key: u64  // [depth:16][material:24][mesh:24]

    fn init(): DrawCall {
        return DrawCall {
            mesh_id: 0
            material_id: 0
            instance_transforms: [Mat4.identity(); MAX_INSTANCES_PER_BATCH]
            instance_count: 0
            sort_key: 0
        }
    }

    fn add_instance(mut self, transform: Mat4): bool {
        if self.instance_count >= MAX_INSTANCES_PER_BATCH {
            return false
        }

        self.instance_transforms[self.instance_count] = transform
        self.instance_count += 1
        return true
    }

    fn compute_sort_key(mut self, camera_distance: f32) {
        // Pack sort key for optimal rendering order
        // Format: [depth:16 bits][material:24 bits][mesh:24 bits]

        let depth_bits = @floatToInt(u64, camera_distance * 65535.0 / 1000.0)  // Max 1000 units
        let material_bits = @intCast(u64, self.material_id)
        let mesh_bits = @intCast(u64, self.mesh_id)

        self.sort_key = (depth_bits << 48) | (material_bits << 24) | mesh_bits
    }
}

// Render optimizer
struct RenderOptimizer {
    renderables: [MAX_RENDERABLES]Renderable
    renderable_count: u32

    frustum: Frustum

    // Draw calls (batched)
    draw_calls: [MAX_DRAW_CALLS]DrawCall
    draw_call_count: u32

    // Statistics
    total_objects: u32
    visible_objects: u32
    culled_objects: u32
    draw_calls_issued: u32

    allocator: Allocator

    fn init(allocator: Allocator): RenderOptimizer {
        return RenderOptimizer {
            renderables: [Renderable.init(0); MAX_RENDERABLES]
            renderable_count: 0
            frustum: Frustum.init()
            draw_calls: [DrawCall.init(); MAX_DRAW_CALLS]
            draw_call_count: 0
            total_objects: 0
            visible_objects: 0
            culled_objects: 0
            draw_calls_issued: 0
            allocator: allocator
        }
    }

    fn add_renderable(mut self, mesh_id: u32, material_id: u32, transform: Mat4, bounding_sphere: BoundingSphere): u32 {
        if self.renderable_count >= MAX_RENDERABLES {
            println("RenderOptimizer: Cannot add renderable - max limit reached!")
            return 0
        }

        let id = self.renderable_count + 1
        self.renderables[self.renderable_count] = Renderable.init(id)
        self.renderables[self.renderable_count].mesh_id = mesh_id
        self.renderables[self.renderable_count].material_id = material_id
        self.renderables[self.renderable_count].transform = transform
        self.renderables[self.renderable_count].bounding_sphere = bounding_sphere

        self.renderable_count += 1
        self.total_objects = self.renderable_count

        return id
    }

    fn update_visibility(mut self, camera_pos: Vec3, view_proj: Mat4) {
        // Extract frustum from view-projection matrix
        self.frustum.extract_from_matrix(view_proj)

        self.visible_objects = 0
        self.culled_objects = 0

        // Frustum cull all renderables
        for i in 0..self.renderable_count {
            let obj = &self.renderables[i]

            // Calculate distance to camera
            self.renderables[i].distance_to_camera = Vec3.distance(camera_pos, obj.bounding_sphere.center)

            // Frustum culling
            if obj.bounding_sphere.intersects_frustum(&self.frustum) {
                self.renderables[i].is_visible = true
                self.visible_objects += 1
            } else {
                self.renderables[i].is_visible = false
                self.culled_objects += 1
            }
        }
    }

    fn build_draw_calls(mut self) {
        self.draw_call_count = 0

        // Sort renderables by material for batching
        // TODO: Implement sorting

        // Build draw calls (batch by mesh+material)
        for i in 0..self.renderable_count {
            let obj = &self.renderables[i]

            if !obj.is_visible {
                continue
            }

            // Find existing batch for this mesh+material
            let mut batch_found = false
            for j in 0..self.draw_call_count {
                let call = &self.draw_calls[j]

                if call.mesh_id == obj.mesh_id and call.material_id == obj.material_id {
                    // Add to existing batch
                    if self.draw_calls[j].add_instance(obj.transform) {
                        batch_found = true
                        break
                    }
                }
            }

            if !batch_found {
                // Create new draw call
                if self.draw_call_count >= MAX_DRAW_CALLS {
                    println("RenderOptimizer: Max draw calls reached!")
                    break
                }

                self.draw_calls[self.draw_call_count] = DrawCall.init()
                self.draw_calls[self.draw_call_count].mesh_id = obj.mesh_id
                self.draw_calls[self.draw_call_count].material_id = obj.material_id
                self.draw_calls[self.draw_call_count].add_instance(obj.transform)
                self.draw_calls[self.draw_call_count].compute_sort_key(obj.distance_to_camera)

                self.draw_call_count += 1
            }
        }

        self.draw_calls_issued = self.draw_call_count

        // Sort draw calls by sort key for optimal rendering
        // TODO: Implement sort
    }

    fn get_draw_calls(self): []DrawCall {
        return self.draw_calls[0..self.draw_call_count]
    }

    fn clear(mut self) {
        self.renderable_count = 0
        self.draw_call_count = 0
        self.visible_objects = 0
        self.culled_objects = 0
    }

    fn print_stats(self) {
        println("\n=== Render Optimizer Stats ===")
        println("Total Objects: {self.total_objects}")
        println("Visible Objects: {self.visible_objects}")
        println("Culled Objects: {self.culled_objects}")
        println("Draw Calls: {self.draw_calls_issued}")

        if self.total_objects > 0 {
            let cull_rate = @intToFloat(f32, self.culled_objects) / @intToFloat(f32, self.total_objects) * 100.0
            println("Cull Rate: {cull_rate:.1}%")
        }

        // Calculate average instances per draw call
        if self.draw_calls_issued > 0 {
            let avg_instances = @intToFloat(f32, self.visible_objects) / @intToFloat(f32, self.draw_calls_issued)
            println("Avg Instances/Draw Call: {avg_instances:.1}")
        }
    }
}

// Math helpers
struct Mat4 {
    m: [16]f32

    fn identity(): Mat4 {
        return Mat4 {
            m: [
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]
        }
    }
}

struct Vec3 {
    x: f32
    y: f32
    z: f32

    fn zero(): Vec3 {
        return Vec3 { x: 0.0, y: 0.0, z: 0.0 }
    }

    fn dot(a: Vec3, b: Vec3): f32 {
        return a.x * b.x + a.y * b.y + a.z * b.z
    }

    fn length(v: Vec3): f32 {
        return @sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
    }

    fn distance(a: Vec3, b: Vec3): f32 {
        let dx = b.x - a.x
        let dy = b.y - a.y
        let dz = b.z - a.z
        return @sqrt(dx * dx + dy * dy + dz * dz)
    }

    fn scale(v: Vec3, s: f32): Vec3 {
        return Vec3 {
            x: v.x * s
            y: v.y * s
            z: v.z * s
        }
    }
}

// Global render optimizer
var g_render_optimizer: ?RenderOptimizer = null

export fn init_render_optimizer(allocator: Allocator) {
    g_render_optimizer = RenderOptimizer.init(allocator)
    println("RenderOptimizer: Initialized")
}

export fn shutdown_render_optimizer() {
    if !g_render_optimizer {
        return
    }

    g_render_optimizer.?.print_stats()
    g_render_optimizer = null

    println("RenderOptimizer: Shutdown")
}
