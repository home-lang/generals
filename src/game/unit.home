// C&C Generals Zero Hour - Home Port
// Unit Management System
//
// Original: Unit.cpp, AIUpdate.cpp (Westwood Studios/EA)
// Ported to Home with modern RTS mechanics

import basics/allocator
import engine/ecs
import engine/math
import graphics/mesh

// Unit types (from C&C Generals)
enum UnitType {
    // USA Units
    Ranger
    Missile_Defender
    Pathfinder
    Colonel_Burton
    Humvee
    Crusader_Tank
    Paladin_Tank
    Tomahawk_Launcher
    Avenger
    Chinook
    Comanche
    Raptor

    // China Units
    Red_Guard
    Tank_Hunter
    Hacker
    Black_Lotus
    Battlemaster_Tank
    Overlord_Tank
    Gattling_Tank
    Dragon_Tank
    Nuke_Cannon
    Helix
    MiG

    // GLA Units
    Rebel
    RPG_Trooper
    Terrorist
    Jarmen_Kell
    Technical
    Scorpion_Tank
    Marauder_Tank
    Toxin_Tractor
    SCUD_Launcher
    Combat_Cycle
}

// Unit categories
enum UnitCategory {
    Infantry
    Vehicle
    Aircraft
    Structure
}

// Unit stance (behavior mode)
enum UnitStance {
    Aggressive  // Attack anything in range
    Defensive   // Attack when attacked
    Hold        // Don't move, attack in range
    Passive     // Never attack
}

// Unit state machine
enum UnitState {
    Idle
    Moving
    Attacking
    Gathering
    Constructing
    Garrisoned
    Repairing
    Dead
}

// Movement type
enum MovementType {
    Ground
    Air
    Water
    Amphibious
}

// Formation types
enum FormationType {
    None
    Line
    Column
    Wedge
    Box
    Scattered
}

// Unit definition (like a blueprint)
struct UnitDefinition {
    type: UnitType
    name: string
    category: UnitCategory
    movement_type: MovementType

    // Stats
    max_health: f32
    armor: f32
    move_speed: f32
    turn_rate: f32
    acceleration: f32

    // Vision & detection
    vision_range: f32
    shroud_clearing_range: f32
    can_see_stealth: bool

    // Combat
    can_attack: bool
    attack_range: f32
    damage: f32
    fire_rate: f32
    reload_time: f32

    // Special abilities
    can_capture: bool
    can_repair: bool
    can_garrison: bool
    is_stealth: bool

    // Economy
    build_cost: u32
    build_time: f32
    power_consumption: i32

    // Model & rendering
    model_name: string
    scale: f32
    selection_radius: f32

    fn init(): UnitDefinition {
        return UnitDefinition {
            type: UnitType.Ranger
            name: "Unknown"
            category: UnitCategory.Infantry
            movement_type: MovementType.Ground
            max_health: 100.0
            armor: 0.0
            move_speed: 5.0
            turn_rate: 3.0
            acceleration: 2.0
            vision_range: 15.0
            shroud_clearing_range: 15.0
            can_see_stealth: false
            can_attack: true
            attack_range: 5.0
            damage: 10.0
            fire_rate: 1.0
            reload_time: 2.0
            can_capture: false
            can_repair: false
            can_garrison: false
            is_stealth: false
            build_cost: 200
            build_time: 5.0
            power_consumption: 0
            model_name: "default"
            scale: 1.0
            selection_radius: 1.0
        }
    }
}

// Unit instance data
struct Unit {
    entity: Entity
    definition: *UnitDefinition

    // Current state
    state: UnitState
    stance: UnitStance

    // Health
    health: f32
    is_alive: bool

    // Movement
    position: Vec3
    rotation: Quaternion
    velocity: Vec3
    target_position: Vec3
    is_moving: bool
    path: []Vec3
    path_index: usize

    // Combat
    target_enemy: ?Entity
    time_until_next_fire: f32
    current_ammo: u32

    // Experience & veterancy
    experience: u32
    kills: u32
    veterancy_level: u32  // 0 = rookie, 1 = veteran, 2 = elite, 3 = heroic

    // Selection
    is_selected: bool

    // Owner
    player_id: u32
    team_id: u32

    fn init(entity: Entity, definition: *UnitDefinition, player_id: u32): Unit {
        return Unit {
            entity: entity
            definition: definition
            state: UnitState.Idle
            stance: UnitStance.Aggressive
            health: definition.max_health
            is_alive: true
            position: Vec3.init(0.0, 0.0, 0.0)
            rotation: Quaternion.identity()
            velocity: Vec3.init(0.0, 0.0, 0.0)
            target_position: Vec3.init(0.0, 0.0, 0.0)
            is_moving: false
            path: []
            path_index: 0
            target_enemy: null
            time_until_next_fire: 0.0
            current_ammo: 100
            experience: 0
            kills: 0
            veterancy_level: 0
            is_selected: false
            player_id: player_id
            team_id: player_id
        }
    }

    fn update(mut self, delta_time: f32) {
        match self.state {
            UnitState.Idle => {
                self.update_idle(delta_time)
            }
            UnitState.Moving => {
                self.update_moving(delta_time)
            }
            UnitState.Attacking => {
                self.update_attacking(delta_time)
            }
            UnitState.Dead => {
                // Do nothing
            }
            _ => {}
        }

        // Update timers
        if self.time_until_next_fire > 0.0 {
            self.time_until_next_fire -= delta_time
        }
    }

    fn update_idle(mut self, delta_time: f32) {
        // Look for enemies if aggressive
        if self.stance == UnitStance.Aggressive {
            // TODO: Scan for enemies in range
        }
    }

    fn update_moving(mut self, delta_time: f32) {
        if !self.is_moving {
            self.state = UnitState.Idle
            return
        }

        // Move towards target
        let to_target = vec3_sub(self.target_position, self.position)
        let distance = to_target.length()

        if distance < 0.5 {
            // Reached target
            self.is_moving = false
            self.velocity = Vec3.init(0.0, 0.0, 0.0)
            self.state = UnitState.Idle
            return
        }

        // Calculate velocity
        let direction = to_target.normalize()
        self.velocity = vec3_mul(direction, self.definition.move_speed)

        // Update position
        self.position = vec3_add(self.position, vec3_mul(self.velocity, delta_time))

        // Update rotation to face movement direction
        // TODO: Smooth rotation with turn rate
    }

    fn update_attacking(mut self, delta_time: f32) {
        if !self.target_enemy {
            self.state = UnitState.Idle
            return
        }

        // TODO: Check if target is still alive and in range
        // TODO: Rotate to face target
        // TODO: Fire weapon when ready
    }

    fn move_to(mut self, target: Vec3) {
        self.target_position = target
        self.is_moving = true
        self.state = UnitState.Moving
    }

    fn attack(mut self, target: Entity) {
        self.target_enemy = target
        self.state = UnitState.Attacking
    }

    fn stop(mut self) {
        self.is_moving = false
        self.velocity = Vec3.init(0.0, 0.0, 0.0)
        self.target_enemy = null
        self.state = UnitState.Idle
    }

    fn take_damage(mut self, damage: f32) {
        let actual_damage = damage - self.definition.armor
        if actual_damage < 0.0 {
            return
        }

        self.health -= actual_damage

        if self.health <= 0.0 {
            self.health = 0.0
            self.is_alive = false
            self.state = UnitState.Dead
        }
    }

    fn heal(mut self, amount: f32) {
        self.health += amount
        if self.health > self.definition.max_health {
            self.health = self.definition.max_health
        }
    }

    fn add_experience(mut self, xp: u32) {
        self.experience += xp

        // Check for veterancy level up
        let old_level = self.veterancy_level

        if self.experience >= 1000 and self.veterancy_level < 3 {
            self.veterancy_level = 3  // Heroic
        } else if self.experience >= 500 and self.veterancy_level < 2 {
            self.veterancy_level = 2  // Elite
        } else if self.experience >= 200 and self.veterancy_level < 1 {
            self.veterancy_level = 1  // Veteran
        }

        if self.veterancy_level > old_level {
            // Level up! Grant bonuses
            self.on_veterancy_levelup()
        }
    }

    fn on_veterancy_levelup(mut self) {
        // Veterancy bonuses (stacking)
        // - 25% health increase per level
        // - 25% damage increase per level
        // - Faster fire rate

        let health_bonus = self.definition.max_health * 0.25 * @intToFloat(f32, self.veterancy_level)
        self.definition.max_health += health_bonus
        self.health = self.definition.max_health

        // Visual feedback (particle effect, sound)
        // TODO: Play levelup effect
    }

    fn get_health_percentage(&self): f32 {
        return self.health / self.definition.max_health
    }

    fn is_enemy_of(&self, other_team: u32): bool {
        return self.team_id != other_team
    }
}

// Formation manager
struct Formation {
    type: FormationType
    units: []Entity
    unit_count: usize
    center: Vec3
    spacing: f32
    allocator: Allocator

    fn init(allocator: Allocator, type: FormationType): Formation {
        return Formation {
            type: type
            units: allocator.alloc(Entity, 64)
            unit_count: 0
            center: Vec3.init(0.0, 0.0, 0.0)
            spacing: 2.0
            allocator: allocator
        }
    }

    fn add_unit(mut self, entity: Entity) {
        if self.unit_count < self.units.len {
            self.units[self.unit_count] = entity
            self.unit_count += 1
        }
    }

    fn calculate_positions(&self, target: Vec3): []Vec3 {
        let positions = self.allocator.alloc(Vec3, self.unit_count)

        match self.type {
            FormationType.Line => {
                self.calculate_line_formation(positions, target)
            }
            FormationType.Column => {
                self.calculate_column_formation(positions, target)
            }
            FormationType.Wedge => {
                self.calculate_wedge_formation(positions, target)
            }
            FormationType.Box => {
                self.calculate_box_formation(positions, target)
            }
            _ => {
                // No formation, just target position
                for i in 0..self.unit_count {
                    positions[i] = target
                }
            }
        }

        return positions
    }

    fn calculate_line_formation(&self, positions: []Vec3, target: Vec3) {
        let half_count = @intToFloat(f32, self.unit_count) * 0.5

        for i in 0..self.unit_count {
            let offset = (@intToFloat(f32, i) - half_count) * self.spacing
            positions[i] = Vec3 {
                x: target.x + offset
                y: target.y
                z: target.z
            }
        }
    }

    fn calculate_column_formation(&self, positions: []Vec3, target: Vec3) {
        for i in 0..self.unit_count {
            let offset = @intToFloat(f32, i) * self.spacing
            positions[i] = Vec3 {
                x: target.x
                y: target.y
                z: target.z + offset
            }
        }
    }

    fn calculate_wedge_formation(&self, positions: []Vec3, target: Vec3) {
        // V-shaped formation
        let mut row: usize = 0
        let mut col: i32 = 0

        for i in 0..self.unit_count {
            positions[i] = Vec3 {
                x: target.x + @intToFloat(f32, col) * self.spacing
                y: target.y
                z: target.z + @intToFloat(f32, row) * self.spacing
            }

            // Alternate left/right
            if col <= 0 {
                col = -col + 1
            } else {
                col = -col
                row += 1
            }
        }
    }

    fn calculate_box_formation(&self, positions: []Vec3, target: Vec3) {
        // Square grid formation
        let side = @intCast(usize, @sqrt(@intToFloat(f32, self.unit_count))) + 1

        for i in 0..self.unit_count {
            let row = i / side
            let col = i % side

            positions[i] = Vec3 {
                x: target.x + @intToFloat(f32, col) * self.spacing
                y: target.y
                z: target.z + @intToFloat(f32, row) * self.spacing
            }
        }
    }

    fn deinit(mut self) {
        self.allocator.free(self.units)
    }
}

// Unit manager
struct UnitManager {
    units: []Unit
    unit_count: usize
    definitions: []UnitDefinition
    definition_count: usize
    allocator: Allocator

    fn init(allocator: Allocator): UnitManager {
        return UnitManager {
            units: allocator.alloc(Unit, 2048)
            unit_count: 0
            definitions: allocator.alloc(UnitDefinition, 128)
            definition_count: 0
            allocator: allocator
        }
    }

    fn register_definition(mut self, def: UnitDefinition) {
        if self.definition_count < self.definitions.len {
            self.definitions[self.definition_count] = def
            self.definition_count += 1
        }
    }

    fn create_unit(mut self, type: UnitType, position: Vec3, player_id: u32, world: *World): ?Entity {
        // Find definition
        let mut def: ?*UnitDefinition = null
        for i in 0..self.definition_count {
            if self.definitions[i].type == type {
                def = &self.definitions[i]
                break
            }
        }

        if !def {
            return null
        }

        // Create entity
        let entity = world.create_entity()

        // Add components
        let mut transform = Transform.init()
        transform.position = position
        world.add_transform(entity, transform)
        world.add_health(entity, def.?.max_health)
        world.add_selectable(entity)
        world.add_team(entity, player_id)

        // Create unit instance
        if self.unit_count < self.units.len {
            self.units[self.unit_count] = Unit.init(entity, def.?, player_id)
            self.units[self.unit_count].position = position
            self.unit_count += 1
        }

        return entity
    }

    fn update(mut self, delta_time: f32) {
        for i in 0..self.unit_count {
            if self.units[i].is_alive {
                self.units[i].update(delta_time)
            }
        }
    }

    fn get_unit_by_entity(&self, entity: Entity): ?*Unit {
        for i in 0..self.unit_count {
            if self.units[i].entity.equals(entity) {
                return &self.units[i]
            }
        }
        return null
    }

    fn deinit(mut self) {
        self.allocator.free(self.units)
        self.allocator.free(self.definitions)
    }
}

// Global unit manager
var g_unit_manager: ?UnitManager = null

export fn init_unit_manager(allocator: Allocator) {
    g_unit_manager = UnitManager.init(allocator)

    // Register default unit definitions
    register_default_units()
}

export fn shutdown_unit_manager() {
    if g_unit_manager {
        g_unit_manager.?.deinit()
        g_unit_manager = null
    }
}

export fn create_unit(type: UnitType, position: Vec3, player_id: u32): ?Entity {
    if g_unit_manager {
        let world = get_world()
        if world {
            return g_unit_manager.?.create_unit(type, position, player_id, world.?)
        }
    }
    return null
}

export fn update_units(delta_time: f32) {
    if g_unit_manager {
        g_unit_manager.?.update(delta_time)
    }
}

fn register_default_units() {
    if !g_unit_manager {
        return
    }

    // USA Ranger (basic infantry)
    let mut ranger = UnitDefinition.init()
    ranger.type = UnitType.Ranger
    ranger.name = "Ranger"
    ranger.category = UnitCategory.Infantry
    ranger.max_health = 100.0
    ranger.move_speed = 5.0
    ranger.attack_range = 8.0
    ranger.damage = 15.0
    ranger.build_cost = 225
    ranger.model_name = "ranger"
    g_unit_manager.?.register_definition(ranger)

    // USA Crusader Tank
    let mut crusader = UnitDefinition.init()
    crusader.type = UnitType.Crusader_Tank
    crusader.name = "Crusader Tank"
    crusader.category = UnitCategory.Vehicle
    crusader.max_health = 400.0
    crusader.armor = 50.0
    crusader.move_speed = 8.0
    crusader.attack_range = 12.0
    crusader.damage = 100.0
    crusader.build_cost = 900
    crusader.model_name = "crusader"
    g_unit_manager.?.register_definition(crusader)

    // TODO: Add more unit definitions (China, GLA units)
}
