// Home Programming Language - Visual Map Editor
// In-game map editor for terrain, objects, and lighting
//
// Features:
// - Terrain height painting
// - Texture splatting (blend up to 4 textures)
// - Object placement (buildings, trees, rocks)
// - Lighting setup
// - Waypoint editing
// - Export to game map format

import graphics::{Vec2, Vec3}
from basics import Collection

// ============================================================================
// Map Data Structures
// ============================================================================

struct TerrainTile {
    height: Float,
    texture_index_0: Int,
    texture_index_1: Int,
    texture_index_2: Int,
    texture_index_3: Int,
    texture_weight_0: Float,
    texture_weight_1: Float,
    texture_weight_2: Float,
    texture_weight_3: Float,
    walkable: Bool,
    water: Bool,
}

fn create_terrain_tile() -> TerrainTile {
    return TerrainTile {
        height: 0.0,
        texture_index_0: 0,
        texture_index_1: 0,
        texture_index_2: 0,
        texture_index_3: 0,
        texture_weight_0: 1.0,
        texture_weight_1: 0.0,
        texture_weight_2: 0.0,
        texture_weight_3: 0.0,
        walkable: true,
        water: false,
    }
}

struct MapObject {
    id: Int,
    object_type: String,
    position: Vec3,
    rotation: Float,
    scale: Float,
    properties: Collection<String>,  // Simplified: collection of "key=value" strings
}

fn create_map_object(object_type: String) -> MapObject {
    return MapObject {
        id: 0,
        object_type: object_type,
        position: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
        rotation: 0.0,
        scale: 1.0,
        properties: Collection::new<String>(),
    }
}

struct EditorMap {
    width: Int,
    height: Int,
    tile_size: Float,
    tiles: Collection<TerrainTile>,
    objects: Collection<MapObject>,
    name: String,
}

fn create_editor_map(width: Int, height: Int, tile_size: Float) -> EditorMap {
    let tiles = Collection::new<TerrainTile>()

    let total = width * height
    let i = 0
    while i < total {
        tiles.push(create_terrain_tile())
        i = i + 1
    }

    return EditorMap {
        width: width,
        height: height,
        tile_size: tile_size,
        tiles: tiles,
        objects: Collection::new<MapObject>(),
        name: "Untitled Map",
    }
}

fn get_tile(map: EditorMap, x: Int, y: Int) -> TerrainTile {
    if x < 0 || y < 0 || x >= map.width || y >= map.height {
        return create_terrain_tile()
    }

    let index = y * map.width + x
    return map.tiles.get(index)
}

fn set_tile(map: EditorMap, x: Int, y: Int, tile: TerrainTile) {
    if x < 0 || y < 0 || x >= map.width || y >= map.height {
        return
    }

    let index = y * map.width + x
    map.tiles.set(index, tile)
}

fn add_object(map: EditorMap, object: MapObject) -> Int {
    object.id = map.objects.len()
    map.objects.push(object)
    return object.id
}

fn remove_object(map: EditorMap, id: Int) {
    let i = 0
    while i < map.objects.len() {
        let obj = map.objects.get(i)
        if obj.id == id {
            map.objects.remove_at(i)
            return
        }
        i = i + 1
    }
}

fn save_map(map: EditorMap, path: String) {
    // In production: write to file
    // Format: GENERALSMAP header
    // Width, Height, TileSize
    // Terrain data (all tiles)
    // Object count
    // Object data (id, type, position, rotation, scale)
}

// ============================================================================
// Editor Tools
// ============================================================================

enum EditorTool {
    SELECT,
    HEIGHT_RAISE,
    HEIGHT_LOWER,
    HEIGHT_SMOOTH,
    TEXTURE_PAINT,
    OBJECT_PLACE,
    OBJECT_REMOVE,
    WAYPOINT_PLACE,
}

struct BrushSettings {
    size: Float,
    strength: Float,
    falloff: Float,
}

fn default_brush_settings() -> BrushSettings {
    return BrushSettings {
        size: 5.0,
        strength: 1.0,
        falloff: 0.5,
    }
}

struct MapEditor {
    map: EditorMap,
    current_tool: EditorTool,
    brush_settings: BrushSettings,
    selected_texture: Int,
    selected_object_type: String,
    has_selected_object: Bool,
    selected_object_id: Int,
    camera_position: Vec3,
    camera_rotation: Vec2,
}

fn create_map_editor(map_width: Int, map_height: Int) -> MapEditor {
    return MapEditor {
        map: create_editor_map(map_width, map_height, 1.0),
        current_tool: EditorTool::SELECT,
        brush_settings: default_brush_settings(),
        selected_texture: 0,
        selected_object_type: "tree",
        has_selected_object: false,
        selected_object_id: 0,
        camera_position: Vec3 { x: 0.0, y: 50.0, z: 50.0 },
        camera_rotation: Vec2 { x: -45.0, y: 0.0 },
    }
}

fn set_tool(editor: MapEditor, tool: EditorTool) {
    editor.current_tool = tool
}

fn handle_input(editor: MapEditor, mouse_x: Float, mouse_y: Float, mouse_down: Bool) {
    // Camera movement would be handled here
    // (WASD keys for movement)

    // Apply tool when mouse is down
    if mouse_down {
        apply_tool(editor, mouse_x, mouse_y)
    }
}

fn apply_tool(editor: MapEditor, mouse_x: Float, mouse_y: Float) {
    // Convert mouse position to world position
    let world_pos = screen_to_world(editor, mouse_x, mouse_y)

    // Convert to tile coordinates
    let tile_x = floor_int(world_pos.x / editor.map.tile_size)
    let tile_y = floor_int(world_pos.z / editor.map.tile_size)

    if editor.current_tool == EditorTool::HEIGHT_RAISE {
        modify_height(editor, tile_x, tile_y, editor.brush_settings.strength)
    } else if editor.current_tool == EditorTool::HEIGHT_LOWER {
        modify_height(editor, tile_x, tile_y, -editor.brush_settings.strength)
    } else if editor.current_tool == EditorTool::HEIGHT_SMOOTH {
        smooth_height(editor, tile_x, tile_y)
    } else if editor.current_tool == EditorTool::TEXTURE_PAINT {
        paint_texture(editor, tile_x, tile_y, editor.selected_texture)
    } else if editor.current_tool == EditorTool::OBJECT_PLACE {
        place_object(editor, world_pos)
    }
}

fn modify_height(editor: MapEditor, center_x: Int, center_y: Int, amount: Float) {
    let brush_radius = floor_int(editor.brush_settings.size)

    let y = center_y - brush_radius
    while y <= center_y + brush_radius {
        let x = center_x - brush_radius
        while x <= center_x + brush_radius {
            if x >= 0 && y >= 0 && x < editor.map.width && y < editor.map.height {
                let tile = get_tile(editor.map, x, y)

                let dx = float(x) - float(center_x)
                let dy = float(y) - float(center_y)
                let distance = sqrt(dx * dx + dy * dy)

                if distance <= editor.brush_settings.size {
                    let falloff = 1.0 - (distance / editor.brush_settings.size) * editor.brush_settings.falloff
                    tile.height = tile.height + amount * falloff
                    set_tile(editor.map, x, y, tile)
                }
            }

            x = x + 1
        }
        y = y + 1
    }
}

fn smooth_height(editor: MapEditor, center_x: Int, center_y: Int) {
    // Average surrounding heights
    let sum = 0.0
    let count = 0

    // Check 4 neighbors (up, down, left, right)
    let neighbors = Collection::new<Vec2>()
    neighbors.push(Vec2 { x: -1.0, y: 0.0 })
    neighbors.push(Vec2 { x: 1.0, y: 0.0 })
    neighbors.push(Vec2 { x: 0.0, y: -1.0 })
    neighbors.push(Vec2 { x: 0.0, y: 1.0 })

    let i = 0
    while i < neighbors.len() {
        let n = neighbors.get(i)
        let nx = center_x + floor_int(n.x)
        let ny = center_y + floor_int(n.y)

        if nx >= 0 && ny >= 0 && nx < editor.map.width && ny < editor.map.height {
            let tile = get_tile(editor.map, nx, ny)
            sum = sum + tile.height
            count = count + 1
        }

        i = i + 1
    }

    if count > 0 {
        let center_tile = get_tile(editor.map, center_x, center_y)
        let average = sum / float(count)
        center_tile.height = center_tile.height + (average - center_tile.height) * 0.5
        set_tile(editor.map, center_x, center_y, center_tile)
    }
}

fn paint_texture(editor: MapEditor, tile_x: Int, tile_y: Int, texture_index: Int) {
    if tile_x >= 0 && tile_y >= 0 && tile_x < editor.map.width && tile_y < editor.map.height {
        let tile = get_tile(editor.map, tile_x, tile_y)
        tile.texture_index_0 = texture_index
        tile.texture_weight_0 = 1.0
        tile.texture_weight_1 = 0.0
        tile.texture_weight_2 = 0.0
        tile.texture_weight_3 = 0.0
        set_tile(editor.map, tile_x, tile_y, tile)
    }
}

fn place_object(editor: MapEditor, position: Vec3) {
    let obj = create_map_object(editor.selected_object_type)
    obj.position = position
    add_object(editor.map, obj)
}

fn screen_to_world(editor: MapEditor, screen_x: Float, screen_y: Float) -> Vec3 {
    // Simple orthographic projection
    // In production: proper ray casting from camera

    return Vec3 {
        x: screen_x + editor.camera_position.x,
        y: 0.0,
        z: editor.camera_position.z,
    }
}

fn render_editor(editor: MapEditor) {
    // Render terrain
    render_terrain(editor)

    // Render objects
    render_objects(editor)

    // Render brush preview
    render_brush(editor)
}

fn render_terrain(editor: MapEditor) {
    // In production: render terrain using OpenGL/Metal
    // - Generate mesh from heightmap
    // - Apply texture splatting
    // - Render with lighting
}

fn render_objects(editor: MapEditor) {
    // In production: render placed objects
    // - Load 3D models
    // - Render at object positions
    // - Apply transformations (rotation, scale)
}

fn render_brush(editor: MapEditor) {
    // In production: render brush circle at mouse position
    // - Draw circle with current brush size
    // - Show falloff gradient
}

// ============================================================================
// Helper Functions
// ============================================================================

fn float(value: Int) -> Float {
    return 0.0 + value
}

fn floor_int(value: Float) -> Int {
    let int_part = 0
    if value >= 0.0 {
        while float(int_part + 1) <= value {
            int_part = int_part + 1
        }
    } else {
        while float(int_part) > value {
            int_part = int_part - 1
        }
    }
    return int_part
}

fn sqrt(x: Float) -> Float {
    if x == 0.0 {
        return 0.0
    }

    let guess = x / 2.0
    let i = 0
    while i < 10 {
        guess = (guess + x / guess) / 2.0
        i = i + 1
    }
    return guess
}

// ============================================================================
// Tests
// ============================================================================

fn test_editor_map_creation() -> Bool {
    let map = create_editor_map(64, 64, 1.0)
    assert(map.width == 64, "Map width should be 64")
    assert(map.height == 64, "Map height should be 64")
    assert(map.tiles.len() == 64 * 64, "Should have 4096 tiles")
    return true
}

fn test_tile_access() -> Bool {
    let map = create_editor_map(10, 10, 1.0)

    let tile = get_tile(map, 5, 5)
    tile.height = 10.0
    set_tile(map, 5, 5, tile)

    let updated_tile = get_tile(map, 5, 5)
    assert(updated_tile.height == 10.0, "Tile height should be 10.0")

    return true
}

fn test_object_management() -> Bool {
    let map = create_editor_map(64, 64, 1.0)

    let obj1 = create_map_object("tree")
    obj1.position = Vec3 { x: 10.0, y: 0.0, z: 20.0 }

    let id1 = add_object(map, obj1)
    assert(map.objects.len() == 1, "Should have 1 object")
    assert(id1 == 0, "First object ID should be 0")

    let obj2 = create_map_object("rock")
    add_object(map, obj2)
    assert(map.objects.len() == 2, "Should have 2 objects")

    remove_object(map, id1)
    assert(map.objects.len() == 1, "Should have 1 object after removal")

    return true
}

fn test_brush_settings() -> Bool {
    let brush = default_brush_settings()
    assert(brush.size == 5.0, "Default brush size should be 5.0")
    assert(brush.strength == 1.0, "Default brush strength should be 1.0")
    assert(brush.falloff == 0.5, "Default brush falloff should be 0.5")
    return true
}

fn test_editor_creation() -> Bool {
    let editor = create_map_editor(128, 128)
    assert(editor.map.width == 128, "Editor map width should be 128")
    assert(editor.current_tool == EditorTool::SELECT, "Default tool should be SELECT")
    return true
}

fn test_height_modification() -> Bool {
    let editor = create_map_editor(20, 20)
    editor.brush_settings.size = 2.0
    editor.brush_settings.strength = 5.0

    modify_height(editor, 10, 10, 5.0)

    let center_tile = get_tile(editor.map, 10, 10)
    assert(center_tile.height > 0.0, "Center tile height should be raised")

    return true
}

fn test_texture_painting() -> Bool {
    let editor = create_map_editor(10, 10)

    paint_texture(editor, 5, 5, 3)

    let tile = get_tile(editor.map, 5, 5)
    assert(tile.texture_index_0 == 3, "Texture index should be 3")
    assert(tile.texture_weight_0 == 1.0, "Texture weight should be 1.0")

    return true
}

fn test_object_placement() -> Bool {
    let editor = create_map_editor(64, 64)
    editor.selected_object_type = "building"

    let pos = Vec3 { x: 50.0, y: 0.0, z: 30.0 }
    place_object(editor, pos)

    assert(editor.map.objects.len() == 1, "Should have 1 placed object")

    let obj = editor.map.objects.get(0)
    assert(obj.position.x == 50.0, "Object X should be 50")
    assert(obj.position.z == 30.0, "Object Z should be 30")

    return true
}

fn test_screen_to_world() -> Bool {
    let editor = create_map_editor(64, 64)
    editor.camera_position = Vec3 { x: 100.0, y: 50.0, z: 100.0 }

    let world = screen_to_world(editor, 10.0, 20.0)
    assert(world.x == 110.0, "World X should be 110")

    return true
}

fn test_out_of_bounds_access() -> Bool {
    let map = create_editor_map(10, 10, 1.0)

    // Should not crash, should return default tile
    let tile = get_tile(map, -1, -1)
    assert(tile.height == 0.0, "Out of bounds should return default tile")

    let tile2 = get_tile(map, 100, 100)
    assert(tile2.height == 0.0, "Out of bounds should return default tile")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_editor_map_creation(), "test_editor_map_creation failed")
    assert(test_tile_access(), "test_tile_access failed")
    assert(test_object_management(), "test_object_management failed")
    assert(test_brush_settings(), "test_brush_settings failed")
    assert(test_editor_creation(), "test_editor_creation failed")
    assert(test_height_modification(), "test_height_modification failed")
    assert(test_texture_painting(), "test_texture_painting failed")
    assert(test_object_placement(), "test_object_placement failed")
    assert(test_screen_to_world(), "test_screen_to_world failed")
    assert(test_out_of_bounds_access(), "test_out_of_bounds_access failed")
    return true
}
