// C&C Generals Zero Hour - Home Port
// Save/Load Game System
//
// Original: SaveGame/ system (Westwood Studios/EA)
// Manages game state serialization for save/load functionality
//
// Allows players to:
// - Save current game state to disk
// - Load previously saved games
// - Auto-save at intervals
// - Quick save/load functionality

import basics/allocator
import core/filesystem

const MAX_SAVE_SLOTS: u32 = 10
const SAVE_VERSION: u32 = 1
const SAVE_MAGIC: u32 = 0x47454E53  // "GENS" in ASCII

// Save game metadata
struct SaveGameMetadata {
    version: u32
    magic: u32

    // Game info
    game_time: f32
    mission_name: string
    campaign_name: string

    // Player info
    player_count: u32
    local_player_id: u32
    local_player_faction: u32

    // Timestamp
    save_time: u64  // Unix timestamp
    save_date_str: string

    // Statistics
    units_on_map: u32
    buildings_on_map: u32

    // Difficulty
    difficulty: u32

    fn init(): SaveGameMetadata {
        return SaveGameMetadata {
            version: SAVE_VERSION
            magic: SAVE_MAGIC
            game_time: 0.0
            mission_name: ""
            campaign_name: ""
            player_count: 0
            local_player_id: 0
            local_player_faction: 0
            save_time: 0
            save_date_str: ""
            units_on_map: 0
            buildings_on_map: 0
            difficulty: 0
        }
    }
}

// Serialization buffer
struct SerializationBuffer {
    data: []u8
    size: u32
    capacity: u32
    position: u32

    allocator: Allocator

    fn init(allocator: Allocator, initial_capacity: u32): SerializationBuffer {
        return SerializationBuffer {
            data: []  // TODO: Allocate buffer
            size: 0
            capacity: initial_capacity
            position: 0
            allocator: allocator
        }
    }

    fn write_u8(mut self, value: u8) {
        // TODO: Write byte to buffer
        self.size += 1
        self.position += 1
    }

    fn write_u32(mut self, value: u32) {
        // Write as little-endian
        self.write_u8(@intCast(u8, value & 0xFF))
        self.write_u8(@intCast(u8, (value >> 8) & 0xFF))
        self.write_u8(@intCast(u8, (value >> 16) & 0xFF))
        self.write_u8(@intCast(u8, (value >> 24) & 0xFF))
    }

    fn write_f32(mut self, value: f32) {
        // TODO: Convert f32 to bytes and write
        self.size += 4
        self.position += 4
    }

    fn write_string(mut self, value: string) {
        // Write length followed by characters
        self.write_u32(@intCast(u32, value.len()))
        // TODO: Write string bytes
        self.size += @intCast(u32, value.len())
        self.position += @intCast(u32, value.len())
    }

    fn read_u8(mut self): u8 {
        // TODO: Read byte from buffer
        self.position += 1
        return 0
    }

    fn read_u32(mut self): u32 {
        // Read as little-endian
        let b0 = @intCast(u32, self.read_u8())
        let b1 = @intCast(u32, self.read_u8())
        let b2 = @intCast(u32, self.read_u8())
        let b3 = @intCast(u32, self.read_u8())
        return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    }

    fn read_f32(mut self): f32 {
        // TODO: Read f32 from bytes
        self.position += 4
        return 0.0
    }

    fn read_string(mut self): string {
        let length = self.read_u32()
        // TODO: Read string bytes
        self.position += length
        return ""
    }

    fn reset(mut self) {
        self.position = 0
    }
}

// Save game slot
struct SaveSlot {
    slot_id: u32
    is_occupied: bool
    metadata: SaveGameMetadata
    file_path: string

    fn init(slot_id: u32): SaveSlot {
        return SaveSlot {
            slot_id: slot_id
            is_occupied: false
            metadata: SaveGameMetadata.init()
            file_path: ""
        }
    }

    fn get_save_file_path(&self): string {
        // Return path like "saves/slot_0.sav"
        return "saves/slot_{}.sav"  // TODO: Format with slot_id
    }
}

// Save game manager
struct SaveGameManager {
    slots: [MAX_SAVE_SLOTS]SaveSlot
    autosave_slot: SaveSlot
    quicksave_slot: SaveSlot

    // Auto-save settings
    autosave_enabled: bool
    autosave_interval: f32  // Seconds
    time_since_autosave: f32

    allocator: Allocator

    fn init(allocator: Allocator): SaveGameManager {
        return SaveGameManager {
            slots: [SaveSlot.init(0); MAX_SAVE_SLOTS]
            autosave_slot: SaveSlot.init(100)  // Special ID for autosave
            quicksave_slot: SaveSlot.init(101)  // Special ID for quicksave
            autosave_enabled: true
            autosave_interval: 300.0  // 5 minutes
            time_since_autosave: 0.0
            allocator: allocator
        }
    }

    fn initialize_slots(mut self) {
        for i in 0..MAX_SAVE_SLOTS {
            self.slots[i] = SaveSlot.init(i)
            self.slots[i].file_path = self.slots[i].get_save_file_path()
        }

        self.autosave_slot.file_path = "saves/autosave.sav"
        self.quicksave_slot.file_path = "saves/quicksave.sav"
    }

    fn scan_save_files(mut self) {
        // Scan save directory and populate slot metadata
        for i in 0..MAX_SAVE_SLOTS {
            let file_path = self.slots[i].file_path
            // TODO: Check if file exists
            // TODO: Load metadata from file header
        }
    }

    fn save_game(mut self, slot_id: u32, game_state: *void): bool {
        if slot_id >= MAX_SAVE_SLOTS {
            println("SaveGameManager: Invalid slot ID")
            return false
        }

        println("SaveGameManager: Saving game to slot {}", slot_id)

        // Create serialization buffer
        let mut buffer = SerializationBuffer.init(self.allocator, 1024 * 1024)  // 1MB initial

        // Serialize game state
        self.serialize_game_state(buffer, game_state)

        // Write to file
        let file_path = self.slots[slot_id].file_path
        let success = self.write_save_file(file_path, buffer)

        if success {
            self.slots[slot_id].is_occupied = true
            println("SaveGameManager: Save successful")
        } else {
            println("SaveGameManager: Save failed")
        }

        return success
    }

    fn load_game(mut self, slot_id: u32, game_state: *void): bool {
        if slot_id >= MAX_SAVE_SLOTS {
            println("SaveGameManager: Invalid slot ID")
            return false
        }

        if !self.slots[slot_id].is_occupied {
            println("SaveGameManager: Slot is empty")
            return false
        }

        println("SaveGameManager: Loading game from slot {}", slot_id)

        // Read from file
        let file_path = self.slots[slot_id].file_path
        let mut buffer = self.read_save_file(file_path)

        if buffer.size == 0 {
            println("SaveGameManager: Load failed - file read error")
            return false
        }

        // Deserialize game state
        let success = self.deserialize_game_state(buffer, game_state)

        if success {
            println("SaveGameManager: Load successful")
        } else {
            println("SaveGameManager: Load failed - deserialization error")
        }

        return success
    }

    fn quicksave(mut self, game_state: *void): bool {
        println("SaveGameManager: Quick save")
        return self.save_to_slot(self.quicksave_slot, game_state)
    }

    fn quickload(mut self, game_state: *void): bool {
        println("SaveGameManager: Quick load")
        return self.load_from_slot(self.quicksave_slot, game_state)
    }

    fn autosave(mut self, game_state: *void): bool {
        if !self.autosave_enabled {
            return false
        }

        println("SaveGameManager: Auto save")
        let success = self.save_to_slot(self.autosave_slot, game_state)

        if success {
            self.time_since_autosave = 0.0
        }

        return success
    }

    fn save_to_slot(mut self, mut slot: SaveSlot, game_state: *void): bool {
        let mut buffer = SerializationBuffer.init(self.allocator, 1024 * 1024)
        self.serialize_game_state(buffer, game_state)

        let success = self.write_save_file(slot.file_path, buffer)
        if success {
            slot.is_occupied = true
        }

        return success
    }

    fn load_from_slot(&self, slot: SaveSlot, game_state: *void): bool {
        if !slot.is_occupied {
            return false
        }

        let mut buffer = self.read_save_file(slot.file_path)
        return self.deserialize_game_state(buffer, game_state)
    }

    fn update(mut self, delta_time: f32, game_state: *void) {
        if self.autosave_enabled {
            self.time_since_autosave += delta_time

            if self.time_since_autosave >= self.autosave_interval {
                self.autosave(game_state)
            }
        }
    }

    fn serialize_game_state(&self, mut buffer: SerializationBuffer, game_state: *void) {
        // Write header
        buffer.write_u32(SAVE_MAGIC)
        buffer.write_u32(SAVE_VERSION)

        // Write metadata
        // buffer.write_f32(game_time)
        // buffer.write_string(mission_name)
        // etc.

        // Write player states
        // buffer.write_u32(player_count)
        // for each player: serialize player data

        // Write entity states
        // for each unit: serialize unit data
        // for each building: serialize building data

        // Write fog of war state
        // Write script engine state
        // Write objectives state
        // etc.
    }

    fn deserialize_game_state(&self, mut buffer: SerializationBuffer, game_state: *void): bool {
        // Read and verify header
        let magic = buffer.read_u32()
        if magic != SAVE_MAGIC {
            println("SaveGameManager: Invalid save file - wrong magic number")
            return false
        }

        let version = buffer.read_u32()
        if version != SAVE_VERSION {
            println("SaveGameManager: Incompatible save file version")
            return false
        }

        // Read metadata
        // game_time = buffer.read_f32()
        // mission_name = buffer.read_string()
        // etc.

        // Read player states
        // player_count = buffer.read_u32()
        // for each player: deserialize player data

        // Read entity states
        // for each unit: deserialize unit data
        // for each building: deserialize building data

        // Read fog of war state
        // Read script engine state
        // Read objectives state
        // etc.

        return true
    }

    fn write_save_file(&self, file_path: string, buffer: SerializationBuffer): bool {
        // TODO: Write buffer to file using filesystem API
        println("SaveGameManager: Writing save file to {}", file_path)
        return true
    }

    fn read_save_file(&self, file_path: string): SerializationBuffer {
        // TODO: Read file using filesystem API
        println("SaveGameManager: Reading save file from {}", file_path)
        return SerializationBuffer.init(self.allocator, 0)
    }

    fn delete_save(mut self, slot_id: u32): bool {
        if slot_id >= MAX_SAVE_SLOTS {
            return false
        }

        let file_path = self.slots[slot_id].file_path
        // TODO: Delete file
        self.slots[slot_id].is_occupied = false

        return true
    }

    fn get_slot_metadata(&self, slot_id: u32): ?SaveGameMetadata {
        if slot_id >= MAX_SAVE_SLOTS {
            return null
        }

        if !self.slots[slot_id].is_occupied {
            return null
        }

        return self.slots[slot_id].metadata
    }
}

// Global save game manager
var g_savegame_manager: ?SaveGameManager = null

export fn init_savegame_manager(allocator: Allocator) {
    g_savegame_manager = SaveGameManager.init(allocator)
    g_savegame_manager.?.initialize_slots()
    g_savegame_manager.?.scan_save_files()
    println("SaveGameManager: System initialized")
}

export fn shutdown_savegame_manager() {
    g_savegame_manager = null
    println("SaveGameManager: System shutdown")
}

export fn save_game(slot_id: u32, game_state: *void): bool {
    if g_savegame_manager {
        return g_savegame_manager.?.save_game(slot_id, game_state)
    }
    return false
}

export fn load_game(slot_id: u32, game_state: *void): bool {
    if g_savegame_manager {
        return g_savegame_manager.?.load_game(slot_id, game_state)
    }
    return false
}

export fn quicksave(game_state: *void): bool {
    if g_savegame_manager {
        return g_savegame_manager.?.quicksave(game_state)
    }
    return false
}

export fn quickload(game_state: *void): bool {
    if g_savegame_manager {
        return g_savegame_manager.?.quickload(game_state)
    }
    return false
}

export fn update_savegame_manager(delta_time: f32, game_state: *void) {
    if g_savegame_manager {
        g_savegame_manager.?.update(delta_time, game_state)
    }
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
