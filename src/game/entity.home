// Entity - Entity Component System for game objects
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/game/common/thing/

import std.collections.{HashMap, Vec}
import math.{Vec2, Vec3, Quat, Mat4}

/// Unique entity identifier
type EntityId = u64

/// Entity handle with generation for safety
struct EntityHandle {
    id: EntityId,
    generation: u32,
}

impl EntityHandle {
    fn new(id: EntityId, generation: u32) -> EntityHandle {
        return EntityHandle { id: id, generation: generation }
    }

    fn is_valid(self: &EntityHandle) -> bool {
        return self.id != 0
    }

    fn invalid() -> EntityHandle {
        return EntityHandle { id: 0, generation: 0 }
    }
}

/// Entity flags for fast queries
bitflags EntityFlags: u32 {
    None = 0,
    Active = 1 << 0,        // Entity is active and updating
    Visible = 1 << 1,       // Entity is visible and should render
    Dead = 1 << 2,          // Entity is marked for deletion
    Selected = 1 << 3,      // Entity is currently selected
    Enemy = 1 << 4,         // Entity belongs to enemy
    Ally = 1 << 5,          // Entity belongs to ally
    Neutral = 1 << 6,       // Entity is neutral
    Building = 1 << 7,      // Entity is a building
    Unit = 1 << 8,          // Entity is a unit
    Projectile = 1 << 9,    // Entity is a projectile
    Terrain = 1 << 10,      // Entity is terrain
}

/// Transform component - position, rotation, scale
struct Transform {
    position: Vec3,
    rotation: Quat,
    scale: Vec3,
    parent: Option<EntityHandle>,

    // Cached matrices
    local_matrix: Mat4,
    world_matrix: Mat4,
    dirty: bool,
}

impl Transform {
    fn new() -> Transform {
        return Transform {
            position: Vec3.new(0.0, 0.0, 0.0),
            rotation: Quat.identity(),
            scale: Vec3.new(1.0, 1.0, 1.0),
            parent: None,
            local_matrix: Mat4.identity(),
            world_matrix: Mat4.identity(),
            dirty: true
        }
    }

    fn at_position(position: Vec3) -> Transform {
        let mut transform = Transform.new()
        transform.position = position
        transform.dirty = true
        return transform
    }

    /// Set position
    fn set_position(self: &mut Transform, position: Vec3) {
        self.position = position
        self.dirty = true
    }

    /// Set rotation
    fn set_rotation(self: &mut Transform, rotation: Quat) {
        self.rotation = rotation
        self.dirty = true
    }

    /// Set scale
    fn set_scale(self: &mut Transform, scale: Vec3) {
        self.scale = scale
        self.dirty = true
    }

    /// Translate (add to position)
    fn translate(self: &mut Transform, offset: Vec3) {
        self.position += offset
        self.dirty = true
    }

    /// Rotate by quaternion
    fn rotate(self: &mut Transform, rotation: Quat) {
        self.rotation = self.rotation * rotation
        self.rotation.normalize()
        self.dirty = true
    }

    /// Get forward direction
    fn forward(self: &Transform) -> Vec3 {
        return self.rotation.rotate_vec3(&Vec3.new(0.0, 0.0, 1.0))
    }

    /// Get right direction
    fn right(self: &Transform) -> Vec3 {
        return self.rotation.rotate_vec3(&Vec3.new(1.0, 0.0, 0.0))
    }

    /// Get up direction
    fn up(self: &Transform) -> Vec3 {
        return self.rotation.rotate_vec3(&Vec3.new(0.0, 1.0, 0.0))
    }

    /// Update matrices
    fn update_matrix(self: &mut Transform) {
        if !self.dirty {
            return
        }

        // Build local transform matrix
        // T * R * S
        let trans = Mat4.translate(&self.position)
        let rot = Mat4.from_quaternion(&self.rotation)
        let scale = Mat4.scale(&self.scale)

        self.local_matrix = trans * rot * scale

        // TODO: Apply parent transform
        self.world_matrix = self.local_matrix

        self.dirty = false
    }

    /// Get world matrix
    fn world_matrix(self: &mut Transform) -> &Mat4 {
        self.update_matrix()
        return &self.world_matrix
    }
}

/// Health component - for units, buildings
struct Health {
    current: i32,
    maximum: i32,
    regeneration_rate: f32,  // HP per second
    invulnerable: bool,
}

impl Health {
    fn new(maximum: i32) -> Health {
        return Health {
            current: maximum,
            maximum: maximum,
            regeneration_rate: 0.0,
            invulnerable: false
        }
    }

    /// Take damage
    fn damage(self: &mut Health, amount: i32) -> bool {
        if self.invulnerable {
            return false
        }

        self.current -= amount
        if self.current < 0 {
            self.current = 0
        }

        return self.current == 0  // Return true if dead
    }

    /// Heal
    fn heal(self: &mut Health, amount: i32) {
        self.current += amount
        if self.current > self.maximum {
            self.current = self.maximum
        }
    }

    /// Update (regeneration)
    fn update(self: &mut Health, dt: f32) {
        if self.regeneration_rate > 0.0 {
            let heal_amount = (self.regeneration_rate * dt) as i32
            self.heal(heal_amount)
        }
    }

    /// Check if alive
    fn is_alive(self: &Health) -> bool {
        return self.current > 0
    }

    /// Get health percentage (0.0 - 1.0)
    fn percentage(self: &Health) -> f32 {
        return (self.current as f32) / (self.maximum as f32)
    }
}

/// Movement component - for units
struct Movement {
    velocity: Vec3,
    max_speed: f32,
    acceleration: f32,
    turn_rate: f32,  // radians per second
    can_move: bool,
}

impl Movement {
    fn new(max_speed: f32) -> Movement {
        return Movement {
            velocity: Vec3.new(0.0, 0.0, 0.0),
            max_speed: max_speed,
            acceleration: max_speed * 2.0,  // Reach max speed in 0.5s
            turn_rate: 3.14159,  // 180 degrees per second
            can_move: true
        }
    }

    /// Update velocity towards target direction
    fn move_towards(self: &mut Movement, direction: Vec3, dt: f32) {
        if !self.can_move {
            return
        }

        // Normalize direction
        let dir = direction.normalized()

        // Accelerate towards target velocity
        let target_velocity = dir * self.max_speed
        let delta_v = target_velocity - self.velocity

        // Apply acceleration
        let accel_amount = self.acceleration * dt
        if delta_v.length() > accel_amount {
            self.velocity += delta_v.normalized() * accel_amount
        } else {
            self.velocity = target_velocity
        }
    }

    /// Stop moving
    fn stop(self: &mut Movement, dt: f32) {
        // Decelerate to zero
        let decel_amount = self.acceleration * dt
        let speed = self.velocity.length()

        if speed > decel_amount {
            self.velocity -= self.velocity.normalized() * decel_amount
        } else {
            self.velocity = Vec3.new(0.0, 0.0, 0.0)
        }
    }

    /// Check if moving
    fn is_moving(self: &Movement) -> bool {
        return self.velocity.length_squared() > 0.01
    }
}

/// Selectable component - for units and buildings
struct Selectable {
    selected: bool,
    selectable: bool,
    selection_radius: f32,
}

impl Selectable {
    fn new(radius: f32) -> Selectable {
        return Selectable {
            selected: false,
            selectable: true,
            selection_radius: radius
        }
    }

    /// Check if point is within selection radius
    fn is_in_radius(self: &Selectable, position: &Vec3, point: &Vec3) -> bool {
        let dist = (point - position).length()
        return dist <= self.selection_radius
    }
}

/// Entity - main game object
struct Entity {
    handle: EntityHandle,
    flags: u32,
    name: String,

    // Core components
    transform: Transform,

    // Optional components
    health: Option<Health>,
    movement: Option<Movement>,
    selectable: Option<Selectable>,

    // Game-specific data
    team_id: u32,
    unit_type: String,
}

impl Entity {
    fn new(id: EntityId, name: String) -> Entity {
        return Entity {
            handle: EntityHandle.new(id, 0),
            flags: EntityFlags.Active as u32,
            name: name,
            transform: Transform.new(),
            health: None,
            movement: None,
            selectable: None,
            team_id: 0,
            unit_type: String.new()
        }
    }

    /// Check if entity has flag
    fn has_flag(self: &Entity, flag: u32) -> bool {
        return (self.flags & flag) != 0
    }

    /// Set flag
    fn set_flag(self: &mut Entity, flag: u32, value: bool) {
        if value {
            self.flags |= flag
        } else {
            self.flags &= !flag
        }
    }

    /// Check if alive
    fn is_alive(self: &Entity) -> bool {
        if let Some(health) = &self.health {
            return health.is_alive()
        }
        return true
    }

    /// Check if dead (marked for deletion)
    fn is_dead(self: &Entity) -> bool {
        return self.has_flag(EntityFlags.Dead as u32)
    }

    /// Mark for deletion
    fn mark_dead(self: &mut Entity) {
        self.set_flag(EntityFlags.Dead as u32, true)
        self.set_flag(EntityFlags.Active as u32, false)
    }

    /// Update entity
    fn update(self: &mut Entity, dt: f32) {
        if !self.has_flag(EntityFlags.Active as u32) {
            return
        }

        // Update health (regeneration)
        if let Some(health) = &mut self.health {
            health.update(dt)
        }

        // Update movement
        if let Some(movement) = &mut self.movement {
            if movement.is_moving() {
                self.transform.translate(movement.velocity * dt)
            }
        }

        // Check death condition
        if !self.is_alive() {
            self.mark_dead()
        }
    }
}
