// Home Programming Language - Networking & Multiplayer System
// Client-server multiplayer architecture for RTS games
//
// Features:
// - Client-server architecture
// - UDP for game state, TCP for reliable messages
// - State synchronization with delta compression
// - Lag compensation and prediction
// - Lobby system
// - Replay recording integration

import graphics::{Vec3}
from basics import Collection

// ============================================================================
// Network Protocol
// ============================================================================

enum PacketType {
    // Connection
    CONNECT,
    CONNECT_ACK,
    DISCONNECT,
    PING,
    PONG,
    // Lobby
    LOBBY_CREATE,
    LOBBY_JOIN,
    LOBBY_LEAVE,
    LOBBY_UPDATE,
    LOBBY_READY,
    LOBBY_START,
    // Game
    GAME_STATE,
    GAME_STATE_DELTA,
    PLAYER_COMMAND,
    CHAT_MESSAGE,
    // Synchronization
    SYNC_REQUEST,
    SYNC_RESPONSE,
}

enum CommandType {
    MOVE,
    ATTACK,
    BUILD,
    SELL,
    SPECIAL,
}

struct PlayerCommand {
    player_id: Int,
    timestamp: Int,
    command_type: CommandType,
    data: Collection<Int>,  // Command-specific data
}

struct EntityState {
    id: Int,
    position: Vec3,
    rotation: Float,
    health: Float,
    flags: Int,
}

struct GameStateSnapshot {
    tick: Int,
    timestamp: Int,
    player_count: Int,
    entities: Collection<EntityState>,
}

// ============================================================================
// Network Connection
// ============================================================================

struct NetworkAddress {
    ip: String,
    port: Int,
}

struct Connection {
    address: NetworkAddress,
    player_id: Int,
    connected: Bool,
    last_ping_time: Int,
    rtt: Int,  // Round-trip time in milliseconds
}

fn create_connection(address: NetworkAddress, player_id: Int) -> Connection {
    return Connection {
        address: address,
        player_id: player_id,
        connected: false,
        last_ping_time: 0,
        rtt: 0,
    }
}

// ============================================================================
// Server
// ============================================================================

struct ServerConfig {
    port: Int,
    max_players: Int,
    tick_rate: Int,         // Server updates per second (e.g., 30)
    max_latency_ms: Int,    // Kick players above this latency
}

struct GameServer {
    config: ServerConfig,
    socket_udp: Int,        // Socket handle (mock)
    socket_tcp: Int,        // Socket handle (mock)
    connections: Collection<Connection>,
    current_tick: Int,
    running: Bool,
    pending_commands: Collection<PlayerCommand>,
    state_history: Collection<GameStateSnapshot>,  // Ring buffer for lag compensation
}

fn create_game_server(config: ServerConfig) -> GameServer {
    return GameServer {
        config: config,
        socket_udp: 0,
        socket_tcp: 0,
        connections: Collection::new<Connection>(),
        current_tick: 0,
        running: false,
        pending_commands: Collection::new<PlayerCommand>(),
        state_history: Collection::new<GameStateSnapshot>(),
    }
}

fn start_server(server: GameServer) {
    server.running = true

    // In production: create network sockets
    // In production: listen on TCP port
    // In production: bind UDP socket

    // Main server loop
    while server.running {
        // Accept new connections (non-blocking)
        accept_new_connections(server)

        // Process incoming packets
        process_incoming_packets(server)

        // Process game logic
        process_game_tick(server)

        // Send state updates to clients
        send_state_updates(server)

        server.current_tick = server.current_tick + 1

        // In production: sleep until next tick (tick_rate timing)
    }
}

fn stop_server(server: GameServer) {
    server.running = false
}

fn accept_new_connections(server: GameServer) {
    // In production: non-blocking TCP accept
    // Create Connection for each new client
}

fn process_incoming_packets(server: GameServer) {
    // In production: read from UDP socket
    // Deserialize packets
    // Handle different PacketType enum values
}

fn process_game_tick(server: GameServer) {
    // Sort pending commands by timestamp
    // (In production: use proper sorting algorithm)

    // Execute commands
    let i = 0
    while i < server.pending_commands.len() {
        let cmd = server.pending_commands.get(i)
        execute_command(server, cmd)
        i = i + 1
    }

    server.pending_commands.clear()

    // Update game state
    // (Game logic would go here)
}

fn execute_command(server: GameServer, cmd: PlayerCommand) {
    // In production: execute player command
    // Move units, attack, build, etc.
}

fn send_state_updates(server: GameServer) {
    // Send full state snapshot every 30 ticks
    // Send delta updates in between

    let send_full_snapshot = (server.current_tick % 30) == 0

    if send_full_snapshot {
        // Send full snapshot
        let i = 0
        while i < server.connections.len() {
            let conn = server.connections.get(i)
            if conn.connected {
                send_full_snapshot_to(server, conn.address)
            }
            i = i + 1
        }
    } else {
        // Send delta update
        let i = 0
        while i < server.connections.len() {
            let conn = server.connections.get(i)
            if conn.connected {
                send_delta_update_to(server, conn.address)
            }
            i = i + 1
        }
    }
}

fn send_full_snapshot_to(server: GameServer, address: NetworkAddress) {
    // In production: serialize full GameStateSnapshot
    // Send via UDP socket
}

fn send_delta_update_to(server: GameServer, address: NetworkAddress) {
    // In production: compute delta from last state
    // Compress and send via UDP
}

fn broadcast_message(server: GameServer, message: String) {
    let i = 0
    while i < server.connections.len() {
        let conn = server.connections.get(i)
        if conn.connected {
            // In production: send message packet
        }
        i = i + 1
    }
}

// ============================================================================
// Client
// ============================================================================

struct ClientConfig {
    server_address: String,
    server_port: Int,
    player_name: String,
}

struct GameClient {
    config: ClientConfig,
    socket_udp: Int,
    socket_tcp: Int,
    player_id: Int,
    connected: Bool,
    current_tick: Int,
    has_predicted_state: Bool,
    predicted_state: GameStateSnapshot,
    has_confirmed_state: Bool,
    confirmed_state: GameStateSnapshot,
    pending_commands: Collection<PlayerCommand>,
}

fn create_game_client(config: ClientConfig) -> GameClient {
    return GameClient {
        config: config,
        socket_udp: 0,
        socket_tcp: 0,
        player_id: 0,
        connected: false,
        current_tick: 0,
        has_predicted_state: false,
        predicted_state: GameStateSnapshot {
            tick: 0,
            timestamp: 0,
            player_count: 0,
            entities: Collection::new<EntityState>(),
        },
        has_confirmed_state: false,
        confirmed_state: GameStateSnapshot {
            tick: 0,
            timestamp: 0,
            player_count: 0,
            entities: Collection::new<EntityState>(),
        },
        pending_commands: Collection::new<PlayerCommand>(),
    }
}

fn connect_client(client: GameClient) {
    // In production: create TCP socket
    // In production: send CONNECT packet
    // In production: wait for CONNECT_ACK

    client.connected = true
}

fn disconnect_client(client: GameClient) {
    // In production: send DISCONNECT packet
    // In production: close sockets

    client.connected = false
}

fn send_command(client: GameClient, command: PlayerCommand) {
    client.pending_commands.push(command)
    // In production: send PLAYER_COMMAND packet via TCP
}

fn update_client(client: GameClient, dt: Float) {
    // Receive packets
    receive_packets(client)

    // Update prediction
    update_prediction(client)

    // Send pending commands
    let i = 0
    while i < client.pending_commands.len() {
        let cmd = client.pending_commands.get(i)
        // In production: send packet
        i = i + 1
    }
    client.pending_commands.clear()

    client.current_tick = client.current_tick + 1
}

fn receive_packets(client: GameClient) {
    // In production: non-blocking receive from UDP and TCP
    // Deserialize packets
    // Update predicted_state or confirmed_state
}

fn update_prediction(client: GameClient) {
    // Client-side prediction
    // Apply pending commands to predicted state
}

fn reconcile_state(client: GameClient, server_state: GameStateSnapshot) {
    // Server reconciliation
    // Compare predicted state with authoritative server state
    // If mismatch, rewind and replay commands

    client.confirmed_state = server_state
    client.has_confirmed_state = true
}

// ============================================================================
// Lobby System
// ============================================================================

struct LobbyPlayer {
    id: Int,
    name: String,
    ready: Bool,
    team: Int,
}

struct Lobby {
    id: Int,
    name: String,
    host_player_id: Int,
    players: Collection<LobbyPlayer>,
    max_players: Int,
    map_name: String,
    game_started: Bool,
}

fn create_lobby(id: Int, name: String, host_id: Int) -> Lobby {
    return Lobby {
        id: id,
        name: name,
        host_player_id: host_id,
        players: Collection::new<LobbyPlayer>(),
        max_players: 8,
        map_name: "default",
        game_started: false,
    }
}

fn add_player_to_lobby(lobby: Lobby, player: LobbyPlayer) -> Bool {
    if lobby.players.len() >= lobby.max_players {
        return false
    }
    lobby.players.push(player)
    return true
}

fn remove_player_from_lobby(lobby: Lobby, player_id: Int) {
    let i = 0
    while i < lobby.players.len() {
        let player = lobby.players.get(i)
        if player.id == player_id {
            lobby.players.remove_at(i)
            return
        }
        i = i + 1
    }
}

fn set_player_ready(lobby: Lobby, player_id: Int, ready: Bool) {
    let i = 0
    while i < lobby.players.len() {
        let player = lobby.players.get(i)
        if player.id == player_id {
            player.ready = ready
            lobby.players.set(i, player)
            return
        }
        i = i + 1
    }
}

fn all_players_ready(lobby: Lobby) -> Bool {
    if lobby.players.len() == 0 {
        return false
    }

    let i = 0
    while i < lobby.players.len() {
        let player = lobby.players.get(i)
        if !player.ready {
            return false
        }
        i = i + 1
    }

    return true
}

fn can_start_lobby(lobby: Lobby) -> Bool {
    return lobby.players.len() >= 2 && all_players_ready(lobby)
}

// ============================================================================
// Replay Recording
// ============================================================================

struct ReplayRecorder {
    file_handle: Int,       // Mock file handle
    recording: Bool,
    start_time: Int,
    commands: Collection<PlayerCommand>,
    states: Collection<GameStateSnapshot>,
}

fn create_replay_recorder(path: String) -> ReplayRecorder {
    // In production: open file for writing

    return ReplayRecorder {
        file_handle: 0,
        recording: true,
        start_time: get_current_time(),
        commands: Collection::new<PlayerCommand>(),
        states: Collection::new<GameStateSnapshot>(),
    }
}

fn record_command(recorder: ReplayRecorder, command: PlayerCommand) {
    if !recorder.recording {
        return
    }

    recorder.commands.push(command)

    // In production: write timestamp + command to file
}

fn record_state(recorder: ReplayRecorder, state: GameStateSnapshot) {
    if !recorder.recording {
        return
    }

    recorder.states.push(state)

    // In production: write timestamp + state snapshot to file
}

fn stop_recording(recorder: ReplayRecorder) {
    recorder.recording = false

    // In production: close file
}

// ============================================================================
// Helper Functions
// ============================================================================

fn get_current_time() -> Int {
    // In production: get system timestamp in milliseconds
    return 0
}

fn create_network_address(ip: String, port: Int) -> NetworkAddress {
    return NetworkAddress { ip: ip, port: port }
}

// ============================================================================
// Tests
// ============================================================================

fn test_lobby_creation() -> Bool {
    let lobby = create_lobby(1, "Test Lobby", 1)
    assert(lobby.id == 1, "Lobby ID should be 1")
    assert(lobby.players.len() == 0, "Lobby should start empty")
    assert(lobby.max_players == 8, "Max players should be 8")
    return true
}

fn test_lobby_player_management() -> Bool {
    let lobby = create_lobby(1, "Test Lobby", 1)

    let player = LobbyPlayer {
        id: 1,
        name: "Player1",
        ready: false,
        team: 0,
    }

    let added = add_player_to_lobby(lobby, player)
    assert(added == true, "Should add player successfully")
    assert(lobby.players.len() == 1, "Should have 1 player")

    set_player_ready(lobby, 1, true)
    let updated_player = lobby.players.get(0)
    assert(updated_player.ready == true, "Player should be ready")

    return true
}

fn test_lobby_full() -> Bool {
    let lobby = create_lobby(1, "Test", 1)
    lobby.max_players = 2

    let player1 = LobbyPlayer { id: 1, name: "P1", ready: false, team: 0 }
    let player2 = LobbyPlayer { id: 2, name: "P2", ready: false, team: 0 }
    let player3 = LobbyPlayer { id: 3, name: "P3", ready: false, team: 0 }

    assert(add_player_to_lobby(lobby, player1) == true, "Should add player 1")
    assert(add_player_to_lobby(lobby, player2) == true, "Should add player 2")
    assert(add_player_to_lobby(lobby, player3) == false, "Should reject player 3 (full)")

    return true
}

fn test_all_players_ready() -> Bool {
    let lobby = create_lobby(1, "Test", 1)

    let player1 = LobbyPlayer { id: 1, name: "P1", ready: false, team: 0 }
    let player2 = LobbyPlayer { id: 2, name: "P2", ready: false, team: 0 }

    add_player_to_lobby(lobby, player1)
    add_player_to_lobby(lobby, player2)

    assert(all_players_ready(lobby) == false, "Not all players ready")

    set_player_ready(lobby, 1, true)
    assert(all_players_ready(lobby) == false, "Still not all ready")

    set_player_ready(lobby, 2, true)
    assert(all_players_ready(lobby) == true, "All players ready")

    return true
}

fn test_can_start_lobby() -> Bool {
    let lobby = create_lobby(1, "Test", 1)

    let player1 = LobbyPlayer { id: 1, name: "P1", ready: false, team: 0 }
    add_player_to_lobby(lobby, player1)

    assert(can_start_lobby(lobby) == false, "Need at least 2 players")

    let player2 = LobbyPlayer { id: 2, name: "P2", ready: false, team: 0 }
    add_player_to_lobby(lobby, player2)

    assert(can_start_lobby(lobby) == false, "Players not ready")

    set_player_ready(lobby, 1, true)
    set_player_ready(lobby, 2, true)

    assert(can_start_lobby(lobby) == true, "Should be able to start")

    return true
}

fn test_server_creation() -> Bool {
    let config = ServerConfig {
        port: 27015,
        max_players: 8,
        tick_rate: 30,
        max_latency_ms: 500,
    }

    let server = create_game_server(config)
    assert(server.current_tick == 0, "Server should start at tick 0")
    assert(server.running == false, "Server should not be running")
    assert(server.connections.len() == 0, "Server should have no connections")

    return true
}

fn test_client_creation() -> Bool {
    let config = ClientConfig {
        server_address: "127.0.0.1",
        server_port: 27015,
        player_name: "Player1",
    }

    let client = create_game_client(config)
    assert(client.connected == false, "Client should not be connected")
    assert(client.player_id == 0, "Client should have no player ID")

    return true
}

fn test_replay_recorder() -> Bool {
    let recorder = create_replay_recorder("test_replay.dat")
    assert(recorder.recording == true, "Recorder should be recording")

    let command = PlayerCommand {
        player_id: 1,
        timestamp: 1000,
        command_type: CommandType::MOVE,
        data: Collection::new<Int>(),
    }

    record_command(recorder, command)
    assert(recorder.commands.len() == 1, "Should have 1 recorded command")

    stop_recording(recorder)
    assert(recorder.recording == false, "Should stop recording")

    return true
}

fn test_connection_creation() -> Bool {
    let addr = create_network_address("192.168.1.1", 27015)
    let conn = create_connection(addr, 1)

    assert(conn.player_id == 1, "Player ID should be 1")
    assert(conn.connected == false, "Should not be connected")
    assert(conn.rtt == 0, "RTT should be 0")

    return true
}

fn test_remove_player_from_lobby() -> Bool {
    let lobby = create_lobby(1, "Test", 1)

    let player1 = LobbyPlayer { id: 1, name: "P1", ready: false, team: 0 }
    let player2 = LobbyPlayer { id: 2, name: "P2", ready: false, team: 0 }

    add_player_to_lobby(lobby, player1)
    add_player_to_lobby(lobby, player2)
    assert(lobby.players.len() == 2, "Should have 2 players")

    remove_player_from_lobby(lobby, 1)
    assert(lobby.players.len() == 1, "Should have 1 player after removal")

    let remaining = lobby.players.get(0)
    assert(remaining.id == 2, "Remaining player should be player 2")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_lobby_creation(), "test_lobby_creation failed")
    assert(test_lobby_player_management(), "test_lobby_player_management failed")
    assert(test_lobby_full(), "test_lobby_full failed")
    assert(test_all_players_ready(), "test_all_players_ready failed")
    assert(test_can_start_lobby(), "test_can_start_lobby failed")
    assert(test_server_creation(), "test_server_creation failed")
    assert(test_client_creation(), "test_client_creation failed")
    assert(test_replay_recorder(), "test_replay_recorder failed")
    assert(test_connection_creation(), "test_connection_creation failed")
    assert(test_remove_player_from_lobby(), "test_remove_player_from_lobby failed")
    return true
}
