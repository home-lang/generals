// C&C Generals Zero Hour - Home Port
// Special Powers System
//
// Original: SpecialPower.cpp + 12 special power modules (Westwood Studios/EA)
// Manages super weapons, general abilities, and faction-specific powers
//
// Special powers in C&C Generals include:
// - USA: A-10 Strike, Carpet Bomb, Fuel Air Bomb, Particle Cannon
// - China: Artillery Barrage, Nuclear Missile, EMP Pulse, Carpet Bomb
// - GLA: SCUD Storm, Anthrax Bomb, Sneak Attack, Emergency Repair

import basics/allocator
import engine/math

const MAX_SPECIAL_POWERS: u32 = 32
const MAX_POWER_NAME_LENGTH: u32 = 64

// Special power type
enum SpecialPowerType {
    // USA Powers
    A10_Strike
    Carpet_Bomb
    Fuel_Air_Bomb
    Particle_Cannon
    Paradrop
    Emergency_Repair_USA

    // China Powers
    Artillery_Barrage
    Nuclear_Missile
    EMP_Pulse
    Carpet_Bomb_China
    Cluster_Mines
    Cash_Hack

    // GLA Powers
    SCUD_Storm
    Anthrax_Bomb
    Sneak_Attack
    Emergency_Repair_GLA
    Radar_Van_Scan
    Cash_Bounty

    // Shared/Generic
    Spy_Drone
    Radar_Scan
    Ambulance
}

// Power targeting type
enum TargetingType {
    None           // Instant activation
    Point          // Click a point on map
    Area           // Click and drag area
    Unit           // Click a unit
    Building       // Click a building
    Object         // Click any object
}

// Power status
enum PowerStatus {
    Unavailable    // Not yet unlocked
    Ready          // Available to use
    Recharging     // Cooling down
    Active         // Currently executing
}

// Special power definition
struct SpecialPowerDefinition {
    power_type: SpecialPowerType
    name: string

    // Cost and requirements
    cost: u32
    requires_rank: u32
    requires_science: u32

    // Timing
    recharge_time: f32  // Seconds
    duration: f32       // For continuous powers

    // Targeting
    targeting: TargetingType
    range: f32          // Max distance from owned units
    radius: f32         // Effect radius

    // Effects
    damage: f32
    damage_radius: f32
    stun_duration: f32
    reveal_radius: f32

    // Audio/Visual
    sound_activation: string
    sound_incoming: string
    particle_effect: string
    screen_shake: bool

    fn init(): SpecialPowerDefinition {
        return SpecialPowerDefinition {
            power_type: SpecialPowerType.A10_Strike
            name: "Special Power"
            cost: 1000
            requires_rank: 0
            requires_science: 0
            recharge_time: 300.0  // 5 minutes
            duration: 0.0
            targeting: TargetingType.Point
            range: 10000.0
            radius: 50.0
            damage: 1000.0
            damage_radius: 100.0
            stun_duration: 0.0
            reveal_radius: 0.0
            sound_activation: "sound/powers/activate.wav"
            sound_incoming: "sound/powers/incoming.wav"
            particle_effect: "fx/explosion"
            screen_shake: true
        }
    }
}

// Active special power instance
struct SpecialPower {
    definition: SpecialPowerDefinition
    player_id: u32

    // State
    status: PowerStatus
    recharge_timer: f32
    activation_timer: f32

    // Targeting
    target_position: Vec3
    target_unit_id: u32

    // Stats
    times_used: u32
    total_damage_dealt: f32

    fn init(definition: SpecialPowerDefinition, player_id: u32): SpecialPower {
        return SpecialPower {
            definition: definition
            player_id: player_id
            status: PowerStatus.Ready
            recharge_timer: 0.0
            activation_timer: 0.0
            target_position: Vec3.init(0.0, 0.0, 0.0)
            target_unit_id: 0
            times_used: 0
            total_damage_dealt: 0.0
        }
    }

    fn update(mut self, delta_time: f32) {
        if self.status == PowerStatus.Recharging {
            self.recharge_timer -= delta_time
            if self.recharge_timer <= 0.0 {
                self.status = PowerStatus.Ready
                self.recharge_timer = 0.0
            }
        }

        if self.status == PowerStatus.Active {
            self.activation_timer -= delta_time
            if self.activation_timer <= 0.0 {
                self.status = PowerStatus.Recharging
                self.recharge_timer = self.definition.recharge_time
                self.activation_timer = 0.0
            }
        }
    }

    fn can_activate(&self): bool {
        return self.status == PowerStatus.Ready
    }

    fn activate(mut self, target_pos: Vec3): bool {
        if !self.can_activate() {
            return false
        }

        self.status = PowerStatus.Active
        self.target_position = target_pos
        self.activation_timer = self.definition.duration
        self.times_used += 1

        println("SpecialPower: Activated {}", self.definition.name)

        // Execute power effects (would be game-specific)
        self.execute_power()

        return true
    }

    fn execute_power(mut self) {
        // Execute the special power effects
        // This would involve:
        // - Creating projectiles/units
        // - Dealing damage in radius
        // - Spawning visual/audio effects
        // - Triggering screen shake
        // - Revealing fog of war

        match self.definition.power_type {
            SpecialPowerType.A10_Strike => {
                // Spawn A-10 aircraft, strafe target area
            }
            SpecialPowerType.Particle_Cannon => {
                // Fire particle beam at target, deal massive damage
            }
            SpecialPowerType.Nuclear_Missile => {
                // Launch nuke, create massive explosion
            }
            SpecialPowerType.EMP_Pulse => {
                // Disable all electronics in radius
            }
            SpecialPowerType.SCUD_Storm => {
                // Launch multiple SCUD missiles at target
            }
            else => {
                // Generic power
            }
        }
    }

    fn get_recharge_percentage(&self): f32 {
        if self.definition.recharge_time == 0.0 {
            return 1.0
        }
        let remaining = self.recharge_timer / self.definition.recharge_time
        return 1.0 - remaining
    }
}

// Special power manager
struct SpecialPowerManager {
    powers: [MAX_SPECIAL_POWERS]SpecialPower
    power_count: u32

    // Power definitions (loaded from data files)
    definitions: [MAX_SPECIAL_POWERS]SpecialPowerDefinition
    definition_count: u32

    allocator: Allocator

    fn init(allocator: Allocator): SpecialPowerManager {
        return SpecialPowerManager {
            powers: [SpecialPower.init(SpecialPowerDefinition.init(), 0); MAX_SPECIAL_POWERS]
            power_count: 0
            definitions: [SpecialPowerDefinition.init(); MAX_SPECIAL_POWERS]
            definition_count: 0
            allocator: allocator
        }
    }

    fn load_definitions(mut self) {
        // Load special power definitions from INI files
        // For now, create some defaults

        // USA Powers
        self.add_definition(self.create_a10_strike())
        self.add_definition(self.create_particle_cannon())

        // China Powers
        self.add_definition(self.create_nuclear_missile())
        self.add_definition(self.create_emp_pulse())

        // GLA Powers
        self.add_definition(self.create_scud_storm())
        self.add_definition(self.create_anthrax_bomb())
    }

    fn add_definition(mut self, def: SpecialPowerDefinition) {
        if self.definition_count >= MAX_SPECIAL_POWERS {
            return
        }
        self.definitions[self.definition_count] = def
        self.definition_count += 1
    }

    fn grant_power(mut self, player_id: u32, power_type: SpecialPowerType): u32 {
        if self.power_count >= MAX_SPECIAL_POWERS {
            return 0
        }

        // Find definition
        let mut definition: ?SpecialPowerDefinition = null
        for i in 0..self.definition_count {
            if self.definitions[i].power_type == power_type {
                definition = self.definitions[i]
                break
            }
        }

        if !definition {
            return 0
        }

        let power_id = self.power_count
        self.powers[power_id] = SpecialPower.init(definition.?, player_id)
        self.power_count += 1

        return power_id
    }

    fn update(mut self, delta_time: f32) {
        for i in 0..self.power_count {
            self.powers[i].update(delta_time)
        }
    }

    fn activate_power(mut self, power_id: u32, target_pos: Vec3): bool {
        if power_id >= self.power_count {
            return false
        }
        return self.powers[power_id].activate(target_pos)
    }

    // Power definitions
    fn create_a10_strike(&self): SpecialPowerDefinition {
        let mut def = SpecialPowerDefinition.init()
        def.power_type = SpecialPowerType.A10_Strike
        def.name = "A-10 Strike"
        def.cost = 800
        def.recharge_time = 180.0  // 3 minutes
        def.damage = 500.0
        def.damage_radius = 50.0
        return def
    }

    fn create_particle_cannon(&self): SpecialPowerDefinition {
        let mut def = SpecialPowerDefinition.init()
        def.power_type = SpecialPowerType.Particle_Cannon
        def.name = "Particle Cannon"
        def.cost = 5000
        def.requires_rank = 3
        def.recharge_time = 360.0  // 6 minutes
        def.damage = 5000.0
        def.damage_radius = 150.0
        def.screen_shake = true
        return def
    }

    fn create_nuclear_missile(&self): SpecialPowerDefinition {
        let mut def = SpecialPowerDefinition.init()
        def.power_type = SpecialPowerType.Nuclear_Missile
        def.name = "Nuclear Missile"
        def.cost = 5000
        def.requires_rank = 3
        def.recharge_time = 420.0  // 7 minutes
        def.damage = 8000.0
        def.damage_radius = 200.0
        def.screen_shake = true
        return def
    }

    fn create_emp_pulse(&self): SpecialPowerDefinition {
        let mut def = SpecialPowerDefinition.init()
        def.power_type = SpecialPowerType.EMP_Pulse
        def.name = "EMP Pulse"
        def.cost = 1500
        def.recharge_time = 240.0  // 4 minutes
        def.damage = 0.0
        def.stun_duration = 30.0  // 30 second stun
        def.damage_radius = 300.0
        return def
    }

    fn create_scud_storm(&self): SpecialPowerDefinition {
        let mut def = SpecialPowerDefinition.init()
        def.power_type = SpecialPowerType.SCUD_Storm
        def.name = "SCUD Storm"
        def.cost = 5000
        def.requires_rank = 3
        def.recharge_time = 360.0  // 6 minutes
        def.damage = 6000.0
        def.damage_radius = 250.0
        def.screen_shake = true
        return def
    }

    fn create_anthrax_bomb(&self): SpecialPowerDefinition {
        let mut def = SpecialPowerDefinition.init()
        def.power_type = SpecialPowerType.Anthrax_Bomb
        def.name = "Anthrax Bomb"
        def.cost = 2000
        def.recharge_time = 300.0  // 5 minutes
        def.damage = 200.0  // Damage over time
        def.damage_radius = 150.0
        def.duration = 60.0  // 60 second poison cloud
        return def
    }
}

// Global special power manager
var g_special_power_manager: ?SpecialPowerManager = null

export fn init_special_power_manager(allocator: Allocator) {
    g_special_power_manager = SpecialPowerManager.init(allocator)
    g_special_power_manager.?.load_definitions()
    println("SpecialPowerManager: System initialized")
}

export fn shutdown_special_power_manager() {
    g_special_power_manager = null
    println("SpecialPowerManager: System shutdown")
}

export fn grant_special_power(player_id: u32, power_type: SpecialPowerType): u32 {
    if g_special_power_manager {
        return g_special_power_manager.?.grant_power(player_id, power_type)
    }
    return 0
}

export fn activate_special_power(power_id: u32, target_pos: Vec3): bool {
    if g_special_power_manager {
        return g_special_power_manager.?.activate_power(power_id, target_pos)
    }
    return false
}

export fn update_special_powers(delta_time: f32) {
    if g_special_power_manager {
        g_special_power_manager.?.update(delta_time)
    }
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
