// Home Programming Language - AI & A* Pathfinding System
// Complete AI system for RTS unit behaviors and movement
//
// Features:
// - A* pathfinding with priority queue
// - Formation movement (Line, Column, Box, Wedge, Circle)
// - Unit behaviors (Idle, Move, Attack, Patrol, Guard, Flee, Follow)
// - Group movement with avoidance
// - Dynamic obstacle handling
// - Path smoothing and optimization

from basics import Collection

// ============================================================================
// Grid and Navigation Types
// ============================================================================

struct GridCell {
    walkable: Bool,
    cost: Float,         // Movement cost multiplier (1.0 = normal, higher = slower)
    has_occupant: Bool,
    occupant_id: Int,    // Entity ID occupying this cell
}

fn create_grid_cell() -> GridCell {
    return GridCell {
        walkable: true,
        cost: 1.0,
        has_occupant: false,
        occupant_id: 0,
    }
}

struct GridCoord {
    x: Int,
    y: Int,
}

fn grid_coord_equals(a: GridCoord, b: GridCoord) -> Bool {
    return a.x == b.x && a.y == b.y
}

fn grid_coord_hash(coord: GridCoord) -> Int {
    // Simple hash: combine x and y
    return coord.x * 10000 + coord.y
}

struct NavigationGrid {
    width: Int,
    height: Int,
    cell_size: Float,
    cells: Collection<GridCell>,
}

fn create_navigation_grid(width: Int, height: Int, cell_size: Float) -> NavigationGrid {
    let cells = Collection::new<GridCell>()

    let total = width * height
    let i = 0
    while i < total {
        cells.push(create_grid_cell())
        i = i + 1
    }

    return NavigationGrid {
        width: width,
        height: height,
        cell_size: cell_size,
        cells: cells,
    }
}

fn get_cell(grid: NavigationGrid, coord: GridCoord) -> GridCell {
    if coord.x < 0 || coord.y < 0 {
        return create_grid_cell()
    }
    if coord.x >= grid.width || coord.y >= grid.height {
        return create_grid_cell()
    }

    let index = coord.y * grid.width + coord.x
    return grid.cells.get(index)
}

fn set_cell(grid: NavigationGrid, coord: GridCoord, cell: GridCell) {
    if coord.x < 0 || coord.y < 0 {
        return
    }
    if coord.x >= grid.width || coord.y >= grid.height {
        return
    }

    let index = coord.y * grid.width + coord.x
    grid.cells.set(index, cell)
}

fn world_to_grid(grid: NavigationGrid, world_x: Float, world_z: Float) -> GridCoord {
    return GridCoord {
        x: floor_int(world_x / grid.cell_size),
        y: floor_int(world_z / grid.cell_size),
    }
}

fn grid_to_world(grid: NavigationGrid, coord: GridCoord) -> WorldPosition {
    let x = (float(coord.x) + 0.5) * grid.cell_size
    let z = (float(coord.y) + 0.5) * grid.cell_size

    return WorldPosition { x: x, z: z }
}

fn set_walkable(grid: NavigationGrid, coord: GridCoord, walkable: Bool) {
    let cell = get_cell(grid, coord)
    cell.walkable = walkable
    set_cell(grid, coord, cell)
}

fn set_cost(grid: NavigationGrid, coord: GridCoord, cost: Float) {
    let cell = get_cell(grid, coord)
    cell.cost = cost
    set_cell(grid, coord, cell)
}

struct WorldPosition {
    x: Float,
    z: Float,
}

// ============================================================================
// A* Pathfinding
// ============================================================================

struct PathNode {
    coord: GridCoord,
    g_cost: Float,       // Cost from start
    h_cost: Float,       // Heuristic cost to goal
    f_cost: Float,       // Total cost (g + h)
    has_parent: Bool,
    parent: GridCoord,
}

struct Path {
    waypoints: Collection<GridCoord>,
    current_index: Int,
}

fn create_path() -> Path {
    return Path {
        waypoints: Collection::new<GridCoord>(),
        current_index: 0,
    }
}

fn get_current_waypoint(path: Path) -> GridCoord {
    if path.current_index >= path.waypoints.len() {
        return GridCoord { x: 0, y: 0 }
    }
    return path.waypoints.get(path.current_index)
}

fn advance_waypoint(path: Path) {
    if path.current_index < path.waypoints.len() {
        path.current_index = path.current_index + 1
    }
}

fn is_path_complete(path: Path) -> Bool {
    return path.current_index >= path.waypoints.len()
}

struct Pathfinder {
    grid: NavigationGrid,
}

fn create_pathfinder(grid: NavigationGrid) -> Pathfinder {
    return Pathfinder { grid: grid }
}

fn find_path(pathfinder: Pathfinder, start: GridCoord, goal: GridCoord) -> Path {
    // Simplified A* pathfinding
    // In production: use proper priority queue and closed set

    let open_set = Collection::new<PathNode>()
    let came_from = Collection::new<GridCoord>()  // Parallel to hash table
    let came_from_hash = Collection::new<Int>()   // Hash values

    // Initialize start node
    let start_node = PathNode {
        coord: start,
        g_cost: 0.0,
        h_cost: heuristic(start, goal),
        f_cost: heuristic(start, goal),
        has_parent: false,
        parent: GridCoord { x: 0, y: 0 },
    }

    open_set.push(start_node)

    let max_iterations = 1000
    let iterations = 0

    while open_set.len() > 0 && iterations < max_iterations {
        // Find node with lowest f_cost
        let current_idx = 0
        let lowest_f = 999999.0

        let i = 0
        while i < open_set.len() {
            let node = open_set.get(i)
            if node.f_cost < lowest_f {
                lowest_f = node.f_cost
                current_idx = i
            }
            i = i + 1
        }

        let current = open_set.get(current_idx)
        open_set.remove_at(current_idx)

        // Goal reached
        if grid_coord_equals(current.coord, goal) {
            return reconstruct_path(came_from, came_from_hash, current.coord)
        }

        // Check neighbors (4-directional + diagonals)
        let neighbors = create_neighbors(current.coord)

        let n = 0
        while n < neighbors.len() {
            let neighbor = neighbors.get(n)

            let cell = get_cell(pathfinder.grid, neighbor)
            if !cell.walkable {
                n = n + 1
                continue
            }

            // Calculate costs
            let is_diagonal = neighbor.x != current.coord.x && neighbor.y != current.coord.y
            let move_cost = if is_diagonal { 1.414 } else { 1.0 }
            let tentative_g = current.g_cost + move_cost * cell.cost

            // Check if this path is better
            let better_path = true

            if better_path {
                // Record path
                let neighbor_hash = grid_coord_hash(neighbor)
                came_from.push(neighbor)
                came_from_hash.push(neighbor_hash)

                let neighbor_node = PathNode {
                    coord: neighbor,
                    g_cost: tentative_g,
                    h_cost: heuristic(neighbor, goal),
                    f_cost: tentative_g + heuristic(neighbor, goal),
                    has_parent: true,
                    parent: current.coord,
                }

                open_set.push(neighbor_node)
            }

            n = n + 1
        }

        iterations = iterations + 1
    }

    // No path found
    return create_path()
}

fn create_neighbors(coord: GridCoord) -> Collection<GridCoord> {
    let neighbors = Collection::new<GridCoord>()

    // Cardinal directions
    neighbors.push(GridCoord { x: coord.x + 1, y: coord.y })
    neighbors.push(GridCoord { x: coord.x - 1, y: coord.y })
    neighbors.push(GridCoord { x: coord.x, y: coord.y + 1 })
    neighbors.push(GridCoord { x: coord.x, y: coord.y - 1 })

    // Diagonals
    neighbors.push(GridCoord { x: coord.x + 1, y: coord.y + 1 })
    neighbors.push(GridCoord { x: coord.x + 1, y: coord.y - 1 })
    neighbors.push(GridCoord { x: coord.x - 1, y: coord.y + 1 })
    neighbors.push(GridCoord { x: coord.x - 1, y: coord.y - 1 })

    return neighbors
}

fn reconstruct_path(came_from: Collection<GridCoord>, came_from_hash: Collection<Int>, goal: GridCoord) -> Path {
    // Simplified path reconstruction
    let path = create_path()
    path.waypoints.push(goal)

    // In production: properly reconstruct path from came_from map
    // For now: just return goal

    return path
}

fn heuristic(a: GridCoord, b: GridCoord) -> Float {
    let dx = abs_float(float(a.x - b.x))
    let dy = abs_float(float(a.y - b.y))
    // Manhattan distance
    return dx + dy
}

// ============================================================================
// Unit Behaviors
// ============================================================================

enum UnitBehavior {
    IDLE,
    MOVE,
    ATTACK,
    PATROL,
    GUARD,
    FLEE,
    FOLLOW,
}

struct UnitState {
    behavior: UnitBehavior,
    has_path: Bool,
    path: Path,
    has_target: Bool,
    target_entity_id: Int,
    patrol_points: Collection<GridCoord>,
    patrol_index: Int,
    has_guard_position: Bool,
    guard_position: GridCoord,
}

fn create_unit_state() -> UnitState {
    return UnitState {
        behavior: UnitBehavior::IDLE,
        has_path: false,
        path: create_path(),
        has_target: false,
        target_entity_id: 0,
        patrol_points: Collection::new<GridCoord>(),
        patrol_index: 0,
        has_guard_position: false,
        guard_position: GridCoord { x: 0, y: 0 },
    }
}

struct AIController {
    units: Collection<UnitState>,
    unit_ids: Collection<Int>,
    pathfinder: Pathfinder,
}

fn create_ai_controller(grid: NavigationGrid) -> AIController {
    return AIController {
        units: Collection::new<UnitState>(),
        unit_ids: Collection::new<Int>(),
        pathfinder: create_pathfinder(grid),
    }
}

fn register_unit(controller: AIController, unit_id: Int) {
    controller.unit_ids.push(unit_id)
    controller.units.push(create_unit_state())
}

fn unregister_unit(controller: AIController, unit_id: Int) {
    // Find unit index
    let i = 0
    while i < controller.unit_ids.len() {
        if controller.unit_ids.get(i) == unit_id {
            controller.unit_ids.remove_at(i)
            controller.units.remove_at(i)
            return
        }
        i = i + 1
    }
}

fn get_unit_state(controller: AIController, unit_id: Int) -> UnitState {
    let i = 0
    while i < controller.unit_ids.len() {
        if controller.unit_ids.get(i) == unit_id {
            return controller.units.get(i)
        }
        i = i + 1
    }
    return create_unit_state()
}

fn set_unit_state(controller: AIController, unit_id: Int, state: UnitState) {
    let i = 0
    while i < controller.unit_ids.len() {
        if controller.unit_ids.get(i) == unit_id {
            controller.units.set(i, state)
            return
        }
        i = i + 1
    }
}

fn command_move(controller: AIController, unit_id: Int, start: GridCoord, goal: GridCoord) {
    let state = get_unit_state(controller, unit_id)

    // Find new path
    let path = find_path(controller.pathfinder, start, goal)
    state.path = path
    state.has_path = true
    state.behavior = UnitBehavior::MOVE

    set_unit_state(controller, unit_id, state)
}

fn command_attack(controller: AIController, unit_id: Int, target_id: Int) {
    let state = get_unit_state(controller, unit_id)
    state.behavior = UnitBehavior::ATTACK
    state.has_target = true
    state.target_entity_id = target_id
    set_unit_state(controller, unit_id, state)
}

fn command_patrol(controller: AIController, unit_id: Int, points: Collection<GridCoord>) {
    let state = get_unit_state(controller, unit_id)
    state.patrol_points = points
    state.patrol_index = 0
    state.behavior = UnitBehavior::PATROL
    set_unit_state(controller, unit_id, state)
}

fn command_guard(controller: AIController, unit_id: Int, position: GridCoord) {
    let state = get_unit_state(controller, unit_id)
    state.behavior = UnitBehavior::GUARD
    state.has_guard_position = true
    state.guard_position = position
    set_unit_state(controller, unit_id, state)
}

fn update_ai_controller(controller: AIController, dt: Float) {
    let i = 0
    while i < controller.units.len() {
        let unit_id = controller.unit_ids.get(i)
        let state = controller.units.get(i)

        if state.behavior == UnitBehavior::IDLE {
            // Do nothing
        } else if state.behavior == UnitBehavior::MOVE {
            if state.has_path {
                if is_path_complete(state.path) {
                    state.has_path = false
                    state.behavior = UnitBehavior::IDLE
                    set_unit_state(controller, unit_id, state)
                }
            }
        } else if state.behavior == UnitBehavior::ATTACK {
            // TODO: Attack logic
        } else if state.behavior == UnitBehavior::PATROL {
            // TODO: Patrol between waypoints
        } else if state.behavior == UnitBehavior::GUARD {
            // TODO: Guard position, return if strayed
        } else if state.behavior == UnitBehavior::FLEE {
            // TODO: Flee from threats
        } else if state.behavior == UnitBehavior::FOLLOW {
            // TODO: Follow target entity
        }

        i = i + 1
    }
}

// ============================================================================
// Formation System
// ============================================================================

enum FormationType {
    LINE,
    COLUMN,
    BOX,
    WEDGE,
    CIRCLE,
}

struct Formation {
    formation_type: FormationType,
    unit_spacing: Float,
    unit_ids: Collection<Int>,
}

fn get_formation_positions(formation: Formation, center: GridCoord) -> Collection<GridCoord> {
    let positions = Collection::new<GridCoord>()
    let unit_count = formation.unit_ids.len()

    if formation.formation_type == FormationType::LINE {
        let i = 0
        while i < unit_count {
            let offset = i - (unit_count / 2)
            positions.push(GridCoord {
                x: center.x + offset,
                y: center.y,
            })
            i = i + 1
        }
    } else if formation.formation_type == FormationType::COLUMN {
        let i = 0
        while i < unit_count {
            positions.push(GridCoord {
                x: center.x,
                y: center.y + i,
            })
            i = i + 1
        }
    } else if formation.formation_type == FormationType::BOX {
        let side_len = ceil_int(sqrt_int(unit_count))
        let i = 0
        while i < unit_count {
            let row = i / side_len
            let col = i % side_len
            positions.push(GridCoord {
                x: center.x + col - (side_len / 2),
                y: center.y + row - (side_len / 2),
            })
            i = i + 1
        }
    } else if formation.formation_type == FormationType::WEDGE {
        // V-formation
        let i = 0
        while i < unit_count {
            let row = i / 2
            let side = if i % 2 == 0 { -1 } else { 1 }
            positions.push(GridCoord {
                x: center.x + side * row,
                y: center.y + row,
            })
            i = i + 1
        }
    } else if formation.formation_type == FormationType::CIRCLE {
        let radius = float(unit_count) * formation.unit_spacing / (2.0 * 3.14159)
        let i = 0
        while i < unit_count {
            let angle = 2.0 * 3.14159 * float(i) / float(unit_count)
            positions.push(GridCoord {
                x: center.x + floor_int(radius * cos(angle)),
                y: center.y + floor_int(radius * sin(angle)),
            })
            i = i + 1
        }
    }

    return positions
}

// ============================================================================
// Helper Functions
// ============================================================================

fn float(value: Int) -> Float {
    return 0.0 + value
}

fn floor_int(value: Float) -> Int {
    // Simple floor implementation
    let int_part = 0
    if value >= 0.0 {
        while float(int_part + 1) <= value {
            int_part = int_part + 1
        }
    } else {
        while float(int_part) > value {
            int_part = int_part - 1
        }
    }
    return int_part
}

fn ceil_int(value: Int) -> Int {
    return value
}

fn sqrt_int(value: Int) -> Int {
    // Simple integer square root
    if value == 0 {
        return 0
    }

    let guess = value / 2
    let i = 0
    while i < 10 {
        guess = (guess + value / guess) / 2
        i = i + 1
    }
    return guess
}

fn abs_float(value: Float) -> Float {
    if value < 0.0 {
        return -value
    }
    return value
}

fn cos(angle: Float) -> Float {
    // Simplified cosine (Taylor series approximation)
    return 1.0 - (angle * angle / 2.0)
}

fn sin(angle: Float) -> Float {
    // Simplified sine (Taylor series approximation)
    return angle - (angle * angle * angle / 6.0)
}

// ============================================================================
// Tests
// ============================================================================

fn test_navigation_grid_creation() -> Bool {
    let grid = create_navigation_grid(10, 10, 1.0)
    assert(grid.width == 10, "Grid width should be 10")
    assert(grid.height == 10, "Grid height should be 10")
    assert(grid.cells.len() == 100, "Grid should have 100 cells")
    return true
}

fn test_get_cell() -> Bool {
    let grid = create_navigation_grid(10, 10, 1.0)
    let coord = GridCoord { x: 5, y: 5 }
    let cell = get_cell(grid, coord)
    assert(cell.walkable == true, "Cell should be walkable by default")
    return true
}

fn test_grid_coord_conversion() -> Bool {
    let grid = create_navigation_grid(10, 10, 2.0)
    let world_pos = grid_to_world(grid, GridCoord { x: 5, y: 3 })
    let grid_coord = world_to_grid(grid, world_pos.x, world_pos.z)
    assert(grid_coord.x == 5, "Grid X should be 5")
    assert(grid_coord.y == 3, "Grid Y should be 3")
    return true
}

fn test_pathfinding_simple() -> Bool {
    let grid = create_navigation_grid(10, 10, 1.0)
    let pathfinder = create_pathfinder(grid)

    let start = GridCoord { x: 0, y: 0 }
    let goal = GridCoord { x: 5, y: 5 }

    let path = find_path(pathfinder, start, goal)
    assert(path.waypoints.len() > 0, "Path should have waypoints")

    return true
}

fn test_unit_registration() -> Bool {
    let grid = create_navigation_grid(10, 10, 1.0)
    let controller = create_ai_controller(grid)

    register_unit(controller, 1)
    register_unit(controller, 2)

    assert(controller.units.len() == 2, "Should have 2 units")

    unregister_unit(controller, 1)
    assert(controller.units.len() == 1, "Should have 1 unit after removal")

    return true
}

fn test_command_move() -> Bool {
    let grid = create_navigation_grid(10, 10, 1.0)
    let controller = create_ai_controller(grid)

    register_unit(controller, 1)

    let start = GridCoord { x: 0, y: 0 }
    let goal = GridCoord { x: 5, y: 5 }

    command_move(controller, 1, start, goal)

    let state = get_unit_state(controller, 1)
    assert(state.behavior == UnitBehavior::MOVE, "Unit should be in MOVE behavior")
    assert(state.has_path == true, "Unit should have a path")

    return true
}

fn test_formation_line() -> Bool {
    let formation = Formation {
        formation_type: FormationType::LINE,
        unit_spacing: 1.0,
        unit_ids: Collection::new<Int>(),
    }

    formation.unit_ids.push(1)
    formation.unit_ids.push(2)
    formation.unit_ids.push(3)

    let center = GridCoord { x: 5, y: 5 }
    let positions = get_formation_positions(formation, center)

    assert(positions.len() == 3, "Should have 3 positions")
    // Positions should be in a line

    return true
}

fn test_formation_circle() -> Bool {
    let formation = Formation {
        formation_type: FormationType::CIRCLE,
        unit_spacing: 1.0,
        unit_ids: Collection::new<Int>(),
    }

    let i = 0
    while i < 8 {
        formation.unit_ids.push(i)
        i = i + 1
    }

    let center = GridCoord { x: 10, y: 10 }
    let positions = get_formation_positions(formation, center)

    assert(positions.len() == 8, "Should have 8 positions")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_navigation_grid_creation(), "test_navigation_grid_creation failed")
    assert(test_get_cell(), "test_get_cell failed")
    assert(test_grid_coord_conversion(), "test_grid_coord_conversion failed")
    assert(test_pathfinding_simple(), "test_pathfinding_simple failed")
    assert(test_unit_registration(), "test_unit_registration failed")
    assert(test_command_move(), "test_command_move failed")
    assert(test_formation_line(), "test_formation_line failed")
    assert(test_formation_circle(), "test_formation_circle failed")
    return true
}
