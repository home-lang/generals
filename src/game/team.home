// C&C Generals Zero Hour - Home Port
// Team Management System
//
// Original: Team.cpp (79KB - Westwood Studios/EA)
// Manages teams, alliances, and shared resources
//
// Teams allow multiple players to cooperate with:
// - Shared vision and radar
// - Allied victory conditions
// - Coordinated attacks
// - Shared special powers (in some modes)

import basics/allocator

const MAX_TEAMS: u32 = 4
const MAX_PLAYERS_PER_TEAM: u32 = 4

// Team definition
struct Team {
    id: u32
    name: string

    // Members
    player_ids: [MAX_PLAYERS_PER_TEAM]u32
    player_count: u32

    // Shared resources (for team games)
    shared_money: u32
    shared_supplies: u32

    // Team state
    is_defeated: bool
    is_victorious: bool

    // Team statistics (aggregate of all members)
    total_units_killed: u32
    total_units_lost: u32
    total_buildings_destroyed: u32
    total_buildings_lost: u32

    // Team bonuses
    bonus_money_multiplier: f32
    bonus_build_speed_multiplier: f32

    fn init(id: u32, name: string): Team {
        return Team {
            id: id
            name: name
            player_ids: [0; MAX_PLAYERS_PER_TEAM]
            player_count: 0
            shared_money: 0
            shared_supplies: 0
            is_defeated: false
            is_victorious: false
            total_units_killed: 0
            total_units_lost: 0
            total_buildings_destroyed: 0
            total_buildings_lost: 0
            bonus_money_multiplier: 1.0
            bonus_build_speed_multiplier: 1.0
        }
    }

    fn add_player(mut self, player_id: u32): bool {
        if self.player_count >= MAX_PLAYERS_PER_TEAM {
            return false
        }

        // Check if player already in team
        for i in 0..self.player_count {
            if self.player_ids[i] == player_id {
                return false
            }
        }

        self.player_ids[self.player_count] = player_id
        self.player_count += 1
        return true
    }

    fn remove_player(mut self, player_id: u32): bool {
        for i in 0..self.player_count {
            if self.player_ids[i] == player_id {
                // Shift remaining players down
                for j in i..(self.player_count - 1) {
                    self.player_ids[j] = self.player_ids[j + 1]
                }
                self.player_count -= 1
                return true
            }
        }
        return false
    }

    fn has_player(self, player_id: u32): bool {
        for i in 0..self.player_count {
            if self.player_ids[i] == player_id {
                return true
            }
        }
        return false
    }

    fn is_empty(self): bool {
        return self.player_count == 0
    }

    fn get_player_count(self): u32 {
        return self.player_count
    }

    // Shared resources
    fn add_shared_money(mut self, amount: u32) {
        self.shared_money += amount
    }

    fn spend_shared_money(mut self, amount: u32): bool {
        if self.shared_money >= amount {
            self.shared_money -= amount
            return true
        }
        return false
    }

    // Statistics
    fn record_unit_kill(mut self) {
        self.total_units_killed += 1
    }

    fn record_unit_loss(mut self) {
        self.total_units_lost += 1
    }

    fn record_building_destroyed(mut self) {
        self.total_buildings_destroyed += 1
    }

    fn record_building_lost(mut self) {
        self.total_buildings_lost += 1
    }

    // State
    fn set_defeated(mut self) {
        self.is_defeated = true
    }

    fn set_victorious(mut self) {
        self.is_victorious = true
    }
}

// Team manager
struct TeamManager {
    teams: [MAX_TEAMS]Team
    team_count: u32

    allocator: Allocator

    fn init(allocator: Allocator): TeamManager {
        return TeamManager {
            teams: [Team.init(0, ""); MAX_TEAMS]
            team_count: 0
            allocator: allocator
        }
    }

    fn create_team(mut self, name: string): u32 {
        if self.team_count >= MAX_TEAMS {
            println("TeamManager: Cannot create team - max limit reached")
            return 0
        }

        let team_id = self.team_count
        self.teams[team_id] = Team.init(team_id, name)
        self.team_count += 1

        return team_id
    }

    fn get_team(mut self, team_id: u32): ?*Team {
        if team_id >= self.team_count {
            return null
        }
        return &self.teams[team_id]
    }

    fn add_player_to_team(mut self, team_id: u32, player_id: u32): bool {
        let team = self.get_team(team_id)
        if team {
            return team.?.add_player(player_id)
        }
        return false
    }

    fn remove_player_from_team(mut self, team_id: u32, player_id: u32): bool {
        let team = self.get_team(team_id)
        if team {
            return team.?.remove_player(player_id)
        }
        return false
    }

    fn get_player_team(self, player_id: u32): ?u32 {
        for i in 0..self.team_count {
            if self.teams[i].has_player(player_id) {
                return i
            }
        }
        return null
    }

    fn are_players_allied(self, player1_id: u32, player2_id: u32): bool {
        let team1 = self.get_player_team(player1_id)
        let team2 = self.get_player_team(player2_id)

        if team1 && team2 {
            return team1.? == team2.?
        }

        return false
    }

    fn get_active_team_count(self): u32 {
        let mut count: u32 = 0
        for i in 0..self.team_count {
            if !self.teams[i].is_defeated && !self.teams[i].is_empty() {
                count += 1
            }
        }
        return count
    }

    fn check_victory_conditions(mut self): ?u32 {
        let active_teams = self.get_active_team_count()

        // If only one team left, they win
        if active_teams == 1 {
            for i in 0..self.team_count {
                if !self.teams[i].is_defeated && !self.teams[i].is_empty() {
                    self.teams[i].set_victorious()
                    return i
                }
            }
        }

        return null
    }
}

// Global team manager
var g_team_manager: ?TeamManager = null

export fn init_team_manager(allocator: Allocator) {
    g_team_manager = TeamManager.init(allocator)
    println("TeamManager: System initialized")
}

export fn shutdown_team_manager() {
    g_team_manager = null
    println("TeamManager: System shutdown")
}

export fn create_team(name: string): u32 {
    if g_team_manager {
        return g_team_manager.?.create_team(name)
    }
    return 0
}

export fn add_player_to_team(team_id: u32, player_id: u32): bool {
    if g_team_manager {
        return g_team_manager.?.add_player_to_team(team_id, player_id)
    }
    return false
}

export fn are_players_allied(player1_id: u32, player2_id: u32): bool {
    if g_team_manager {
        return g_team_manager.?.are_players_allied(player1_id, player2_id)
    }
    return false
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
