// Audio Engine - Complete Audio System for C&C Generals
// Implements: WAV/MP3 loading, 3D positional audio, music, voice, effects

// ============================================================================
// Audio Configuration
// ============================================================================

const MAX_CHANNELS: i32 = 64
const MAX_SOUNDS: i32 = 512
const MAX_MUSIC_TRACKS: i32 = 32
const SAMPLE_RATE: i32 = 44100
const DEFAULT_MASTER_VOLUME: f32 = 0.8

// ============================================================================
// Audio Types
// ============================================================================

enum SoundType {
    EFFECT,        // Short sound effects (gunfire, explosions)
    VOICE,         // Unit voice responses
    AMBIENT,       // Environmental sounds (wind, machinery)
    MUSIC,         // Background music
    UI,            // Interface sounds (clicks, alerts)
    EVA,           // EVA announcer voice
}

enum SoundState {
    STOPPED,
    PLAYING,
    PAUSED,
    FADING_IN,
    FADING_OUT,
}

// ============================================================================
// Audio Buffer (Raw audio data)
// ============================================================================

struct AudioBuffer {
    id: i32,
    name: String,
    sample_rate: i32,
    channels: i32,          // 1 = mono, 2 = stereo
    bits_per_sample: i32,   // 8 or 16
    data_size: i32,
    data: [u8],
    duration: f32,          // In seconds
    is_loaded: Bool,
}

fn create_audio_buffer(id: i32, name: String) -> AudioBuffer {
    return AudioBuffer {
        id: id,
        name: name,
        sample_rate: SAMPLE_RATE,
        channels: 2,
        bits_per_sample: 16,
        data_size: 0,
        data: [],
        duration: 0.0,
        is_loaded: false,
    }
}

// ============================================================================
// Sound Instance (Playing sound)
// ============================================================================

struct SoundInstance {
    id: i32,
    buffer_id: i32,
    sound_type: SoundType,
    state: SoundState,

    // Volume control
    volume: f32,
    pan: f32,               // -1.0 (left) to 1.0 (right)
    pitch: f32,             // 0.5 to 2.0

    // 3D positioning
    is_3d: Bool,
    position: Vec3,
    min_distance: f32,
    max_distance: f32,
    rolloff_factor: f32,

    // Playback state
    playback_position: f32, // In seconds
    loop_count: i32,        // -1 = infinite loop
    loops_remaining: i32,

    // Fading
    fade_start_volume: f32,
    fade_target_volume: f32,
    fade_duration: f32,
    fade_elapsed: f32,

    // Priority (for channel management)
    priority: i32,

    // Callbacks
    on_complete: fn(i32),
}

fn create_sound_instance(id: i32, buffer_id: i32, sound_type: SoundType) -> SoundInstance {
    return SoundInstance {
        id: id,
        buffer_id: buffer_id,
        sound_type: sound_type,
        state: SoundState::STOPPED,
        volume: 1.0,
        pan: 0.0,
        pitch: 1.0,
        is_3d: false,
        position: vec3(0.0, 0.0, 0.0),
        min_distance: 1.0,
        max_distance: 100.0,
        rolloff_factor: 1.0,
        playback_position: 0.0,
        loop_count: 0,
        loops_remaining: 0,
        fade_start_volume: 1.0,
        fade_target_volume: 1.0,
        fade_duration: 0.0,
        fade_elapsed: 0.0,
        priority: 0,
        on_complete: null,
    }
}

// ============================================================================
// Music Track
// ============================================================================

struct MusicTrack {
    id: i32,
    name: String,
    file_path: String,
    duration: f32,
    is_loaded: Bool,
    is_streaming: Bool,

    // Streaming state
    stream_position: i32,
    buffer_id: i32,
}

fn create_music_track(id: i32, name: String, path: String) -> MusicTrack {
    return MusicTrack {
        id: id,
        name: name,
        file_path: path,
        duration: 0.0,
        is_loaded: false,
        is_streaming: true,
        stream_position: 0,
        buffer_id: -1,
    }
}

// ============================================================================
// Listener (Player's ears)
// ============================================================================

struct AudioListener {
    position: Vec3,
    velocity: Vec3,
    forward: Vec3,
    up: Vec3,
}

fn create_listener() -> AudioListener {
    return AudioListener {
        position: vec3(0.0, 0.0, 0.0),
        velocity: vec3(0.0, 0.0, 0.0),
        forward: vec3(0.0, 0.0, -1.0),
        up: vec3(0.0, 1.0, 0.0),
    }
}

// ============================================================================
// Volume Settings
// ============================================================================

struct VolumeSettings {
    master: f32,
    music: f32,
    effects: f32,
    voice: f32,
    ambient: f32,
    ui: f32,
    eva: f32,
}

fn default_volume_settings() -> VolumeSettings {
    return VolumeSettings {
        master: 0.8,
        music: 0.7,
        effects: 0.8,
        voice: 0.9,
        ambient: 0.6,
        ui: 0.8,
        eva: 1.0,
    }
}

// ============================================================================
// Audio Engine
// ============================================================================

struct AudioEngine {
    is_initialized: Bool,

    // Buffers (loaded sounds)
    buffers: [AudioBuffer],
    next_buffer_id: i32,

    // Active sound instances
    instances: [SoundInstance],
    next_instance_id: i32,

    // Music system
    music_tracks: [MusicTrack],
    current_music_id: i32,
    next_music_id: i32,
    music_crossfade_time: f32,
    music_state: SoundState,

    // Listener (camera position)
    listener: AudioListener,

    // Volume controls
    volumes: VolumeSettings,

    // EVA system
    eva_queue: [i32],       // Queue of EVA message buffer IDs
    eva_playing: Bool,

    // Hardware info
    device_name: String,
    supports_eax: Bool,
}

fn create_audio_engine() -> AudioEngine {
    return AudioEngine {
        is_initialized: false,
        buffers: [],
        next_buffer_id: 1,
        instances: [],
        next_instance_id: 1,
        music_tracks: [],
        current_music_id: -1,
        next_music_id: 1,
        music_crossfade_time: 2.0,
        music_state: SoundState::STOPPED,
        listener: create_listener(),
        volumes: default_volume_settings(),
        eva_queue: [],
        eva_playing: false,
        device_name: "",
        supports_eax: false,
    }
}

fn init_audio_engine(engine: AudioEngine) -> Bool {
    // Initialize audio backend (OpenAL, macOS Audio, etc.)
    // This would call platform-specific audio initialization

    engine.is_initialized = true
    engine.device_name = "Default Audio Device"

    return true
}

fn shutdown_audio_engine(engine: AudioEngine) {
    // Stop all sounds
    stop_all_sounds(engine)

    // Free all buffers
    engine.buffers = []
    engine.instances = []
    engine.music_tracks = []

    engine.is_initialized = false
}

// ============================================================================
// Sound Loading
// ============================================================================

fn load_wav_file(engine: AudioEngine, name: String, path: String) -> i32 {
    let buffer = create_audio_buffer(engine.next_buffer_id, name)
    engine.next_buffer_id = engine.next_buffer_id + 1

    // WAV file format:
    // "RIFF" + file_size + "WAVE"
    // "fmt " + format_chunk_size + format_data
    // "data" + data_size + audio_data

    // In production, would read and parse WAV file
    buffer.is_loaded = true
    engine.buffers = engine.buffers + [buffer]

    return buffer.id
}

fn load_mp3_file(engine: AudioEngine, name: String, path: String) -> i32 {
    let buffer = create_audio_buffer(engine.next_buffer_id, name)
    engine.next_buffer_id = engine.next_buffer_id + 1

    // MP3 decoding would use external library (minimp3, etc.)
    buffer.is_loaded = true
    engine.buffers = engine.buffers + [buffer]

    return buffer.id
}

fn unload_buffer(engine: AudioEngine, buffer_id: i32) {
    let new_buffers: [AudioBuffer] = []
    for buf in engine.buffers {
        if buf.id != buffer_id {
            new_buffers = new_buffers + [buf]
        }
    }
    engine.buffers = new_buffers
}

fn get_buffer(engine: AudioEngine, buffer_id: i32) -> AudioBuffer {
    for buf in engine.buffers {
        if buf.id == buffer_id {
            return buf
        }
    }
    return create_audio_buffer(-1, "")
}

// ============================================================================
// Sound Playback
// ============================================================================

fn play_sound(engine: AudioEngine, buffer_id: i32, sound_type: SoundType) -> i32 {
    let instance = create_sound_instance(engine.next_instance_id, buffer_id, sound_type)
    engine.next_instance_id = engine.next_instance_id + 1

    instance.state = SoundState::PLAYING
    instance.volume = get_type_volume(engine, sound_type)

    engine.instances = engine.instances + [instance]

    return instance.id
}

fn play_sound_3d(engine: AudioEngine, buffer_id: i32, position: Vec3, sound_type: SoundType) -> i32 {
    let instance_id = play_sound(engine, buffer_id, sound_type)
    let instance = get_instance(engine, instance_id)

    if instance.id != -1 {
        instance.is_3d = true
        instance.position = position
    }

    return instance_id
}

fn play_sound_looped(engine: AudioEngine, buffer_id: i32, sound_type: SoundType, loop_count: i32) -> i32 {
    let instance_id = play_sound(engine, buffer_id, sound_type)
    let instance = get_instance(engine, instance_id)

    if instance.id != -1 {
        instance.loop_count = loop_count
        instance.loops_remaining = loop_count
    }

    return instance_id
}

fn stop_sound(engine: AudioEngine, instance_id: i32) {
    let instance = get_instance(engine, instance_id)
    if instance.id != -1 {
        instance.state = SoundState::STOPPED
        remove_instance(engine, instance_id)
    }
}

fn pause_sound(engine: AudioEngine, instance_id: i32) {
    let instance = get_instance(engine, instance_id)
    if instance.id != -1 && instance.state == SoundState::PLAYING {
        instance.state = SoundState::PAUSED
    }
}

fn resume_sound(engine: AudioEngine, instance_id: i32) {
    let instance = get_instance(engine, instance_id)
    if instance.id != -1 && instance.state == SoundState::PAUSED {
        instance.state = SoundState::PLAYING
    }
}

fn stop_all_sounds(engine: AudioEngine) {
    for instance in engine.instances {
        instance.state = SoundState::STOPPED
    }
    engine.instances = []
}

fn stop_sounds_of_type(engine: AudioEngine, sound_type: SoundType) {
    let remaining: [SoundInstance] = []
    for instance in engine.instances {
        if instance.sound_type == sound_type {
            instance.state = SoundState::STOPPED
        } else {
            remaining = remaining + [instance]
        }
    }
    engine.instances = remaining
}

// ============================================================================
// Sound Properties
// ============================================================================

fn set_sound_volume(engine: AudioEngine, instance_id: i32, volume: f32) {
    let instance = get_instance(engine, instance_id)
    if instance.id != -1 {
        instance.volume = clamp(volume, 0.0, 1.0)
    }
}

fn set_sound_pan(engine: AudioEngine, instance_id: i32, pan: f32) {
    let instance = get_instance(engine, instance_id)
    if instance.id != -1 {
        instance.pan = clamp(pan, -1.0, 1.0)
    }
}

fn set_sound_pitch(engine: AudioEngine, instance_id: i32, pitch: f32) {
    let instance = get_instance(engine, instance_id)
    if instance.id != -1 {
        instance.pitch = clamp(pitch, 0.5, 2.0)
    }
}

fn set_sound_position(engine: AudioEngine, instance_id: i32, position: Vec3) {
    let instance = get_instance(engine, instance_id)
    if instance.id != -1 {
        instance.position = position
    }
}

fn fade_sound(engine: AudioEngine, instance_id: i32, target_volume: f32, duration: f32) {
    let instance = get_instance(engine, instance_id)
    if instance.id != -1 {
        instance.fade_start_volume = instance.volume
        instance.fade_target_volume = target_volume
        instance.fade_duration = duration
        instance.fade_elapsed = 0.0

        if target_volume > instance.volume {
            instance.state = SoundState::FADING_IN
        } else {
            instance.state = SoundState::FADING_OUT
        }
    }
}

// ============================================================================
// Music System
// ============================================================================

fn load_music_track(engine: AudioEngine, name: String, path: String) -> i32 {
    let track = create_music_track(engine.next_music_id, name, path)
    engine.next_music_id = engine.next_music_id + 1

    track.is_loaded = true
    engine.music_tracks = engine.music_tracks + [track]

    return track.id
}

fn play_music(engine: AudioEngine, track_id: i32) {
    // Crossfade from current track to new track
    if engine.current_music_id != -1 {
        // Fade out current music
        engine.music_state = SoundState::FADING_OUT
    }

    engine.current_music_id = track_id
    engine.music_state = SoundState::PLAYING
}

fn play_music_with_crossfade(engine: AudioEngine, track_id: i32, crossfade_time: f32) {
    engine.music_crossfade_time = crossfade_time
    play_music(engine, track_id)
}

fn stop_music(engine: AudioEngine) {
    engine.music_state = SoundState::STOPPED
    engine.current_music_id = -1
}

fn pause_music(engine: AudioEngine) {
    if engine.music_state == SoundState::PLAYING {
        engine.music_state = SoundState::PAUSED
    }
}

fn resume_music(engine: AudioEngine) {
    if engine.music_state == SoundState::PAUSED {
        engine.music_state = SoundState::PLAYING
    }
}

fn set_music_volume(engine: AudioEngine, volume: f32) {
    engine.volumes.music = clamp(volume, 0.0, 1.0)
}

// ============================================================================
// EVA System (Announcer Voice)
// ============================================================================

fn queue_eva_message(engine: AudioEngine, buffer_id: i32) {
    engine.eva_queue = engine.eva_queue + [buffer_id]
}

fn play_eva_immediate(engine: AudioEngine, buffer_id: i32) {
    // Stop current EVA and play this one immediately
    if engine.eva_playing {
        // Would stop current EVA sound
    }

    play_sound(engine, buffer_id, SoundType::EVA)
    engine.eva_playing = true
}

fn update_eva_queue(engine: AudioEngine) {
    if !engine.eva_playing && engine.eva_queue.length > 0 {
        let next_message = engine.eva_queue[0]
        // Remove from queue
        let new_queue: [i32] = []
        for i in 1..engine.eva_queue.length {
            new_queue = new_queue + [engine.eva_queue[i]]
        }
        engine.eva_queue = new_queue

        play_sound(engine, next_message, SoundType::EVA)
        engine.eva_playing = true
    }
}

// ============================================================================
// Listener (Camera)
// ============================================================================

fn set_listener_position(engine: AudioEngine, position: Vec3) {
    engine.listener.position = position
}

fn set_listener_orientation(engine: AudioEngine, forward: Vec3, up: Vec3) {
    engine.listener.forward = forward
    engine.listener.up = up
}

fn set_listener_velocity(engine: AudioEngine, velocity: Vec3) {
    engine.listener.velocity = velocity
}

// ============================================================================
// Volume Control
// ============================================================================

fn set_master_volume(engine: AudioEngine, volume: f32) {
    engine.volumes.master = clamp(volume, 0.0, 1.0)
}

fn set_effects_volume(engine: AudioEngine, volume: f32) {
    engine.volumes.effects = clamp(volume, 0.0, 1.0)
}

fn set_voice_volume(engine: AudioEngine, volume: f32) {
    engine.volumes.voice = clamp(volume, 0.0, 1.0)
}

fn set_ambient_volume(engine: AudioEngine, volume: f32) {
    engine.volumes.ambient = clamp(volume, 0.0, 1.0)
}

fn get_type_volume(engine: AudioEngine, sound_type: SoundType) -> f32 {
    let base_volume = engine.volumes.master

    if sound_type == SoundType::EFFECT {
        return base_volume * engine.volumes.effects
    } else if sound_type == SoundType::VOICE {
        return base_volume * engine.volumes.voice
    } else if sound_type == SoundType::AMBIENT {
        return base_volume * engine.volumes.ambient
    } else if sound_type == SoundType::MUSIC {
        return base_volume * engine.volumes.music
    } else if sound_type == SoundType::UI {
        return base_volume * engine.volumes.ui
    } else if sound_type == SoundType::EVA {
        return base_volume * engine.volumes.eva
    }

    return base_volume
}

// ============================================================================
// Update Loop
// ============================================================================

fn update_audio_engine(engine: AudioEngine, delta_time: f32) {
    if !engine.is_initialized {
        return
    }

    // Update all sound instances
    let active_instances: [SoundInstance] = []
    for instance in engine.instances {
        update_sound_instance(engine, instance, delta_time)

        if instance.state != SoundState::STOPPED {
            active_instances = active_instances + [instance]
        } else {
            // Trigger completion callback
            if instance.on_complete != null {
                instance.on_complete(instance.id)
            }
        }
    }
    engine.instances = active_instances

    // Update EVA queue
    update_eva_queue(engine)

    // Update 3D audio positioning
    for instance in engine.instances {
        if instance.is_3d {
            update_3d_sound(engine, instance)
        }
    }
}

fn update_sound_instance(engine: AudioEngine, instance: SoundInstance, delta_time: f32) {
    // Update fading
    if instance.state == SoundState::FADING_IN || instance.state == SoundState::FADING_OUT {
        instance.fade_elapsed = instance.fade_elapsed + delta_time

        if instance.fade_elapsed >= instance.fade_duration {
            instance.volume = instance.fade_target_volume
            if instance.fade_target_volume <= 0.0 {
                instance.state = SoundState::STOPPED
            } else {
                instance.state = SoundState::PLAYING
            }
        } else {
            let t = instance.fade_elapsed / instance.fade_duration
            instance.volume = lerp(instance.fade_start_volume, instance.fade_target_volume, t)
        }
    }

    // Update playback position
    if instance.state == SoundState::PLAYING {
        let buffer = get_buffer(engine, instance.buffer_id)
        instance.playback_position = instance.playback_position + delta_time * instance.pitch

        // Check for end of sound
        if instance.playback_position >= buffer.duration {
            if instance.loops_remaining != 0 {
                instance.playback_position = 0.0
                if instance.loops_remaining > 0 {
                    instance.loops_remaining = instance.loops_remaining - 1
                }
            } else {
                instance.state = SoundState::STOPPED
            }
        }
    }
}

fn update_3d_sound(engine: AudioEngine, instance: SoundInstance) {
    // Calculate distance to listener
    let dx = instance.position.x - engine.listener.position.x
    let dy = instance.position.y - engine.listener.position.y
    let dz = instance.position.z - engine.listener.position.z
    let distance = sqrt(dx * dx + dy * dy + dz * dz)

    // Calculate volume attenuation
    let attenuation = 1.0
    if distance > instance.min_distance {
        if distance >= instance.max_distance {
            attenuation = 0.0
        } else {
            let ratio = (distance - instance.min_distance) / (instance.max_distance - instance.min_distance)
            attenuation = 1.0 - ratio * instance.rolloff_factor
            attenuation = max(0.0, attenuation)
        }
    }

    // Calculate panning based on position relative to listener
    // Project position onto listener's left-right axis
    // This is simplified - full implementation would use dot products
    let pan = clamp(dx / instance.max_distance, -1.0, 1.0)

    // Apply calculated values (would send to audio backend)
    // set_backend_volume(instance.id, instance.volume * attenuation)
    // set_backend_pan(instance.id, pan)
}

// ============================================================================
// Utility Functions
// ============================================================================

fn get_instance(engine: AudioEngine, instance_id: i32) -> SoundInstance {
    for instance in engine.instances {
        if instance.id == instance_id {
            return instance
        }
    }
    return create_sound_instance(-1, -1, SoundType::EFFECT)
}

fn remove_instance(engine: AudioEngine, instance_id: i32) {
    let remaining: [SoundInstance] = []
    for instance in engine.instances {
        if instance.id != instance_id {
            remaining = remaining + [instance]
        }
    }
    engine.instances = remaining
}

struct Vec3 {
    x: f32,
    y: f32,
    z: f32,
}

fn vec3(x: f32, y: f32, z: f32) -> Vec3 {
    return Vec3 { x: x, y: y, z: z }
}

fn clamp(x: f32, min_val: f32, max_val: f32) -> f32 {
    if x < min_val { return min_val }
    if x > max_val { return max_val }
    return x
}

fn lerp(a: f32, b: f32, t: f32) -> f32 {
    return a + (b - a) * t
}

fn max(a: f32, b: f32) -> f32 {
    if a > b { return a }
    return b
}

fn sqrt(x: f32) -> f32 {
    if x <= 0.0 { return 0.0 }
    let guess = x / 2.0
    let result = guess
    for i in 0..5 {
        result = (result + x / result) / 2.0
    }
    return result
}

// ============================================================================
// Tests
// ============================================================================

fn test_audio_engine_creation() -> Bool {
    let engine = create_audio_engine()

    assert(!engine.is_initialized, "Should not be initialized")
    assert(engine.buffers.length == 0, "Should have no buffers")
    assert(engine.instances.length == 0, "Should have no instances")

    return true
}

fn test_volume_settings() -> Bool {
    let engine = create_audio_engine()
    init_audio_engine(engine)

    set_master_volume(engine, 0.5)
    assert(engine.volumes.master == 0.5, "Master should be 0.5")

    set_effects_volume(engine, 1.0)
    let effect_vol = get_type_volume(engine, SoundType::EFFECT)
    assert(effect_vol == 0.5, "Effect volume should be 0.5 (master * effects)")

    return true
}

fn test_sound_loading() -> Bool {
    let engine = create_audio_engine()
    init_audio_engine(engine)

    let buffer_id = load_wav_file(engine, "test_sound", "test.wav")
    assert(buffer_id > 0, "Should return valid buffer ID")
    assert(engine.buffers.length == 1, "Should have one buffer")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_audio_engine_creation(), "Audio engine creation test failed")
    assert(test_volume_settings(), "Volume settings test failed")
    assert(test_sound_loading(), "Sound loading test failed")
    return true
}
