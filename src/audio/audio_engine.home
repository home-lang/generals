// C&C Generals Zero Hour - Home Port
// Audio Engine (Core audio system)
//
// Original: GameAudio.cpp, WWAudio.cpp (Westwood Studios/EA)
// Ported to Home with EA's audio architecture
//
// Audio file locations (matching EA's directory structure):
// - Data/Audio/Sounds/      - Sound effects (.wav)
// - Data/Audio/Music/        - Music tracks (.mp3)
// - Data/Audio/Voice/        - Voice-overs, unit responses (.wav)
//   - Data/Audio/Voice/US/   - English
//   - Data/Audio/Voice/Chinese/ - Chinese
//   - Data/Audio/Voice/GLA/  - GLA faction
// - Data/Audio/Ambient/      - Ambient sounds

import basics/allocator
import basics/string
import engine/math

// Audio type (from EA's AudioType enum)
enum AudioType {
    Music        // Background music (.mp3 files)
    Streaming    // Streamed audio (cutscenes, voice)
    SoundEffect  // Sound effects (.wav files)
}

// Audio priority (from EA's AudioPriority enum)
enum AudioPriority {
    Lowest
    Low
    Normal
    High
    Critical
}

// Sound type flags (from EA's SoundType enum)
enum SoundType {
    UI           // UI sounds (button clicks, etc.)
    World        // 3D positioned sounds in world
    Shrouded     // Sounds in fog of war
    Global       // Global sounds (not positional)
    Voice        // Voice-overs
    Player       // Only for local player
    Allies       // Only for allies
    Enemies      // Only for enemies
    Everyone     // For all players
}

// Audio control flags (from EA's AudioControl enum)
enum AudioControl {
    Loop         // Loop the sound
    Random       // Randomly pick from sound list
    All          // Play all sounds in sequence
    PostDelay    // Delay before playing
    Interrupt    // Can interrupt other sounds
}

// Audio handle (unique ID for playing sounds)
type AudioHandle = u32
const INVALID_AUDIO_HANDLE: AudioHandle = 0

// Audio event definition (from EA's AudioEventInfo)
struct AudioEventInfo {
    audio_name: string  // Event name (e.g., "ButtonClick", "TankFire")
    filename: string    // For music tracks
    volume: f32
    volume_shift: f32   // Random volume variation
    min_volume: f32
    pitch_shift_min: f32
    pitch_shift_max: f32
    delay_min: i32      // Milliseconds
    delay_max: i32
    loop_count: i32     // 0 = infinite loop
    limit: i32          // Max simultaneous instances
    priority: AudioPriority
    sound_type: u32     // Bitmask of SoundType flags
    control: u32        // Bitmask of AudioControl flags
    audio_type: AudioType
    low_pass_freq: f32  // Low-pass filter frequency
    min_distance: f32   // Minimum 3D distance
    max_distance: f32   // Maximum 3D distance (attenuation)
}

// Audio event instance (from EA's AudioEventRTS)
struct AudioEvent {
    event_name: string
    handle: AudioHandle
    is_playing: bool
    is_paused: bool
    position: Vec3
    is_positional: bool
    object_id: u32      // If attached to game object
    volume: f32
    pitch: f32
    delay: f32
    loop_count: i32
    time_of_day: TimeOfDay
    priority: AudioPriority
}

// Time of day enum
enum TimeOfDay {
    Morning   // Dawn
    Midday    // Day
    Evening   // Dusk
    Night     // Night
}

// Audio channel (mixer channel)
struct AudioChannel {
    channel_id: u32
    volume: f32
    is_active: bool
}

// Audio engine
struct AudioEngine {
    event_count: usize
    channel_count: usize
    max_channels: usize
    master_volume: f32
    music_volume: f32
    sfx_volume: f32
    voice_volume: f32
    listener_position: Vec3
    listener_forward: Vec3
    current_time_of_day: TimeOfDay
    next_handle: AudioHandle
    allocator: Allocator
}

// Helper functions

fn random_range(min: usize, max: usize): usize {
    // TODO: Proper random number generation
    return min
}

fn random_range_f32(min: f32, max: f32): f32 {
    // TODO: Proper random number generation
    return min
}

fn clamp(value: f32, min: f32, max: f32): f32 {
    if (value < min) { return min }
    if (value > max) { return max }
    return value
}

// Global audio engine
var g_audio_engine: ?AudioEngine = null

export fn init_audio_engine(allocator: Allocator) {
    g_audio_engine = AudioEngine.init(allocator, 32)  // 32 audio channels

    // Initialize channels
    for i in 0..32 {
        g_audio_engine.?.channels[i] = AudioChannel.init(@intCast(u32, i))
        g_audio_engine.?.channel_count += 1
    }
}

export fn shutdown_audio_engine() {
    if (g_audio_engine) {
        g_audio_engine.?.deinit()
        g_audio_engine = null
    }
}

export fn update_audio(delta_time: f32) {
    if (g_audio_engine) {
        g_audio_engine.?.update(delta_time)
    }
}

export fn play_sound(event_name: string): AudioHandle {
    if (g_audio_engine) {
        return g_audio_engine.?.play_audio_event(event_name)
    }
    return INVALID_AUDIO_HANDLE
}

export fn play_sound_3d(event_name: string, position: Vec3): AudioHandle {
    if (g_audio_engine) {
        return g_audio_engine.?.play_audio_event_3d(event_name, position)
    }
    return INVALID_AUDIO_HANDLE
}

export fn stop_sound(handle: AudioHandle) {
    if (g_audio_engine) {
        g_audio_engine.?.stop_audio(handle)
    }
}

export fn audio_set_listener(position: Vec3, forward: Vec3) {
    if (g_audio_engine) {
        g_audio_engine.?.set_listener_position(position, forward)
    }
}

export fn audio_register_event(event_info: AudioEventInfo) {
    if (g_audio_engine) {
        g_audio_engine.?.register_event(event_info)
    }
}
