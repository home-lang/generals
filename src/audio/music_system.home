// C&C Generals Zero Hour - Home Port
// Music System (Dynamic soundtrack)
//
// Original: Music.ini, MusicManager.cpp (Westwood Studios/EA)
// Music by Frank Klepacki and Bill Brown
//
// Music file locations (from EA's original data files):
// All music located in: Data/Audio/Music/
//
// Main Menu Music:
// - Menu.mp3
//
// USA Faction Themes:
// - USA1.mp3 - "USA Theme" (Frank Klepacki)
// - USA2.mp3 - "Cavalry Approaching"
// - USA3.mp3 - "War Machine"
// - USA4.mp3 - "Tank Rush"
// - USA5.mp3 - "Battle"
//
// China Faction Themes:
// - China1.mp3 - "China Theme" (Frank Klepacki)
// - China2.mp3 - "Red Army"
// - China3.mp3 - "Dragon Rising"
// - China4.mp3 - "March to War"
//
// GLA Faction Themes:
// - GLA1.mp3 - "GLA Theme" (Frank Klepacki)
// - GLA2.mp3 - "Desert Combat"
// - GLA3.mp3 - "Guerrilla"
// - GLA4.mp3 - "Sandstorm"
//
// Combat Music (plays during battles):
// - Battle1.mp3
// - Battle2.mp3
// - Battle3.mp3
// - Combat.mp3
// - Conflict.mp3
//
// Victory/Defeat Music:
// - Victory.mp3
// - Defeat.mp3
//
// Credits Music:
// - Credits.mp3

import basics/allocator
import audio/audio_engine

// Music track
struct MusicTrack {
    name: string
    filename: string
    faction: string  // "USA", "China", "GLA", "Neutral"
    mood: MusicMood
    duration: f32  // Seconds

    fn init(name: string, filename: string, faction: string, mood: MusicMood): MusicTrack {
        return MusicTrack {
            name: name
            filename: filename
            faction: faction
            mood: mood
            duration: 180.0  // Default 3 minutes
        }
    }
}

// Music mood (determines when to play)
enum MusicMood {
    Menu
    Ambient      // Peaceful, exploring
    Combat       // During battle
    Victory
    Defeat
    Credits
}

// Music state
enum MusicState {
    Stopped
    Playing
    FadingOut
    FadingIn
}

// Music manager
struct MusicManager {
    // Track library
    tracks: []MusicTrack
    track_count: usize

    // Playlists per faction
    usa_tracks: []usize
    usa_track_count: usize
    china_tracks: []usize
    china_track_count: usize
    gla_tracks: []usize
    gla_track_count: usize
    neutral_tracks: []usize
    neutral_track_count: usize

    // Combat tracks
    combat_tracks: []usize
    combat_track_count: usize

    // Current state
    current_track_index: ?usize
    current_handle: AudioHandle
    current_state: MusicState

    // Settings
    current_faction: string
    current_mood: MusicMood
    music_volume: f32
    is_enabled: bool
    shuffle: bool

    // Fade
    fade_duration: f32
    fade_timer: f32

    // Next track
    next_track_index: ?usize

    allocator: Allocator

    fn init(allocator: Allocator): MusicManager {
        return MusicManager {
            tracks: allocator.alloc(MusicTrack, 64)
            track_count: 0
            usa_tracks: allocator.alloc(usize, 16)
            usa_track_count: 0
            china_tracks: allocator.alloc(usize, 16)
            china_track_count: 0
            gla_tracks: allocator.alloc(usize, 16)
            gla_track_count: 0
            neutral_tracks: allocator.alloc(usize, 16)
            neutral_track_count: 0
            combat_tracks: allocator.alloc(usize, 16)
            combat_track_count: 0
            current_track_index: null
            current_handle: INVALID_AUDIO_HANDLE
            current_state: MusicState.Stopped
            current_faction: "Neutral"
            current_mood: MusicMood.Menu
            music_volume: 0.8
            is_enabled: true
            shuffle: true
            fade_duration: 2.0
            fade_timer: 0.0
            next_track_index: null
            allocator: allocator
        }
    }

    fn register_all_tracks(mut self) {
        // Menu music
        self.register_track("Menu Theme", "Data/Audio/Music/Menu.mp3", "Neutral", MusicMood.Menu)

        // USA faction themes
        self.register_track("USA Theme", "Data/Audio/Music/USA1.mp3", "USA", MusicMood.Ambient)
        self.register_track("Cavalry Approaching", "Data/Audio/Music/USA2.mp3", "USA", MusicMood.Ambient)
        self.register_track("War Machine", "Data/Audio/Music/USA3.mp3", "USA", MusicMood.Combat)
        self.register_track("Tank Rush", "Data/Audio/Music/USA4.mp3", "USA", MusicMood.Combat)
        self.register_track("Battle", "Data/Audio/Music/USA5.mp3", "USA", MusicMood.Combat)

        // China faction themes
        self.register_track("China Theme", "Data/Audio/Music/China1.mp3", "China", MusicMood.Ambient)
        self.register_track("Red Army", "Data/Audio/Music/China2.mp3", "China", MusicMood.Ambient)
        self.register_track("Dragon Rising", "Data/Audio/Music/China3.mp3", "China", MusicMood.Combat)
        self.register_track("March to War", "Data/Audio/Music/China4.mp3", "China", MusicMood.Combat)

        // GLA faction themes
        self.register_track("GLA Theme", "Data/Audio/Music/GLA1.mp3", "GLA", MusicMood.Ambient)
        self.register_track("Desert Combat", "Data/Audio/Music/GLA2.mp3", "GLA", MusicMood.Combat)
        self.register_track("Guerrilla", "Data/Audio/Music/GLA3.mp3", "GLA", MusicMood.Combat)
        self.register_track("Sandstorm", "Data/Audio/Music/GLA4.mp3", "GLA", MusicMood.Ambient)

        // Combat music (neutral, works for any faction)
        self.register_track("Battle Theme 1", "Data/Audio/Music/Battle1.mp3", "Neutral", MusicMood.Combat)
        self.register_track("Battle Theme 2", "Data/Audio/Music/Battle2.mp3", "Neutral", MusicMood.Combat)
        self.register_track("Battle Theme 3", "Data/Audio/Music/Battle3.mp3", "Neutral", MusicMood.Combat)
        self.register_track("Combat", "Data/Audio/Music/Combat.mp3", "Neutral", MusicMood.Combat)
        self.register_track("Conflict", "Data/Audio/Music/Conflict.mp3", "Neutral", MusicMood.Combat)

        // Victory/defeat
        self.register_track("Victory", "Data/Audio/Music/Victory.mp3", "Neutral", MusicMood.Victory)
        self.register_track("Defeat", "Data/Audio/Music/Defeat.mp3", "Neutral", MusicMood.Defeat)

        // Credits
        self.register_track("Credits", "Data/Audio/Music/Credits.mp3", "Neutral", MusicMood.Credits)
    }

    fn register_track(mut self, name: string, filename: string, faction: string, mood: MusicMood) {
        if self.track_count >= self.tracks.len {
            return
        }

        let track = MusicTrack.init(name, filename, faction, mood)
        let track_index = self.track_count
        self.tracks[track_index] = track
        self.track_count += 1

        // Add to appropriate playlist
        if faction == "USA" {
            if self.usa_track_count < self.usa_tracks.len {
                self.usa_tracks[self.usa_track_count] = track_index
                self.usa_track_count += 1
            }
        } else if faction == "China" {
            if self.china_track_count < self.china_tracks.len {
                self.china_tracks[self.china_track_count] = track_index
                self.china_track_count += 1
            }
        } else if faction == "GLA" {
            if self.gla_track_count < self.gla_tracks.len {
                self.gla_tracks[self.gla_track_count] = track_index
                self.gla_track_count += 1
            }
        } else {
            if self.neutral_track_count < self.neutral_tracks.len {
                self.neutral_tracks[self.neutral_track_count] = track_index
                self.neutral_track_count += 1
            }
        }

        // Add to combat playlist if combat mood
        if mood == MusicMood.Combat {
            if self.combat_track_count < self.combat_tracks.len {
                self.combat_tracks[self.combat_track_count] = track_index
                self.combat_track_count += 1
            }
        }
    }

    fn set_faction(mut self, faction: string) {
        self.current_faction = faction
    }

    fn set_mood(mut self, mood: MusicMood) {
        if self.current_mood == mood {
            return
        }

        self.current_mood = mood

        // Transition to appropriate music
        self.play_next_track()
    }

    fn play_menu_music(mut self) {
        self.current_mood = MusicMood.Menu
        self.play_track_by_name("Menu Theme")
    }

    fn play_combat_music(mut self) {
        if self.current_mood == MusicMood.Combat {
            return  // Already playing combat music
        }

        self.current_mood = MusicMood.Combat
        self.fade_out()
        self.next_track_index = self.select_random_combat_track()
    }

    fn play_ambient_music(mut self) {
        if self.current_mood == MusicMood.Ambient {
            return
        }

        self.current_mood = MusicMood.Ambient
        self.fade_out()
        self.next_track_index = self.select_random_ambient_track()
    }

    fn play_victory_music(mut self) {
        self.current_mood = MusicMood.Victory
        self.play_track_by_name("Victory")
    }

    fn play_defeat_music(mut self) {
        self.current_mood = MusicMood.Defeat
        self.play_track_by_name("Defeat")
    }

    fn play_track_by_name(mut self, name: string) {
        for i in 0..self.track_count {
            if self.tracks[i].name == name {
                self.play_track(i)
                return
            }
        }
    }

    fn play_track(mut self, track_index: usize) {
        if track_index >= self.track_count {
            return
        }

        // Stop current track
        if self.current_handle != INVALID_AUDIO_HANDLE {
            stop_sound(self.current_handle)
        }

        let track = &self.tracks[track_index]

        // Register as audio event
        let mut music_event = AudioEventInfo.init(track.name)
        music_event.filename = track.filename
        music_event.volume = self.music_volume
        music_event.audio_type = AudioType.Music
        music_event.priority = AudioPriority.Low
        music_event.sound_type = @enumToInt(SoundType.Global)
        music_event.control = @enumToInt(AudioControl.Loop)
        music_event.loop_count = 1  // Play once
        audio_register_event(music_event)

        // Play the track
        self.current_handle = play_sound(track.name)
        self.current_track_index = track_index
        self.current_state = MusicState.Playing
    }

    fn play_next_track(mut self) {
        if !self.is_enabled {
            return
        }

        // Select next track based on current mood
        let next_index = match self.current_mood {
            MusicMood.Combat => self.select_random_combat_track()
            MusicMood.Ambient => self.select_random_ambient_track()
            MusicMood.Menu => self.find_track_by_name("Menu Theme")
            MusicMood.Victory => self.find_track_by_name("Victory")
            MusicMood.Defeat => self.find_track_by_name("Defeat")
            MusicMood.Credits => self.find_track_by_name("Credits")
        }

        if next_index {
            self.play_track(next_index.?)
        }
    }

    fn select_random_combat_track(&self): ?usize {
        if self.combat_track_count == 0 {
            return null
        }

        // Random combat track
        let random_index = random_range(0, self.combat_track_count)
        return self.combat_tracks[random_index]
    }

    fn select_random_ambient_track(&self): ?usize {
        // Select from faction-specific tracks
        let playlist: []usize = []
        let playlist_count: usize = 0

        if self.current_faction == "USA" {
            playlist = self.usa_tracks
            playlist_count = self.usa_track_count
        } else if self.current_faction == "China" {
            playlist = self.china_tracks
            playlist_count = self.china_track_count
        } else if self.current_faction == "GLA" {
            playlist = self.gla_tracks
            playlist_count = self.gla_track_count
        } else {
            playlist = self.neutral_tracks
            playlist_count = self.neutral_track_count
        }

        if playlist_count == 0 {
            return null
        }

        // Filter for ambient mood only
        // For now, just return random from faction playlist
        let random_index = random_range(0, playlist_count)
        return playlist[random_index]
    }

    fn find_track_by_name(&self, name: string): ?usize {
        for i in 0..self.track_count {
            if self.tracks[i].name == name {
                return i
            }
        }
        return null
    }

    fn update(mut self, delta_time: f32) {
        if !self.is_enabled {
            return
        }

        // Handle fading
        if self.current_state == MusicState.FadingOut {
            self.fade_timer += delta_time

            if self.fade_timer >= self.fade_duration {
                // Fade complete, stop current track
                if self.current_handle != INVALID_AUDIO_HANDLE {
                    stop_sound(self.current_handle)
                    self.current_handle = INVALID_AUDIO_HANDLE
                }

                // Play next track if queued
                if self.next_track_index {
                    self.play_track(self.next_track_index.?)
                    self.next_track_index = null
                }

                self.current_state = MusicState.Stopped
                self.fade_timer = 0.0
            } else {
                // Update fade volume
                let fade_progress = self.fade_timer / self.fade_duration
                let volume = self.music_volume * (1.0 - fade_progress)
                // TODO: Set volume on current track
            }
        }

        // Check if current track finished
        // TODO: Query if track is still playing
        // If finished, play next track
    }

    fn fade_out(mut self) {
        self.current_state = MusicState.FadingOut
        self.fade_timer = 0.0
    }

    fn stop(mut self) {
        if self.current_handle != INVALID_AUDIO_HANDLE {
            stop_sound(self.current_handle)
            self.current_handle = INVALID_AUDIO_HANDLE
        }

        self.current_state = MusicState.Stopped
        self.current_track_index = null
    }

    fn set_enabled(mut self, enabled: bool) {
        self.is_enabled = enabled

        if !enabled {
            self.stop()
        }
    }

    fn set_volume(mut self, volume: f32) {
        self.music_volume = clamp(volume, 0.0, 1.0)
        // TODO: Update current track volume
    }

    fn deinit(mut self) {
        self.stop()
        self.allocator.free(self.tracks)
        self.allocator.free(self.usa_tracks)
        self.allocator.free(self.china_tracks)
        self.allocator.free(self.gla_tracks)
        self.allocator.free(self.neutral_tracks)
        self.allocator.free(self.combat_tracks)
    }
}

// Helper functions

fn random_range(min: usize, max: usize): usize {
    // TODO: Proper random
    return min
}

fn clamp(value: f32, min: f32, max: f32): f32 {
    if value < min { return min }
    if value > max { return max }
    return value
}

// Global music manager
var g_music_manager: ?MusicManager = null

export fn init_music_system(allocator: Allocator) {
    g_music_manager = MusicManager.init(allocator)
    g_music_manager.?.register_all_tracks()
}

export fn shutdown_music_system() {
    if g_music_manager {
        g_music_manager.?.deinit()
        g_music_manager = null
    }
}

export fn update_music(delta_time: f32) {
    if g_music_manager {
        g_music_manager.?.update(delta_time)
    }
}

export fn music_set_faction(faction: string) {
    if g_music_manager {
        g_music_manager.?.set_faction(faction)
    }
}

export fn music_play_menu() {
    if g_music_manager {
        g_music_manager.?.play_menu_music()
    }
}

export fn music_play_combat() {
    if g_music_manager {
        g_music_manager.?.play_combat_music()
    }
}

export fn music_play_ambient() {
    if g_music_manager {
        g_music_manager.?.play_ambient_music()
    }
}

export fn music_play_victory() {
    if g_music_manager {
        g_music_manager.?.play_victory_music()
    }
}

export fn music_play_defeat() {
    if g_music_manager {
        g_music_manager.?.play_defeat_music()
    }
}

export fn music_set_enabled(enabled: bool) {
    if g_music_manager {
        g_music_manager.?.set_enabled(enabled)
    }
}

export fn music_set_volume(volume: f32) {
    if g_music_manager {
        g_music_manager.?.set_volume(volume)
    }
}
