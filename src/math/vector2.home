// Vector2 - 2D Vector Math
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/w3d/math/vector2.h

// Math functions (sqrt, sin, cos, etc.) are built-in

/// 2D Vector with float precision
struct Vec2 {
    x: f32,
    y: f32,

    /// Create vector from components
    fn init(x: f32, y: f32) -> Vec2 {
        return Vec2 { x: x, y: y }
    }

    /// Create zero vector
    fn zero() -> Vec2 {
        return Vec2 { x: 0.0, y: 0.0 }
    }

    /// Create unit vector (1, 1)
    fn one() -> Vec2 {
        return Vec2 { x: 1.0, y: 1.0 }
    }

    /// Set vector components
    fn set(self: &mut Vec2, x: f32, y: f32) {
        self.x = x
        self.y = y
    }

    /// Get squared length (avoids sqrt for performance)
    fn length_squared(self: &Vec2) -> f32 {
        return self.x * self.x + self.y * self.y
    }

    /// Get length of vector
    fn length(self: &Vec2) -> f32 {
        return math.sqrt(self.length_squared())
    }

    /// Normalize vector in-place
    fn normalize(self: &mut Vec2) {
        let len_sq = self.length_squared()
        if len_sq != 0.0 {
            let inv_len = 1.0 / math.sqrt(len_sq)
            self.x *= inv_len
            self.y *= inv_len
        }
    }

    /// Get normalized copy without modifying original
    fn normalized(self: &Vec2) -> Vec2 {
        let len_sq = self.length_squared()
        if len_sq != 0.0 {
            let inv_len = 1.0 / math.sqrt(len_sq)
            return Vec2 { x: self.x * inv_len, y: self.y * inv_len }
        }
        return Vec2 { x: 0.0, y: 0.0 }
    }

    /// Dot product
    fn dot(self: &Vec2, other: &Vec2) -> f32 {
        return self.x * other.x + self.y * other.y
    }

    /// Perpendicular dot product (2D cross product Z component)
    fn perp_dot(self: &Vec2, other: &Vec2) -> f32 {
        return self.x * -other.y + self.y * other.x
    }

    /// Rotate vector by angle (radians)
    fn rotate(self: &mut Vec2, angle: f32) {
        let s = math.sin(angle)
        let c = math.cos(angle)
        self.rotate_sc(s, c)
    }

    /// Rotate vector by pre-computed sin/cos
    fn rotate_sc(self: &mut Vec2, s: f32, c: f32) {
        let new_x = self.x * c + self.y * -s
        let new_y = self.x * s + self.y * c
        self.x = new_x
        self.y = new_y
    }

    /// Scale by components
    fn scale(self: &mut Vec2, sx: f32, sy: f32) {
        self.x *= sx
        self.y *= sy
    }

    /// Scale by another vector
    fn scale_vec(self: &mut Vec2, other: &Vec2) {
        self.x *= other.x
        self.y *= other.y
    }

    /// Update to minimum of self and other
    fn update_min(self: &mut Vec2, other: &Vec2) {
        if other.x < self.x {
            self.x = other.x
        }
        if other.y < self.y {
            self.y = other.y
        }
    }

    /// Update to maximum of self and other
    fn update_max(self: &mut Vec2, other: &Vec2) {
        if other.x > self.x {
            self.x = other.x
        }
        if other.y > self.y {
            self.y = other.y
        }
    }

    /// Linear interpolation
    fn lerp(a: &Vec2, b: &Vec2, t: f32) -> Vec2 {
        return Vec2 {
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t
        }
    }

    /// Distance between two vectors
    fn distance(a: &Vec2, b: &Vec2) -> f32 {
        let dx = a.x - b.x
        let dy = a.y - b.y
        return math.sqrt(dx * dx + dy * dy)
    }

    /// Quick approximation of distance (faster but less accurate)
    fn quick_distance(a: &Vec2, b: &Vec2) -> f32 {
        let x_diff = math.abs(a.x - b.x)
        let y_diff = math.abs(a.y - b.y)

        if x_diff > y_diff {
            return (y_diff / 2.0) + x_diff
        } else {
            return (x_diff / 2.0) + y_diff
        }
    }

    /// Check if vector is valid (no NaN/Inf)
    fn is_valid(self: &Vec2) -> bool {
        return math.is_finite(self.x) && math.is_finite(self.y)
    }

    /// Operator: vector + vector
    fn add(self: &Vec2, other: &Vec2) -> Vec2 {
        return Vec2 { x: self.x + other.x, y: self.y + other.y }
    }

    /// Operator: vector - vector
    fn sub(self: &Vec2, other: &Vec2) -> Vec2 {
        return Vec2 { x: self.x - other.x, y: self.y - other.y }
    }

    /// Operator: vector * scalar
    fn mul_scalar(self: &Vec2, k: f32) -> Vec2 {
        return Vec2 { x: self.x * k, y: self.y * k }
    }

    /// Operator: vector / scalar
    fn div_scalar(self: &Vec2, k: f32) -> Vec2 {
        let inv_k = 1.0 / k
        return Vec2 { x: self.x * inv_k, y: self.y * inv_k }
    }

    /// Operator: -vector (negation)
    fn negate(self: &Vec2) -> Vec2 {
        return Vec2 { x: -self.x, y: -self.y }
    }

    /// Check equality
    fn equals(self: &Vec2, other: &Vec2) -> bool {
        return self.x == other.x && self.y == other.y
    }

    /// Check equality within epsilon
    fn equals_epsilon(self: &Vec2, other: &Vec2, epsilon: f32) -> bool {
        return math.abs(self.x - other.x) < epsilon &&
               math.abs(self.y - other.y) < epsilon
    }
}
