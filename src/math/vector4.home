// Vector4 - 4D Vector Math
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/w3d/math/vector4.h

// Math functions (sqrt, sin, cos, etc.) are built-in
import math/vector3::{Vec3}

/// 4D Vector with float precision
struct Vec4 {
    x: f32,
    y: f32,
    z: f32,
    w: f32,

    /// Create vector from components
    fn init(x: f32, y: f32, z: f32, w: f32): Vec4 {
        return Vec4 { x: x, y: y, z: z, w: w }
    }

    /// Create zero vector
    fn zero(): Vec4 {
        return Vec4 { x: 0.0, y: 0.0, z: 0.0, w: 0.0 }
    }

    /// Create from Vec3 with w component
    fn from_vec3(v: &Vec3, w: f32): Vec4 {
        return Vec4 { x: v.x, y: v.y, z: v.z, w: w }
    }

    /// Set vector components
    fn set(self: &mut Vec4, x: f32, y: f32, z: f32, w: f32) {
        self.x = x
        self.y = y
        self.z = z
        self.w = w
    }

    /// Get squared length (avoids sqrt for performance)
    fn length_squared(self: &Vec4): f32 {
        return self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w
    }

    /// Get length of vector
    fn length(self: &Vec4): f32 {
        return math.sqrt(self.length_squared())
    }

    /// Normalize vector in-place
    fn normalize(self: &mut Vec4) {
        let len_sq = self.length_squared()
        if len_sq != 0.0 {
            let inv_len = 1.0 / math.sqrt(len_sq)
            self.x *= inv_len
            self.y *= inv_len
            self.z *= inv_len
            self.w *= inv_len
        }
    }

    /// Get normalized copy without modifying original
    fn normalized(self: &Vec4): Vec4 {
        let len_sq = self.length_squared()
        if len_sq != 0.0 {
            let inv_len = 1.0 / math.sqrt(len_sq)
            return Vec4 {
                x: self.x * inv_len,
                y: self.y * inv_len,
                z: self.z * inv_len,
                w: self.w * inv_len
            }
        }
        return Vec4.zero()
    }

    /// Dot product
    fn dot(self: &Vec4, other: &Vec4): f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w
    }

    /// Linear interpolation
    fn lerp(a: &Vec4, b: &Vec4, t: f32): Vec4 {
        return Vec4 {
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t,
            z: a.z + (b.z - a.z) * t,
            w: a.w + (b.w - a.w) * t
        }
    }

    /// Check if vector is valid (no NaN/Inf)
    fn is_valid(self: &Vec4): bool {
        return math.is_finite(self.x) &&
               math.is_finite(self.y) &&
               math.is_finite(self.z) &&
               math.is_finite(self.w)
    }

    /// Convert to Vec3 (drop w component)
    fn to_vec3(self: &Vec4): Vec3 {
        return Vec3 { x: self.x, y: self.y, z: self.z }
    }

    /// Operator: vector + vector
    fn add(self: &Vec4, other: &Vec4): Vec4 {
        return Vec4 {
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
            w: self.w + other.w
        }
    }

    /// Operator: vector - vector
    fn sub(self: &Vec4, other: &Vec4): Vec4 {
        return Vec4 {
            x: self.x - other.x,
            y: self.y - other.y,
            z: self.z - other.z,
            w: self.w - other.w
        }
    }

    /// Operator: vector * scalar
    fn mul_scalar(self: &Vec4, k: f32): Vec4 {
        return Vec4 {
            x: self.x * k,
            y: self.y * k,
            z: self.z * k,
            w: self.w * k
        }
    }

    /// Operator: vector / scalar
    fn div_scalar(self: &Vec4, k: f32): Vec4 {
        let inv_k = 1.0 / k
        return Vec4 {
            x: self.x * inv_k,
            y: self.y * inv_k,
            z: self.z * inv_k,
            w: self.w * inv_k
        }
    }

    /// Operator: -vector (negation)
    fn negate(self: &Vec4): Vec4 {
        return Vec4 { x: -self.x, y: -self.y, z: -self.z, w: -self.w }
    }

    /// Check equality
    fn equals(self: &Vec4, other: &Vec4): bool {
        return self.x == other.x &&
               self.y == other.y &&
               self.z == other.z &&
               self.w == other.w
    }

    /// Check equality within epsilon
    fn equals_epsilon(self: &Vec4, other: &Vec4, epsilon: f32): bool {
        return math.abs(self.x - other.x) < epsilon &&
               math.abs(self.y - other.y) < epsilon &&
               math.abs(self.z - other.z) < epsilon &&
               math.abs(self.w - other.w) < epsilon
    }
}
