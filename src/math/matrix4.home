// Matrix4 - 4x4 Matrix Math
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/w3d/math/matrix4.h

// Math functions (sqrt, sin, cos, etc.) are built-in
import math/vector3::{Vec3}
import math/vector4::{Vec4}

/// 4x4 Matrix stored as row-major (4 Vec4 rows)
struct Mat4 {
    rows: [Vec4; 4],

    /// Create identity matrix
    fn identity(): Mat4 {
        return Mat4 {
            rows: [
                Vec4 { x: 1.0, y: 0.0, z: 0.0, w: 0.0 },
                Vec4 { x: 0.0, y: 1.0, z: 0.0, w: 0.0 },
                Vec4 { x: 0.0, y: 0.0, z: 1.0, w: 0.0 },
                Vec4 { x: 0.0, y: 0.0, z: 0.0, w: 1.0 }
            ]
        }
    }

    /// Create zero matrix
    fn zero(): Mat4 {
        return Mat4 {
            rows: [
                Vec4.zero(),
                Vec4.zero(),
                Vec4.zero(),
                Vec4.zero()
            ]
        }
    }

    /// Create from row vectors
    fn from_rows(r0: &Vec4, r1: &Vec4, r2: &Vec4, r3: &Vec4): Mat4 {
        return Mat4 {
            rows: [*r0, *r1, *r2, *r3]
        }
    }

    /// Create from 16 floats (row-major order)
    fn from_floats(
        f00: f32, f01: f32, f02: f32, f03: f32,
        f10: f32, f11: f32, f12: f32, f13: f32,
        f20: f32, f21: f32, f22: f32, f23: f32,
        f30: f32, f31: f32, f32, f33: f32
    ): Mat4 {
        return Mat4 {
            rows: [
                Vec4 { x: f00, y: f01, z: f02, w: f03 },
                Vec4 { x: f10, y: f11, z: f12, w: f13 },
                Vec4 { x: f20, y: f21, z: f22, w: f23 },
                Vec4 { x: f30, y: f31, z: f32, w: f33 }
            ]
        }
    }

    /// Create orthographic projection matrix
    fn ortho(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32): Mat4 {
        let mut m = Mat4.identity()

        m.rows[0].x = 2.0 / (right - left)
        m.rows[0].w = -(right + left) / (right - left)

        m.rows[1].y = 2.0 / (top - bottom)
        m.rows[1].w = -(top + bottom) / (top - bottom)

        m.rows[2].z = -2.0 / (far - near)
        m.rows[2].w = -(far + near) / (far - near)

        return m
    }

    /// Create perspective projection matrix from FOV
    fn perspective_fov(h_fov: f32, v_fov: f32, near: f32, far: f32): Mat4 {
        let mut m = Mat4.identity()

        m.rows[0].x = 1.0 / math.tan(h_fov * 0.5)
        m.rows[1].y = 1.0 / math.tan(v_fov * 0.5)
        m.rows[2].z = -(far + near) / (far - near)
        m.rows[2].w = -(2.0 * far * near) / (far - near)
        m.rows[3].z = -1.0
        m.rows[3].w = 0.0

        return m
    }

    /// Create perspective projection matrix from frustum
    fn perspective(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32): Mat4 {
        let mut m = Mat4.identity()

        m.rows[0].x = (2.0 * near) / (right - left)
        m.rows[0].z = (right + left) / (right - left)

        m.rows[1].y = (2.0 * near) / (top - bottom)
        m.rows[1].z = (top + bottom) / (top - bottom)

        m.rows[2].z = -(far + near) / (far - near)
        m.rows[2].w = -(2.0 * far * near) / (far - near)

        m.rows[3].z = -1.0
        m.rows[3].w = 0.0

        return m
    }

    /// Get/set element at [row][col]
    fn get(self: &Mat4, row: usize, col: usize): f32 {
        match col {
            0 => return self.rows[row].x,
            1 => return self.rows[row].y,
            2 => return self.rows[row].z,
            3 => return self.rows[row].w,
            _ => return 0.0
        }
    }

    fn set(self: &mut Mat4, row: usize, col: usize, value: f32) {
        match col {
            0 => self.rows[row].x = value,
            1 => self.rows[row].y = value,
            2 => self.rows[row].z = value,
            3 => self.rows[row].w = value,
            _ => {}
        }
    }

    /// Transpose matrix
    fn transpose(self: &Mat4): Mat4 {
        return Mat4.from_rows(
            &Vec4 { x: self.rows[0].x, y: self.rows[1].x, z: self.rows[2].x, w: self.rows[3].x },
            &Vec4 { x: self.rows[0].y, y: self.rows[1].y, z: self.rows[2].y, w: self.rows[3].y },
            &Vec4 { x: self.rows[0].z, y: self.rows[1].z, z: self.rows[2].z, w: self.rows[3].z },
            &Vec4 { x: self.rows[0].w, y: self.rows[1].w, z: self.rows[2].w, w: self.rows[3].w }
        )
    }

    /// Calculate determinant
    fn determinant(self: &Mat4): f32 {
        let r = &self.rows
        let mut det = 0.0

        det  = (r[0].x * r[1].y - r[0].y * r[1].x) * (r[2].z * r[3].w - r[2].w * r[3].z)
        det -= (r[0].x * r[1].z - r[0].z * r[1].x) * (r[2].y * r[3].w - r[2].w * r[3].y)
        det += (r[0].x * r[1].w - r[0].w * r[1].x) * (r[2].y * r[3].z - r[2].z * r[3].y)
        det += (r[0].y * r[1].z - r[0].z * r[1].y) * (r[2].x * r[3].w - r[2].w * r[3].x)
        det -= (r[0].y * r[1].w - r[0].w * r[1].y) * (r[2].x * r[3].z - r[2].z * r[3].x)
        det += (r[0].z * r[1].w - r[0].w * r[1].z) * (r[2].x * r[3].y - r[2].y * r[3].x)

        return det
    }

    /// Calculate inverse matrix
    fn inverse(self: &Mat4): Mat4 {
        let s = self.determinant()
        if s == 0.0 {
            return Mat4.zero()
        }

        let s_inv = 1.0 / s
        let r = &self.rows
        let mut t = Mat4.zero()

        // Row 0
        t.rows[0].x = s_inv * (
            r[1].y * (r[2].z * r[3].w - r[2].w * r[3].z) +
            r[1].z * (r[2].w * r[3].y - r[2].y * r[3].w) +
            r[1].w * (r[2].y * r[3].z - r[2].z * r[3].y)
        )
        t.rows[0].y = s_inv * (
            r[2].y * (r[0].z * r[3].w - r[0].w * r[3].z) +
            r[2].z * (r[0].w * r[3].y - r[0].y * r[3].w) +
            r[2].w * (r[0].y * r[3].z - r[0].z * r[3].y)
        )
        t.rows[0].z = s_inv * (
            r[3].y * (r[0].z * r[1].w - r[0].w * r[1].z) +
            r[3].z * (r[0].w * r[1].y - r[0].y * r[1].w) +
            r[3].w * (r[0].y * r[1].z - r[0].z * r[1].y)
        )
        t.rows[0].w = s_inv * (
            r[0].y * (r[1].w * r[2].z - r[1].z * r[2].w) +
            r[0].z * (r[1].y * r[2].w - r[1].w * r[2].y) +
            r[0].w * (r[1].z * r[2].y - r[1].y * r[2].z)
        )

        // Row 1
        t.rows[1].x = s_inv * (
            r[1].z * (r[2].x * r[3].w - r[2].w * r[3].x) +
            r[1].w * (r[2].z * r[3].x - r[2].x * r[3].z) +
            r[1].x * (r[2].w * r[3].z - r[2].z * r[3].w)
        )
        t.rows[1].y = s_inv * (
            r[2].z * (r[0].x * r[3].w - r[0].w * r[3].x) +
            r[2].w * (r[0].z * r[3].x - r[0].x * r[3].z) +
            r[2].x * (r[0].w * r[3].z - r[0].z * r[3].w)
        )
        t.rows[1].z = s_inv * (
            r[3].z * (r[0].x * r[1].w - r[0].w * r[1].x) +
            r[3].w * (r[0].z * r[1].x - r[0].x * r[1].z) +
            r[3].x * (r[0].w * r[1].z - r[0].z * r[1].w)
        )
        t.rows[1].w = s_inv * (
            r[0].z * (r[1].w * r[2].x - r[1].x * r[2].w) +
            r[0].w * (r[1].x * r[2].z - r[1].z * r[2].x) +
            r[0].x * (r[1].z * r[2].w - r[1].w * r[2].z)
        )

        // Row 2
        t.rows[2].x = s_inv * (
            r[1].w * (r[2].x * r[3].y - r[2].y * r[3].x) +
            r[1].x * (r[2].y * r[3].w - r[2].w * r[3].y) +
            r[1].y * (r[2].w * r[3].x - r[2].x * r[3].w)
        )
        t.rows[2].y = s_inv * (
            r[2].w * (r[0].x * r[3].y - r[0].y * r[3].x) +
            r[2].x * (r[0].y * r[3].w - r[0].w * r[3].y) +
            r[2].y * (r[0].w * r[3].x - r[0].x * r[3].w)
        )
        t.rows[2].z = s_inv * (
            r[3].w * (r[0].x * r[1].y - r[0].y * r[1].x) +
            r[3].x * (r[0].y * r[1].w - r[0].w * r[1].y) +
            r[3].y * (r[0].w * r[1].x - r[0].x * r[1].w)
        )
        t.rows[2].w = s_inv * (
            r[0].w * (r[1].y * r[2].x - r[1].x * r[2].y) +
            r[0].x * (r[1].w * r[2].y - r[1].y * r[2].w) +
            r[0].y * (r[1].x * r[2].w - r[1].w * r[2].x)
        )

        // Row 3
        t.rows[3].x = s_inv * (
            r[1].x * (r[2].z * r[3].y - r[2].y * r[3].z) +
            r[1].y * (r[2].x * r[3].z - r[2].z * r[3].x) +
            r[1].z * (r[2].y * r[3].x - r[2].x * r[3].y)
        )
        t.rows[3].y = s_inv * (
            r[2].x * (r[0].z * r[3].y - r[0].y * r[3].z) +
            r[2].y * (r[0].x * r[3].z - r[0].z * r[3].x) +
            r[2].z * (r[0].y * r[3].x - r[0].x * r[3].y)
        )
        t.rows[3].z = s_inv * (
            r[3].x * (r[0].z * r[1].y - r[0].y * r[1].z) +
            r[3].y * (r[0].x * r[1].z - r[0].z * r[1].x) +
            r[3].z * (r[0].y * r[1].x - r[0].x * r[1].y)
        )
        t.rows[3].w = s_inv * (
            r[0].x * (r[1].y * r[2].z - r[1].z * r[2].y) +
            r[0].y * (r[1].z * r[2].x - r[1].x * r[2].z) +
            r[0].z * (r[1].x * r[2].y - r[1].y * r[2].x)
        )

        return t
    }

    /// Transform a Vec3 (treat as position with w=1)
    fn transform_point(self: &Mat4, v: &Vec3): Vec3 {
        return Vec3 {
            x: self.rows[0].x * v.x + self.rows[0].y * v.y + self.rows[0].z * v.z + self.rows[0].w,
            y: self.rows[1].x * v.x + self.rows[1].y * v.y + self.rows[1].z * v.z + self.rows[1].w,
            z: self.rows[2].x * v.x + self.rows[2].y * v.y + self.rows[2].z * v.z + self.rows[2].w
        }
    }

    /// Transform a Vec3 as direction (w=0, ignore translation)
    fn transform_direction(self: &Mat4, v: &Vec3): Vec3 {
        return Vec3 {
            x: self.rows[0].x * v.x + self.rows[0].y * v.y + self.rows[0].z * v.z,
            y: self.rows[1].x * v.x + self.rows[1].y * v.y + self.rows[1].z * v.z,
            z: self.rows[2].x * v.x + self.rows[2].y * v.y + self.rows[2].z * v.z
        }
    }

    /// Transform a Vec4
    fn transform_vec4(self: &Mat4, v: &Vec4): Vec4 {
        return Vec4 {
            x: self.rows[0].x * v.x + self.rows[0].y * v.y + self.rows[0].z * v.z + self.rows[0].w * v.w,
            y: self.rows[1].x * v.x + self.rows[1].y * v.y + self.rows[1].z * v.z + self.rows[1].w * v.w,
            z: self.rows[2].x * v.x + self.rows[2].y * v.y + self.rows[2].z * v.z + self.rows[2].w * v.w,
            w: self.rows[3].x * v.x + self.rows[3].y * v.y + self.rows[3].z * v.z + self.rows[3].w * v.w
        }
    }

    /// Matrix multiplication
    fn mul(self: &Mat4, other: &Mat4): Mat4 {
        let a = &self.rows
        let b = &other.rows
        let mut result = Mat4.zero()

        // Row 0
        result.rows[0].x = a[0].x * b[0].x + a[0].y * b[1].x + a[0].z * b[2].x + a[0].w * b[3].x
        result.rows[0].y = a[0].x * b[0].y + a[0].y * b[1].y + a[0].z * b[2].y + a[0].w * b[3].y
        result.rows[0].z = a[0].x * b[0].z + a[0].y * b[1].z + a[0].z * b[2].z + a[0].w * b[3].z
        result.rows[0].w = a[0].x * b[0].w + a[0].y * b[1].w + a[0].z * b[2].w + a[0].w * b[3].w

        // Row 1
        result.rows[1].x = a[1].x * b[0].x + a[1].y * b[1].x + a[1].z * b[2].x + a[1].w * b[3].x
        result.rows[1].y = a[1].x * b[0].y + a[1].y * b[1].y + a[1].z * b[2].y + a[1].w * b[3].y
        result.rows[1].z = a[1].x * b[0].z + a[1].y * b[1].z + a[1].z * b[2].z + a[1].w * b[3].z
        result.rows[1].w = a[1].x * b[0].w + a[1].y * b[1].w + a[1].z * b[2].w + a[1].w * b[3].w

        // Row 2
        result.rows[2].x = a[2].x * b[0].x + a[2].y * b[1].x + a[2].z * b[2].x + a[2].w * b[3].x
        result.rows[2].y = a[2].x * b[0].y + a[2].y * b[1].y + a[2].z * b[2].y + a[2].w * b[3].y
        result.rows[2].z = a[2].x * b[0].z + a[2].y * b[1].z + a[2].z * b[2].z + a[2].w * b[3].z
        result.rows[2].w = a[2].x * b[0].w + a[2].y * b[1].w + a[2].z * b[2].w + a[2].w * b[3].w

        // Row 3
        result.rows[3].x = a[3].x * b[0].x + a[3].y * b[1].x + a[3].z * b[2].x + a[3].w * b[3].x
        result.rows[3].y = a[3].x * b[0].y + a[3].y * b[1].y + a[3].z * b[2].y + a[3].w * b[3].y
        result.rows[3].z = a[3].x * b[0].z + a[3].y * b[1].z + a[3].z * b[2].z + a[3].w * b[3].z
        result.rows[3].w = a[3].x * b[0].w + a[3].y * b[1].w + a[3].z * b[2].w + a[3].w * b[3].w

        return result
    }

    /// Matrix addition
    fn add(self: &Mat4, other: &Mat4): Mat4 {
        return Mat4.from_rows(
            &self.rows[0].add(&other.rows[0]),
            &self.rows[1].add(&other.rows[1]),
            &self.rows[2].add(&other.rows[2]),
            &self.rows[3].add(&other.rows[3])
        )
    }

    /// Matrix subtraction
    fn sub(self: &Mat4, other: &Mat4): Mat4 {
        return Mat4.from_rows(
            &self.rows[0].sub(&other.rows[0]),
            &self.rows[1].sub(&other.rows[1]),
            &self.rows[2].sub(&other.rows[2]),
            &self.rows[3].sub(&other.rows[3])
        )
    }

    /// Scalar multiplication
    fn mul_scalar(self: &Mat4, s: f32): Mat4 {
        return Mat4.from_rows(
            &self.rows[0].mul_scalar(s),
            &self.rows[1].mul_scalar(s),
            &self.rows[2].mul_scalar(s),
            &self.rows[3].mul_scalar(s)
        )
    }

    /// Scalar division
    fn div_scalar(self: &Mat4, s: f32): Mat4 {
        let inv = 1.0 / s
        return self.mul_scalar(inv)
    }

    /// Check equality
    fn equals(self: &Mat4, other: &Mat4): bool {
        return self.rows[0].equals(&other.rows[0]) &&
               self.rows[1].equals(&other.rows[1]) &&
               self.rows[2].equals(&other.rows[2]) &&
               self.rows[3].equals(&other.rows[3])
    }
}
