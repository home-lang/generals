// Quaternion - Rotation representation
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/w3d/math/quat.h

// Math functions (sqrt, sin, cos, etc.) are built-in
import math/vector3::{Vec3}

/// Quaternion for representing rotations
/// Format: (x, y, z, w) where w is the scalar component
struct Quat {
    x: f32,
    y: f32,
    z: f32,
    w: f32,

    /// Create identity quaternion (no rotation)
    fn identity() -> Quat {
        return Quat { x: 0.0, y: 0.0, z: 0.0, w: 1.0 }
    }

    /// Create from components
    fn init(x: f32, y: f32, z: f32, w: f32) -> Quat {
        return Quat { x: x, y: y, z: z, w: w }
    }

    /// Create from axis and angle (radians)
    fn from_axis_angle(axis: &Vec3, angle: f32) -> Quat {
        let half_angle = angle * 0.5
        let s = math.sin(half_angle)
        let c = math.cos(half_angle)

        return Quat {
            x: axis.x * s,
            y: axis.y * s,
            z: axis.z * s,
            w: c
        }
    }

    /// Set quaternion components
    fn set(self: &mut Quat, x: f32, y: f32, z: f32, w: f32) {
        self.x = x
        self.y = y
        self.z = z
        self.w = w
    }

    /// Make identity
    fn make_identity(self: &mut Quat) {
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        self.w = 1.0
    }

    /// Get squared length
    fn length_squared(self: &Quat) -> f32 {
        return self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w
    }

    /// Get length
    fn length(self: &Quat) -> f32 {
        return math.sqrt(self.length_squared())
    }

    /// Normalize quaternion in-place
    fn normalize(self: &mut Quat) {
        let mag = self.length()
        if mag != 0.0 {
            let inv_mag = 1.0 / mag
            self.x *= inv_mag
            self.y *= inv_mag
            self.z *= inv_mag
            self.w *= inv_mag
        }
    }

    /// Get normalized copy
    fn normalized(self: &Quat) -> Quat {
        let mag = self.length()
        if mag != 0.0 {
            let inv_mag = 1.0 / mag
            return Quat {
                x: self.x * inv_mag,
                y: self.y * inv_mag,
                z: self.z * inv_mag,
                w: self.w * inv_mag
            }
        }
        return *self
    }

    /// Scale quaternion
    fn scale(self: &mut Quat, s: f32) {
        self.x *= s
        self.y *= s
        self.z *= s
        self.w *= s
    }

    /// Rotate a vector by this quaternion
    fn rotate_vector(self: &Quat, v: &Vec3) -> Vec3 {
        // Quaternion multiplication: q * v * q^-1
        // Optimized form avoiding full quaternion multiplication
        let qx = self.w * v.x + (self.y * v.z - v.y * self.z)
        let qy = self.w * v.y - (self.x * v.z - v.x * self.z)
        let qz = self.w * v.z + (self.x * v.y - v.x * self.y)
        let qw = -(self.x * v.x + self.y * v.y + self.z * v.z)

        return Vec3 {
            x: qw * (-self.x) + self.w * qx + (qy * (-self.z) - (-self.y) * qz),
            y: qw * (-self.y) + self.w * qy - (qx * (-self.z) - (-self.x) * qz),
            z: qw * (-self.z) + self.w * qz + (qx * (-self.y) - (-self.x) * qy)
        }
    }

    /// Rotate around X axis
    fn rotate_x(self: &mut Quat, angle: f32) {
        let half_angle = angle * 0.5
        let s = math.sin(half_angle)
        let c = math.cos(half_angle)

        let new_x = self.x * c + self.w * s
        let new_y = self.y * c + self.z * s
        let new_z = self.z * c - self.y * s
        let new_w = self.w * c - self.x * s

        self.x = new_x
        self.y = new_y
        self.z = new_z
        self.w = new_w
    }

    /// Rotate around Y axis
    fn rotate_y(self: &mut Quat, angle: f32) {
        let half_angle = angle * 0.5
        let s = math.sin(half_angle)
        let c = math.cos(half_angle)

        let new_x = self.x * c - self.z * s
        let new_y = self.y * c + self.w * s
        let new_z = self.z * c + self.x * s
        let new_w = self.w * c - self.y * s

        self.x = new_x
        self.y = new_y
        self.z = new_z
        self.w = new_w
    }

    /// Rotate around Z axis
    fn rotate_z(self: &mut Quat, angle: f32) {
        let half_angle = angle * 0.5
        let s = math.sin(half_angle)
        let c = math.cos(half_angle)

        let new_x = self.x * c + self.y * s
        let new_y = self.y * c - self.x * s
        let new_z = self.z * c + self.w * s
        let new_w = self.w * c - self.z * s

        self.x = new_x
        self.y = new_y
        self.z = new_z
        self.w = new_w
    }

    /// Make this quaternion closest to target (handles double-cover)
    fn make_closest(self: &mut Quat, target: &Quat) {
        // Check if we need to negate to find shortest path
        let dot = self.x * target.x + self.y * target.y + self.z * target.z + self.w * target.w
        if dot < 0.0 {
            self.x = -self.x
            self.y = -self.y
            self.z = -self.z
            self.w = -self.w
        }
    }

    /// Check if valid (no NaN/Inf)
    fn is_valid(self: &Quat) -> bool {
        return math.is_finite(self.x) &&
               math.is_finite(self.y) &&
               math.is_finite(self.z) &&
               math.is_finite(self.w)
    }

    /// Quaternion multiplication
    fn mul(self: &Quat, other: &Quat) -> Quat {
        return Quat {
            x: self.w * other.x + other.w * self.x + (self.y * other.z - other.y * self.z),
            y: self.w * other.y + other.w * self.y - (self.x * other.z - other.x * self.z),
            z: self.w * other.z + other.w * self.z + (self.x * other.y - other.x * self.y),
            w: self.w * other.w - (self.x * other.x + self.y * other.y + self.z * other.z)
        }
    }

    /// Quaternion addition
    fn add(self: &Quat, other: &Quat) -> Quat {
        return Quat {
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
            w: self.w + other.w
        }
    }

    /// Quaternion subtraction
    fn sub(self: &Quat, other: &Quat) -> Quat {
        return Quat {
            x: self.x - other.x,
            y: self.y - other.y,
            z: self.z - other.z,
            w: self.w - other.w
        }
    }

    /// Scalar multiplication
    fn mul_scalar(self: &Quat, s: f32) -> Quat {
        return Quat {
            x: self.x * s,
            y: self.y * s,
            z: self.z * s,
            w: self.w * s
        }
    }

    /// Negation
    fn negate(self: &Quat) -> Quat {
        return Quat { x: -self.x, y: -self.y, z: -self.z, w: -self.w }
    }

    /// Conjugate (inverse for unit quaternions)
    fn conjugate(self: &Quat) -> Quat {
        return Quat { x: -self.x, y: -self.y, z: -self.z, w: self.w }
    }

    /// Inverse
    fn inverse(self: &Quat) -> Quat {
        return self.conjugate()
    }

    /// Spherical linear interpolation (SLERP)
    fn slerp(a: &Quat, b: &Quat, t: f32) -> Quat {
        let mut cos_omega = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

        // Ensure shortest path
        let mut b_flip = *b
        if cos_omega < 0.0 {
            cos_omega = -cos_omega
            b_flip = b.negate()
        }

        // Use linear interpolation if very close (avoid division by zero)
        if cos_omega > 0.9995 {
            return Quat {
                x: a.x + (b_flip.x - a.x) * t,
                y: a.y + (b_flip.y - a.y) * t,
                z: a.z + (b_flip.z - a.z) * t,
                w: a.w + (b_flip.w - a.w) * t
            }.normalized()
        }

        // Standard SLERP
        let omega = math.acos(cos_omega)
        let sin_omega = math.sin(omega)

        let k0 = math.sin((1.0 - t) * omega) / sin_omega
        let k1 = math.sin(t * omega) / sin_omega

        return Quat {
            x: a.x * k0 + b_flip.x * k1,
            y: a.y * k0 + b_flip.y * k1,
            z: a.z * k0 + b_flip.z * k1,
            w: a.w * k0 + b_flip.w * k1
        }
    }

    /// Check equality within epsilon
    fn equals_epsilon(self: &Quat, other: &Quat, epsilon: f32) -> bool {
        return math.abs(self.x - other.x) < epsilon &&
               math.abs(self.y - other.y) < epsilon &&
               math.abs(self.z - other.z) < epsilon &&
               math.abs(self.w - other.w) < epsilon
    }
}
