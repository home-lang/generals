// Vector3 - 3D Vector Math
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/w3d/math/vector3.h

// Math functions (sqrt, sin, cos, etc.) are built-in

/// 3D Vector with float precision
struct Vec3 {
    x: f32,
    y: f32,
    z: f32,

    /// Create vector from components
    fn init(x: f32, y: f32, z: f32) -> Vec3 {
        return Vec3 { x: x, y: y, z: z }
    }

    /// Create zero vector
    fn zero() -> Vec3 {
        return Vec3 { x: 0.0, y: 0.0, z: 0.0 }
    }

    /// Create unit vector (1, 1, 1)
    fn one() -> Vec3 {
        return Vec3 { x: 1.0, y: 1.0, z: 1.0 }
    }

    /// Unit vectors for each axis
    fn unit_x() -> Vec3 { return Vec3 { x: 1.0, y: 0.0, z: 0.0 } }
    fn unit_y() -> Vec3 { return Vec3 { x: 0.0, y: 1.0, z: 0.0 } }
    fn unit_z() -> Vec3 { return Vec3 { x: 0.0, y: 0.0, z: 1.0 } }

    /// Set vector components
    fn set(self: &mut Vec3, x: f32, y: f32, z: f32) {
        self.x = x
        self.y = y
        self.z = z
    }

    /// Get squared length (avoids sqrt for performance)
    fn length_squared(self: &Vec3) -> f32 {
        return self.x * self.x + self.y * self.y + self.z * self.z
    }

    /// Get length of vector
    fn length(self: &Vec3) -> f32 {
        return math.sqrt(self.length_squared())
    }

    /// Normalize vector in-place
    fn normalize(self: &mut Vec3) {
        let len_sq = self.length_squared()
        if len_sq != 0.0 {
            let inv_len = 1.0 / math.sqrt(len_sq)
            self.x *= inv_len
            self.y *= inv_len
            self.z *= inv_len
        }
    }

    /// Get normalized copy without modifying original
    fn normalized(self: &Vec3) -> Vec3 {
        let len_sq = self.length_squared()
        if len_sq != 0.0 {
            let inv_len = 1.0 / math.sqrt(len_sq)
            return Vec3 {
                x: self.x * inv_len,
                y: self.y * inv_len,
                z: self.z * inv_len
            }
        }
        return Vec3.zero()
    }

    /// Dot product
    fn dot(self: &Vec3, other: &Vec3) -> f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z
    }

    /// Cross product
    fn cross(self: &Vec3, other: &Vec3) -> Vec3 {
        return Vec3 {
            x: self.y * other.z - self.z * other.y,
            y: self.z * other.x - self.x * other.z,
            z: self.x * other.y - self.y * other.x
        }
    }

    /// Normalized cross product
    fn cross_normalized(self: &Vec3, other: &Vec3) -> Vec3 {
        let result = self.cross(other)
        return result.normalized()
    }

    /// Individual cross product components (optimization for when only one is needed)
    fn cross_x(self: &Vec3, other: &Vec3) -> f32 {
        return self.y * other.z - self.z * other.y
    }

    fn cross_y(self: &Vec3, other: &Vec3) -> f32 {
        return self.z * other.x - self.x * other.z
    }

    fn cross_z(self: &Vec3, other: &Vec3) -> f32 {
        return self.x * other.y - self.y * other.x
    }

    /// Scale by components
    fn scale(self: &mut Vec3, sx: f32, sy: f32, sz: f32) {
        self.x *= sx
        self.y *= sy
        self.z *= sz
    }

    /// Scale by another vector
    fn scale_vec(self: &mut Vec3, other: &Vec3) {
        self.x *= other.x
        self.y *= other.y
        self.z *= other.z
    }

    /// Rotate around X axis
    fn rotate_x(self: &mut Vec3, angle: f32) {
        let s = math.sin(angle)
        let c = math.cos(angle)
        self.rotate_x_sc(s, c)
    }

    fn rotate_x_sc(self: &mut Vec3, s: f32, c: f32) {
        let tmp_y = self.y
        let tmp_z = self.z
        self.y = c * tmp_y - s * tmp_z
        self.z = s * tmp_y + c * tmp_z
    }

    /// Rotate around Y axis
    fn rotate_y(self: &mut Vec3, angle: f32) {
        let s = math.sin(angle)
        let c = math.cos(angle)
        self.rotate_y_sc(s, c)
    }

    fn rotate_y_sc(self: &mut Vec3, s: f32, c: f32) {
        let tmp_x = self.x
        let tmp_z = self.z
        self.x = c * tmp_x + s * tmp_z
        self.z = -s * tmp_x + c * tmp_z
    }

    /// Rotate around Z axis
    fn rotate_z(self: &mut Vec3, angle: f32) {
        let s = math.sin(angle)
        let c = math.cos(angle)
        self.rotate_z_sc(s, c)
    }

    fn rotate_z_sc(self: &mut Vec3, s: f32, c: f32) {
        let tmp_x = self.x
        let tmp_y = self.y
        self.x = c * tmp_x - s * tmp_y
        self.y = s * tmp_x + c * tmp_y
    }

    /// Update to minimum of self and other
    fn update_min(self: &mut Vec3, other: &Vec3) {
        if other.x < self.x { self.x = other.x }
        if other.y < self.y { self.y = other.y }
        if other.z < self.z { self.z = other.z }
    }

    /// Update to maximum of self and other
    fn update_max(self: &mut Vec3, other: &Vec3) {
        if other.x > self.x { self.x = other.x }
        if other.y > self.y { self.y = other.y }
        if other.z > self.z { self.z = other.z }
    }

    /// Cap absolute values
    fn cap_absolute(self: &mut Vec3, cap: &Vec3) {
        if self.x > 0.0 {
            if cap.x < self.x { self.x = cap.x }
        } else {
            if -cap.x > self.x { self.x = -cap.x }
        }

        if self.y > 0.0 {
            if cap.y < self.y { self.y = cap.y }
        } else {
            if -cap.y > self.y { self.y = -cap.y }
        }

        if self.z > 0.0 {
            if cap.z < self.z { self.z = cap.z }
        } else {
            if -cap.z > self.z { self.z = -cap.z }
        }
    }

    /// Linear interpolation
    fn lerp(a: &Vec3, b: &Vec3, t: f32) -> Vec3 {
        return Vec3 {
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t,
            z: a.z + (b.z - a.z) * t
        }
    }

    /// Distance between two vectors
    fn distance(a: &Vec3, b: &Vec3) -> f32 {
        let dx = a.x - b.x
        let dy = a.y - b.y
        let dz = a.z - b.z
        return math.sqrt(dx * dx + dy * dy + dz * dz)
    }

    /// Quick approximation of length (faster but less accurate)
    /// Uses formula: max + (11/32)*mid + (1/4)*min
    fn quick_length(self: &Vec3) -> f32 {
        let mut max = math.abs(self.x)
        let mut mid = math.abs(self.y)
        let mut min = math.abs(self.z)

        // Sort into max, mid, min
        if max < mid {
            let tmp = max
            max = mid
            mid = tmp
        }

        if max < min {
            let tmp = max
            max = min
            min = tmp
        }

        if mid < min {
            let tmp = mid
            mid = min
            min = tmp
        }

        return max + (11.0 / 32.0) * mid + (0.25) * min
    }

    /// Quick distance approximation
    fn quick_distance(a: &Vec3, b: &Vec3) -> f32 {
        let temp = a.sub(b)
        return temp.quick_length()
    }

    /// Linear interpolation utilities for finding coordinates
    fn find_x_at_y(y: f32, p1: &Vec3, p2: &Vec3) -> f32 {
        return p1.x + ((y - p1.y) * ((p2.x - p1.x) / (p2.y - p1.y)))
    }

    fn find_x_at_z(z: f32, p1: &Vec3, p2: &Vec3) -> f32 {
        return p1.x + ((z - p1.z) * ((p2.x - p1.x) / (p2.z - p1.z)))
    }

    fn find_y_at_x(x: f32, p1: &Vec3, p2: &Vec3) -> f32 {
        return p1.y + ((x - p1.x) * ((p2.y - p1.y) / (p2.x - p1.x)))
    }

    fn find_y_at_z(z: f32, p1: &Vec3, p2: &Vec3) -> f32 {
        return p1.y + ((z - p1.z) * ((p2.y - p1.y) / (p2.z - p1.z)))
    }

    fn find_z_at_x(x: f32, p1: &Vec3, p2: &Vec3) -> f32 {
        return p1.z + ((x - p1.x) * ((p2.z - p1.z) / (p2.x - p1.x)))
    }

    fn find_z_at_y(y: f32, p1: &Vec3, p2: &Vec3) -> f32 {
        return p1.z + ((y - p1.y) * ((p2.z - p1.z) / (p2.y - p1.y)))
    }

    /// Convert to color (ABGR format)
    fn to_abgr(self: &Vec3) -> u32 {
        let r = (self.x * 255.0) as u32
        let g = (self.y * 255.0) as u32
        let b = (self.z * 255.0) as u32
        return (255 << 24) | (b << 16) | (g << 8) | r
    }

    /// Convert to color (ARGB format)
    fn to_argb(self: &Vec3) -> u32 {
        let r = (self.x * 255.0) as u32
        let g = (self.y * 255.0) as u32
        let b = (self.z * 255.0) as u32
        return (255 << 24) | (r << 16) | (g << 8) | b
    }

    /// Check if vector is valid (no NaN/Inf)
    fn is_valid(self: &Vec3) -> bool {
        return math.is_finite(self.x) &&
               math.is_finite(self.y) &&
               math.is_finite(self.z)
    }

    /// Operator: vector + vector
    fn add(self: &Vec3, other: &Vec3) -> Vec3 {
        return Vec3 {
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z
        }
    }

    /// Operator: vector - vector
    fn sub(self: &Vec3, other: &Vec3) -> Vec3 {
        return Vec3 {
            x: self.x - other.x,
            y: self.y - other.y,
            z: self.z - other.z
        }
    }

    /// Operator: vector * scalar
    fn mul_scalar(self: &Vec3, k: f32) -> Vec3 {
        return Vec3 {
            x: self.x * k,
            y: self.y * k,
            z: self.z * k
        }
    }

    /// Operator: vector / scalar
    fn div_scalar(self: &Vec3, k: f32) -> Vec3 {
        let inv_k = 1.0 / k
        return Vec3 {
            x: self.x * inv_k,
            y: self.y * inv_k,
            z: self.z * inv_k
        }
    }

    /// Operator: -vector (negation)
    fn negate(self: &Vec3) -> Vec3 {
        return Vec3 { x: -self.x, y: -self.y, z: -self.z }
    }

    /// Check equality
    fn equals(self: &Vec3, other: &Vec3) -> bool {
        return self.x == other.x &&
               self.y == other.y &&
               self.z == other.z
    }

    /// Check equality within epsilon
    fn equals_epsilon(self: &Vec3, other: &Vec3, epsilon: f32) -> bool {
        return math.abs(self.x - other.x) < epsilon &&
               math.abs(self.y - other.y) < epsilon &&
               math.abs(self.z - other.z) < epsilon
    }
}
