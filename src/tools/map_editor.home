// C&C Generals Zero Hour - Home Port
// Map Editor Tool
//
// Original: WorldBuilder.exe (EA's official map editor)
// Ported to Home with modern editor features
//
// C&C Generals Map Format (.map files):
// - Text-based format with embedded INI
// - Contains terrain heightmap data
// - Object placement (units, buildings, props)
// - Scripting for objectives and triggers
// - Lighting and environment settings
//
// Example .map file structure:
// ```
// Map MyCustomMap
//   MapSize = 200 200
//   HeightMapType = Flat
//   WaterTransparency = 50
//
//   Object AmericaTankCrusader
//     Position = X:100 Y:150 Z:0
//     Angle = 45
//     Team = TeamUSA
//   End
//
//   Team TeamUSA
//     Name = "USA Forces"
//     IsPlayerControlled = Yes
//     StartMoney = 5000
//   End
// End
// ```

import basics/allocator
import basics/string
import basics/filesystem
import engine/math
import tools/ini_parser

// Map metadata
struct MapInfo {
    map_name: string
    display_name: string
    description: string
    author: string
    player_count: u32       // 2-8 players
    width: u32              // Map width in cells
    height: u32             // Map height in cells
    tileset: string         // "Desert", "Snow", "Urban", etc.

    fn init(): MapInfo {
        return MapInfo {
            map_name: "NewMap"
            display_name: "New Map"
            description: ""
            author: ""
            player_count: 2
            width: 200
            height: 200
            tileset: "Desert"
        }
    }
}

// Terrain tile type
enum TerrainType {
    Grass
    Sand
    Rock
    Snow
    Water
    Cliff
    Road
    Concrete
}

// Terrain cell
struct TerrainCell {
    height: f32             // Height in world units
    terrain_type: TerrainType
    texture_index: u32      // Which texture to use
    walkable: bool          // Can units traverse this cell?
    buildable: bool         // Can buildings be placed here?
}

// Object placement on map
struct MapObject {
    object_type: string     // INI object name (e.g., "AmericaTankCrusader")
    position: Vec3
    rotation: f32           // Angle in degrees
    team_id: u32            // Which team owns this object
    initial_health: f32     // Override default health (0 = use default)
    script_tag: string      // For mission scripting

    fn init(object_type: string, position: Vec3): MapObject {
        return MapObject {
            object_type: object_type
            position: position
            rotation: 0.0
            team_id: 0
            initial_health: 0.0
            script_tag: ""
        }
    }
}

// Player start location
struct PlayerStart {
    player_id: u32
    position: Vec3
    team_name: string
    starting_money: i32
    faction: string         // "USA", "China", "GLA"
    is_human: bool          // vs AI

    fn init(player_id: u32): PlayerStart {
        return PlayerStart {
            player_id: player_id
            position: Vec3.init(0.0, 0.0, 0.0)
            team_name: "Team{player_id}"
            starting_money: 10000
            faction: "USA"
            is_human: true
        }
    }
}

// Map lighting and environment
struct MapEnvironment {
    time_of_day: string     // "Morning", "Midday", "Evening", "Night"
    weather: string         // "Clear", "Cloudy", "Rainy", "Snowy"
    ambient_color: Vec3     // RGB ambient light
    sun_direction: Vec3     // Directional light direction
    sun_color: Vec3         // RGB sun color
    fog_enabled: bool
    fog_color: Vec3
    fog_start: f32
    fog_end: f32

    fn init(): MapEnvironment {
        return MapEnvironment {
            time_of_day: "Midday"
            weather: "Clear"
            ambient_color: Vec3.init(0.3, 0.3, 0.3)
            sun_direction: Vec3.init(-1.0, -1.0, -1.0)
            sun_color: Vec3.init(1.0, 0.9, 0.8)
            fog_enabled: false
            fog_color: Vec3.init(0.7, 0.7, 0.8)
            fog_start: 100.0
            fog_end: 500.0
        }
    }
}

// Map data
struct GameMap {
    info: MapInfo
    terrain: []TerrainCell  // 2D grid stored as 1D array
    objects: []MapObject
    player_starts: []PlayerStart
    environment: MapEnvironment
    allocator: Allocator

    fn init(allocator: Allocator, width: u32, height: u32): GameMap {
        let cell_count = @intCast(usize, width * height)

        let mut map = GameMap {
            info: MapInfo.init()
            terrain: allocator.alloc(TerrainCell, cell_count)
            objects: []
            player_starts: []
            environment: MapEnvironment.init()
            allocator: allocator
        }

        map.info.width = width
        map.info.height = height

        // Initialize flat terrain
        for i in 0..cell_count {
            map.terrain[i] = TerrainCell {
                height: 0.0
                terrain_type: TerrainType.Grass
                texture_index: 0
                walkable: true
                buildable: true
            }
        }

        return map
    }

    fn get_cell(self, x: u32, y: u32): ?*TerrainCell {
        if x >= self.info.width or y >= self.info.height {
            return null
        }

        let index = @intCast(usize, y * self.info.width + x)
        return &self.terrain[index]
    }

    fn set_cell_height(mut self, x: u32, y: u32, height: f32) {
        let cell = self.get_cell(x, y)
        if cell {
            cell.?.height = height
        }
    }

    fn add_object(mut self, object: MapObject) {
        let new_objects = self.allocator.alloc(MapObject, self.objects.len + 1)

        for i in 0..self.objects.len {
            new_objects[i] = self.objects[i]
        }

        new_objects[self.objects.len] = object

        if self.objects.len > 0 {
            self.allocator.free(self.objects)
        }

        self.objects = new_objects
    }

    fn add_player_start(mut self, player_start: PlayerStart) {
        let new_starts = self.allocator.alloc(PlayerStart, self.player_starts.len + 1)

        for i in 0..self.player_starts.len {
            new_starts[i] = self.player_starts[i]
        }

        new_starts[self.player_starts.len] = player_start

        if self.player_starts.len > 0 {
            self.allocator.free(self.player_starts)
        }

        self.player_starts = new_starts
    }

    fn save_to_file(self, filepath: string): bool {
        let file = File.create(filepath, FileMode.Write)
        if !file {
            println("Failed to create map file: {filepath}")
            return false
        }
        defer file.close()

        // Write map header
        file.write_line("Map {self.info.map_name}")
        file.write_line("  DisplayName = \"{self.info.display_name}\"")
        file.write_line("  Description = \"{self.info.description}\"")
        file.write_line("  Author = \"{self.info.author}\"")
        file.write_line("  MapSize = {self.info.width} {self.info.height}")
        file.write_line("  PlayerCount = {self.info.player_count}")
        file.write_line("  Tileset = {self.info.tileset}")
        file.write_line("")

        // Write environment settings
        file.write_line("  Environment")
        file.write_line("    TimeOfDay = {self.environment.time_of_day}")
        file.write_line("    Weather = {self.environment.weather}")
        file.write_line("    AmbientColor = {self.environment.ambient_color.x} {self.environment.ambient_color.y} {self.environment.ambient_color.z}")
        file.write_line("    SunDirection = {self.environment.sun_direction.x} {self.environment.sun_direction.y} {self.environment.sun_direction.z}")
        file.write_line("    SunColor = {self.environment.sun_color.x} {self.environment.sun_color.y} {self.environment.sun_color.z}")
        file.write_line("  End")
        file.write_line("")

        // Write terrain heightmap
        file.write_line("  HeightMap")
        for y in 0..self.info.height {
            for x in 0..self.info.width {
                let cell = self.get_cell(x, y)
                if cell {
                    file.write("{cell.?.height} ")
                }
            }
            file.write_line("")
        }
        file.write_line("  End")
        file.write_line("")

        // Write player starts
        for i in 0..self.player_starts.len {
            let start = &self.player_starts[i]
            file.write_line("  PlayerStart Player{start.player_id}")
            file.write_line("    Position = X:{start.position.x} Y:{start.position.y} Z:{start.position.z}")
            file.write_line("    Team = {start.team_name}")
            file.write_line("    StartMoney = {start.starting_money}")
            file.write_line("    Faction = {start.faction}")
            file.write_line("    IsHuman = {if start.is_human { "Yes" } else { "No" }}")
            file.write_line("  End")
            file.write_line("")
        }

        // Write placed objects
        for i in 0..self.objects.len {
            let obj = &self.objects[i]
            file.write_line("  Object {obj.object_type} Tag_{i}")
            file.write_line("    Position = X:{obj.position.x} Y:{obj.position.y} Z:{obj.position.z}")
            file.write_line("    Angle = {obj.rotation}")
            file.write_line("    Team = Team{obj.team_id}")

            if obj.initial_health > 0.0 {
                file.write_line("    InitialHealth = {obj.initial_health}")
            }

            if obj.script_tag.len > 0 {
                file.write_line("    ScriptTag = {obj.script_tag}")
            }

            file.write_line("  End")
            file.write_line("")
        }

        // Close map definition
        file.write_line("End")

        println("Map saved: {filepath}")
        return true
    }

    fn load_from_file(mut self, filepath: string): bool {
        let mut parser = INIParser.init(self.allocator)
        let doc = parser.parse_file(filepath)

        if !doc {
            println("Failed to parse map file: {filepath}")
            return false
        }

        // Get "Map" section
        let maps = doc.?.get_all_sections("Map")
        if maps.len == 0 {
            println("No Map section found in file")
            return false
        }

        let map_section = maps[0]

        // Load map info
        self.info.map_name = map_section.name
        self.info.display_name = map_section.get_string("DisplayName", map_section.name)
        self.info.description = map_section.get_string("Description", "")
        self.info.author = map_section.get_string("Author", "")
        self.info.player_count = @intCast(u32, map_section.get_int("PlayerCount", 2))
        self.info.tileset = map_section.get_string("Tileset", "Desert")

        // Parse MapSize
        let map_size = map_section.get_string("MapSize", "200 200")
        let size_parts = map_size.split_whitespace()
        if size_parts.len >= 2 {
            self.info.width = @intCast(u32, size_parts[0].parse_int())
            self.info.height = @intCast(u32, size_parts[1].parse_int())
        }

        // Load environment
        let env_module = map_section.get_module("Environment")
        if env_module {
            self.environment.time_of_day = env_module.?.get_string("TimeOfDay", "Midday")
            self.environment.weather = env_module.?.get_string("Weather", "Clear")
        }

        // Load player starts
        let player_starts = map_section.get_all_modules("PlayerStart")
        for start_module in player_starts {
            let mut start = PlayerStart.init(0)

            // Parse position
            let pos_str = start_module.get_string("Position", "X:0 Y:0 Z:0")
            start.position = self.parse_position(pos_str)

            start.team_name = start_module.get_string("Team", "Team1")
            start.starting_money = @intCast(i32, start_module.get_int("StartMoney", 10000))
            start.faction = start_module.get_string("Faction", "USA")
            start.is_human = start_module.get_bool("IsHuman", true)

            self.add_player_start(start)
        }

        // Load placed objects
        let object_modules = map_section.get_all_modules("Object")
        for obj_module in object_modules {
            let mut obj = MapObject.init(obj_module.module_type, Vec3.init(0.0, 0.0, 0.0))

            let pos_str = obj_module.get_string("Position", "X:0 Y:0 Z:0")
            obj.position = self.parse_position(pos_str)
            obj.rotation = @intToFloat(f32, obj_module.get_float("Angle", 0.0))
            obj.initial_health = @intToFloat(f32, obj_module.get_float("InitialHealth", 0.0))
            obj.script_tag = obj_module.get_string("ScriptTag", "")

            self.add_object(obj)
        }

        println("Map loaded: {self.info.map_name}")
        println("  Size: {self.info.width}x{self.info.height}")
        println("  Players: {self.info.player_count}")
        println("  Objects: {self.objects.len}")

        return true
    }

    fn parse_position(self, pos_str: string): Vec3 {
        // Parse "X:100 Y:150 Z:0" format
        let parts = pos_str.split_whitespace()
        let mut pos = Vec3.init(0.0, 0.0, 0.0)

        for part in parts {
            if part.starts_with("X:") {
                pos.x = part.substring(2).parse_float()
            } else if part.starts_with("Y:") {
                pos.y = part.substring(2).parse_float()
            } else if part.starts_with("Z:") {
                pos.z = part.substring(2).parse_float()
            }
        }

        return pos
    }

    fn deinit(mut self) {
        self.allocator.free(self.terrain)

        if self.objects.len > 0 {
            self.allocator.free(self.objects)
        }

        if self.player_starts.len > 0 {
            self.allocator.free(self.player_starts)
        }
    }
}

// Map Editor (interactive tool)
struct MapEditor {
    current_map: ?GameMap
    selected_object_type: string
    brush_size: u32
    brush_height: f32
    allocator: Allocator

    fn init(allocator: Allocator): MapEditor {
        return MapEditor {
            current_map: null
            selected_object_type: ""
            brush_size: 1
            brush_height: 0.0
            allocator: allocator
        }
    }

    fn new_map(mut self, width: u32, height: u32): GameMap {
        self.current_map = GameMap.init(self.allocator, width, height)
        println("Created new map: {width}x{height}")
        return self.current_map.?
    }

    fn load_map(mut self, filepath: string): bool {
        let mut map = GameMap.init(self.allocator, 200, 200)

        if !map.load_from_file(filepath) {
            return false
        }

        self.current_map = map
        return true
    }

    fn save_map(self, filepath: string): bool {
        if !self.current_map {
            println("No map loaded")
            return false
        }

        return self.current_map.?.save_to_file(filepath)
    }

    fn raise_terrain(mut self, x: u32, y: u32, amount: f32) {
        if !self.current_map {
            return
        }

        let cell = self.current_map.?.get_cell(x, y)
        if cell {
            cell.?.height += amount
        }
    }

    fn place_object(mut self, object_type: string, position: Vec3) {
        if !self.current_map {
            return
        }

        let obj = MapObject.init(object_type, position)
        self.current_map.?.add_object(obj)

        println("Placed {object_type} at ({position.x}, {position.y}, {position.z})")
    }
}

// Export functions
export fn create_new_map(width: u32, height: u32): GameMap {
    let allocator = get_global_allocator()
    return GameMap.init(allocator, width, height)
}

export fn load_map(filepath: string): ?GameMap {
    let allocator = get_global_allocator()
    let mut map = GameMap.init(allocator, 200, 200)

    if !map.load_from_file(filepath) {
        return null
    }

    return map
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
