// C&C Generals Zero Hour - Home Port
// INI Parser (Game Data & Mod Support)
//
// Original: INI.cpp, INI.h (Westwood Studios/EA)
// Ported to Home with EA's INI format for game configuration
//
// INI files in C&C Generals define:
// - Unit stats and properties (Data/INI/Object/*.ini)
// - Weapon definitions (Data/INI/Weapon.ini)
// - Player powers (Data/INI/CommandSet.ini)
// - Maps (Data/Maps/*.map with embedded INI)
// - Game logic scripts
//
// Format example from EA's Object/AmericaTankCrusader.ini:
// ```ini
// Object AmericaTankCrusader
//   ; *** ART Parameters ***
//   SelectPortrait = Portrait_AmericaTankCrusader
//   ButtonImage = Portrait_AmericaTankCrusader
//
//   Draw = W3DTankDraw ModuleTag_01
//     OkToChangeModelColor = Yes
//     DefaultConditionState
//       Model = AVCrusadr_SKN
//     End
//   End
//
//   ; *** DESIGN parameters ***
//   DisplayName = OBJECT:Crusader
//   Side = America
//   EditorSorting = VEHICLE
//   TransportSlotCount = 3
//
//   ArmorSet
//     Conditions = None
//     Armor = TankArmor
//   End
//
//   Body = ActiveBody ModuleTag_02
//     MaxHealth = 400.0
//     InitialHealth = 400.0
//   End
// End
// ```

import basics/allocator
import basics/string
import basics/filesystem

// INI value types
enum INIValueType {
    String
    Integer
    Float
    Boolean
    List        // Space-separated values
}

// INI property (key-value pair)
struct INIProperty {
    key: string
    value: string
    value_type: INIValueType
    line_number: u32

    fn as_string(&self): string {
        return self.value
    }

    fn as_int(&self): i64 {
        // TODO: Implement string to int conversion
        return 0
    }

    fn as_float(&self): f64 {
        // TODO: Implement string to float conversion
        return 0.0
    }

    fn as_bool(&self): bool {
        let lowercase = self.value.to_lowercase()
        return lowercase == "yes" or lowercase == "true" or lowercase == "1"
    }

    fn as_list(&self, separator: string): []string {
        return self.value.split(separator)
    }
}

// INI module (nested block like "Draw = W3DTankDraw ModuleTag_01 ... End")
struct INIModule {
    module_type: string     // e.g., "W3DTankDraw", "ActiveBody"
    tag: string             // e.g., "ModuleTag_01"
    properties: []INIProperty
    nested_modules: []INIModule  // Modules can contain sub-modules

    fn get_property(&self, key: string): ?*INIProperty {
        for i in 0..self.properties.len {
            if self.properties[i].key == key {
                return &self.properties[i]
            }
        }
        return null
    }

    fn get_string(&self, key: string, default: string): string {
        let prop = self.get_property(key)
        if prop {
            return prop.?.as_string()
        }
        return default
    }

    fn get_int(&self, key: string, default: i64): i64 {
        let prop = self.get_property(key)
        if prop {
            return prop.?.as_int()
        }
        return default
    }

    fn get_float(&self, key: string, default: f64): f64 {
        let prop = self.get_property(key)
        if prop {
            return prop.?.as_float()
        }
        return default
    }

    fn get_bool(&self, key: string, default: bool): bool {
        let prop = self.get_property(key)
        if prop {
            return prop.?.as_bool()
        }
        return default
    }
}

// INI section (top-level object like "Object AmericaTankCrusader")
struct INISection {
    section_type: string    // e.g., "Object", "Weapon", "CommandSet"
    name: string            // e.g., "AmericaTankCrusader"
    properties: []INIProperty
    modules: []INIModule

    fn get_property(&self, key: string): ?*INIProperty {
        for i in 0..self.properties.len {
            if self.properties[i].key == key {
                return &self.properties[i]
            }
        }
        return null
    }

    fn get_module(&self, module_type: string): ?*INIModule {
        for i in 0..self.modules.len {
            if self.modules[i].module_type == module_type {
                return &self.modules[i]
            }
        }
        return null
    }

    fn get_all_modules(&self, module_type: string): []* INIModule {
        let mut result: []*INIModule = []

        for i in 0..self.modules.len {
            if self.modules[i].module_type == module_type {
                result = result.append(&self.modules[i])
            }
        }

        return result
    }

    fn get_string(&self, key: string, default: string): string {
        let prop = self.get_property(key)
        if prop {
            return prop.?.as_string()
        }
        return default
    }

    fn get_int(&self, key: string, default: i64): i64 {
        let prop = self.get_property(key)
        if prop {
            return prop.?.as_int()
        }
        return default
    }

    fn get_float(&self, key: string, default: f64): f64 {
        let prop = self.get_property(key)
        if prop {
            return prop.?.as_float()
        }
        return default
    }

    fn get_bool(&self, key: string, default: bool): bool {
        let prop = self.get_property(key)
        if prop {
            return prop.?.as_bool()
        }
        return default
    }
}

// Parsed INI document
struct INIDocument {
    sections: []INISection
    allocator: Allocator

    fn init(allocator: Allocator): INIDocument {
        return INIDocument {
            sections: []
            allocator: allocator
        }
    }

    fn get_section(&self, section_type: string, name: string): ?*INISection {
        for i in 0..self.sections.len {
            if self.sections[i].section_type == section_type and self.sections[i].name == name {
                return &self.sections[i]
            }
        }
        return null
    }

    fn get_all_sections(&self, section_type: string): []*INISection {
        let mut result: []*INISection = []

        for i in 0..self.sections.len {
            if self.sections[i].section_type == section_type {
                result = result.append(&self.sections[i])
            }
        }

        return result
    }

    fn add_section(mut self, section: INISection) {
        let new_sections = self.allocator.alloc(INISection, self.sections.len + 1)

        for i in 0..self.sections.len {
            new_sections[i] = self.sections[i]
        }

        new_sections[self.sections.len] = section

        if self.sections.len > 0 {
            self.allocator.free(self.sections)
        }

        self.sections = new_sections
    }

    fn deinit(mut self) {
        if self.sections.len > 0 {
            self.allocator.free(self.sections)
        }
    }
}

// INI Parser
struct INIParser {
    allocator: Allocator
    current_line: u32

    fn init(allocator: Allocator): INIParser {
        return INIParser {
            allocator: allocator
            current_line: 0
        }
    }

    fn parse_file(mut self, filepath: string): ?INIDocument {
        let file = File.open(filepath, FileMode.Read)
        if !file {
            println("Failed to open INI file: {filepath}")
            return null
        }
        defer file.close()

        let contents = file.read_all_text()
        if !contents {
            println("Failed to read INI file: {filepath}")
            return null
        }

        return self.parse_string(contents.?)
    }

    fn parse_string(mut self, contents: string): ?INIDocument {
        let mut doc = INIDocument.init(self.allocator)
        let lines = contents.split("\n")

        let mut i: usize = 0
        while i < lines.len {
            self.current_line = @intCast(u32, i + 1)
            let line = self.trim_line(lines[i])

            // Skip empty lines and comments
            if line.len == 0 or line.starts_with(";") or line.starts_with("//") {
                i += 1
                continue
            }

            // Check for section header (e.g., "Object AmericaTankCrusader")
            if self.is_section_start(line) {
                let section = self.parse_section(lines, &i)
                if section {
                    doc.add_section(section.?)
                }
            }

            i += 1
        }

        return doc
    }

    fn is_section_start(&self, line: string): bool {
        // Section starts with keywords like "Object", "Weapon", "CommandSet", etc.
        let keywords = ["Object", "Weapon", "CommandSet", "CommandButton", "Science", "Upgrade", "SpecialPower", "ArmorSet", "WeaponSet"]

        for keyword in keywords {
            if line.starts_with(keyword) and !line.contains("=") {
                return true
            }
        }

        return false
    }

    fn parse_section(mut self, lines: []string, index: *usize): ?INISection {
        let header_line = self.trim_line(lines[*index])
        let header_parts = header_line.split_whitespace()

        if header_parts.len < 2 {
            println("Warning: Invalid section header at line {self.current_line}: {header_line}")
            return null
        }

        let mut section = INISection {
            section_type: header_parts[0]
            name: header_parts[1]
            properties: []
            modules: []
        }

        *index += 1

        // Parse section content until "End"
        while *index < lines.len {
            self.current_line = @intCast(u32, *index + 1)
            let line = self.trim_line(lines[*index])

            // Skip empty lines and comments
            if line.len == 0 or line.starts_with(";") or line.starts_with("//") {
                *index += 1
                continue
            }

            // Check for section end
            if line == "End" {
                break
            }

            // Check for module start (e.g., "Draw = W3DTankDraw ModuleTag_01")
            if self.is_module_start(line) {
                let module = self.parse_module(lines, index)
                if module {
                    section.modules = section.modules.append(module.?)
                }
            } else if line.contains("=") {
                // Regular property
                let prop = self.parse_property(line)
                if prop {
                    section.properties = section.properties.append(prop.?)
                }
            }

            *index += 1
        }

        return section
    }

    fn is_module_start(&self, line: string): bool {
        // Module lines have format: "ModuleName = ModuleType Tag"
        // e.g., "Draw = W3DTankDraw ModuleTag_01"
        if !line.contains("=") {
            return false
        }

        let module_keywords = ["Draw", "Body", "Behavior", "LocomotorSet", "ArmorSet", "WeaponSet", "ClientUpdate", "Physics"]

        for keyword in module_keywords {
            if line.starts_with(keyword) {
                return true
            }
        }

        return false
    }

    fn parse_module(mut self, lines: []string, index: *usize): ?INIModule {
        let header_line = self.trim_line(lines[*index])
        let parts = header_line.split("=")

        if parts.len < 2 {
            return null
        }

        let right_side = parts[1].trim()
        let right_parts = right_side.split_whitespace()

        let mut module = INIModule {
            module_type: if right_parts.len > 0 { right_parts[0] } else { "" }
            tag: if right_parts.len > 1 { right_parts[1] } else { "" }
            properties: []
            nested_modules: []
        }

        *index += 1

        // Parse module content until "End"
        while *index < lines.len {
            self.current_line = @intCast(u32, *index + 1)
            let line = self.trim_line(lines[*index])

            if line.len == 0 or line.starts_with(";") or line.starts_with("//") {
                *index += 1
                continue
            }

            if line == "End" {
                break
            }

            // Check for nested module
            if self.is_module_start(line) {
                let nested = self.parse_module(lines, index)
                if nested {
                    module.nested_modules = module.nested_modules.append(nested.?)
                }
            } else if line.contains("=") {
                let prop = self.parse_property(line)
                if prop {
                    module.properties = module.properties.append(prop.?)
                }
            }

            *index += 1
        }

        return module
    }

    fn parse_property(&self, line: string): ?INIProperty {
        let parts = line.split("=")

        if parts.len < 2 {
            return null
        }

        let key = parts[0].trim()
        let value = parts[1].trim()

        // Remove inline comments
        let value_clean = value
        if value.contains(";") {
            value_clean = value.split(";")[0].trim()
        }

        return INIProperty {
            key: key
            value: value_clean
            value_type: self.infer_value_type(value_clean)
            line_number: self.current_line
        }
    }

    fn infer_value_type(&self, value: string): INIValueType {
        // Check for boolean
        let lowercase = value.to_lowercase()
        if lowercase == "yes" or lowercase == "no" or lowercase == "true" or lowercase == "false" {
            return INIValueType.Boolean
        }

        // Check for integer
        if value.is_numeric() and !value.contains(".") {
            return INIValueType.Integer
        }

        // Check for float
        if value.is_numeric() and value.contains(".") {
            return INIValueType.Float
        }

        // Check for list (multiple space-separated values)
        if value.contains(" ") {
            return INIValueType.List
        }

        return INIValueType.String
    }

    fn trim_line(&self, line: string): string {
        // Trim whitespace and remove Windows line endings
        let trimmed = line.trim()
        if trimmed.ends_with("\r") {
            trimmed = trimmed.substring(0, trimmed.len - 1)
        }
        return trimmed
    }
}

// Example: Load and parse a unit definition
export fn load_unit_from_ini(filepath: string): ?INISection {
    let allocator = get_global_allocator()
    let mut parser = INIParser.init(allocator)

    let doc = parser.parse_file(filepath)
    if !doc {
        return null
    }

    // Get first "Object" section
    let sections = doc.?.get_all_sections("Object")
    if sections.len > 0 {
        return sections[0]
    }

    return null
}

// Example: Extract unit stats
export fn print_unit_stats(section: *INISection) {
    println("=== Unit: {section.name} ===")
    println("  DisplayName: {section.get_string("DisplayName", "Unknown")}")
    println("  Side: {section.get_string("Side", "Unknown")}")

    // Get Body module for health
    let body = section.get_module("ActiveBody")
    if body {
        println("  MaxHealth: {body.?.get_float("MaxHealth", 0.0)}")
    }

    // Get ArmorSet
    let armor_set = section.get_module("ArmorSet")
    if armor_set {
        println("  Armor: {armor_set.?.get_string("Armor", "None")}")
    }
}
