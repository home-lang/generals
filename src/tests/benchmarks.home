// C&C Generals Zero Hour - Home Port
// Performance Benchmarks
//
// Comprehensive performance benchmarks to ensure the game
// meets EA's original performance targets.
//
// Target performance metrics (based on EA's original):
// - 60 FPS with 1000+ units on screen
// - < 16ms frame time
// - < 5ms logic update time
// - < 10ms render time
// - < 100μs pathfinding per unit
// - < 1μs ECS component query
//
// Benchmark categories:
// - Core systems (memory allocation, string operations)
// - Engine (math, ECS queries, pathfinding)
// - Rendering (draw calls, state changes)
// - Game logic (unit updates, combat calculations)
// - Networking (command serialization, checksums)

import basics/allocator
import tests/test_framework

// Core System Benchmarks
export fn benchmark_memory_allocation() {
    println("\n=== Memory Allocation Benchmark ===")

    let iterations: u32 = 100000

    // Benchmark: Small allocations (32 bytes)
    let result = Benchmark.run("Small allocations (32B)", iterations, || {
        // let ptr = game_alloc(32)
        // game_free(ptr)
    })
    result.print()

    // Benchmark: Medium allocations (128 bytes)
    let result2 = Benchmark.run("Medium allocations (128B)", iterations, || {
        // let ptr = game_alloc(128)
        // game_free(ptr)
    })
    result2.print()

    // Benchmark: Large allocations (512 bytes)
    let result3 = Benchmark.run("Large allocations (512B)", iterations, || {
        // let ptr = game_alloc(512)
        // game_free(ptr)
    })
    result3.print()
}

export fn benchmark_string_operations() {
    println("\n=== String Operations Benchmark ===")

    let iterations: u32 = 10000

    // Benchmark: string interning
    let result = Benchmark.run("String interning", iterations, || {
        // let str = intern_string("test_string_12345")
    })
    result.print()

    // Benchmark: string concatenation
    let result2 = Benchmark.run("String concatenation", iterations, || {
        // let mut sb = StringBuilder.init(allocator)
        // sb.append("Hello")
        // sb.append(" ")
        // sb.append("World")
        // let result = sb.to_string()
    })
    result2.print()
}

// Engine System Benchmarks
export fn benchmark_math_operations() {
    println("\n=== Math Operations Benchmark ===")

    let iterations: u32 = 1000000

    // Benchmark: Vec3 operations
    let result = Benchmark.run("Vec3 dot product", iterations, || {
        // let v1 = Vec3.new(1.0, 2.0, 3.0)
        // let v2 = Vec3.new(4.0, 5.0, 6.0)
        // let dot = Vec3.dot(v1, v2)
    })
    result.print()

    // Benchmark: Mat4 multiplication
    let result2 = Benchmark.run("Mat4 multiplication", iterations / 10, || {
        // let m1 = Mat4.identity()
        // let m2 = Mat4.translation(1.0, 2.0, 3.0)
        // let m3 = Mat4.multiply(m1, m2)
    })
    result2.print()

    // Benchmark: Quaternion operations
    let result3 = Benchmark.run("Quaternion multiplication", iterations, || {
        // let q1 = Quat.from_axis_angle(Vec3.new(0.0, 1.0, 0.0), 1.57)
        // let q2 = Quat.from_axis_angle(Vec3.new(1.0, 0.0, 0.0), 0.785)
        // let q3 = Quat.multiply(q1, q2)
    })
    result3.print()
}

export fn benchmark_ecs_operations() {
    println("\n=== ECS Operations Benchmark ===")

    let iterations: u32 = 100000

    // Benchmark: Entity creation
    let result = Benchmark.run("Entity creation", iterations, || {
        // let ecs = get_global_ecs()
        // let entity = ecs.create_entity()
        // ecs.destroy_entity(entity)
    })
    result.print()

    // Benchmark: Component addition
    let result2 = Benchmark.run("Component addition", iterations, || {
        // let ecs = get_global_ecs()
        // let entity = ecs.create_entity()
        // ecs.add_component(entity, PositionComponent { x: 0.0, y: 0.0, z: 0.0 })
        // ecs.destroy_entity(entity)
    })
    result2.print()

    // Benchmark: Component query (1000 entities)
    // Setup: Create 1000 entities with position components
    let result3 = Benchmark.run("Component query (1000 entities)", 1000, || {
        // let ecs = get_global_ecs()
        // let entities = ecs.query_components<PositionComponent>()
        // // Iterate through all results
    })
    result3.print()
}

export fn benchmark_pathfinding() {
    println("\n=== Pathfinding Benchmark ===")

    let iterations: u32 = 1000

    // Benchmark: A* short path (10 units distance)
    let result = Benchmark.run("A* short path (10 units)", iterations, || {
        // let start = Vec2.new(0.0, 0.0)
        // let goal = Vec2.new(10.0, 10.0)
        // let path = find_path(start, goal)
    })
    result.print()

    // Benchmark: A* medium path (50 units distance)
    let result2 = Benchmark.run("A* medium path (50 units)", iterations / 10, || {
        // let start = Vec2.new(0.0, 0.0)
        // let goal = Vec2.new(50.0, 50.0)
        // let path = find_path(start, goal)
    })
    result2.print()

    // Benchmark: A* long path (200 units distance)
    let result3 = Benchmark.run("A* long path (200 units)", iterations / 100, || {
        // let start = Vec2.new(0.0, 0.0)
        // let goal = Vec2.new(200.0, 200.0)
        // let path = find_path(start, goal)
    })
    result3.print()
}

// Rendering Benchmarks
export fn benchmark_rendering() {
    println("\n=== Rendering Benchmark ===")

    let iterations: u32 = 1000

    // Benchmark: Frustum culling (1000 objects)
    let result = Benchmark.run("Frustum culling (1000 objects)", iterations, || {
        // let optimizer = get_render_optimizer()
        // optimizer.update_visibility(camera_pos, view_proj)
    })
    result.print()

    // Benchmark: Draw call batching (1000 objects)
    let result2 = Benchmark.run("Draw call batching (1000 objects)", iterations, || {
        // let optimizer = get_render_optimizer()
        // optimizer.build_draw_calls()
    })
    result2.print()
}

// Game Logic Benchmarks
export fn benchmark_unit_updates() {
    println("\n=== Unit Update Benchmark ===")

    let iterations: u32 = 1000

    // Benchmark: Update 100 units
    let result = Benchmark.run("Update 100 units", iterations, || {
        // for i in 0..100 {
        //     let unit = get_unit(i)
        //     unit.update(0.033)
        // }
    })
    result.print()

    // Benchmark: Update 1000 units
    let result2 = Benchmark.run("Update 1000 units", iterations / 10, || {
        // for i in 0..1000 {
        //     let unit = get_unit(i)
        //     unit.update(0.033)
        // }
    })
    result2.print()
}

export fn benchmark_combat_calculations() {
    println("\n=== Combat Calculations Benchmark ===")

    let iterations: u32 = 10000

    // Benchmark: Damage calculation
    let result = Benchmark.run("Damage calculation", iterations, || {
        // let attacker = get_unit(0)
        // let target = get_unit(1)
        // let damage = calculate_damage(attacker, target)
    })
    result.print()

    // Benchmark: Line of sight check
    let result2 = Benchmark.run("Line of sight check", iterations, || {
        // let start = Vec3.new(0.0, 0.0, 0.0)
        // let end = Vec3.new(100.0, 0.0, 100.0)
        // let has_los = check_line_of_sight(start, end)
    })
    result2.print()
}

// Networking Benchmarks
export fn benchmark_networking() {
    println("\n=== Networking Benchmark ===")

    let iterations: u32 = 10000

    // Benchmark: Command serialization
    let result = Benchmark.run("Command serialization", iterations, || {
        // let cmd = MoveCommand { unit_id: 1, x: 100.0, y: 200.0 }
        // let bytes = serialize_command(cmd)
    })
    result.print()

    // Benchmark: Game state checksum (1000 entities)
    let result2 = Benchmark.run("Game state checksum (1000 entities)", 100, || {
        // let checksum = calculate_game_state_checksum()
    })
    result2.print()
}

// Object Pooling Benchmarks
export fn benchmark_object_pooling() {
    println("\n=== Object Pooling Benchmark ===")

    let iterations: u32 = 100000

    // Benchmark: Pool acquire/release
    let result = Benchmark.run("Pool acquire/release", iterations, || {
        // let pool = get_particle_pool()
        // let obj = pool.acquire()
        // pool.release(obj)
    })
    result.print()

    // Benchmark: vs regular allocation
    let result2 = Benchmark.run("Regular allocation (comparison)", iterations, || {
        // let obj = allocator.alloc<Particle>()
        // allocator.free(obj)
    })
    result2.print()

    println("\nSpeedup: {result2.avg_time_ms / result.avg_time_ms:.1}x faster")
}

// Frame Time Benchmark (simulated full frame)
export fn benchmark_full_frame() {
    println("\n=== Full Frame Benchmark ===")

    let iterations: u32 = 1000

    let result = Benchmark.run("Full frame (1000 units)", iterations, || {
        // Simulate full game frame with 1000 units

        // 1. Input processing
        // process_input()

        // 2. Logic update (30 Hz)
        // update_game_logic(0.033)

        // 3. Audio update
        // update_audio(0.016)

        // 4. Render
        // render_frame()
    })
    result.print()

    // Check if meeting 60 FPS target (16.66ms per frame)
    if (result.avg_time_ms < 16.66) {
        println("\n✓ MEETING 60 FPS TARGET ({result.avg_time_ms:.2}ms < 16.66ms)")
    } else {
        println("\n✗ NOT MEETING 60 FPS TARGET ({result.avg_time_ms:.2}ms > 16.66ms)")
    }
}

// Run all benchmarks
export fn run_all_benchmarks() {
    println("\n" + "=".repeat(60))
    println("RUNNING PERFORMANCE BENCHMARKS")
    println("=".repeat(60))

    benchmark_memory_allocation()
    benchmark_string_operations()
    benchmark_math_operations()
    benchmark_ecs_operations()
    benchmark_pathfinding()
    benchmark_rendering()
    benchmark_unit_updates()
    benchmark_combat_calculations()
    benchmark_networking()
    benchmark_object_pooling()
    benchmark_full_frame()

    println("\n" + "=".repeat(60))
    println("BENCHMARKS COMPLETE")
    println("=".repeat(60))
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
