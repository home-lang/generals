// C&C Generals Zero Hour - Home Port
// Unit Testing Framework
//
// Simple but comprehensive testing framework for validating
// all game systems before release.
//
// Test categories:
// - Unit tests (individual functions/modules)
// - Integration tests (systems working together)
// - Performance tests (benchmarks)
// - Network tests (multiplayer stress testing)
//
// Usage:
// ```
// test("Memory pool allocation") {
//     let pool = MemoryPool.init(allocator, 1024)
//     let ptr = pool.alloc(64)
//     assert(ptr != null, "Allocation failed!")
//     pool.free(ptr)
// }
//
// benchmark("Pathfinding performance") {
//     run_a_star_pathfinding(start, goal)
// }
// ```

import basics/allocator
import basics/string

const MAX_TESTS: u32 = 1000
const MAX_TEST_NAME_LENGTH: u32 = 128

// Test result
enum TestResult {
    NotRun
    Passed
    Failed
    Skipped
}

// Test case
struct Test {
    name: string
    category: string
    result: TestResult
    error_message: string
    duration_ms: f64

    fn init(name: string, category: string): Test {
        return Test {
            name: name
            category: category
            result: TestResult.NotRun
            error_message: ""
            duration_ms: 0.0
        }
    }
}

// Test suite
struct TestSuite {
    tests: [MAX_TESTS]Test
    test_count: u32

    passed_count: u32
    failed_count: u32
    skipped_count: u32

    allocator: Allocator

    fn init(allocator: Allocator): TestSuite {
        return TestSuite {
            tests: [Test.init("", ""); MAX_TESTS]
            test_count: 0
            passed_count: 0
            failed_count: 0
            skipped_count: 0
            allocator: allocator
        }
    }

    fn add_test(mut self, name: string, category: string) {
        if self.test_count >= MAX_TESTS {
            println("TestSuite: Cannot add test - max limit reached!")
            return
        }

        self.tests[self.test_count] = Test.init(name, category)
        self.test_count += 1
    }

    fn run_test(mut self, test_index: u32, test_fn: fn(): bool) {
        if test_index >= self.test_count {
            return
        }

        println("  Running: {self.tests[test_index].name}...")

        let start_time = get_time_milliseconds()

        // Run test
        let passed = test_fn()

        let end_time = get_time_milliseconds()
        self.tests[test_index].duration_ms = end_time - start_time

        if passed {
            self.tests[test_index].result = TestResult.Passed
            self.passed_count += 1
            println("    ✓ PASSED ({self.tests[test_index].duration_ms:.2}ms)")
        } else {
            self.tests[test_index].result = TestResult.Failed
            self.failed_count += 1
            println("    ✗ FAILED ({self.tests[test_index].duration_ms:.2}ms)")
        }
    }

    fn skip_test(mut self, test_index: u32, reason: string) {
        if test_index >= self.test_count {
            return
        }

        self.tests[test_index].result = TestResult.Skipped
        self.tests[test_index].error_message = reason
        self.skipped_count += 1

        println("  Skipped: {self.tests[test_index].name} - {reason}")
    }

    fn print_summary(self) {
        println("\n" + "=".repeat(60))
        println("TEST SUMMARY")
        println("=".repeat(60))

        println("\nTotal Tests: {self.test_count}")
        println("✓ Passed: {self.passed_count}")
        println("✗ Failed: {self.failed_count}")
        println("○ Skipped: {self.skipped_count}")

        if self.test_count > 0 {
            let pass_rate = @intToFloat(f32, self.passed_count) / @intToFloat(f32, self.test_count) * 100.0
            println("\nPass Rate: {pass_rate:.1}%")
        }

        // Print failed tests
        if self.failed_count > 0 {
            println("\nFAILED TESTS:")
            for i in 0..self.test_count {
                if self.tests[i].result == TestResult.Failed {
                    println("  ✗ {self.tests[i].name}")
                    if self.tests[i].error_message.len > 0 {
                        println("    Error: {self.tests[i].error_message}")
                    }
                }
            }
        }

        println("\n" + "=".repeat(60))
    }

    fn all_tests_passed(self): bool {
        return self.failed_count == 0 and self.test_count > 0
    }
}

// Benchmark result
struct BenchmarkResult {
    name: string
    iterations: u32
    total_time_ms: f64
    avg_time_ms: f64
    min_time_ms: f64
    max_time_ms: f64
    ops_per_second: f64

    fn print(self) {
        println("\n=== Benchmark: {self.name} ===")
        println("Iterations: {self.iterations}")
        println("Total Time: {self.total_time_ms:.2}ms")
        println("Average: {self.avg_time_ms:.4}ms")
        println("Min: {self.min_time_ms:.4}ms")
        println("Max: {self.max_time_ms:.4}ms")
        println("Ops/sec: {self.ops_per_second:.0}")
    }
}

// Benchmark runner
struct Benchmark {
    fn run(name: string, iterations: u32, bench_fn: fn(): void): BenchmarkResult {
        println("Running benchmark: {name} ({iterations} iterations)...")

        let mut min_time = f64.MAX
        let mut max_time: f64 = 0.0
        let mut total_time: f64 = 0.0

        for i in 0..iterations {
            let start = get_time_milliseconds()
            bench_fn()
            let end = get_time_milliseconds()

            let duration = end - start
            total_time += duration

            if duration < min_time {
                min_time = duration
            }

            if duration > max_time {
                max_time = duration
            }
        }

        let avg_time = total_time / @intToFloat(f64, iterations)
        let ops_per_sec = 1000.0 / avg_time

        return BenchmarkResult {
            name: name
            iterations: iterations
            total_time_ms: total_time
            avg_time_ms: avg_time
            min_time_ms: min_time
            max_time_ms: max_time
            ops_per_second: ops_per_sec
        }
    }
}

// Assertion helpers
fn assert(condition: bool, message: string): bool {
    if !condition {
        println("ASSERTION FAILED: {message}")
        return false
    }
    return true
}

fn assert_eq<T>(actual: T, expected: T, message: string): bool {
    if actual != expected {
        println("ASSERTION FAILED: {message}")
        println("  Expected: {expected}")
        println("  Actual: {actual}")
        return false
    }
    return true
}

fn assert_ne<T>(actual: T, unexpected: T, message: string): bool {
    if actual == unexpected {
        println("ASSERTION FAILED: {message}")
        println("  Should not equal: {unexpected}")
        println("  Actual: {actual}")
        return false
    }
    return true
}

fn assert_null(ptr: ?*void, message: string): bool {
    if ptr != null {
        println("ASSERTION FAILED: {message}")
        println("  Expected: null")
        println("  Actual: non-null pointer")
        return false
    }
    return true
}

fn assert_not_null(ptr: ?*void, message: string): bool {
    if ptr == null {
        println("ASSERTION FAILED: {message}")
        println("  Expected: non-null pointer")
        println("  Actual: null")
        return false
    }
    return true
}

fn assert_approx_eq(actual: f32, expected: f32, epsilon: f32, message: string): bool {
    let diff = if actual > expected { actual - expected } else { expected - actual }

    if diff > epsilon {
        println("ASSERTION FAILED: {message}")
        println("  Expected: {expected} (±{epsilon})")
        println("  Actual: {actual}")
        println("  Difference: {diff}")
        return false
    }
    return true
}

// Global test suite
var g_test_suite: ?TestSuite = null

export fn init_test_suite(allocator: Allocator) {
    g_test_suite = TestSuite.init(allocator)
    println("Test Framework: Initialized")
}

export fn shutdown_test_suite() {
    if !g_test_suite {
        return
    }

    g_test_suite.?.print_summary()

    let all_passed = g_test_suite.?.all_tests_passed()
    g_test_suite = null

    println("Test Framework: Shutdown")

    if !all_passed {
        // Exit with error code
        // platform_exit(1)
    }
}

export fn register_test(name: string, category: string) {
    if !g_test_suite {
        return
    }

    g_test_suite.?.add_test(name, category)
}

export fn run_test(test_index: u32, test_fn: fn(): bool) {
    if !g_test_suite {
        return
    }

    g_test_suite.?.run_test(test_index, test_fn)
}

// Platform-specific time function
fn get_time_milliseconds(): f64 {
    // TODO: Platform-specific high-resolution timer
    return 0.0
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
