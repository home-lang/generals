// macOS Window - Home wrapper for Objective-C implementation
//
// This module provides a high-level interface to macOS NSWindow
// through FFI to Objective-C. The actual window creation and event
// handling is done in macos_window.m (Objective-C).
//
// Features:
// - Window creation with title, size, and resizable option
// - Show/hide window
// - Event polling (keyboard, mouse)
// - Native NSWindow handle access for Metal rendering
// - Keyboard state tracking (WASD + arrow keys)
// - Mouse button state tracking (left/right buttons + clicks)


// C-compatible window struct (matches macos_window.m)
struct MacOSWindowC {
    ns_app: i32,           // Opaque pointer to NSApplication
    ns_window: i32,        // Opaque pointer to NSWindow
    should_close: bool,
    // Keyboard state
    key_up: bool,
    key_down: bool,
    key_left: bool,
    key_right: bool,
    key_w: bool,
    key_a: bool,
    key_s: bool,
    key_d: bool,
    // Mouse button state
    mouse_left_down: bool,
    mouse_right_down: bool,
    mouse_left_clicked: bool,
    mouse_right_clicked: bool,
}

// Extern C functions from macos_window.m (Objective-C implementation)
// These are FFI declarations - the actual implementation is in macos_window.m
//
// In production, these would be declared as:
// extern fn macos_window_create(title: string, width: i32, height: i32, resizable: bool): MacOSWindowC
// extern fn macos_window_show(window: MacOSWindowC)
// etc.
//
// For now, we provide stub implementations for compilation

fn macos_window_create_stub(title: string, width: i32, height: i32, resizable: bool): MacOSWindowC {
    return MacOSWindowC {
        ns_app: 0,
        ns_window: 0,
        should_close: false,
        key_up: false,
        key_down: false,
        key_left: false,
        key_right: false,
        key_w: false,
        key_a: false,
        key_s: false,
        key_d: false,
        mouse_left_down: false,
        mouse_right_down: false,
        mouse_left_clicked: false,
        mouse_right_clicked: false,
    }
}

fn macos_window_show_stub(window: MacOSWindowC) {
    // In production: call Objective-C to show NSWindow
}

fn macos_window_hide_stub(window: MacOSWindowC) {
    // In production: call Objective-C to hide NSWindow
}

fn macos_window_poll_events_stub(window: MacOSWindowC): bool {
    // In production: poll NSApplication event loop
    // Returns true if window should continue running, false if close requested
    return !window.should_close
}

fn macos_window_get_native_handle_stub(window: MacOSWindowC): i32 {
    // In production: return NSWindow* as opaque pointer
    return window.ns_window
}

fn macos_window_get_mouse_position_stub(window: MacOSWindowC): MousePosition {
    // In production: get mouse coordinates from NSEvent
    return MousePosition { x: 0.0, y: 0.0 }
}

fn macos_window_destroy_stub(window: MacOSWindowC) {
    // In production: release NSWindow and cleanup
}

// ============================================================================
// Public API
// ============================================================================

struct MousePosition {
    x: f64,
    y: f64,
}

struct KeyboardState {
    up: bool,
    down: bool,
    left: bool,
    right: bool,
    w: bool,
    a: bool,
    s: bool,
    d: bool,
}

struct MouseButtonState {
    left_down: bool,
    right_down: bool,
    left_clicked: bool,
    right_clicked: bool,
}

struct MacOSWindow {
    window: MacOSWindowC,
    width: i32,
    height: i32,
    title: string,
}

fn create_macos_window(title: string, width: i32, height: i32, resizable: bool): MacOSWindow {
    let window = macos_window_create_stub(title, width, height, resizable)

    return MacOSWindow {
        window: window,
        width: width,
        height: height,
        title: title,
    }
}

fn destroy_macos_window(window: MacOSWindow) {
    macos_window_destroy_stub(window.window)
}

fn show_macos_window(window: MacOSWindow) {
    macos_window_show_stub(window.window)
}

fn hide_macos_window(window: MacOSWindow) {
    macos_window_hide_stub(window.window)
}

fn poll_macos_window_events(window: MacOSWindow): bool {
    return macos_window_poll_events_stub(window.window)
}

fn get_native_handle(window: MacOSWindow): i32 {
    return macos_window_get_native_handle_stub(window.window)
}

fn get_mouse_position(window: MacOSWindow): MousePosition {
    return macos_window_get_mouse_position_stub(window.window)
}

fn get_keyboard_state(window: MacOSWindow): KeyboardState {
    return KeyboardState {
        up: window.window.key_up,
        down: window.window.key_down,
        left: window.window.key_left,
        right: window.window.key_right,
        w: window.window.key_w,
        a: window.window.key_a,
        s: window.window.key_s,
        d: window.window.key_d,
    }
}

fn get_mouse_button_state(window: MacOSWindow): MouseButtonState {
    return MouseButtonState {
        left_down: window.window.mouse_left_down,
        right_down: window.window.mouse_right_down,
        left_clicked: window.window.mouse_left_clicked,
        right_clicked: window.window.mouse_right_clicked,
    }
}

fn should_close(window: MacOSWindow): bool {
    return window.window.should_close
}

fn set_should_close(window: MacOSWindow, value: bool) {
    window.window.should_close = value
}

// ============================================================================
// Helper Functions
// ============================================================================

fn is_key_pressed(window: MacOSWindow, key: string): bool {
    let state = get_keyboard_state(window)

    if (key == "up") {
        return state.up
    }
    if (key == "down") {
        return state.down
    }
    if (key == "left") {
        return state.left
    }
    if (key == "right") {
        return state.right
    }
    if (key == "w") {
        return state.w
    }
    if (key == "a") {
        return state.a
    }
    if (key == "s") {
        return state.s
    }
    if (key == "d") {
        return state.d
    }

    return false
}

fn is_mouse_button_down(window: MacOSWindow, button: string): bool {
    let state = get_mouse_button_state(window)

    if (button == "left") {
        return state.left_down
    }
    if (button == "right") {
        return state.right_down
    }

    return false
}

fn was_mouse_button_clicked(window: MacOSWindow, button: string): bool {
    let state = get_mouse_button_state(window)

    if (button == "left") {
        return state.left_clicked
    }
    if (button == "right") {
        return state.right_clicked
    }

    return false
}

// ============================================================================
// Tests
// ============================================================================

fn test_window_creation(): bool {
    let window = create_macos_window("Test Window", 1024, 768, true)
    assert(window.width == 1024, "Window width should be 1024")
    assert(window.height == 768, "Window height should be 768")
    assert(window.title == "Test Window", "Window title should be 'Test Window'")
    destroy_macos_window(window)
    return true
}

fn test_window_show_hide(): bool {
    let window = create_macos_window("Test", 800, 600, false)
    show_macos_window(window)
    hide_macos_window(window)
    destroy_macos_window(window)
    return true
}

fn test_event_polling(): bool {
    let window = create_macos_window("Test", 640, 480, true)
    let should_continue = poll_macos_window_events(window)
    assert(should_continue == true, "Window should not close initially")
    destroy_macos_window(window)
    return true
}

fn test_native_handle(): bool {
    let window = create_macos_window("Test", 800, 600, true)
    let handle = get_native_handle(window)
    // Note: handle will be 0 in stub implementation
    assert(handle >= 0, "Native handle should be valid")
    destroy_macos_window(window)
    return true
}

fn test_mouse_position(): bool {
    let window = create_macos_window("Test", 800, 600, true)
    let pos = get_mouse_position(window)
    assert(pos.x >= 0.0, "Mouse X should be non-negative")
    assert(pos.y >= 0.0, "Mouse Y should be non-negative")
    destroy_macos_window(window)
    return true
}

fn test_keyboard_state(): bool {
    let window = create_macos_window("Test", 800, 600, true)
    let state = get_keyboard_state(window)
    // All keys should be unpressed initially
    assert(state.up == false, "Up key should be unpressed")
    assert(state.down == false, "Down key should be unpressed")
    assert(state.left == false, "Left key should be unpressed")
    assert(state.right == false, "Right key should be unpressed")
    assert(state.w == false, "W key should be unpressed")
    assert(state.a == false, "A key should be unpressed")
    assert(state.s == false, "S key should be unpressed")
    assert(state.d == false, "D key should be unpressed")
    destroy_macos_window(window)
    return true
}

fn test_mouse_button_state(): bool {
    let window = create_macos_window("Test", 800, 600, true)
    let state = get_mouse_button_state(window)
    // All buttons should be unpressed initially
    assert(state.left_down == false, "Left button should be unpressed")
    assert(state.right_down == false, "Right button should be unpressed")
    assert(state.left_clicked == false, "Left button should not be clicked")
    assert(state.right_clicked == false, "Right button should not be clicked")
    destroy_macos_window(window)
    return true
}

fn test_should_close(): bool {
    let window = create_macos_window("Test", 800, 600, true)
    assert(should_close(window) == false, "Window should not close initially")
    set_should_close(window, true)
    assert(should_close(window) == true, "Window should close after setting")
    destroy_macos_window(window)
    return true
}

fn test_is_key_pressed(): bool {
    let window = create_macos_window("Test", 800, 600, true)
    assert(is_key_pressed(window, "w") == false, "W key should be unpressed")
    assert(is_key_pressed(window, "up") == false, "Up key should be unpressed")
    destroy_macos_window(window)
    return true
}

fn test_is_mouse_button_down(): bool {
    let window = create_macos_window("Test", 800, 600, true)
    assert(is_mouse_button_down(window, "left") == false, "Left button should be unpressed")
    assert(is_mouse_button_down(window, "right") == false, "Right button should be unpressed")
    destroy_macos_window(window)
    return true
}

fn test_was_mouse_button_clicked(): bool {
    let window = create_macos_window("Test", 800, 600, true)
    assert(was_mouse_button_clicked(window, "left") == false, "Left button should not be clicked")
    assert(was_mouse_button_clicked(window, "right") == false, "Right button should not be clicked")
    destroy_macos_window(window)
    return true
}

fn run_all_tests(): bool {
    assert(test_window_creation(), "test_window_creation failed")
    assert(test_window_show_hide(), "test_window_show_hide failed")
    assert(test_event_polling(), "test_event_polling failed")
    assert(test_native_handle(), "test_native_handle failed")
    assert(test_mouse_position(), "test_mouse_position failed")
    assert(test_keyboard_state(), "test_keyboard_state failed")
    assert(test_mouse_button_state(), "test_mouse_button_state failed")
    assert(test_should_close(), "test_should_close failed")
    assert(test_is_key_pressed(), "test_is_key_pressed failed")
    assert(test_is_mouse_button_down(), "test_is_mouse_button_down failed")
    assert(test_was_mouse_button_clicked(), "test_was_mouse_button_clicked failed")
    return true
}
