// macOS Metal Renderer - Home wrapper for Objective-C Metal implementation
//
// This module provides a high-level interface to Apple's Metal graphics API
// through FFI to Objective-C. The actual Metal device, command queue, and
// rendering is done in macos_renderer.m (Objective-C).
//
// Features:
// - Metal device creation and initialization
// - Command queue management
// - Metal layer (CAMetalLayer) setup
// - Frame rendering with clear color
// - Automatic drawable acquisition and presentation
//
// Usage:
//   let window = create_macos_window("Game", 1024, 768, true)
//   let ns_window = get_native_handle(window)
//   let renderer = create_macos_renderer(ns_window)
//
//   while poll_macos_window_events(window) {
//       render_frame(renderer, 0.0, 0.5, 1.0, 1.0)  // Blue background
//   }
//
//   destroy_macos_renderer(renderer)
//   destroy_macos_window(window)


// C-compatible renderer struct (matches macos_renderer.m)
struct MacOSRendererC {
    metal_device: i32,         // Opaque pointer to id<MTLDevice>
    metal_command_queue: i32,  // Opaque pointer to id<MTLCommandQueue>
    metal_layer: i32,          // Opaque pointer to CAMetalLayer
}

// Extern C functions from macos_renderer.m (Objective-C implementation)
// These are FFI declarations - the actual implementation is in macos_renderer.m
//
// In production, these would be declared as:
// extern fn macos_renderer_create(ns_window: i32): MacOSRendererC
// extern fn macos_renderer_render_frame(renderer: MacOSRendererC, r: f64, g: f64, b: f64, a: f64): bool
// extern fn macos_renderer_destroy(renderer: MacOSRendererC)
//
// For now, we provide stub implementations for compilation

fn macos_renderer_create_stub(ns_window: i32): MacOSRendererC {
    // In production: create Metal device, command queue, and layer
    // MTLDevice *device = MTLCreateSystemDefaultDevice()
    // id<MTLCommandQueue> queue = [device newCommandQueue]
    // CAMetalLayer *layer = [CAMetalLayer layer]
    // [layer setDevice:device]
    // [nsWindow.contentView setLayer:layer]

    return MacOSRendererC {
        metal_device: 1,         // Mock device pointer
        metal_command_queue: 2,  // Mock queue pointer
        metal_layer: 3,          // Mock layer pointer
    }
}

fn macos_renderer_render_frame_stub(renderer: MacOSRendererC, r: f64, g: f64, b: f64, a: f64): bool {
    // In production: render a frame with clear color
    //
    // id<CAMetalDrawable> drawable = [layer nextDrawable]
    // id<MTLCommandBuffer> commandBuffer = [queue commandBuffer]
    // MTLRenderPassDescriptor *renderPass = [MTLRenderPassDescriptor new]
    // renderPass.colorAttachments[0].texture = drawable.texture
    // renderPass.colorAttachments[0].loadAction = MTLLoadActionClear
    // renderPass.colorAttachments[0].clearColor = MTLClearColorMake(r, g, b, a)
    // id<MTLRenderCommandEncoder> encoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPass]
    // [encoder endEncoding]
    // [commandBuffer presentDrawable:drawable]
    // [commandBuffer commit]

    return true
}

fn macos_renderer_destroy_stub(renderer: MacOSRendererC) {
    // In production: release Metal resources
    // [device release]
    // [queue release]
    // [layer release]
}

// ============================================================================
// Public API
// ============================================================================

struct MacOSRenderer {
    renderer: MacOSRendererC,
    clear_color: Color,
}

struct Color {
    r: f64,
    g: f64,
    b: f64,
    a: f64,
}

fn create_macos_renderer(ns_window: i32): MacOSRenderer {
    let renderer = macos_renderer_create_stub(ns_window)

    return MacOSRenderer {
        renderer: renderer,
        clear_color: Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
    }
}

fn destroy_macos_renderer(renderer: MacOSRenderer) {
    macos_renderer_destroy_stub(renderer.renderer)
}

fn render_frame(renderer: MacOSRenderer, r: f64, g: f64, b: f64, a: f64): bool {
    return macos_renderer_render_frame_stub(renderer.renderer, r, g, b, a)
}

fn render_frame_with_color(renderer: MacOSRenderer, color: Color): bool {
    return macos_renderer_render_frame_stub(renderer.renderer, color.r, color.g, color.b, color.a)
}

fn render_clear_frame(renderer: MacOSRenderer): bool {
    let color = renderer.clear_color
    return macos_renderer_render_frame_stub(renderer.renderer, color.r, color.g, color.b, color.a)
}

fn set_clear_color(renderer: MacOSRenderer, r: f64, g: f64, b: f64, a: f64) {
    renderer.clear_color = Color { r: r, g: g, b: b, a: a }
}

fn get_metal_device(renderer: MacOSRenderer): i32 {
    return renderer.renderer.metal_device
}

fn get_metal_command_queue(renderer: MacOSRenderer): i32 {
    return renderer.renderer.metal_command_queue
}

fn get_metal_layer(renderer: MacOSRenderer): i32 {
    return renderer.renderer.metal_layer
}

fn is_metal_supported(renderer: MacOSRenderer): bool {
    return renderer.renderer.metal_device != 0
}

// ============================================================================
// Color Helpers
// ============================================================================

fn create_color(r: f64, g: f64, b: f64, a: f64): Color {
    return Color { r: r, g: g, b: b, a: a }
}

fn color_white(): Color {
    return Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }
}

fn color_black(): Color {
    return Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }
}

fn color_red(): Color {
    return Color { r: 1.0, g: 0.0, b: 0.0, a: 1.0 }
}

fn color_green(): Color {
    return Color { r: 0.0, g: 1.0, b: 0.0, a: 1.0 }
}

fn color_blue(): Color {
    return Color { r: 0.0, g: 0.0, b: 1.0, a: 1.0 }
}

fn color_cornflower_blue(): Color {
    return Color { r: 0.392, g: 0.584, b: 0.929, a: 1.0 }
}

fn color_from_rgb(r: i32, g: i32, b: i32): Color {
    return Color {
        r: float(r) / 255.0,
        g: float(g) / 255.0,
        b: float(b) / 255.0,
        a: 1.0,
    }
}

fn color_from_rgba(r: i32, g: i32, b: i32, a: i32): Color {
    return Color {
        r: float(r) / 255.0,
        g: float(g) / 255.0,
        b: float(b) / 255.0,
        a: float(a) / 255.0,
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

fn float(value: i32): f64 {
    return 0.0 + value
}

fn clamp(value: f64, min: f64, max: f64): f64 {
    if value < min {
        return min
    }
    if value > max {
        return max
    }
    return value
}

// ============================================================================
// Tests
// ============================================================================

fn test_renderer_creation(): bool {
    let ns_window = 123  // Mock NSWindow pointer
    let renderer = create_macos_renderer(ns_window)
    assert(is_metal_supported(renderer), "Metal should be supported")
    destroy_macos_renderer(renderer)
    return true
}

fn test_render_frame(): bool {
    let ns_window = 123
    let renderer = create_macos_renderer(ns_window)
    let success = render_frame(renderer, 0.0, 0.5, 1.0, 1.0)
    assert(success == true, "Render frame should succeed")
    destroy_macos_renderer(renderer)
    return true
}

fn test_clear_color(): bool {
    let ns_window = 123
    let renderer = create_macos_renderer(ns_window)
    set_clear_color(renderer, 1.0, 0.0, 0.0, 1.0)
    assert(renderer.clear_color.r == 1.0, "Clear color R should be 1.0")
    assert(renderer.clear_color.g == 0.0, "Clear color G should be 0.0")
    assert(renderer.clear_color.b == 0.0, "Clear color B should be 0.0")
    assert(renderer.clear_color.a == 1.0, "Clear color A should be 1.0")
    destroy_macos_renderer(renderer)
    return true
}

fn test_render_with_color(): bool {
    let ns_window = 123
    let renderer = create_macos_renderer(ns_window)
    let red = color_red()
    let success = render_frame_with_color(renderer, red)
    assert(success == true, "Render with color should succeed")
    destroy_macos_renderer(renderer)
    return true
}

fn test_metal_handles(): bool {
    let ns_window = 123
    let renderer = create_macos_renderer(ns_window)
    assert(get_metal_device(renderer) > 0, "Metal device should be valid")
    assert(get_metal_command_queue(renderer) > 0, "Metal command queue should be valid")
    assert(get_metal_layer(renderer) > 0, "Metal layer should be valid")
    destroy_macos_renderer(renderer)
    return true
}

fn test_color_helpers(): bool {
    let white = color_white()
    assert(white.r == 1.0 && white.g == 1.0 && white.b == 1.0, "White should be (1,1,1)")

    let black = color_black()
    assert(black.r == 0.0 && black.g == 0.0 && black.b == 0.0, "Black should be (0,0,0)")

    let red = color_red()
    assert(red.r == 1.0 && red.g == 0.0 && red.b == 0.0, "Red should be (1,0,0)")

    let green = color_green()
    assert(green.r == 0.0 && green.g == 1.0 && green.b == 0.0, "Green should be (0,1,0)")

    let blue = color_blue()
    assert(blue.r == 0.0 && blue.g == 0.0 && blue.b == 1.0, "Blue should be (0,0,1)")

    return true
}

fn test_color_from_rgb(): bool {
    let color = color_from_rgb(255, 128, 64)
    assert(color.r == 1.0, "R should be 1.0")
    assert(color.g > 0.5 && color.g < 0.51, "G should be ~0.5")
    assert(color.b > 0.25 && color.b < 0.26, "B should be ~0.25")
    assert(color.a == 1.0, "A should be 1.0")
    return true
}

fn test_color_from_rgba(): bool {
    let color = color_from_rgba(255, 0, 0, 128)
    assert(color.r == 1.0, "R should be 1.0")
    assert(color.g == 0.0, "G should be 0.0")
    assert(color.b == 0.0, "B should be 0.0")
    assert(color.a > 0.5 && color.a < 0.51, "A should be ~0.5")
    return true
}

fn test_clamp(): bool {
    assert(clamp(0.5, 0.0, 1.0) == 0.5, "0.5 should clamp to 0.5")
    assert(clamp(-0.5, 0.0, 1.0) == 0.0, "-0.5 should clamp to 0.0")
    assert(clamp(1.5, 0.0, 1.0) == 1.0, "1.5 should clamp to 1.0")
    return true
}

fn test_render_clear_frame(): bool {
    let ns_window = 123
    let renderer = create_macos_renderer(ns_window)
    set_clear_color(renderer, 0.2, 0.3, 0.4, 1.0)
    let success = render_clear_frame(renderer)
    assert(success == true, "Render clear frame should succeed")
    destroy_macos_renderer(renderer)
    return true
}

fn run_all_tests(): bool {
    assert(test_renderer_creation(), "test_renderer_creation failed")
    assert(test_render_frame(), "test_render_frame failed")
    assert(test_clear_color(), "test_clear_color failed")
    assert(test_render_with_color(), "test_render_with_color failed")
    assert(test_metal_handles(), "test_metal_handles failed")
    assert(test_color_helpers(), "test_color_helpers failed")
    assert(test_color_from_rgb(), "test_color_from_rgb failed")
    assert(test_color_from_rgba(), "test_color_from_rgba failed")
    assert(test_clamp(), "test_clamp failed")
    assert(test_render_clear_frame(), "test_render_clear_frame failed")
    return true
}
