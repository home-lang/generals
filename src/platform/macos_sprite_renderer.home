// macOS Sprite Renderer - Home wrapper for Metal sprite batching
//
// This module provides 2D sprite rendering with Metal, optimized for
// real-time games. The actual Metal pipeline, vertex buffers, and
// rendering is done in macos_sprite_renderer.m (Objective-C).
//
// Features:
// - Texture creation from BGRA pixel data
// - Batched sprite rendering (multiple sprites per frame)
// - Filled rectangle drawing
// - Selection circle rendering (for RTS unit selection)
// - Render pass management with begin/end frame
// - Viewport-aware coordinate system
//
// Usage:
//   let window = create_macos_window("Game", 1024, 768, true)
//   let ns_window = get_native_handle(window)
//   let renderer = create_sprite_renderer(ns_window)
//
//   // Create texture
//   let texture_data = [...] // BGRA pixel data
//   let texture = create_texture(renderer, 64, 64, texture_data)
//
//   // Render loop
//   while poll_macos_window_events(window) {
//       let ctx = begin_frame(renderer)
//       draw_sprite_batched(renderer, ctx, texture, 100.0, 100.0, 64.0, 64.0)
//       draw_rect(renderer, ctx, 50.0, 50.0, 200.0, 100.0, 1.0, 0.0, 0.0, 1.0)
//       end_frame(renderer, ctx)
//   }
//
//   destroy_texture(texture)
//   destroy_sprite_renderer(renderer)

import graphics::{Vec2}

// C-compatible sprite renderer struct
struct SpriteRendererC {
    metal_device: i32,           // Opaque pointer to id<MTLDevice>
    metal_command_queue: i32,    // Opaque pointer to id<MTLCommandQueue>
    metal_layer: i32,            // Opaque pointer to CAMetalLayer
    pipeline_state: i32,         // Opaque pointer to id<MTLRenderPipelineState> (sprite)
    sampler_state: i32,          // Opaque pointer to id<MTLSamplerState>
    vertex_buffer: i32,          // Opaque pointer to id<MTLBuffer> (sprite vertices)
    color_pipeline_state: i32,   // Opaque pointer to id<MTLRenderPipelineState> (color)
    color_vertex_buffer: i32,    // Opaque pointer to id<MTLBuffer> (color vertices)
    viewport_width: f64,
    viewport_height: f64,
}

// Render context for batched rendering
struct RenderContextC {
    drawable: i32,          // Opaque pointer to id<CAMetalDrawable>
    command_buffer: i32,    // Opaque pointer to id<MTLCommandBuffer>
    render_encoder: i32,    // Opaque pointer to id<MTLRenderCommandEncoder>
}

// Extern C functions from macos_sprite_renderer.m
// These are FFI declarations - the actual implementation is in macos_sprite_renderer.m
//
// For now, we provide stub implementations for compilation

fn sprite_renderer_create_stub(ns_window: i32): SpriteRendererC {
    // In production: create Metal sprite renderer
    // - Load sprite vertex/fragment shaders
    // - Create render pipeline state
    // - Create sampler state (linear filtering, clamp to edge)
    // - Allocate vertex buffer for quad vertices
    // - Create color pipeline for filled shapes
    // - Get viewport dimensions from NSWindow

    return SpriteRendererC {
        metal_device: 1,
        metal_command_queue: 2,
        metal_layer: 3,
        pipeline_state: 4,
        sampler_state: 5,
        vertex_buffer: 6,
        color_pipeline_state: 7,
        color_vertex_buffer: 8,
        viewport_width: 1024.0,
        viewport_height: 768.0,
    }
}

fn sprite_renderer_create_texture_stub(renderer: SpriteRendererC, width: i32, height: i32, data: Vec<i32>): i32 {
    // In production: create MTLTexture from BGRA data
    // MTLTextureDescriptor *desc = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
    //                                                                                   width:width
    //                                                                                  height:height
    //                                                                               mipmapped:NO]
    // id<MTLTexture> texture = [device newTextureWithDescriptor:desc]
    // [texture replaceRegion:MTLRegionMake2D(0, 0, width, height)
    //               mipmapLevel:0
    //                 withBytes:data.ptr
    //               bytesPerRow:width * 4]

    return 100  // Mock texture pointer
}

fn sprite_renderer_draw_sprite_stub(renderer: SpriteRendererC, texture: i32, x: f64, y: f64, width: f64, height: f64): bool {
    // In production: immediate mode sprite draw (creates own render pass)
    // Not recommended - use batched version instead
    return true
}

fn sprite_renderer_begin_frame_stub(renderer: SpriteRendererC): RenderContextC {
    // In production: begin new frame
    // id<CAMetalDrawable> drawable = [layer nextDrawable]
    // id<MTLCommandBuffer> commandBuffer = [commandQueue commandBuffer]
    // MTLRenderPassDescriptor *renderPass = [MTLRenderPassDescriptor new]
    // renderPass.colorAttachments[0].texture = drawable.texture
    // renderPass.colorAttachments[0].loadAction = MTLLoadActionClear
    // renderPass.colorAttachments[0].clearColor = MTLClearColorMake(0, 0, 0, 1)
    // id<MTLRenderCommandEncoder> encoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPass]

    return RenderContextC {
        drawable: 1000,
        command_buffer: 1001,
        render_encoder: 1002,
    }
}

fn sprite_renderer_draw_sprite_batched_stub(renderer: SpriteRendererC, ctx: RenderContextC, texture: i32, x: f64, y: f64, width: f64, height: f64) {
    // In production: encode sprite draw command
    // - Convert screen coordinates to NDC (-1 to 1)
    // - Update vertex buffer with quad vertices
    // - Set pipeline state (sprite shader)
    // - Set texture and sampler
    // - Draw indexed triangles (2 triangles = 1 quad)
}

fn sprite_renderer_draw_rect_stub(renderer: SpriteRendererC, ctx: RenderContextC, x: f64, y: f64, width: f64, height: f64, r: f64, g: f64, b: f64, a: f64) {
    // In production: encode filled rectangle
    // - Convert screen coordinates to NDC
    // - Update color vertex buffer
    // - Set pipeline state (color shader)
    // - Set color uniform
    // - Draw triangles
}

fn sprite_renderer_draw_selection_circle_stub(renderer: SpriteRendererC, ctx: RenderContextC, center_x: f64, center_y: f64, radius: f64, r: f64, g: f64, b: f64, a: f64) {
    // In production: encode selection circle
    // - Generate circle vertices (32 segments)
    // - Convert to NDC
    // - Set pipeline state (color shader)
    // - Set color uniform
    // - Draw triangle fan or line strip
}

fn sprite_renderer_end_frame_stub(renderer: SpriteRendererC, ctx: RenderContextC) {
    // In production: end frame and present
    // [encoder endEncoding]
    // [commandBuffer presentDrawable:drawable]
    // [commandBuffer commit]
}

fn sprite_renderer_destroy_texture_stub(texture: i32) {
    // In production: release MTLTexture
    // [texture release]
}

fn sprite_renderer_destroy_stub(renderer: SpriteRendererC) {
    // In production: release all Metal resources
    // [device release]
    // [commandQueue release]
    // [layer release]
    // [pipelineState release]
    // [samplerState release]
    // [vertexBuffer release]
    // [colorPipelineState release]
    // [colorVertexBuffer release]
}

// ============================================================================
// Public API
// ============================================================================

struct Texture {
    ptr: i32,
    width: i32,
    height: i32,
}

struct RenderContext {
    ctx: RenderContextC,
}

struct SpriteRenderer {
    renderer: SpriteRendererC,
}

fn create_sprite_renderer(ns_window: i32): SpriteRenderer {
    let renderer = sprite_renderer_create_stub(ns_window)

    return SpriteRenderer {
        renderer: renderer,
    }
}

fn destroy_sprite_renderer(renderer: SpriteRenderer) {
    sprite_renderer_destroy_stub(renderer.renderer)
}

fn create_texture(renderer: SpriteRenderer, width: i32, height: i32, data: Vec<i32>): Texture {
    let texture_ptr = sprite_renderer_create_texture_stub(renderer.renderer, width, height, data)

    return Texture {
        ptr: texture_ptr,
        width: width,
        height: height,
    }
}

fn destroy_texture(texture: Texture) {
    sprite_renderer_destroy_texture_stub(texture.ptr)
}

fn draw_sprite(renderer: SpriteRenderer, texture: Texture, x: f64, y: f64, width: f64, height: f64): bool {
    return sprite_renderer_draw_sprite_stub(renderer.renderer, texture.ptr, x, y, width, height)
}

fn begin_frame(renderer: SpriteRenderer): RenderContext {
    let ctx = sprite_renderer_begin_frame_stub(renderer.renderer)
    return RenderContext { ctx: ctx }
}

fn end_frame(renderer: SpriteRenderer, ctx: RenderContext) {
    sprite_renderer_end_frame_stub(renderer.renderer, ctx.ctx)
}

fn draw_sprite_batched(renderer: SpriteRenderer, ctx: RenderContext, texture: Texture, x: f64, y: f64, width: f64, height: f64) {
    sprite_renderer_draw_sprite_batched_stub(renderer.renderer, ctx.ctx, texture.ptr, x, y, width, height)
}

fn draw_rect(renderer: SpriteRenderer, ctx: RenderContext, x: f64, y: f64, width: f64, height: f64, r: f64, g: f64, b: f64, a: f64) {
    sprite_renderer_draw_rect_stub(renderer.renderer, ctx.ctx, x, y, width, height, r, g, b, a)
}

fn draw_selection_circle(renderer: SpriteRenderer, ctx: RenderContext, center_x: f64, center_y: f64, radius: f64, r: f64, g: f64, b: f64, a: f64) {
    sprite_renderer_draw_selection_circle_stub(renderer.renderer, ctx.ctx, center_x, center_y, radius, r, g, b, a)
}

fn is_render_context_valid(ctx: RenderContext): bool {
    return ctx.ctx.render_encoder != 0
}

fn get_viewport_width(renderer: SpriteRenderer): f64 {
    return renderer.renderer.viewport_width
}

fn get_viewport_height(renderer: SpriteRenderer): f64 {
    return renderer.renderer.viewport_height
}

// ============================================================================
// Helper Functions
// ============================================================================

fn create_solid_color_texture(renderer: SpriteRenderer, width: i32, height: i32, r: i32, g: i32, b: i32, a: i32): Texture {
    // Create texture filled with solid color (BGRA format)
    let data = Vec::new<i32>()
    let total_pixels = width * height

    let i = 0
    while i < total_pixels {
        data.push(b)  // Blue
        data.push(g)  // Green
        data.push(r)  // Red
        data.push(a)  // Alpha
        i = i + 1
    }

    return create_texture(renderer, width, height, data)
}

fn create_white_texture(renderer: SpriteRenderer): Texture {
    return create_solid_color_texture(renderer, 1, 1, 255, 255, 255, 255)
}

fn screen_to_ndc(screen_x: f64, screen_y: f64, viewport_width: f64, viewport_height: f64): Vec2 {
    // Convert screen coordinates (0,0 top-left) to NDC (-1,-1 bottom-left, 1,1 top-right)
    let ndc_x = (screen_x / viewport_width) * 2.0 - 1.0
    let ndc_y = 1.0 - (screen_y / viewport_height) * 2.0

    return Vec2 { x: ndc_x, y: ndc_y }
}

fn ndc_to_screen(ndc_x: f64, ndc_y: f64, viewport_width: f64, viewport_height: f64): Vec2 {
    // Convert NDC to screen coordinates
    let screen_x = (ndc_x + 1.0) * viewport_width / 2.0
    let screen_y = (1.0 - ndc_y) * viewport_height / 2.0

    return Vec2 { x: screen_x, y: screen_y }
}

// ============================================================================
// Tests
// ============================================================================

fn test_sprite_renderer_creation(): bool {
    let ns_window = 123
    let renderer = create_sprite_renderer(ns_window)
    assert(get_viewport_width(renderer) > 0.0, "Viewport width should be positive")
    assert(get_viewport_height(renderer) > 0.0, "Viewport height should be positive")
    destroy_sprite_renderer(renderer)
    return true
}

fn test_texture_creation(): bool {
    let ns_window = 123
    let renderer = create_sprite_renderer(ns_window)

    let data = Vec::new<i32>()
    let i = 0
    while i < 64 * 64 * 4 {  // 64x64 BGRA
        data.push(255)
        i = i + 1
    }

    let texture = create_texture(renderer, 64, 64, data)
    assert(texture.width == 64, "Texture width should be 64")
    assert(texture.height == 64, "Texture height should be 64")
    assert(texture.ptr > 0, "Texture pointer should be valid")

    destroy_texture(texture)
    destroy_sprite_renderer(renderer)
    return true
}

fn test_render_context(): bool {
    let ns_window = 123
    let renderer = create_sprite_renderer(ns_window)

    let ctx = begin_frame(renderer)
    assert(is_render_context_valid(ctx), "Render context should be valid")

    end_frame(renderer, ctx)
    destroy_sprite_renderer(renderer)
    return true
}

fn test_draw_sprite_batched(): bool {
    let ns_window = 123
    let renderer = create_sprite_renderer(ns_window)

    let data = Vec::new<i32>()
    let i = 0
    while i < 32 * 32 * 4 {
        data.push(255)
        i = i + 1
    }
    let texture = create_texture(renderer, 32, 32, data)

    let ctx = begin_frame(renderer)
    draw_sprite_batched(renderer, ctx, texture, 100.0, 100.0, 32.0, 32.0)
    end_frame(renderer, ctx)

    destroy_texture(texture)
    destroy_sprite_renderer(renderer)
    return true
}

fn test_draw_rect(): bool {
    let ns_window = 123
    let renderer = create_sprite_renderer(ns_window)

    let ctx = begin_frame(renderer)
    draw_rect(renderer, ctx, 50.0, 50.0, 200.0, 100.0, 1.0, 0.0, 0.0, 1.0)
    end_frame(renderer, ctx)

    destroy_sprite_renderer(renderer)
    return true
}

fn test_draw_selection_circle(): bool {
    let ns_window = 123
    let renderer = create_sprite_renderer(ns_window)

    let ctx = begin_frame(renderer)
    draw_selection_circle(renderer, ctx, 512.0, 384.0, 50.0, 0.0, 1.0, 0.0, 1.0)
    end_frame(renderer, ctx)

    destroy_sprite_renderer(renderer)
    return true
}

fn test_solid_color_texture(): bool {
    let ns_window = 123
    let renderer = create_sprite_renderer(ns_window)

    let red_texture = create_solid_color_texture(renderer, 16, 16, 255, 0, 0, 255)
    assert(red_texture.width == 16, "Texture width should be 16")
    assert(red_texture.height == 16, "Texture height should be 16")

    destroy_texture(red_texture)
    destroy_sprite_renderer(renderer)
    return true
}

fn test_white_texture(): bool {
    let ns_window = 123
    let renderer = create_sprite_renderer(ns_window)

    let white = create_white_texture(renderer)
    assert(white.width == 1, "White texture width should be 1")
    assert(white.height == 1, "White texture height should be 1")

    destroy_texture(white)
    destroy_sprite_renderer(renderer)
    return true
}

fn test_screen_to_ndc(): bool {
    let viewport_width = 1024.0
    let viewport_height = 768.0

    // Center of screen should be (0, 0) in NDC
    let center = screen_to_ndc(512.0, 384.0, viewport_width, viewport_height)
    assert(center.x > -0.01 && center.x < 0.01, "Center X should be ~0")
    assert(center.y > -0.01 && center.y < 0.01, "Center Y should be ~0")

    // Top-left should be (-1, 1)
    let top_left = screen_to_ndc(0.0, 0.0, viewport_width, viewport_height)
    assert(top_left.x == -1.0, "Top-left X should be -1")
    assert(top_left.y == 1.0, "Top-left Y should be 1")

    // Bottom-right should be (1, -1)
    let bottom_right = screen_to_ndc(1024.0, 768.0, viewport_width, viewport_height)
    assert(bottom_right.x == 1.0, "Bottom-right X should be 1")
    assert(bottom_right.y == -1.0, "Bottom-right Y should be -1")

    return true
}

fn test_ndc_to_screen(): bool {
    let viewport_width = 1024.0
    let viewport_height = 768.0

    // (0, 0) in NDC should be center of screen
    let center = ndc_to_screen(0.0, 0.0, viewport_width, viewport_height)
    assert(center.x == 512.0, "Center X should be 512")
    assert(center.y == 384.0, "Center Y should be 384")

    // (-1, 1) in NDC should be top-left
    let top_left = ndc_to_screen(-1.0, 1.0, viewport_width, viewport_height)
    assert(top_left.x == 0.0, "Top-left X should be 0")
    assert(top_left.y == 0.0, "Top-left Y should be 0")

    // (1, -1) in NDC should be bottom-right
    let bottom_right = ndc_to_screen(1.0, -1.0, viewport_width, viewport_height)
    assert(bottom_right.x == 1024.0, "Bottom-right X should be 1024")
    assert(bottom_right.y == 768.0, "Bottom-right Y should be 768")

    return true
}

fn run_all_tests(): bool {
    assert(test_sprite_renderer_creation(), "test_sprite_renderer_creation failed")
    assert(test_texture_creation(), "test_texture_creation failed")
    assert(test_render_context(), "test_render_context failed")
    assert(test_draw_sprite_batched(), "test_draw_sprite_batched failed")
    assert(test_draw_rect(), "test_draw_rect failed")
    assert(test_draw_selection_circle(), "test_draw_selection_circle failed")
    assert(test_solid_color_texture(), "test_solid_color_texture failed")
    assert(test_white_texture(), "test_white_texture failed")
    assert(test_screen_to_ndc(), "test_screen_to_ndc failed")
    assert(test_ndc_to_screen(), "test_ndc_to_screen failed")
    return true
}
