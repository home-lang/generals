// C&C Generals Zero Hour - Home Port
// Platform Window Management
//
// Original: Win32Window.cpp (Westwood Studios/EA)
// Ported to Home with cross-platform support (Windows, macOS, Linux)

import basics/allocator
import graphics/renderer

// Window creation flags
const WINDOW_RESIZABLE: u32 = 0x0001
const WINDOW_FULLSCREEN: u32 = 0x0002
const WINDOW_BORDERLESS: u32 = 0x0004
const WINDOW_VSYNC: u32 = 0x0008
const WINDOW_HIGH_DPI: u32 = 0x0010
const WINDOW_ALWAYS_ON_TOP: u32 = 0x0020

// Window events
enum WindowEvent {
    None
    Close
    Resize { width: u32, height: u32 }
    Minimize
    Maximize
    Restore
    Focus { gained: bool }
    MouseEnter
    MouseLeave
    DpiChanged { scale: f32 }
}

// Window style presets
enum WindowStyle {
    Windowed
    Fullscreen
    BorderlessFullscreen
}

// Display mode information
struct DisplayMode {
    width: u32
    height: u32
    refresh_rate: u32
    bits_per_pixel: u32
}

// Monitor information
struct Monitor {
    name: string
    is_primary: bool
    x: i32
    y: i32
    width: u32
    height: u32
    dpi_scale: f32
    display_modes: []DisplayMode
    mode_count: usize
}

// Window creation parameters
struct WindowConfig {
    title: string
    width: u32
    height: u32
    x: i32
    y: i32
    flags: u32
    style: WindowStyle
    monitor: ?*Monitor
}

// Platform-specific window handle
struct PlatformWindow {
    // Windows: HWND
    // macOS: NSWindow*
    // Linux: xcb_window_t or similar
    native_handle: *u8
    native_instance: *u8  // HINSTANCE on Windows
}

// Main window structure
struct Window {
    config: WindowConfig
    platform: PlatformWindow
    is_open: bool
    width: u32
    height: u32
    framebuffer_width: u32  // May differ on high-DPI displays
    framebuffer_height: u32
    dpi_scale: f32
    is_focused: bool
    is_minimized: bool
    allocator: Allocator

    fn init(allocator: Allocator, config: WindowConfig): Window {
        return Window {
            config: config
            platform: PlatformWindow {
                native_handle: null
                native_instance: null
            }
            is_open: false
            width: config.width
            height: config.height
            framebuffer_width: config.width
            framebuffer_height: config.height
            dpi_scale: 1.0
            is_focused: true
            is_minimized: false
            allocator: allocator
        }
    }

    fn create(mut self): bool {
        // Platform-specific window creation
        comptime if @import("builtin").os.tag == .windows {
            return self.create_windows()
        } else if @import("builtin").os.tag == .macos {
            return self.create_macos()
        } else if @import("builtin").os.tag == .linux {
            return self.create_linux()
        } else {
            return false
        }
    }

    fn poll_events(mut self): []WindowEvent {
        // Poll and return all pending window events
        comptime if @import("builtin").os.tag == .windows {
            return self.poll_events_windows()
        } else if @import("builtin").os.tag == .macos {
            return self.poll_events_macos()
        } else if @import("builtin").os.tag == .linux {
            return self.poll_events_linux()
        } else {
            return []
        }
    }

    fn swap_buffers(self) {
        // Present rendered frame to screen
        comptime if @import("builtin").os.tag == .windows {
            self.swap_buffers_windows()
        } else if @import("builtin").os.tag == .macos {
            self.swap_buffers_macos()
        } else if @import("builtin").os.tag == .linux {
            self.swap_buffers_linux()
        }
    }

    fn set_title(mut self, title: string) {
        self.config.title = title

        comptime if @import("builtin").os.tag == .windows {
            self.set_title_windows(title)
        } else if @import("builtin").os.tag == .macos {
            self.set_title_macos(title)
        } else if @import("builtin").os.tag == .linux {
            self.set_title_linux(title)
        }
    }

    fn set_size(mut self, width: u32, height: u32) {
        self.width = width
        self.height = height

        comptime if @import("builtin").os.tag == .windows {
            self.set_size_windows(width, height)
        } else if @import("builtin").os.tag == .macos {
            self.set_size_macos(width, height)
        } else if @import("builtin").os.tag == .linux {
            self.set_size_linux(width, height)
        }
    }

    fn set_fullscreen(mut self, fullscreen: bool) {
        if fullscreen {
            self.config.style = WindowStyle.Fullscreen
        } else {
            self.config.style = WindowStyle.Windowed
        }

        comptime if @import("builtin").os.tag == .windows {
            self.set_fullscreen_windows(fullscreen)
        } else if @import("builtin").os.tag == .macos {
            self.set_fullscreen_macos(fullscreen)
        } else if @import("builtin").os.tag == .linux {
            self.set_fullscreen_linux(fullscreen)
        }
    }

    fn show(mut self) {
        comptime if @import("builtin").os.tag == .windows {
            self.show_windows()
        } else if @import("builtin").os.tag == .macos {
            self.show_macos()
        } else if @import("builtin").os.tag == .linux {
            self.show_linux()
        }
    }

    fn hide(mut self) {
        comptime if @import("builtin").os.tag == .windows {
            self.hide_windows()
        } else if @import("builtin").os.tag == .macos {
            self.hide_macos()
        } else if @import("builtin").os.tag == .linux {
            self.hide_linux()
        }
    }

    fn get_native_handle(self): *u8 {
        return self.platform.native_handle
    }

    fn close(mut self) {
        self.is_open = false

        comptime if @import("builtin").os.tag == .windows {
            self.close_windows()
        } else if @import("builtin").os.tag == .macos {
            self.close_macos()
        } else if @import("builtin").os.tag == .linux {
            self.close_linux()
        }
    }

    // Platform-specific implementations (Windows)

    fn create_windows(mut self): bool {
        // TODO: Create Win32 window
        // - RegisterClassEx with WNDCLASSEX
        // - CreateWindowEx
        // - Get DC with GetDC
        // - Set up pixel format for OpenGL/DirectX

        self.is_open = true
        return true
    }

    fn poll_events_windows(mut self): []WindowEvent {
        // TODO: Process Windows messages with PeekMessage/DispatchMessage
        // MSG msg;
        // while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        //     TranslateMessage(&msg);
        //     DispatchMessage(&msg);
        // }
        return []
    }

    fn swap_buffers_windows(self) {
        // TODO: SwapBuffers(hdc) or IDXGISwapChain::Present
    }

    fn set_title_windows(self, title: string) {
        // TODO: SetWindowText(hwnd, title)
    }

    fn set_size_windows(self, width: u32, height: u32) {
        // TODO: SetWindowPos(hwnd, ...)
    }

    fn set_fullscreen_windows(self, fullscreen: bool) {
        // TODO: ChangeDisplaySettings or use borderless window
    }

    fn show_windows(self) {
        // TODO: ShowWindow(hwnd, SW_SHOW)
    }

    fn hide_windows(self) {
        // TODO: ShowWindow(hwnd, SW_HIDE)
    }

    fn close_windows(mut self) {
        // TODO: DestroyWindow(hwnd)
    }

    // Platform-specific implementations (macOS)

    fn create_macos(mut self): bool {
        // TODO: Create NSWindow via Objective-C runtime
        // - NSWindow alloc/init
        // - Set content view
        // - Make key and order front

        self.is_open = true
        return true
    }

    fn poll_events_macos(mut self): []WindowEvent {
        // TODO: NSApp nextEventMatchingMask until nil
        return []
    }

    fn swap_buffers_macos(self) {
        // TODO: CAMetalLayer nextDrawable or NSOpenGLContext flushBuffer
    }

    fn set_title_macos(self, title: string) {
        // TODO: [window setTitle:@"title"]
    }

    fn set_size_macos(self, width: u32, height: u32) {
        // TODO: [window setFrame:rect display:YES]
    }

    fn set_fullscreen_macos(self, fullscreen: bool) {
        // TODO: [window toggleFullScreen:nil]
    }

    fn show_macos(self) {
        // TODO: [window makeKeyAndOrderFront:nil]
    }

    fn hide_macos(self) {
        // TODO: [window orderOut:nil]
    }

    fn close_macos(mut self) {
        // TODO: [window close]
    }

    // Platform-specific implementations (Linux)

    fn create_linux(mut self): bool {
        // TODO: Create X11/Wayland window
        // X11: xcb_create_window or XCreateWindow
        // Wayland: wl_compositor_create_surface

        self.is_open = true
        return true
    }

    fn poll_events_linux(mut self): []WindowEvent {
        // TODO: xcb_poll_for_event or wl_display_dispatch_pending
        return []
    }

    fn swap_buffers_linux(self) {
        // TODO: glXSwapBuffers or eglSwapBuffers
    }

    fn set_title_linux(self, title: string) {
        // TODO: xcb_change_property with _NET_WM_NAME
    }

    fn set_size_linux(self, width: u32, height: u32) {
        // TODO: xcb_configure_window
    }

    fn set_fullscreen_linux(self, fullscreen: bool) {
        // TODO: _NET_WM_STATE_FULLSCREEN property
    }

    fn show_linux(self) {
        // TODO: xcb_map_window
    }

    fn hide_linux(self) {
        // TODO: xcb_unmap_window
    }

    fn close_linux(mut self) {
        // TODO: xcb_destroy_window
    }
}

// Monitor enumeration
struct MonitorManager {
    monitors: []Monitor
    monitor_count: usize
    primary_monitor: ?*Monitor
    allocator: Allocator

    fn init(allocator: Allocator): MonitorManager {
        return MonitorManager {
            monitors: allocator.alloc(Monitor, 16)  // Max 16 monitors
            monitor_count: 0
            primary_monitor: null
            allocator: allocator
        }
    }

    fn enumerate(mut self) {
        comptime if @import("builtin").os.tag == .windows {
            self.enumerate_windows()
        } else if @import("builtin").os.tag == .macos {
            self.enumerate_macos()
        } else if @import("builtin").os.tag == .linux {
            self.enumerate_linux()
        }
    }

    fn get_primary(self): ?*Monitor {
        return self.primary_monitor
    }

    fn enumerate_windows(mut self) {
        // TODO: EnumDisplayMonitors + GetMonitorInfo
    }

    fn enumerate_macos(mut self) {
        // TODO: NSScreen screens
    }

    fn enumerate_linux(mut self) {
        // TODO: XRandR or Wayland output enumeration
    }

    fn deinit(mut self) {
        for i in 0..self.monitor_count {
            if self.monitors[i].display_modes.len > 0 {
                self.allocator.free(self.monitors[i].display_modes)
            }
        }
        self.allocator.free(self.monitors)
    }
}

// Global window and monitor manager
var g_window: ?Window = null
var g_monitor_manager: ?MonitorManager = null

export fn init_window_system(allocator: Allocator) {
    g_monitor_manager = MonitorManager.init(allocator)
    g_monitor_manager.?.enumerate()
}

export fn create_window(allocator: Allocator, config: WindowConfig): bool {
    let mut window = Window.init(allocator, config)

    if !window.create() {
        return false
    }

    g_window = window
    return true
}

export fn poll_window_events(): []WindowEvent {
    if g_window {
        return g_window.?.poll_events()
    }
    return []
}

export fn is_window_open(): bool {
    if g_window {
        return g_window.?.is_open
    }
    return false
}

export fn swap_buffers() {
    if g_window {
        g_window.?.swap_buffers()
    }
}

export fn get_window_size(): [2]u32 {
    if g_window {
        return [2]u32{ g_window.?.width, g_window.?.height }
    }
    return [2]u32{ 0, 0 }
}

export fn get_framebuffer_size(): [2]u32 {
    if g_window {
        return [2]u32{ g_window.?.framebuffer_width, g_window.?.framebuffer_height }
    }
    return [2]u32{ 0, 0 }
}

export fn get_native_window_handle(): ?*u8 {
    if g_window {
        return g_window.?.get_native_handle()
    }
    return null
}

export fn close_window() {
    if g_window {
        g_window.?.close()
        g_window = null
    }
}

export fn shutdown_window_system() {
    close_window()

    if g_monitor_manager {
        g_monitor_manager.?.deinit()
        g_monitor_manager = null
    }
}
