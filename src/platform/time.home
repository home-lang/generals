// Time - High-resolution timing for game loop
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/game/common/system/gametimer.h

// Time functions are built into Home

/// High-resolution timer for game loop timing
struct GameTimer {
    start_time: u64,
    last_frame_time: u64,
    accumulated_time: f64,
    frame_count: u64,
    paused: bool,
    pause_start: u64,
    total_pause_time: u64,

    /// Create new timer
    fn new(): GameTimer {
        let now = Time.now_nanos()
        return GameTimer {
            start_time: now,
            last_frame_time: now,
            accumulated_time: 0.0,
            frame_count: 0,
            paused: false,
            pause_start: 0,
            total_pause_time: 0
        }
    }

    /// Reset timer to current time
    fn reset(self: &mut GameTimer) {
        let now = Time.now_nanos()
        self.start_time = now
        self.last_frame_time = now
        self.accumulated_time = 0.0
        self.frame_count = 0
        self.total_pause_time = 0
    }

    /// Get current time in nanoseconds
    fn now_nanos(self: &GameTimer): u64 {
        let now = Time.now_nanos()
        if self.paused {
            return self.pause_start - self.start_time - self.total_pause_time
        }
        return now - self.start_time - self.total_pause_time
    }

    /// Get current time in seconds
    fn now_seconds(self: &GameTimer): f64 {
        return (self.now_nanos() as f64) / 1_000_000_000.0
    }

    /// Get delta time since last frame (in seconds)
    fn delta(self: &mut GameTimer): f32 {
        let now = Time.now_nanos()
        let delta_nanos = now - self.last_frame_time
        self.last_frame_time = now
        self.frame_count += 1

        let delta_seconds = (delta_nanos as f64) / 1_000_000_000.0
        self.accumulated_time += delta_seconds

        return delta_seconds as f32
    }

    /// Get average FPS
    fn fps(self: &GameTimer): f32 {
        if self.accumulated_time == 0.0 {
            return 0.0
        }
        return (self.frame_count as f32) / (self.accumulated_time as f32)
    }

    /// Pause timer
    fn pause(self: &mut GameTimer) {
        if !self.paused {
            self.paused = true
            self.pause_start = Time.now_nanos()
        }
    }

    /// Resume timer
    fn resume(self: &mut GameTimer) {
        if self.paused {
            self.paused = false
            let pause_duration = Time.now_nanos() - self.pause_start
            self.total_pause_time += pause_duration
            self.last_frame_time += pause_duration
        }
    }

    /// Check if paused
    fn is_paused(self: &GameTimer): bool {
        return self.paused
    }
}

/// Utility functions for time operations
struct Time {
    /// Get current time in nanoseconds (monotonic clock)
    fn now_nanos(): u64 {
        return std.time.Instant.now().duration_since_epoch().as_nanos() as u64
    }

    /// Get current time in milliseconds
    fn now_millis(): u64 {
        return std.time.Instant.now().duration_since_epoch().as_millis() as u64
    }

    /// Get current time in seconds
    fn now_seconds(): f64 {
        return (Time.now_nanos() as f64) / 1_000_000_000.0
    }

    /// Sleep for specified milliseconds
    fn sleep_millis(ms: u64) {
        std.thread.sleep(std.time.Duration.from_millis(ms))
    }

    /// Sleep for specified seconds
    fn sleep_seconds(seconds: f32) {
        let ms = (seconds * 1000.0) as u64
        Time.sleep_millis(ms)
    }

    /// Convert seconds to milliseconds
    fn seconds_to_millis(seconds: f32): u64 {
        return (seconds * 1000.0) as u64
    }

    /// Convert milliseconds to seconds
    fn millis_to_seconds(ms: u64): f32 {
        return (ms as f32) / 1000.0
    }

    /// Convert nanoseconds to seconds
    fn nanos_to_seconds(nanos: u64): f64 {
        return (nanos as f64) / 1_000_000_000.0
    }

    /// Convert seconds to nanoseconds
    fn seconds_to_nanos(seconds: f64): u64 {
        return (seconds * 1_000_000_000.0) as u64
    }
}

/// Frame rate limiter for fixed timestep game loops
struct FrameLimiter {
    target_fps: f32,
    target_frame_time: f64,
    last_frame: u64,
    frame_accumulator: f64,

    /// Create new frame limiter with target FPS
    fn new(target_fps: f32): FrameLimiter {
        return FrameLimiter {
            target_fps: target_fps,
            target_frame_time: 1.0 / (target_fps as f64),
            last_frame: Time.now_nanos(),
            frame_accumulator: 0.0
        }
    }

    /// Wait until next frame should start
    /// Returns true if a frame should be processed
    fn wait_for_next_frame(self: &mut FrameLimiter): bool {
        let now = Time.now_nanos()
        let delta = (now - self.last_frame) as f64 / 1_000_000_000.0

        self.frame_accumulator += delta
        self.last_frame = now

        if self.frame_accumulator >= self.target_frame_time {
            self.frame_accumulator -= self.target_frame_time
            // Cap accumulator to prevent spiral of death
            if self.frame_accumulator > self.target_frame_time * 5.0 {
                self.frame_accumulator = self.target_frame_time
            }
            return true
        }

        // Sleep for remaining time
        let remaining = self.target_frame_time - self.frame_accumulator
        if remaining > 0.001 {
            Time.sleep_millis((remaining * 1000.0) as u64)
        }

        return false
    }

    /// Set new target FPS
    fn set_fps(self: &mut FrameLimiter, fps: f32) {
        self.target_fps = fps
        self.target_frame_time = 1.0 / (fps as f64)
    }

    /// Get current target FPS
    fn get_fps(self: &FrameLimiter): f32 {
        return self.target_fps
    }
}

/// Stopwatch for measuring durations
struct Stopwatch {
    start_time: u64,
    running: bool,
    elapsed_nanos: u64,

    /// Create new stopped stopwatch
    fn new(): Stopwatch {
        return Stopwatch {
            start_time: 0,
            running: false,
            elapsed_nanos: 0
        }
    }

    /// Start or resume stopwatch
    fn start(self: &mut Stopwatch) {
        if !self.running {
            self.running = true
            self.start_time = Time.now_nanos()
        }
    }

    /// Stop stopwatch and record elapsed time
    fn stop(self: &mut Stopwatch) {
        if self.running {
            self.running = false
            let now = Time.now_nanos()
            self.elapsed_nanos += now - self.start_time
        }
    }

    /// Reset stopwatch to zero
    fn reset(self: &mut Stopwatch) {
        self.elapsed_nanos = 0
        self.running = false
    }

    /// Restart stopwatch from zero
    fn restart(self: &mut Stopwatch) {
        self.reset()
        self.start()
    }

    /// Get elapsed time in seconds
    fn elapsed_seconds(self: &Stopwatch): f64 {
        let total = self.elapsed_nanos
        if self.running {
            let now = Time.now_nanos()
            return Time.nanos_to_seconds(total + (now - self.start_time))
        }
        return Time.nanos_to_seconds(total)
    }

    /// Get elapsed time in milliseconds
    fn elapsed_millis(self: &Stopwatch): u64 {
        return (self.elapsed_seconds() * 1000.0) as u64
    }

    /// Check if running
    fn is_running(self: &Stopwatch): bool {
        return self.running
    }
}
