// INI Parser - C&C Generals configuration file parser
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/game/common/ini/ini.h

import std.collections.HashMap
import platform.file.File

/// INI file format:
/// [SectionName]
/// key = value
/// key2 = value with spaces
/// ; comment line
///
/// C&C Generals uses INI files for all game data:
/// - Unit definitions
/// - Weapon stats
/// - Building properties
/// - Game rules

/// A single key-value pair in an INI section
struct IniProperty {
    key: String,
    value: String,
}

/// A section in an INI file with properties
struct IniSection {
    name: String,
    properties: HashMap<String, String>,
}

impl IniSection {
    fn new(name: String) -> IniSection {
        return IniSection {
            name: name,
            properties: HashMap.new()
        }
    }

    /// Get a property value
    fn get(self: &IniSection, key: &str) -> Option<&String> {
        return self.properties.get(key)
    }

    /// Get property as string with default
    fn get_string(self: &IniSection, key: &str, default: String) -> String {
        match self.get(key) {
            Some(val) => return val.clone(),
            None => return default
        }
    }

    /// Get property as integer
    fn get_int(self: &IniSection, key: &str, default: i32) -> i32 {
        match self.get(key) {
            Some(val) => {
                match val.parse::<i32>() {
                    Ok(num) => return num,
                    Err(_) => return default
                }
            },
            None => return default
        }
    }

    /// Get property as float
    fn get_float(self: &IniSection, key: &str, default: f32) -> f32 {
        match self.get(key) {
            Some(val) => {
                match val.parse::<f32>() {
                    Ok(num) => return num,
                    Err(_) => return default
                }
            },
            None => return default
        }
    }

    /// Get property as boolean
    fn get_bool(self: &IniSection, key: &str, default: bool) -> bool {
        match self.get(key) {
            Some(val) => {
                let lower = val.to_lowercase()
                if lower == "yes" || lower == "true" || lower == "1" {
                    return true
                } else if lower == "no" || lower == "false" || lower == "0" {
                    return false
                }
                return default
            },
            None => return default
        }
    }

    /// Set a property
    fn set(self: &mut IniSection, key: String, value: String) {
        self.properties.insert(key, value)
    }

    /// Check if property exists
    fn has(self: &IniSection, key: &str) -> bool {
        return self.properties.contains_key(key)
    }
}

/// INI file parser
struct IniFile {
    filename: String,
    sections: HashMap<String, IniSection>,
}

impl IniFile {
    /// Create empty INI file
    fn new() -> IniFile {
        return IniFile {
            filename: String.new(),
            sections: HashMap.new()
        }
    }

    /// Parse INI file from string
    fn parse(content: String) -> Result<IniFile, String> {
        let mut ini = IniFile.new()
        let mut current_section: Option<String> = None

        for (line_num, line) in content.lines().enumerate() {
            let trimmed = line.trim()

            // Skip empty lines
            if trimmed.is_empty() {
                continue
            }

            // Skip comments (starts with ; or //)
            if trimmed.starts_with(';') || trimmed.starts_with("//") {
                continue
            }

            // Check for section header [SectionName]
            if trimmed.starts_with('[') && trimmed.ends_with(']') {
                let section_name = trimmed[1..trimmed.len()-1].to_string()
                current_section = Some(section_name.clone())

                if !ini.sections.contains_key(&section_name) {
                    ini.sections.insert(section_name.clone(), IniSection.new(section_name))
                }
                continue
            }

            // Parse key = value
            if let Some(equals_pos) = trimmed.find('=') {
                let key = trimmed[0..equals_pos].trim().to_string()
                let value = trimmed[equals_pos+1..].trim().to_string()

                // Store in current section
                match &current_section {
                    Some(section_name) => {
                        if let Some(section) = ini.sections.get_mut(section_name) {
                            section.set(key, value)
                        }
                    },
                    None => {
                        return Err(format!("Property outside section at line {}", line_num + 1))
                    }
                }
            }
        }

        return Ok(ini)
    }

    /// Load INI file from disk
    fn load(path: String) -> Result<IniFile, String> {
        let content = File.read_all_text(path.clone())?
        let mut ini = IniFile.parse(content)?
        ini.filename = path
        return Ok(ini)
    }

    /// Get a section by name
    fn get_section(self: &IniFile, name: &str) -> Option<&IniSection> {
        return self.sections.get(name)
    }

    /// Get a section mutably
    fn get_section_mut(self: &mut IniFile, name: &str) -> Option<&mut IniSection> {
        return self.sections.get_mut(name)
    }

    /// Check if section exists
    fn has_section(self: &IniFile, name: &str) -> bool {
        return self.sections.contains_key(name)
    }

    /// Get property from section (convenience method)
    fn get(self: &IniFile, section: &str, key: &str) -> Option<String> {
        match self.get_section(section) {
            Some(sec) => {
                match sec.get(key) {
                    Some(val) => return Some(val.clone()),
                    None => return None
                }
            },
            None => return None
        }
    }

    /// Get string with default
    fn get_string(self: &IniFile, section: &str, key: &str, default: String) -> String {
        match self.get(section, key) {
            Some(val) => return val,
            None => return default
        }
    }

    /// Get integer with default
    fn get_int(self: &IniFile, section: &str, key: &str, default: i32) -> i32 {
        match self.get_section(section) {
            Some(sec) => return sec.get_int(key, default),
            None => return default
        }
    }

    /// Get float with default
    fn get_float(self: &IniFile, section: &str, key: &str, default: f32) -> f32 {
        match self.get_section(section) {
            Some(sec) => return sec.get_float(key, default),
            None => return default
        }
    }

    /// Get boolean with default
    fn get_bool(self: &IniFile, section: &str, key: &str, default: bool) -> bool {
        match self.get_section(section) {
            Some(sec) => return sec.get_bool(key, default),
            None => return default
        }
    }

    /// List all section names
    fn section_names(self: &IniFile) -> Vec<String> {
        let mut names = Vec.new()
        for (name, _) in &self.sections {
            names.push(name.clone())
        }
        return names
    }

    /// Save INI file to disk
    fn save(self: &IniFile, path: String) -> Result<(), String> {
        let mut output = String.new()

        for (section_name, section) in &self.sections {
            output.push_str(&format!("[{}]\n", section_name))

            for (key, value) in &section.properties {
                output.push_str(&format!("{} = {}\n", key, value))
            }

            output.push('\n')  // Blank line between sections
        }

        return File.write_all_text(path, output)
    }
}

/// Specialized parser for C&C Generals game data
struct GeneralsDataParser {
    /// Parse unit definition from INI
    fn parse_unit(ini: &IniFile, section_name: &str) -> Result<UnitDefinition, String> {
        match ini.get_section(section_name) {
            Some(section) => {
                let unit = UnitDefinition {
                    name: section_name.to_string(),
                    display_name: section.get_string("DisplayName", section_name.to_string()),
                    health: section.get_int("Health", 100),
                    speed: section.get_float("Speed", 0.0),
                    cost: section.get_int("BuildCost", 0),
                    build_time: section.get_float("BuildTime", 1.0),
                    weapon: section.get_string("Weapon", String.new()),
                    armor: section.get_string("Armor", String.new()),
                }
                return Ok(unit)
            },
            None => return Err(format!("Section not found: {}", section_name))
        }
    }

    /// Parse weapon definition from INI
    fn parse_weapon(ini: &IniFile, section_name: &str) -> Result<WeaponDefinition, String> {
        match ini.get_section(section_name) {
            Some(section) => {
                let weapon = WeaponDefinition {
                    name: section_name.to_string(),
                    damage: section.get_int("Damage", 0),
                    range: section.get_float("Range", 0.0),
                    fire_rate: section.get_float("FireRate", 1.0),
                    projectile: section.get_string("Projectile", String.new()),
                }
                return Ok(weapon)
            },
            None => return Err(format!("Section not found: {}", section_name))
        }
    }
}

/// Unit definition (example game data structure)
struct UnitDefinition {
    name: String,
    display_name: String,
    health: i32,
    speed: f32,
    cost: i32,
    build_time: f32,
    weapon: String,
    armor: String,
}

/// Weapon definition (example game data structure)
struct WeaponDefinition {
    name: String,
    damage: i32,
    range: f32,
    fire_rate: f32,
    projectile: String,
}
