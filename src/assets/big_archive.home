// BIG Archive - EA's .BIG archive format reader
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/platform/w3dengine/common/win32bigfilesystem.cpp

import std.io
import std.collections.HashMap
import platform.file.{File, FileInfo}

/// .BIG file format:
/// Header:
///   - Magic: "BIGF" or "BIG4" (4 bytes)
///   - Archive Size: u32 (little-endian)
///   - File Count: u32 (big-endian)
///   - First File Offset: u32 (big-endian) - usually 16
/// File Entries (starting at offset 16):
///   Each entry:
///   - File Offset: u32 (big-endian)
///   - File Size: u32 (big-endian)
///   - Filename: null-terminated string (max 260 chars)

const BIG_MAGIC_BIGF: u32 = 0x46474942  // "BIGF"
const BIG_MAGIC_BIG4: u32 = 0x34474942  // "BIG4"
const BIG_PATH_MAX: usize = 260

/// Information about a file stored in a .BIG archive
struct ArchivedFileInfo {
    filename: String,
    path: String,           // Directory path within archive
    offset: u32,            // Offset in archive file
    size: u32,              // File size in bytes
    archive_name: String,   // Name of parent archive
}

impl ArchivedFileInfo {
    fn new() -> ArchivedFileInfo {
        return ArchivedFileInfo {
            filename: String.new(),
            path: String.new(),
            offset: 0,
            size: 0,
            archive_name: String.new()
        }
    }
}

/// .BIG Archive reader
struct BigArchive {
    archive_path: String,
    archive_file: Option<File>,
    files: HashMap<String, ArchivedFileInfo>,  // Lowercase filename -> info
    total_files: u32,
    archive_size: u32,
}

impl BigArchive {
    /// Open and parse a .BIG archive
    fn open(path: String) -> Result<BigArchive, String> {
        let mut archive = BigArchive {
            archive_path: path.clone(),
            archive_file: None,
            files: HashMap.new(),
            total_files: 0,
            archive_size: 0
        }

        // Open archive file
        let mut file = match File.open(path.clone(), FileMode.Read | FileMode.Binary) {
            Ok(f) => f,
            Err(e) => return Err("Failed to open archive: " + e)
        }

        // Read and verify magic number
        let mut magic_buf = [0u8; 4]
        if file.read(&mut magic_buf)? != 4 {
            return Err("Failed to read magic number")
        }

        let magic = u32.from_le_bytes(magic_buf)
        if magic != BIG_MAGIC_BIGF && magic != BIG_MAGIC_BIG4 {
            return Err(format!("Invalid BIG magic: 0x{:08X}", magic))
        }

        // Read archive size (little-endian)
        let mut size_buf = [0u8; 4]
        if file.read(&mut size_buf)? != 4 {
            return Err("Failed to read archive size")
        }
        archive.archive_size = u32.from_le_bytes(size_buf)

        // Read file count (big-endian)
        let mut count_buf = [0u8; 4]
        if file.read(&mut count_buf)? != 4 {
            return Err("Failed to read file count")
        }
        archive.total_files = u32.from_be_bytes(count_buf)

        println!("BigArchive: {} contains {} files ({} bytes)",
            path, archive.total_files, archive.archive_size)

        // Seek to file table (offset 16)
        file.seek(16, SeekMode.Start)?

        // Read each file entry
        for i in 0..archive.total_files {
            let info = archive.read_file_entry(&mut file)?

            // Store by lowercase filename for case-insensitive lookup
            let key = info.path.clone() + "/" + info.filename.clone()
            let key_lower = key.to_lowercase()
            archive.files.insert(key_lower, info)
        }

        archive.archive_file = Some(file)
        return Ok(archive)
    }

    /// Read a single file entry from the archive header
    fn read_file_entry(self: &mut BigArchive, file: &mut File) -> Result<ArchivedFileInfo, String> {
        let mut info = ArchivedFileInfo.new()
        info.archive_name = self.archive_path.clone()

        // Read file offset (big-endian)
        let mut offset_buf = [0u8; 4]
        if file.read(&mut offset_buf)? != 4 {
            return Err("Failed to read file offset")
        }
        info.offset = u32.from_be_bytes(offset_buf)

        // Read file size (big-endian)
        let mut size_buf = [0u8; 4]
        if file.read(&mut size_buf)? != 4 {
            return Err("Failed to read file size")
        }
        info.size = u32.from_be_bytes(size_buf)

        // Read null-terminated filename (max 260 chars)
        let mut name_buf = Vec.with_capacity(BIG_PATH_MAX)
        let mut byte = [0u8; 1]

        for _ in 0..BIG_PATH_MAX {
            if file.read(&mut byte)? != 1 {
                return Err("Failed to read filename")
            }

            if byte[0] == 0 {
                break  // Null terminator
            }

            name_buf.push(byte[0])
        }

        let full_path = match String.from_utf8(name_buf) {
            Ok(s) => s,
            Err(_) => return Err("Invalid UTF-8 in filename")
        }

        // Split path and filename
        // Find last slash or backslash
        let mut name_start = 0
        for (i, ch) in full_path.chars().enumerate().rev() {
            if ch == '\\' || ch == '/' {
                name_start = i + 1
                break
            }
        }

        if name_start > 0 {
            info.path = full_path[0..name_start - 1].to_string()
            info.filename = full_path[name_start..].to_string()
        } else {
            info.path = String.new()
            info.filename = full_path
        }

        // Normalize to lowercase for case-insensitive matching
        info.filename = info.filename.to_lowercase()

        return Ok(info)
    }

    /// Extract a file from the archive
    fn extract_file(self: &mut BigArchive, filename: String) -> Result<Vec<u8>, String> {
        // Normalize filename to lowercase
        let key = filename.to_lowercase()

        // Find file info
        let info = match self.files.get(&key) {
            Some(info) => info,
            None => return Err("File not found in archive: " + filename)
        }

        // Get archive file handle
        let file = match &mut self.archive_file {
            Some(f) => f,
            None => return Err("Archive not open")
        }

        // Seek to file data
        file.seek(info.offset as i64, SeekMode.Start)?

        // Read file data
        let mut data = vec![0u8; info.size as usize]
        let bytes_read = file.read(&mut data)?

        if bytes_read != info.size as usize {
            return Err(format!("Read {} bytes, expected {}", bytes_read, info.size))
        }

        return Ok(data)
    }

    /// Check if archive contains a file
    fn contains_file(self: &BigArchive, filename: String) -> bool {
        let key = filename.to_lowercase()
        return self.files.contains_key(&key)
    }

    /// Get file info without extracting
    fn get_file_info(self: &BigArchive, filename: String) -> Option<&ArchivedFileInfo> {
        let key = filename.to_lowercase()
        return self.files.get(&key)
    }

    /// List all files in archive
    fn list_files(self: &BigArchive) -> Vec<String> {
        let mut files = Vec.new()
        for (_, info) in &self.files {
            let mut full_path = String.new()
            if !info.path.is_empty() {
                full_path.push_str(&info.path)
                full_path.push('/')
            }
            full_path.push_str(&info.filename)
            files.push(full_path)
        }
        return files
    }

    /// Get total number of files
    fn file_count(self: &BigArchive) -> u32 {
        return self.total_files
    }

    /// Close archive
    fn close(self: &mut BigArchive) {
        if let Some(mut file) = self.archive_file.take() {
            file.close()
        }
    }
}

/// Manages multiple .BIG archives
struct BigArchiveManager {
    archives: HashMap<String, BigArchive>,
}

impl BigArchiveManager {
    fn new() -> BigArchiveManager {
        return BigArchiveManager {
            archives: HashMap.new()
        }
    }

    /// Load all .BIG files from a directory
    fn load_from_directory(self: &mut BigArchiveManager, dir: String) -> Result<usize, String> {
        let files = File.list_directory(dir.clone())?

        let mut loaded = 0
        for filename in files {
            if filename.ends_with(".big") || filename.ends_with(".BIG") {
                let path = dir.clone() + "/" + filename.clone()
                match BigArchive.open(path.clone()) {
                    Ok(archive) => {
                        println!("Loaded archive: {}", filename)
                        self.archives.insert(filename, archive)
                        loaded += 1
                    },
                    Err(e) => {
                        println!("Warning: Failed to load {}: {}", filename, e)
                    }
                }
            }
        }

        return Ok(loaded)
    }

    /// Find and extract a file from any loaded archive
    fn extract_file(self: &mut BigArchiveManager, filename: String) -> Result<Vec<u8>, String> {
        // Try each archive until we find the file
        for (archive_name, archive) in &mut self.archives {
            if archive.contains_file(filename.clone()) {
                println!("Found {} in archive {}", filename, archive_name)
                return archive.extract_file(filename)
            }
        }

        return Err("File not found in any archive: " + filename)
    }

    /// Check if any archive contains the file
    fn contains_file(self: &BigArchiveManager, filename: String) -> bool {
        for (_, archive) in &self.archives {
            if archive.contains_file(filename.clone()) {
                return true
            }
        }
        return false
    }

    /// Close all archives
    fn close_all(self: &mut BigArchiveManager) {
        for (_, archive) in &mut self.archives {
            archive.close()
        }
        self.archives.clear()
    }
}
