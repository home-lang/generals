// Object system for C&C Generals Zero Hour
// Based on Thyme's object.h - Complete game objects combining all modules
// Written in Home language

import thing
import kindof
import locomotor
import weapon
import body
import player

// Object status flags
enum ObjectStatus {
    DESTROYED = 0,
    SOLD = 1,
    UNDER_CONSTRUCTION = 2,
    ATTACKING = 3,
    MOVING = 4,
    DAMAGED = 5,
    REALLYDAMAGED = 6,
    GARRISONED = 7,
    POWERED = 8,
    DISABLED = 9,
    AFLAME = 10,
    AIRBORNE_TARGET = 11,
    СЕЛECTABLE = 12,
    INVISIBLE = 13,
    DETECTED = 14,
}

// Object - Complete game object combining all systems
struct Object {
    // Core identification
    object_id: i32,
    thing: thing::Thing,

    // Owner
    owner_player_id: i32,

    // Status flags
    status_bits: i32,  // Bitfield of ObjectStatus

    // Modules
    body: body::Body?,
    locomotor: locomotor::Locomotor?,
    weapon_set: weapon::WeaponSet?,

    // Position/movement
    velocity: thing::Vec3,
    target_position: thing::Vec3?,
    target_object_id: i32,

    // Vision
    vision_range: f64,
    shroud_clearing_range: f64,

    // Construction
    construction_percent: f64,
    is_being_built: bool,

    // Garrison
    garrisoned_units: Vec<i32>,  // Object IDs
    garrison_capacity: i32,

    // Production (for buildings)
    production_queue: Vec<i32>,  // What's being built

    // Experience
    experience_points: i32,
    veterancy_level: i32,

    fn init(
        object_id: i32,
        thing: thing::Thing,
        owner_player_id: i32
    ): Object {
        return Object {
            object_id: object_id,
            thing: thing,
            owner_player_id: owner_player_id,
            status_bits: 0,
            body: null,
            locomotor: null,
            weapon_set: null,
            velocity: thing::Vec3::zero(),
            target_position: null,
            target_object_id: -1,
            vision_range: 150.0,
            shroud_clearing_range: 150.0,
            construction_percent: 0.0,
            is_being_built: false,
            garrisoned_units: Vec::new(),
            garrison_capacity: 0,
            production_queue: Vec::new(),
            experience_points: 0,
            veterancy_level: 0,
        }
    }

    fn get_id(&self): i32 {
        return self.object_id
    }

    fn get_position(&self): thing::Vec3 {
        return self.thing.get_position()
    }

    fn set_position(&self, pos: thing::Vec3) {
        self.thing.set_position(pos)
    }

    fn get_orientation(&self): f64 {
        return self.thing.get_orientation()
    }

    fn set_orientation(&self, angle: f64) {
        self.thing.set_orientation(angle)
    }

    fn is_kindof(&self, kind: kindof::KindOf): bool {
        return self.thing.is_kindof(kind)
    }

    fn set_status(&self, status: ObjectStatus, value: bool) {
        let bit = 1 << (status as Int)
        if value {
            self.status_bits = self.status_bits | bit
        } else {
            self.status_bits = self.status_bits & (~bit)
        }
    }

    fn get_status(&self, status: ObjectStatus): bool {
        let bit = 1 << (status as Int)
        return (self.status_bits & bit) != 0
    }

    fn is_destroyed(&self): bool {
        return self.get_status(ObjectStatus::DESTROYED)
    }

    fn is_selectable(&self): bool {
        return self.get_status(ObjectStatus::СЕЛECTABLE) &&
               !self.is_destroyed()
    }

    fn is_mobile(&self): bool {
        return self.locomotor != null &&
               !self.thing.is_kindof(kindof::KindOf::IMMOBILE)
    }

    fn is_structure(&self): bool {
        return self.thing.is_kindof(kindof::KindOf::STRUCTURE)
    }

    fn is_infantry(&self): bool {
        return self.thing.is_kindof(kindof::KindOf::INFANTRY)
    }

    fn is_vehicle(&self): bool {
        return self.thing.is_kindof(kindof::KindOf::VEHICLE)
    }

    fn is_aircraft(&self): bool {
        return self.thing.is_kindof(kindof::KindOf::AIRCRAFT)
    }

    fn get_health(&self): f64 {
        if let Some(body) = self.body {
            return body.get_health()
        }
        return 0.0
    }

    fn get_max_health(&self): f64 {
        if let Some(body) = self.body {
            return body.get_max_health()
        }
        return 0.0
    }

    fn get_health_percentage(&self): f64 {
        if let Some(body) = self.body {
            return body.get_health_percentage()
        }
        return 0.0
    }

    fn take_damage(&self, damage: f64, attacker_id: i32, current_frame: i32) {
        if let Some(body) = self.body {
            body.attempt_damage(damage, attacker_id, current_frame)

            if body.is_destroyed() {
                self.destroy()
            }
        }
    }

    fn heal(&self, amount: f64, current_frame: i32) {
        if let Some(body) = self.body {
            body.attempt_healing(amount, current_frame)
        }
    }

    fn destroy(&self) {
        self.set_status(ObjectStatus::DESTROYED, true)
        self.set_status(ObjectStatus::СЕЛECTABLE, false)
    }

    fn move_to(&self, target: thing::Vec3) {
        if !self.is_mobile() {
            return
        }

        self.target_position = target
        self.target_object_id = -1
        self.set_status(ObjectStatus::MOVING, true)
    }

    fn attack_object(&self, target_id: i32) {
        if self.weapon_set == null {
            return
        }

        self.target_object_id = target_id
        self.set_status(ObjectStatus::ATTACKING, true)
    }

    fn stop(&self) {
        self.target_position = null
        self.target_object_id = -1
        self.set_status(ObjectStatus::MOVING, false)
        self.set_status(ObjectStatus::ATTACKING, false)
    }

    fn can_garrison(&self): bool {
        return self.garrison_capacity > 0 &&
               self.garrisoned_units.count() < self.garrison_capacity
    }

    fn garrison_unit(&self, unit_id: i32): bool {
        if !self.can_garrison() {
            return false
        }

        self.garrisoned_units.add(unit_id)
        self.set_status(ObjectStatus::GARRISONED, true)
        return true
    }

    fn eject_garrison(&self): Vec<i32> {
        let units = self.garrisoned_units
        self.garrisoned_units = Vec::new()
        self.set_status(ObjectStatus::GARRISONED, false)
        return units
    }

    fn start_construction(&self) {
        self.is_being_built = true
        self.construction_percent = 0.0
        self.set_status(ObjectStatus::UNDER_CONSTRUCTION, true)
    }

    fn update_construction(&self, delta_percent: f64) {
        if !self.is_being_built {
            return
        }

        self.construction_percent = self.construction_percent + delta_percent

        if self.construction_percent >= 100.0 {
            self.construction_percent = 100.0
            self.complete_construction()
        }
    }

    fn complete_construction(&self) {
        self.is_being_built = false
        self.set_status(ObjectStatus::UNDER_CONSTRUCTION, false)

        // Set to full health
        if let Some(body) = self.body {
            body.current_health = body.max_health
            body.update_damage_state()
        }
    }

    fn award_experience(&self, xp: i32) {
        self.experience_points = self.experience_points + xp

        // Check for level up (simplified)
        let xp_for_next_level = (self.veterancy_level + 1) * 100

        if self.experience_points >= xp_for_next_level {
            self.veterancy_level = self.veterancy_level + 1

            // Award health bonus
            if let Some(body) = self.body {
                body.on_veterancy_level_changed(self.veterancy_level - 1, self.veterancy_level)
            }
        }
    }

    fn get_veterancy_level(&self): i32 {
        return self.veterancy_level
    }

    fn update(&self, current_frame: i32, delta_time: f64) {
        // Update body
        if let Some(body) = self.body {
            body.update(current_frame)
        }

        // Update weapons
        if let Some(weapon_set) = self.weapon_set {
            weapon_set.update(current_frame)
        }

        // Update movement
        if self.is_mobile() && self.target_position != null {
            self.update_movement(delta_time)
        }

        // Update construction
        if self.is_being_built {
            // Construction progresses at ~10% per second
            self.update_construction(delta_time * 10.0)
        }
    }

    fn update_movement(&self, delta_time: f64) {
        if self.locomotor == null || self.target_position == null {
            return
        }

        let current_pos = self.get_position()
        let target = self.target_position?

        // Calculate direction
        let dx = target.x - current_pos.x
        let dy = target.y - current_pos.y
        let distance = sqrt(dx * dx + dy * dy)

        if distance < 1.0 {
            // Reached target
            self.target_position = null
            self.set_status(ObjectStatus::MOVING, false)
            return
        }

        // Move towards target
        let loco = self.locomotor?
        let speed = loco.get_max_speed(false)
        let move_distance = speed * delta_time

        let direction_x = dx / distance
        let direction_y = dy / distance

        let new_x = current_pos.x + direction_x * move_distance
        let new_y = current_pos.y + direction_y * move_distance

        self.set_position(thing::Vec3::init(new_x, new_y, current_pos.z))

        // Update orientation to face movement direction
        let angle = atan2(direction_y, direction_x)
        self.set_orientation(angle)
    }

    fn distance_to(&self, other: Object): f64 {
        return self.get_position().distance(other.get_position())
    }

    fn can_see(&self, other: Object): bool {
        let dist = self.distance_to(other)
        return dist <= self.vision_range
    }
}

// ObjectManager - Manages all objects in the game
struct ObjectManager {
    objects: Vec<Object>,
    next_id: i32,

    fn init(): ObjectManager {
        return ObjectManager {
            objects: Vec::new(),
            next_id: 0,
        }
    }

    fn create_object(&self, thing: thing::Thing, owner_player_id: i32): Object {
        let id = self.next_id
        self.next_id = self.next_id + 1

        let obj = Object::init(id, thing, owner_player_id)
        self.objects.add(obj)
        return obj
    }

    fn get_object(&self, object_id: i32): Object? {
        for obj in self.objects {
            if obj.object_id == object_id {
                return obj
            }
        }
        return null
    }

    fn remove_object(&self, object_id: i32) {
        let new_objects = Vec::new()
        for obj in self.objects {
            if obj.object_id != object_id {
                new_objects.add(obj)
            }
        }
        self.objects = new_objects
    }

    fn get_all_objects(&self): Vec<Object> {
        return self.objects
    }

    fn get_objects_for_player(&self, player_id: i32): Vec<Object> {
        let player_objects = Vec::new()
        for obj in self.objects {
            if obj.owner_player_id == player_id {
                player_objects.add(obj)
            }
        }
        return player_objects
    }

    fn get_selectable_objects(&self): Vec<Object> {
        let selectable = Vec::new()
        for obj in self.objects {
            if obj.is_selectable() {
                selectable.add(obj)
            }
        }
        return selectable
    }

    fn update_all(&self, current_frame: i32, delta_time: f64) {
        for obj in self.objects {
            obj.update(current_frame, delta_time)
        }
    }

    fn get_object_count(&self): i32 {
        return self.objects.count()
    }
}

// Tests
test "Object: basic creation" {
    let template = thing::create_basic_template(
        "Ranger",
        kindof::kindof_mask_infantry(),
        5.0,
        10.0
    )
    let thing = thing::Thing::init(template)
    let obj = Object::init(0, thing, 0)

    assert obj.get_id() == 0
    assert obj.owner_player_id == 0
    assert obj.is_infantry()
}

test "Object: position and movement" {
    let template = thing::create_basic_template(
        "Tank",
        kindof::kindof_mask_vehicle(),
        10.0,
        15.0
    )
    let thing = thing::Thing::init(template)
    let obj = Object::init(0, thing, 0)

    obj.set_position(thing::Vec3::init(100.0, 100.0, 0.0))
    let pos = obj.get_position()
    assert pos.x == 100.0
    assert pos.y == 100.0
}

test "Object: status flags" {
    let template = thing::create_basic_template(
        "Building",
        kindof::kindof_mask_structure(),
        20.0,
        30.0
    )
    let thing = thing::Thing::init(template)
    let obj = Object::init(0, thing, 0)

    assert !obj.get_status(ObjectStatus::DAMAGED)

    obj.set_status(ObjectStatus::DAMAGED, true)
    assert obj.get_status(ObjectStatus::DAMAGED)

    obj.set_status(ObjectStatus::DAMAGED, false)
    assert !obj.get_status(ObjectStatus::DAMAGED)
}

test "Object: health and damage" {
    let template = thing::create_basic_template(
        "Tank",
        kindof::kindof_mask_vehicle(),
        10.0,
        15.0
    )
    let thing = thing::Thing::init(template)
    let obj = Object::init(0, thing, 0)

    obj.body = body::Body::init(1000.0)

    assert obj.get_health() == 1000.0
    assert obj.get_health_percentage() == 100.0

    obj.take_damage(300.0, 1, 0)
    assert obj.get_health() == 700.0
    assert !obj.is_destroyed()

    obj.take_damage(700.0, 1, 0)
    assert obj.is_destroyed()
}

test "Object: construction" {
    let template = thing::create_basic_template(
        "Barracks",
        kindof::kindof_mask_structure(),
        30.0,
        40.0
    )
    let thing = thing::Thing::init(template)
    let obj = Object::init(0, thing, 0)

    obj.start_construction()
    assert obj.is_being_built
    assert obj.construction_percent == 0.0

    obj.update_construction(50.0)
    assert obj.construction_percent == 50.0
    assert obj.is_being_built

    obj.update_construction(50.0)
    assert obj.construction_percent == 100.0
    assert !obj.is_being_built
}

test "Object: garrison" {
    let template = thing::create_basic_template(
        "Bunker",
        kindof::kindof_mask_structure(),
        20.0,
        20.0
    )
    let thing = thing::Thing::init(template)
    let obj = Object::init(0, thing, 0)

    obj.garrison_capacity = 5

    assert obj.can_garrison()
    assert obj.garrison_unit(100)
    assert obj.garrison_unit(101)

    assert obj.garrisoned_units.count() == 2

    let units = obj.eject_garrison()
    assert units.count() == 2
    assert obj.garrisoned_units.count() == 0
}

test "Object: experience and veterancy" {
    let template = thing::create_basic_template(
        "Tank",
        kindof::kindof_mask_vehicle(),
        10.0,
        15.0
    )
    let thing = thing::Thing::init(template)
    let obj = Object::init(0, thing, 0)

    assert obj.get_veterancy_level() == 0

    obj.award_experience(100)
    assert obj.get_veterancy_level() == 1

    obj.award_experience(200)
    assert obj.get_veterancy_level() == 2
}

test "ObjectManager: create and retrieve" {
    let manager = ObjectManager::init()

    let template = thing::create_basic_template(
        "Ranger",
        kindof::kindof_mask_infantry(),
        5.0,
        10.0
    )
    let thing = thing::Thing::init(template)

    let obj = manager.create_object(thing, 0)
    assert obj.get_id() == 0

    let retrieved = manager.get_object(0)?
    assert retrieved.get_id() == 0
}

test "ObjectManager: filter by player" {
    let manager = ObjectManager::init()

    let template = thing::create_basic_template(
        "Unit",
        kindof::kindof_mask_infantry(),
        5.0,
        10.0
    )

    manager.create_object(thing::Thing::init(template), 0)
    manager.create_object(thing::Thing::init(template), 0)
    manager.create_object(thing::Thing::init(template), 1)

    let player0_objects = manager.get_objects_for_player(0)
    assert player0_objects.count() == 2

    let player1_objects = manager.get_objects_for_player(1)
    assert player1_objects.count() == 1
}

test "ObjectManager: remove object" {
    let manager = ObjectManager::init()

    let template = thing::create_basic_template(
        "Unit",
        kindof::kindof_mask_infantry(),
        5.0,
        10.0
    )

    let obj = manager.create_object(thing::Thing::init(template), 0)
    assert manager.get_object_count() == 1

    manager.remove_object(obj.get_id())
    assert manager.get_object_count() == 0
}
