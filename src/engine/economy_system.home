// Economy System - Complete supply collection, resource management, and production costs
// Implements C&C Generals Zero Hour economy mechanics

// ============================================================================
// RESOURCE TYPES
// ============================================================================

enum ResourceType {
    SUPPLY,          // Main resource from supply docks/stashes
    POWER,           // Generated by power plants
    BOUNTY,          // Earned from destroying enemies
    CRATE_MONEY,     // Found in supply crates
    HACKER_INCOME,   // GLA hackers generate money
    BLACK_MARKET,    // GLA black market passive income
    GENERAL_POINT    // Earned from experience
}

// ============================================================================
// SUPPLY SOURCES
// ============================================================================

enum SupplySourceType {
    SUPPLY_DOCK,     // Standard supply dock (finite)
    SUPPLY_STASH,    // GLA supply stash (finite)
    SUPPLY_DROP,     // USA supply drop (infinite, cooldown)
    OIL_DERRICK,     // Tech building (slow infinite)
    CRATE           // Map crate (one-time)
}

struct SupplySource {
    id: i32,
    source_type: SupplySourceType,
    position: Vec3,
    remaining_supplies: i32,      // -1 for infinite
    max_supplies: i32,
    gather_rate: i32,             // Per trip
    respawn_timer: f32,           // For supply drops
    respawn_cooldown: f32,
    owner_id: i32,                // For captured tech buildings
    is_depleted: bool,
    workers_assigned: [i32; 8],   // Unit IDs of workers
    worker_count: i32
}

fn create_supply_dock(id: i32, position: Vec3): SupplySource {
    return SupplySource {
        id: id,
        source_type: SupplySourceType::SUPPLY_DOCK,
        position: position,
        remaining_supplies: 25000,     // Standard dock value
        max_supplies: 25000,
        gather_rate: 300,              // Per trip
        respawn_timer: 0.0,
        respawn_cooldown: 0.0,
        owner_id: -1,
        is_depleted: false,
        workers_assigned: [-1; 8],
        worker_count: 0
    }
}

fn create_supply_stash(id: i32, position: Vec3): SupplySource {
    return SupplySource {
        id: id,
        source_type: SupplySourceType::SUPPLY_STASH,
        position: position,
        remaining_supplies: 15000,     // Smaller than docks
        max_supplies: 15000,
        gather_rate: 200,
        respawn_timer: 0.0,
        respawn_cooldown: 0.0,
        owner_id: -1,
        is_depleted: false,
        workers_assigned: [-1; 8],
        worker_count: 0
    }
}

fn create_oil_derrick(id: i32, position: Vec3, owner: i32): SupplySource {
    return SupplySource {
        id: id,
        source_type: SupplySourceType::OIL_DERRICK,
        position: position,
        remaining_supplies: -1,        // Infinite
        max_supplies: -1,
        gather_rate: 10,               // Slow trickle per second
        respawn_timer: 0.0,
        respawn_cooldown: 0.0,
        owner_id: owner,
        is_depleted: false,
        workers_assigned: [-1; 8],
        worker_count: 0
    }
}

// ============================================================================
// SUPPLY COLLECTORS
// ============================================================================

enum CollectorType {
    CHINOOK,         // USA supply helicopter
    SUPPLY_TRUCK,    // China supply truck
    WORKER,          // GLA worker
    HACKER          // GLA hacker (generates money directly)
}

enum CollectorState {
    IDLE,
    MOVING_TO_SOURCE,
    COLLECTING,
    RETURNING_TO_BASE,
    DEPOSITING,
    WAITING_IN_QUEUE
}

struct SupplyCollector {
    unit_id: i32,
    collector_type: CollectorType,
    state: CollectorState,
    owner_id: i32,

    // Navigation
    position: Vec3,
    target_position: Vec3,
    move_speed: f32,

    // Collection
    assigned_source_id: i32,
    assigned_depot_id: i32,
    current_load: i32,
    max_load: i32,
    collect_time: f32,
    collect_timer: f32,

    // Hacker specific
    hack_income_rate: f32,
    hack_timer: f32,
    internet_center_bonus: f32
}

fn create_chinook(unit_id: i32, owner: i32, position: Vec3): SupplyCollector {
    return SupplyCollector {
        unit_id: unit_id,
        collector_type: CollectorType::CHINOOK,
        state: CollectorState::IDLE,
        owner_id: owner,
        position: position,
        target_position: position,
        move_speed: 120.0,           // Fast helicopter
        assigned_source_id: -1,
        assigned_depot_id: -1,
        current_load: 0,
        max_load: 600,               // Carries more per trip
        collect_time: 3.0,
        collect_timer: 0.0,
        hack_income_rate: 0.0,
        hack_timer: 0.0,
        internet_center_bonus: 1.0
    }
}

fn create_supply_truck(unit_id: i32, owner: i32, position: Vec3): SupplyCollector {
    return SupplyCollector {
        unit_id: unit_id,
        collector_type: CollectorType::SUPPLY_TRUCK,
        state: CollectorState::IDLE,
        owner_id: owner,
        position: position,
        target_position: position,
        move_speed: 60.0,            // Ground vehicle
        assigned_source_id: -1,
        assigned_depot_id: -1,
        current_load: 0,
        max_load: 300,
        collect_time: 2.5,
        collect_timer: 0.0,
        hack_income_rate: 0.0,
        hack_timer: 0.0,
        internet_center_bonus: 1.0
    }
}

fn create_worker(unit_id: i32, owner: i32, position: Vec3): SupplyCollector {
    return SupplyCollector {
        unit_id: unit_id,
        collector_type: CollectorType::WORKER,
        state: CollectorState::IDLE,
        owner_id: owner,
        position: position,
        target_position: position,
        move_speed: 40.0,            // Slow on foot
        assigned_source_id: -1,
        assigned_depot_id: -1,
        current_load: 0,
        max_load: 150,               // Carries less
        collect_time: 2.0,
        collect_timer: 0.0,
        hack_income_rate: 0.0,
        hack_timer: 0.0,
        internet_center_bonus: 1.0
    }
}

fn create_hacker(unit_id: i32, owner: i32, position: Vec3): SupplyCollector {
    return SupplyCollector {
        unit_id: unit_id,
        collector_type: CollectorType::HACKER,
        state: CollectorState::IDLE,
        owner_id: owner,
        position: position,
        target_position: position,
        move_speed: 35.0,
        assigned_source_id: -1,
        assigned_depot_id: -1,
        current_load: 0,
        max_load: 0,                 // Doesn't carry supplies
        collect_time: 0.0,
        collect_timer: 0.0,
        hack_income_rate: 5.0,       // $/second base rate
        hack_timer: 0.0,
        internet_center_bonus: 1.0
    }
}

// ============================================================================
// SUPPLY DEPOTS
// ============================================================================

enum DepotType {
    SUPPLY_CENTER,       // USA
    SUPPLY_DEPOT,        // China
    SUPPLY_STASH_DEPOT,  // GLA
    BLACK_MARKET        // GLA passive income
}

struct SupplyDepot {
    building_id: i32,
    depot_type: DepotType,
    position: Vec3,
    owner_id: i32,

    // Queue management
    collectors_in_queue: [i32; 16],
    queue_count: i32,
    deposit_time: f32,

    // Black market specific
    passive_income_rate: f32,
    income_timer: f32,

    // Upgrades
    has_supply_lines: bool,        // USA upgrade
    supply_bonus_percent: f32
}

fn create_supply_center(building_id: i32, owner: i32, position: Vec3): SupplyDepot {
    return SupplyDepot {
        building_id: building_id,
        depot_type: DepotType::SUPPLY_CENTER,
        position: position,
        owner_id: owner,
        collectors_in_queue: [-1; 16],
        queue_count: 0,
        deposit_time: 1.0,
        passive_income_rate: 0.0,
        income_timer: 0.0,
        has_supply_lines: false,
        supply_bonus_percent: 0.0
    }
}

fn create_supply_depot_china(building_id: i32, owner: i32, position: Vec3): SupplyDepot {
    return SupplyDepot {
        building_id: building_id,
        depot_type: DepotType::SUPPLY_DEPOT,
        position: position,
        owner_id: owner,
        collectors_in_queue: [-1; 16],
        queue_count: 0,
        deposit_time: 0.8,
        passive_income_rate: 0.0,
        income_timer: 0.0,
        has_supply_lines: false,
        supply_bonus_percent: 0.0
    }
}

fn create_supply_stash_depot(building_id: i32, owner: i32, position: Vec3): SupplyDepot {
    return SupplyDepot {
        building_id: building_id,
        depot_type: DepotType::SUPPLY_STASH_DEPOT,
        position: position,
        owner_id: owner,
        collectors_in_queue: [-1; 16],
        queue_count: 0,
        deposit_time: 1.2,
        passive_income_rate: 0.0,
        income_timer: 0.0,
        has_supply_lines: false,
        supply_bonus_percent: 0.0
    }
}

fn create_black_market(building_id: i32, owner: i32, position: Vec3): SupplyDepot {
    return SupplyDepot {
        building_id: building_id,
        depot_type: DepotType::BLACK_MARKET,
        position: position,
        owner_id: owner,
        collectors_in_queue: [-1; 16],
        queue_count: 0,
        deposit_time: 0.0,
        passive_income_rate: 20.0,   // $/second
        income_timer: 0.0,
        has_supply_lines: false,
        supply_bonus_percent: 0.0
    }
}

// ============================================================================
// PLAYER RESOURCES
// ============================================================================

struct PlayerResources {
    player_id: i32,

    // Current amounts
    supplies: i32,
    max_supplies: i32,

    // Experience/generals
    experience: i32,
    general_points: i32,
    general_level: i32,

    // Income tracking
    total_earned: i32,
    total_spent: i32,
    income_rate: f32,            // $/second average

    // Power
    power_produced: i32,
    power_consumed: i32,
    is_low_power: bool,

    // Bonuses
    supply_gather_bonus: f32,    // Multiplier
    unit_cost_reduction: f32,    // Percentage
    build_speed_bonus: f32,      // Multiplier

    // Faction bonuses
    faction: i32                 // 0=USA, 1=China, 2=GLA
}

fn create_player_resources(player_id: i32, faction: i32): PlayerResources {
    let starting_supplies: i32 = 10000   // Standard starting amount

    return PlayerResources {
        player_id: player_id,
        supplies: starting_supplies,
        max_supplies: 999999,
        experience: 0,
        general_points: 0,
        general_level: 1,
        total_earned: starting_supplies,
        total_spent: 0,
        income_rate: 0.0,
        power_produced: 0,
        power_consumed: 0,
        is_low_power: false,
        supply_gather_bonus: 1.0,
        unit_cost_reduction: 0.0,
        build_speed_bonus: 1.0,
        faction: faction
    }
}

fn add_supplies(resources: mut PlayerResources, amount: i32) {
    resources.supplies = resources.supplies + amount
    if (resources.supplies > resources.max_supplies) {
        resources.supplies = resources.max_supplies
    }
    resources.total_earned = resources.total_earned + amount
}

fn spend_supplies(resources: mut PlayerResources, amount: i32): bool {
    // Apply cost reduction
    let actual_cost: i32 = cast(i32, cast(f32, amount) * (1.0 - resources.unit_cost_reduction))

    if (resources.supplies >= actual_cost) {
        resources.supplies = resources.supplies - actual_cost
        resources.total_spent = resources.total_spent + actual_cost
        return true
    }
    return false
}

fn can_afford(resources: PlayerResources, amount: i32): bool {
    let actual_cost: i32 = cast(i32, cast(f32, amount) * (1.0 - resources.unit_cost_reduction))
    return resources.supplies >= actual_cost
}

fn add_experience(resources: mut PlayerResources, amount: i32) {
    resources.experience = resources.experience + amount

    // Check for level up
    let xp_for_next: i32 = get_xp_for_level(resources.general_level + 1)
    if (resources.experience >= xp_for_next and resources.general_level < 5) {
        resources.general_level = resources.general_level + 1
        resources.general_points = resources.general_points + 1
    }
}

fn get_xp_for_level(level: i32): i32 {
    if (level == 1) { return 0 }
    if (level == 2) { return 500 }
    if (level == 3) { return 1500 }
    if (level == 4) { return 3000 }
    if (level == 5) { return 6000 }
    return 999999
}

// ============================================================================
// PRODUCTION COSTS
// ============================================================================

struct UnitCost {
    name: [u8; 32],
    supply_cost: i32,
    build_time: f32,          // Seconds
    prerequisite: [u8; 32],
    population: i32
}

struct BuildingCost {
    name: [u8; 32],
    supply_cost: i32,
    build_time: f32,
    power_produced: i32,
    power_consumed: i32,
    prerequisite: [u8; 32]
}

struct UpgradeCost {
    name: [u8; 32],
    supply_cost: i32,
    research_time: f32,
    prerequisite: [u8; 32]
}

// USA Unit Costs
fn get_usa_unit_costs(): [UnitCost; 32] {
    let mut costs: [UnitCost; 32] = []
    let mut idx: i32 = 0

    // Infantry
    costs[idx] = UnitCost { name: "Ranger", supply_cost: 225, build_time: 5.0, prerequisite: "Barracks", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Missile Defender", supply_cost: 300, build_time: 7.0, prerequisite: "Barracks", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Pathfinder", supply_cost: 600, build_time: 15.0, prerequisite: "Barracks + Strategy Center", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Colonel Burton", supply_cost: 1500, build_time: 30.0, prerequisite: "Barracks + Strategy Center", population: 1 }
    idx = idx + 1

    // Vehicles
    costs[idx] = UnitCost { name: "Humvee", supply_cost: 700, build_time: 10.0, prerequisite: "War Factory", population: 3 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Crusader Tank", supply_cost: 900, build_time: 12.0, prerequisite: "War Factory", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Paladin Tank", supply_cost: 1100, build_time: 15.0, prerequisite: "War Factory + Strategy Center", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Tomahawk", supply_cost: 1200, build_time: 18.0, prerequisite: "War Factory + Strategy Center", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Ambulance", supply_cost: 600, build_time: 8.0, prerequisite: "War Factory", population: 2 }
    idx = idx + 1

    // Aircraft
    costs[idx] = UnitCost { name: "Comanche", supply_cost: 1500, build_time: 20.0, prerequisite: "Airfield", population: 3 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Raptor", supply_cost: 1400, build_time: 18.0, prerequisite: "Airfield", population: 0 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Stealth Fighter", supply_cost: 1600, build_time: 22.0, prerequisite: "Airfield + Strategy Center", population: 0 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Aurora Bomber", supply_cost: 2500, build_time: 30.0, prerequisite: "Airfield + Strategy Center", population: 0 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Chinook", supply_cost: 1200, build_time: 15.0, prerequisite: "Supply Center", population: 0 }
    idx = idx + 1

    return costs
}

// China Unit Costs
fn get_china_unit_costs(): [UnitCost; 32] {
    let mut costs: [UnitCost; 32] = []
    let mut idx: i32 = 0

    // Infantry
    costs[idx] = UnitCost { name: "Red Guard", supply_cost: 300, build_time: 5.0, prerequisite: "Barracks", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Tank Hunter", supply_cost: 300, build_time: 6.0, prerequisite: "Barracks", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Hacker", supply_cost: 625, build_time: 12.0, prerequisite: "Barracks + Propaganda Center", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Black Lotus", supply_cost: 1500, build_time: 25.0, prerequisite: "Barracks + Propaganda Center", population: 1 }
    idx = idx + 1

    // Vehicles
    costs[idx] = UnitCost { name: "Battlemaster", supply_cost: 800, build_time: 10.0, prerequisite: "War Factory", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Dragon Tank", supply_cost: 800, build_time: 10.0, prerequisite: "War Factory", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Gatling Tank", supply_cost: 800, build_time: 10.0, prerequisite: "War Factory", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Inferno Cannon", supply_cost: 900, build_time: 12.0, prerequisite: "War Factory + Propaganda Center", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Overlord", supply_cost: 2000, build_time: 25.0, prerequisite: "War Factory + Propaganda Center", population: 6 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Nuke Cannon", supply_cost: 1600, build_time: 20.0, prerequisite: "War Factory + Propaganda Center", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Supply Truck", supply_cost: 600, build_time: 8.0, prerequisite: "Supply Depot", population: 0 }
    idx = idx + 1

    // Aircraft
    costs[idx] = UnitCost { name: "MiG", supply_cost: 1200, build_time: 15.0, prerequisite: "Airfield", population: 0 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Helix", supply_cost: 1500, build_time: 20.0, prerequisite: "Airfield + Propaganda Center", population: 4 }
    idx = idx + 1

    return costs
}

// GLA Unit Costs
fn get_gla_unit_costs(): [UnitCost; 32] {
    let mut costs: [UnitCost; 32] = []
    let mut idx: i32 = 0

    // Infantry
    costs[idx] = UnitCost { name: "Rebel", supply_cost: 150, build_time: 3.0, prerequisite: "Barracks", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "RPG Trooper", supply_cost: 300, build_time: 6.0, prerequisite: "Barracks", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Terrorist", supply_cost: 200, build_time: 4.0, prerequisite: "Barracks", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Angry Mob", supply_cost: 800, build_time: 15.0, prerequisite: "Barracks + Palace", population: 5 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Hijacker", supply_cost: 400, build_time: 8.0, prerequisite: "Barracks + Palace", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Jarmen Kell", supply_cost: 1500, build_time: 25.0, prerequisite: "Barracks + Palace", population: 1 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Worker", supply_cost: 200, build_time: 4.0, prerequisite: "Command Center", population: 0 }
    idx = idx + 1

    // Vehicles
    costs[idx] = UnitCost { name: "Technical", supply_cost: 500, build_time: 6.0, prerequisite: "Arms Dealer", population: 2 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Scorpion", supply_cost: 600, build_time: 8.0, prerequisite: "Arms Dealer", population: 3 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Quad Cannon", supply_cost: 700, build_time: 9.0, prerequisite: "Arms Dealer", population: 3 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Marauder", supply_cost: 800, build_time: 10.0, prerequisite: "Arms Dealer + Palace", population: 4 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Rocket Buggy", supply_cost: 900, build_time: 11.0, prerequisite: "Arms Dealer + Palace", population: 3 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Toxin Tractor", supply_cost: 600, build_time: 8.0, prerequisite: "Arms Dealer", population: 3 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "Bomb Truck", supply_cost: 1200, build_time: 15.0, prerequisite: "Arms Dealer + Palace", population: 3 }
    idx = idx + 1
    costs[idx] = UnitCost { name: "SCUD Launcher", supply_cost: 1200, build_time: 15.0, prerequisite: "Arms Dealer + Palace", population: 4 }
    idx = idx + 1

    return costs
}

// Building Costs
fn get_usa_building_costs(): [BuildingCost; 16] {
    let mut costs: [BuildingCost; 16] = []
    let mut idx: i32 = 0

    costs[idx] = BuildingCost { name: "Command Center", supply_cost: 2000, build_time: 30.0, power_produced: 0, power_consumed: 2, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Power Plant", supply_cost: 800, build_time: 15.0, power_produced: 5, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Barracks", supply_cost: 500, build_time: 10.0, power_produced: 0, power_consumed: 1, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Supply Center", supply_cost: 2000, build_time: 20.0, power_produced: 0, power_consumed: 1, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "War Factory", supply_cost: 2000, build_time: 25.0, power_produced: 0, power_consumed: 2, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Airfield", supply_cost: 1000, build_time: 15.0, power_produced: 0, power_consumed: 2, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Strategy Center", supply_cost: 2500, build_time: 30.0, power_produced: 0, power_consumed: 3, prerequisite: "War Factory" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Particle Cannon", supply_cost: 5000, build_time: 60.0, power_produced: 0, power_consumed: 10, prerequisite: "Strategy Center" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Patriot Missile", supply_cost: 1000, build_time: 12.0, power_produced: 0, power_consumed: 2, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Fire Base", supply_cost: 1000, build_time: 15.0, power_produced: 0, power_consumed: 1, prerequisite: "" }
    idx = idx + 1

    return costs
}

fn get_china_building_costs(): [BuildingCost; 16] {
    let mut costs: [BuildingCost; 16] = []
    let mut idx: i32 = 0

    costs[idx] = BuildingCost { name: "Command Center", supply_cost: 2000, build_time: 30.0, power_produced: 0, power_consumed: 2, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Nuclear Reactor", supply_cost: 1000, build_time: 20.0, power_produced: 10, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Barracks", supply_cost: 500, build_time: 10.0, power_produced: 0, power_consumed: 1, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Supply Depot", supply_cost: 1500, build_time: 15.0, power_produced: 0, power_consumed: 1, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "War Factory", supply_cost: 2000, build_time: 25.0, power_produced: 0, power_consumed: 2, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Airfield", supply_cost: 1000, build_time: 15.0, power_produced: 0, power_consumed: 2, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Propaganda Center", supply_cost: 2000, build_time: 25.0, power_produced: 0, power_consumed: 2, prerequisite: "War Factory" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Nuclear Missile", supply_cost: 5000, build_time: 60.0, power_produced: 0, power_consumed: 10, prerequisite: "Propaganda Center" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Gatling Cannon", supply_cost: 1200, build_time: 15.0, power_produced: 0, power_consumed: 2, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Bunker", supply_cost: 400, build_time: 8.0, power_produced: 0, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Speaker Tower", supply_cost: 500, build_time: 10.0, power_produced: 0, power_consumed: 1, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Internet Center", supply_cost: 2500, build_time: 30.0, power_produced: 0, power_consumed: 3, prerequisite: "Propaganda Center" }
    idx = idx + 1

    return costs
}

fn get_gla_building_costs(): [BuildingCost; 16] {
    let mut costs: [BuildingCost; 16] = []
    let mut idx: i32 = 0

    // GLA doesn't use power!
    costs[idx] = BuildingCost { name: "Command Center", supply_cost: 2000, build_time: 30.0, power_produced: 0, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Barracks", supply_cost: 500, build_time: 10.0, power_produced: 0, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Supply Stash", supply_cost: 1500, build_time: 15.0, power_produced: 0, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Arms Dealer", supply_cost: 2500, build_time: 25.0, power_produced: 0, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Palace", supply_cost: 2500, build_time: 30.0, power_produced: 0, power_consumed: 0, prerequisite: "Arms Dealer" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "SCUD Storm", supply_cost: 5000, build_time: 60.0, power_produced: 0, power_consumed: 0, prerequisite: "Palace" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Tunnel Network", supply_cost: 800, build_time: 12.0, power_produced: 0, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Stinger Site", supply_cost: 900, build_time: 10.0, power_produced: 0, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Demo Trap", supply_cost: 400, build_time: 5.0, power_produced: 0, power_consumed: 0, prerequisite: "" }
    idx = idx + 1
    costs[idx] = BuildingCost { name: "Black Market", supply_cost: 2500, build_time: 25.0, power_produced: 0, power_consumed: 0, prerequisite: "Palace" }
    idx = idx + 1

    return costs
}

// ============================================================================
// ECONOMY MANAGER
// ============================================================================

struct EconomyManager {
    // Supply sources
    sources: [SupplySource; 64],
    source_count: i32,

    // Collectors
    collectors: [SupplyCollector; 128],
    collector_count: i32,

    // Depots
    depots: [SupplyDepot; 32],
    depot_count: i32,

    // Player resources
    player_resources: [PlayerResources; 8],
    player_count: i32,

    // Next IDs
    next_source_id: i32,
    next_collector_id: i32,
    next_depot_id: i32
}

fn create_economy_manager(): EconomyManager {
    return EconomyManager {
        sources: [],
        source_count: 0,
        collectors: [],
        collector_count: 0,
        depots: [],
        depot_count: 0,
        player_resources: [],
        player_count: 0,
        next_source_id: 1,
        next_collector_id: 1,
        next_depot_id: 1
    }
}

fn register_player(em: mut EconomyManager, player_id: i32, faction: i32) {
    if (em.player_count < 8) {
        em.player_resources[em.player_count] = create_player_resources(player_id, faction)
        em.player_count = em.player_count + 1
    }
}

fn get_player_resources(em: EconomyManager, player_id: i32): PlayerResources {
    for i in 0..em.player_count {
        if (em.player_resources[i].player_id == player_id) {
            return em.player_resources[i]
        }
    }
    return create_player_resources(-1, 0)
}

fn add_supply_source(em: mut EconomyManager, source: SupplySource): i32 {
    if (em.source_count < 64) {
        let mut new_source: SupplySource = source
        new_source.id = em.next_source_id
        em.sources[em.source_count] = new_source
        em.source_count = em.source_count + 1
        em.next_source_id = em.next_source_id + 1
        return new_source.id
    }
    return -1
}

fn add_collector(em: mut EconomyManager, collector: SupplyCollector): i32 {
    if (em.collector_count < 128) {
        let mut new_collector: SupplyCollector = collector
        new_collector.unit_id = em.next_collector_id
        em.collectors[em.collector_count] = new_collector
        em.collector_count = em.collector_count + 1
        em.next_collector_id = em.next_collector_id + 1
        return new_collector.unit_id
    }
    return -1
}

fn add_depot(em: mut EconomyManager, depot: SupplyDepot): i32 {
    if (em.depot_count < 32) {
        let mut new_depot: SupplyDepot = depot
        new_depot.building_id = em.next_depot_id
        em.depots[em.depot_count] = new_depot
        em.depot_count = em.depot_count + 1
        em.next_depot_id = em.next_depot_id + 1
        return new_depot.building_id
    }
    return -1
}

// ============================================================================
// SUPPLY COLLECTION LOGIC
// ============================================================================

fn find_nearest_source(em: EconomyManager, position: Vec3, owner_id: i32): i32 {
    let mut nearest_id: i32 = -1
    let mut nearest_dist: f32 = 999999.0

    for i in 0..em.source_count {
        let source: SupplySource = em.sources[i]

        // Skip depleted sources
        if (source.is_depleted) { continue }

        // Check if source has supplies (or infinite)
        if (source.remaining_supplies == 0) { continue }

        // Check worker limit
        if (source.worker_count >= 8) { continue }

        let dx: f32 = source.position.x - position.x
        let dy: f32 = source.position.y - position.y
        let dz: f32 = source.position.z - position.z
        let dist: f32 = sqrt(dx*dx + dy*dy + dz*dz)

        if (dist < nearest_dist) {
            nearest_dist = dist
            nearest_id = source.id
        }
    }

    return nearest_id
}

fn find_nearest_depot(em: EconomyManager, position: Vec3, owner_id: i32): i32 {
    let mut nearest_id: i32 = -1
    let mut nearest_dist: f32 = 999999.0

    for i in 0..em.depot_count {
        let depot: SupplyDepot = em.depots[i]

        // Must belong to player
        if (depot.owner_id != owner_id) { continue }

        // Skip black markets (not supply depots)
        if (depot.depot_type == DepotType::BLACK_MARKET) { continue }

        let dx: f32 = depot.position.x - position.x
        let dy: f32 = depot.position.y - position.y
        let dz: f32 = depot.position.z - position.z
        let dist: f32 = sqrt(dx*dx + dy*dy + dz*dz)

        if (dist < nearest_dist) {
            nearest_dist = dist
            nearest_id = depot.building_id
        }
    }

    return nearest_id
}

fn assign_collector_to_source(em: mut EconomyManager, collector_idx: i32, source_id: i32) {
    // Find source
    for i in 0..em.source_count {
        if (em.sources[i].id == source_id) {
            // Add to source's worker list
            if (em.sources[i].worker_count < 8) {
                em.sources[i].workers_assigned[em.sources[i].worker_count] = em.collectors[collector_idx].unit_id
                em.sources[i].worker_count = em.sources[i].worker_count + 1
            }
            break
        }
    }

    em.collectors[collector_idx].assigned_source_id = source_id
}

fn update_collector(em: mut EconomyManager, idx: i32, delta_time: f32) {
    let mut collector: SupplyCollector = em.collectors[idx]

    // Handle hacker special case
    if (collector.collector_type == CollectorType::HACKER) {
        update_hacker(em, idx, delta_time)
        return
    }

    if (collector.state == CollectorState::IDLE) {
        // Find nearest source and depot
        let source_id: i32 = find_nearest_source(em, collector.position, collector.owner_id)
        let depot_id: i32 = find_nearest_depot(em, collector.position, collector.owner_id)

        if (source_id != -1 and depot_id != -1) {
            assign_collector_to_source(em, idx, source_id)
            collector.assigned_depot_id = depot_id
            collector.state = CollectorState::MOVING_TO_SOURCE

            // Set target to source position
            for i in 0..em.source_count {
                if (em.sources[i].id == source_id) {
                    collector.target_position = em.sources[i].position
                    break
                }
            }
        }
    }
    else if collector.state == CollectorState::MOVING_TO_SOURCE {
        // Move towards source
        let dx: f32 = collector.target_position.x - collector.position.x
        let dy: f32 = collector.target_position.y - collector.position.y
        let dz: f32 = collector.target_position.z - collector.position.z
        let dist: f32 = sqrt(dx*dx + dy*dy + dz*dz)

        if (dist < 5.0) {
            // Arrived at source
            collector.state = CollectorState::COLLECTING
            collector.collect_timer = 0.0
        } else {
            // Keep moving
            let speed: f32 = collector.move_speed * delta_time
            collector.position.x = collector.position.x + (dx / dist) * speed
            collector.position.y = collector.position.y + (dy / dist) * speed
            collector.position.z = collector.position.z + (dz / dist) * speed
        }
    }
    else if collector.state == CollectorState::COLLECTING {
        collector.collect_timer = collector.collect_timer + delta_time

        if (collector.collect_timer >= collector.collect_time) {
            // Collect supplies from source
            for i in 0..em.source_count {
                if (em.sources[i].id == collector.assigned_source_id) {
                    let gather: i32 = em.sources[i].gather_rate

                    if (em.sources[i].remaining_supplies != -1) {
                        // Finite source
                        if (em.sources[i].remaining_supplies >= gather) {
                            collector.current_load = gather
                            em.sources[i].remaining_supplies = em.sources[i].remaining_supplies - gather
                        } else {
                            collector.current_load = em.sources[i].remaining_supplies
                            em.sources[i].remaining_supplies = 0
                            em.sources[i].is_depleted = true
                        }
                    } else {
                        // Infinite source
                        collector.current_load = gather
                    }
                    break
                }
            }

            // Head back to depot
            collector.state = CollectorState::RETURNING_TO_BASE

            // Set target to depot position
            for i in 0..em.depot_count {
                if (em.depots[i].building_id == collector.assigned_depot_id) {
                    collector.target_position = em.depots[i].position
                    break
                }
            }
        }
    }
    else if collector.state == CollectorState::RETURNING_TO_BASE {
        // Move towards depot
        let dx: f32 = collector.target_position.x - collector.position.x
        let dy: f32 = collector.target_position.y - collector.position.y
        let dz: f32 = collector.target_position.z - collector.position.z
        let dist: f32 = sqrt(dx*dx + dy*dy + dz*dz)

        if (dist < 5.0) {
            // Arrived at depot
            collector.state = CollectorState::DEPOSITING
            collector.collect_timer = 0.0
        } else {
            // Keep moving
            let speed: f32 = collector.move_speed * delta_time
            collector.position.x = collector.position.x + (dx / dist) * speed
            collector.position.y = collector.position.y + (dy / dist) * speed
            collector.position.z = collector.position.z + (dz / dist) * speed
        }
    }
    else if collector.state == CollectorState::DEPOSITING {
        // Find depot for bonus
        let mut supply_bonus: f32 = 1.0
        for i in 0..em.depot_count {
            if (em.depots[i].building_id == collector.assigned_depot_id) {
                supply_bonus = 1.0 + em.depots[i].supply_bonus_percent
                collector.collect_timer = collector.collect_timer + delta_time

                if (collector.collect_timer >= em.depots[i].deposit_time) {
                    // Deposit supplies
                    let deposit_amount: i32 = cast(i32, cast(f32, collector.current_load) * supply_bonus)

                    // Apply player gather bonus
                    for j in 0..em.player_count {
                        if (em.player_resources[j].player_id == collector.owner_id) {
                            let final_amount: i32 = cast(i32, cast(f32, deposit_amount) * em.player_resources[j].supply_gather_bonus)
                            add_supplies(em.player_resources[j], final_amount)
                            break
                        }
                    }

                    collector.current_load = 0

                    // Check if source is depleted
                    let mut source_depleted: bool = false
                    for k in 0..em.source_count {
                        if (em.sources[k].id == collector.assigned_source_id) {
                            source_depleted = em.sources[k].is_depleted
                            break
                        }
                    }

                    if (source_depleted) {
                        // Find new source
                        collector.assigned_source_id = -1
                        collector.state = CollectorState::IDLE
                    } else {
                        // Head back to source
                        collector.state = CollectorState::MOVING_TO_SOURCE
                        for k in 0..em.source_count {
                            if (em.sources[k].id == collector.assigned_source_id) {
                                collector.target_position = em.sources[k].position
                                break
                            }
                        }
                    }
                }
                break
            }
        }
    }

    em.collectors[idx] = collector
}

fn update_hacker(em: mut EconomyManager, idx: i32, delta_time: f32) {
    let mut hacker: SupplyCollector = em.collectors[idx]

    // Hackers generate money while idle (hacking the internet)
    if (hacker.state == CollectorState::IDLE) {
        hacker.hack_timer = hacker.hack_timer + delta_time

        // Generate income every second
        if (hacker.hack_timer >= 1.0) {
            hacker.hack_timer = hacker.hack_timer - 1.0

            let income: i32 = cast(i32, hacker.hack_income_rate * hacker.internet_center_bonus)

            // Add to player resources
            for i in 0..em.player_count {
                if (em.player_resources[i].player_id == hacker.owner_id) {
                    add_supplies(em.player_resources[i], income)
                    break
                }
            }
        }
    }

    em.collectors[idx] = hacker
}

// ============================================================================
// PASSIVE INCOME
// ============================================================================

fn update_passive_income(em: mut EconomyManager, delta_time: f32) {
    // Update oil derricks
    for i in 0..em.source_count {
        if (em.sources[i].source_type == SupplySourceType::OIL_DERRICK) {
            if (em.sources[i].owner_id != -1) {
                // Add income to owner
                let income: i32 = cast(i32, cast(f32, em.sources[i].gather_rate) * delta_time)
                for j in 0..em.player_count {
                    if (em.player_resources[j].player_id == em.sources[i].owner_id) {
                        add_supplies(em.player_resources[j], income)
                        break
                    }
                }
            }
        }
    }

    // Update black markets
    for i in 0..em.depot_count {
        if (em.depots[i].depot_type == DepotType::BLACK_MARKET) {
            em.depots[i].income_timer = em.depots[i].income_timer + delta_time

            if (em.depots[i].income_timer >= 1.0) {
                em.depots[i].income_timer = em.depots[i].income_timer - 1.0

                let income: i32 = cast(i32, em.depots[i].passive_income_rate)
                for j in 0..em.player_count {
                    if (em.player_resources[j].player_id == em.depots[i].owner_id) {
                        add_supplies(em.player_resources[j], income)
                        break
                    }
                }
            }
        }
    }
}

// ============================================================================
// PRODUCTION QUEUE SYSTEM
// ============================================================================

enum ProductionType {
    UNIT,
    BUILDING,
    UPGRADE
}

struct ProductionItem {
    production_type: ProductionType,
    name: [u8; 32],
    cost: i32,
    build_time: f32,
    progress: f32,
    is_paused: bool
}

struct ProductionQueue {
    owner_id: i32,
    building_id: i32,           // Building producing items
    items: [ProductionItem; 16],
    item_count: i32,
    rally_point: Vec3,
    is_active: bool
}

fn create_production_queue(owner_id: i32, building_id: i32): ProductionQueue {
    return ProductionQueue {
        owner_id: owner_id,
        building_id: building_id,
        items: [],
        item_count: 0,
        rally_point: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
        is_active: true
    }
}

fn queue_unit(queue: mut ProductionQueue, name: [u8; 32], cost: i32, build_time: f32, resources: mut PlayerResources): bool {
    // Check if can afford
    if (not can_afford(resources, cost)) {
        return false
    }

    // Check queue capacity
    if (queue.item_count >= 16) {
        return false
    }

    // Deduct cost
    spend_supplies(resources, cost)

    // Add to queue
    queue.items[queue.item_count] = ProductionItem {
        production_type: ProductionType::UNIT,
        name: name,
        cost: cost,
        build_time: build_time,
        progress: 0.0,
        is_paused: false
    }
    queue.item_count = queue.item_count + 1

    return true
}

fn queue_upgrade(queue: mut ProductionQueue, name: [u8; 32], cost: i32, research_time: f32, resources: mut PlayerResources): bool {
    if (not can_afford(resources, cost)) {
        return false
    }

    if (queue.item_count >= 16) {
        return false
    }

    spend_supplies(resources, cost)

    queue.items[queue.item_count] = ProductionItem {
        production_type: ProductionType::UPGRADE,
        name: name,
        cost: cost,
        build_time: research_time,
        progress: 0.0,
        is_paused: false
    }
    queue.item_count = queue.item_count + 1

    return true
}

fn cancel_production(queue: mut ProductionQueue, index: i32, resources: mut PlayerResources) {
    if (index < 0 or index >= queue.item_count) {
        return
    }

    // Refund cost (partial if in progress)
    let item: ProductionItem = queue.items[index]
    let refund_percent: f32 = 1.0 - (item.progress / item.build_time)
    let refund: i32 = cast(i32, cast(f32, item.cost) * refund_percent)
    add_supplies(resources, refund)

    // Remove from queue
    for i in index..(queue.item_count - 1) {
        queue.items[i] = queue.items[i + 1]
    }
    queue.item_count = queue.item_count - 1
}

fn update_production_queue(queue: mut ProductionQueue, delta_time: f32, build_speed_bonus: f32): bool {
    // Returns true if an item completed

    if (queue.item_count == 0 or not queue.is_active) {
        return false
    }

    let mut current: ProductionItem = queue.items[0]

    if (current.is_paused) {
        return false
    }

    // Progress production
    current.progress = current.progress + (delta_time * build_speed_bonus)
    queue.items[0] = current

    if (current.progress >= current.build_time) {
        // Item completed - remove from queue
        for i in 0..(queue.item_count - 1) {
            queue.items[i] = queue.items[i + 1]
        }
        queue.item_count = queue.item_count - 1

        return true
    }

    return false
}

fn get_production_progress_percent(queue: ProductionQueue): f32 {
    if (queue.item_count == 0) {
        return 0.0
    }

    let current: ProductionItem = queue.items[0]
    return (current.progress / current.build_time) * 100.0
}

// ============================================================================
// BOUNTY SYSTEM
// ============================================================================

struct BountyConfig {
    infantry_bounty: i32,
    vehicle_bounty_percent: f32,     // % of unit cost
    building_bounty_percent: f32,
    hero_bounty: i32
}

fn get_default_bounty_config(): BountyConfig {
    return BountyConfig {
        infantry_bounty: 25,
        vehicle_bounty_percent: 0.25,
        building_bounty_percent: 0.15,
        hero_bounty: 500
    }
}

fn calculate_bounty(config: BountyConfig, unit_cost: i32, is_infantry: bool, is_hero: bool, is_building: bool): i32 {
    if (is_hero) {
        return config.hero_bounty
    }

    if (is_infantry) {
        return config.infantry_bounty
    }

    if (is_building) {
        return cast(i32, cast(f32, unit_cost) * config.building_bounty_percent)
    }

    // Vehicle
    return cast(i32, cast(f32, unit_cost) * config.vehicle_bounty_percent)
}

fn award_bounty(em: mut EconomyManager, player_id: i32, amount: i32) {
    for i in 0..em.player_count {
        if (em.player_resources[i].player_id == player_id) {
            add_supplies(em.player_resources[i], amount)
            break
        }
    }
}

// ============================================================================
// CRATE SYSTEM
// ============================================================================

enum CrateType {
    MONEY_SMALL,     // 500
    MONEY_MEDIUM,    // 1000
    MONEY_LARGE,     // 2500
    HEAL,
    VETERANCY,
    REVEAL_MAP
}

struct Crate {
    id: i32,
    crate_type: CrateType,
    position: Vec3,
    is_collected: bool
}

fn create_money_crate(id: i32, position: Vec3, size: i32): Crate {
    let crate_type: CrateType = match size {
        0 => CrateType::MONEY_SMALL,
        1 => CrateType::MONEY_MEDIUM,
        _ => CrateType::MONEY_LARGE
    }

    return Crate {
        id: id,
        crate_type: crate_type,
        position: position,
        is_collected: false
    }
}

fn get_crate_money_value(crate_type: CrateType): i32 {
    match crate_type {
        CrateType::MONEY_SMALL => return 500,
        CrateType::MONEY_MEDIUM => return 1000,
        CrateType::MONEY_LARGE => return 2500,
        _ => return 0
    }
}

fn collect_crate(em: mut EconomyManager, crate: mut Crate, player_id: i32) {
    if (crate.is_collected) { return }

    crate.is_collected = true

    match crate.crate_type {
        CrateType::MONEY_SMALL | CrateType::MONEY_MEDIUM | CrateType::MONEY_LARGE => {
            let value: i32 = get_crate_money_value(crate.crate_type)
            for i in 0..em.player_count {
                if (em.player_resources[i].player_id == player_id) {
                    add_supplies(em.player_resources[i], value)
                    break
                }
            }
        },
        _ => {}
    }
}

// ============================================================================
// ECONOMY UPDATE
// ============================================================================

fn update_economy(em: mut EconomyManager, delta_time: f32) {
    // Update all collectors
    for i in 0..em.collector_count {
        update_collector(em, i, delta_time)
    }

    // Update passive income sources
    update_passive_income(em, delta_time)

    // Update income rate tracking
    // (Rolling average would be calculated here)
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn sqrt(x: f32): f32 {
    // Newton-Raphson square root approximation
    if (x <= 0.0) { return 0.0 }

    let mut guess: f32 = x / 2.0
    for i in 0..10 {
        guess = (guess + x / guess) / 2.0
    }
    return guess
}

// ============================================================================
// DEBUG/TEST FUNCTIONS
// ============================================================================

fn test_economy_system() {
    print("Testing Economy System...")

    // Create manager
    let mut em: EconomyManager = create_economy_manager()

    // Register players
    register_player(em, 0, 0)  // USA
    register_player(em, 1, 2)  // GLA

    // Add supply docks
    let dock1_id: i32 = add_supply_source(em, create_supply_dock(0, Vec3 { x: 100.0, y: 0.0, z: 100.0 }))
    let dock2_id: i32 = add_supply_source(em, create_supply_dock(0, Vec3 { x: -100.0, y: 0.0, z: -100.0 }))

    print("Created supply docks: " + str(dock1_id) + ", " + str(dock2_id))

    // Add depots
    let depot1_id: i32 = add_depot(em, create_supply_center(0, 0, Vec3 { x: 50.0, y: 0.0, z: 50.0 }))
    let depot2_id: i32 = add_depot(em, create_supply_stash_depot(0, 1, Vec3 { x: -50.0, y: 0.0, z: -50.0 }))

    print("Created depots: " + str(depot1_id) + ", " + str(depot2_id))

    // Add collectors
    let chinook_id: i32 = add_collector(em, create_chinook(0, 0, Vec3 { x: 50.0, y: 10.0, z: 50.0 }))
    let worker_id: i32 = add_collector(em, create_worker(0, 1, Vec3 { x: -50.0, y: 0.0, z: -50.0 }))
    let hacker_id: i32 = add_collector(em, create_hacker(0, 1, Vec3 { x: -60.0, y: 0.0, z: -60.0 }))

    print("Created collectors: chinook=" + str(chinook_id) + ", worker=" + str(worker_id) + ", hacker=" + str(hacker_id))

    // Simulate for a few seconds
    for frame in 0..60 {
        update_economy(em, 0.1)  // 100ms per frame
    }

    // Check resources
    let p0_res: PlayerResources = get_player_resources(em, 0)
    let p1_res: PlayerResources = get_player_resources(em, 1)

    print("Player 0 (USA) supplies: " + str(p0_res.supplies))
    print("Player 1 (GLA) supplies: " + str(p1_res.supplies))

    // Test production queue
    let mut queue: ProductionQueue = create_production_queue(0, 1)
    let mut p0_mut: PlayerResources = p0_res

    let queued: bool = queue_unit(queue, "Ranger", 225, 5.0, p0_mut)
    print("Queued Ranger: " + str(queued))
    print("Remaining supplies after queue: " + str(p0_mut.supplies))

    // Test bounty
    let bounty_config: BountyConfig = get_default_bounty_config()
    let vehicle_bounty: i32 = calculate_bounty(bounty_config, 900, false, false, false)
    print("Crusader tank bounty: " + str(vehicle_bounty))

    // Test unit costs
    let usa_costs: [UnitCost; 32] = get_usa_unit_costs()
    print("Ranger cost: " + str(usa_costs[0].supply_cost))
    print("Crusader cost: " + str(usa_costs[5].supply_cost))

    let china_costs: [UnitCost; 32] = get_china_unit_costs()
    print("Red Guard cost: " + str(china_costs[0].supply_cost))
    print("Overlord cost: " + str(china_costs[8].supply_cost))

    let gla_costs: [UnitCost; 32] = get_gla_unit_costs()
    print("Rebel cost: " + str(gla_costs[0].supply_cost))
    print("SCUD Launcher cost: " + str(gla_costs[14].supply_cost))

    print("Economy System tests complete!")
}
