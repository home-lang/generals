// Display System - Resolution, Fullscreen, and Aspect Ratio Management
// Based on original C&C Generals display settings
// Implements: supported resolutions, fullscreen mode, aspect ratio handling

// ============================================================================
// Supported Resolutions (from original game)
// ============================================================================

struct Resolution {
    width: i32,
    height: i32,
    aspect_ratio: f32,
    name: String,
}

fn create_resolution(width: i32, height: i32, name: String) -> Resolution {
    let aspect = (width as f32) / (height as f32)
    return Resolution {
        width: width,
        height: height,
        aspect_ratio: aspect,
        name: name,
    }
}

// Standard resolutions supported by original Generals
const RESOLUTION_800x600: Resolution = create_resolution(800, 600, "800x600")
const RESOLUTION_1024x768: Resolution = create_resolution(1024, 768, "1024x768")
const RESOLUTION_1280x1024: Resolution = create_resolution(1280, 1024, "1280x1024")
const RESOLUTION_1600x1200: Resolution = create_resolution(1600, 1200, "1600x1200")

// Modern widescreen resolutions (extended support)
const RESOLUTION_1280x720: Resolution = create_resolution(1280, 720, "1280x720 (720p)")
const RESOLUTION_1920x1080: Resolution = create_resolution(1920, 1080, "1920x1080 (1080p)")
const RESOLUTION_2560x1440: Resolution = create_resolution(2560, 1440, "2560x1440 (1440p)")
const RESOLUTION_3840x2160: Resolution = create_resolution(3840, 2160, "3840x2160 (4K)")

// All supported resolutions
fn get_supported_resolutions() -> [Resolution] {
    return [
        // Original 4:3 resolutions
        RESOLUTION_800x600,
        RESOLUTION_1024x768,
        RESOLUTION_1280x1024,
        RESOLUTION_1600x1200,
        // Modern 16:9 resolutions
        RESOLUTION_1280x720,
        RESOLUTION_1920x1080,
        RESOLUTION_2560x1440,
        RESOLUTION_3840x2160,
    ]
}

// Default resolution (authentic original)
const DEFAULT_RESOLUTION: Resolution = RESOLUTION_800x600

// ============================================================================
// Aspect Ratio Handling
// ============================================================================

enum AspectRatioMode {
    STRETCH,        // Stretch to fill (distorts image)
    LETTERBOX,      // Black bars on top/bottom
    PILLARBOX,      // Black bars on left/right
    CROP,           // Crop to fill (loses content)
    AUTO,           // Automatically choose best fit
}

struct ViewportRect {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}

// Calculate viewport for given content and window dimensions
fn calculate_viewport(
    content_width: i32,
    content_height: i32,
    window_width: i32,
    window_height: i32,
    mode: AspectRatioMode
) -> ViewportRect {
    let content_aspect = (content_width as f32) / (content_height as f32)
    let window_aspect = (window_width as f32) / (window_height as f32)

    if mode == AspectRatioMode::STRETCH {
        // Fill entire window
        return ViewportRect {
            x: 0,
            y: 0,
            width: window_width,
            height: window_height,
        }
    }

    if mode == AspectRatioMode::AUTO {
        // Automatically determine letterbox or pillarbox
        if window_aspect > content_aspect {
            // Window is wider - pillarbox
            return calculate_pillarbox(content_width, content_height, window_width, window_height)
        } else {
            // Window is taller - letterbox
            return calculate_letterbox(content_width, content_height, window_width, window_height)
        }
    }

    if mode == AspectRatioMode::LETTERBOX {
        return calculate_letterbox(content_width, content_height, window_width, window_height)
    }

    if mode == AspectRatioMode::PILLARBOX {
        return calculate_pillarbox(content_width, content_height, window_width, window_height)
    }

    if mode == AspectRatioMode::CROP {
        return calculate_crop(content_width, content_height, window_width, window_height)
    }

    // Default to auto
    return calculate_viewport(content_width, content_height, window_width, window_height, AspectRatioMode::AUTO)
}

fn calculate_letterbox(content_width: i32, content_height: i32, window_width: i32, window_height: i32) -> ViewportRect {
    let content_aspect = (content_width as f32) / (content_height as f32)

    // Fit to width, calculate height
    let viewport_width = window_width
    let viewport_height = ((window_width as f32) / content_aspect) as i32

    let x = 0
    let y = (window_height - viewport_height) / 2

    return ViewportRect {
        x: x,
        y: y,
        width: viewport_width,
        height: viewport_height,
    }
}

fn calculate_pillarbox(content_width: i32, content_height: i32, window_width: i32, window_height: i32) -> ViewportRect {
    let content_aspect = (content_width as f32) / (content_height as f32)

    // Fit to height, calculate width
    let viewport_height = window_height
    let viewport_width = ((window_height as f32) * content_aspect) as i32

    let x = (window_width - viewport_width) / 2
    let y = 0

    return ViewportRect {
        x: x,
        y: y,
        width: viewport_width,
        height: viewport_height,
    }
}

fn calculate_crop(content_width: i32, content_height: i32, window_width: i32, window_height: i32) -> ViewportRect {
    let content_aspect = (content_width as f32) / (content_height as f32)
    let window_aspect = (window_width as f32) / (window_height as f32)

    let viewport_width: i32
    let viewport_height: i32

    if window_aspect > content_aspect {
        // Window wider than content - fit to width, crop height
        viewport_width = window_width
        viewport_height = ((window_width as f32) / content_aspect) as i32
    } else {
        // Window taller than content - fit to height, crop width
        viewport_height = window_height
        viewport_width = ((window_height as f32) * content_aspect) as i32
    }

    let x = (window_width - viewport_width) / 2
    let y = (window_height - viewport_height) / 2

    return ViewportRect {
        x: x,
        y: y,
        width: viewport_width,
        height: viewport_height,
    }
}

// ============================================================================
// Display Mode (Windowed/Fullscreen)
// ============================================================================

enum DisplayMode {
    WINDOWED,
    FULLSCREEN,
    FULLSCREEN_WINDOWED,  // Borderless fullscreen
}

// ============================================================================
// Display Settings
// ============================================================================

struct DisplaySettings {
    resolution: Resolution,
    mode: DisplayMode,
    aspect_mode: AspectRatioMode,
    vsync: Bool,
    refresh_rate: i32,
    gamma: f32,
    brightness: f32,
    contrast: f32,
    hdr_enabled: Bool,
    high_dpi: Bool,
}

fn default_display_settings() -> DisplaySettings {
    return DisplaySettings {
        resolution: DEFAULT_RESOLUTION,
        mode: DisplayMode::WINDOWED,
        aspect_mode: AspectRatioMode::AUTO,
        vsync: true,
        refresh_rate: 60,
        gamma: 1.0,
        brightness: 1.0,
        contrast: 1.0,
        hdr_enabled: false,
        high_dpi: true,
    }
}

// ============================================================================
// Display Manager
// ============================================================================

struct DisplayManager {
    settings: DisplaySettings,
    current_viewport: ViewportRect,
    native_width: i32,
    native_height: i32,
    scale_factor: f32,
    is_initialized: Bool,
}

fn create_display_manager() -> DisplayManager {
    return DisplayManager {
        settings: default_display_settings(),
        current_viewport: ViewportRect { x: 0, y: 0, width: 800, height: 600 },
        native_width: 800,
        native_height: 600,
        scale_factor: 1.0,
        is_initialized: false,
    }
}

fn init_display(dm: DisplayManager, native_width: i32, native_height: i32) {
    dm.native_width = native_width
    dm.native_height = native_height
    dm.is_initialized = true

    // Calculate initial viewport
    update_viewport(dm)
}

fn set_resolution(dm: DisplayManager, res: Resolution) {
    dm.settings.resolution = res
    update_viewport(dm)
}

fn set_display_mode(dm: DisplayManager, mode: DisplayMode) {
    dm.settings.mode = mode

    // Platform-specific fullscreen handling would go here
    // For macOS: NSWindow.toggleFullScreen
    // For Windows: SetWindowLongPtr with WS_POPUP
    // For Linux: XRandR or Wayland fullscreen protocol
}

fn set_aspect_mode(dm: DisplayManager, mode: AspectRatioMode) {
    dm.settings.aspect_mode = mode
    update_viewport(dm)
}

fn update_viewport(dm: DisplayManager) {
    // Calculate viewport based on current settings
    dm.current_viewport = calculate_viewport(
        dm.settings.resolution.width,
        dm.settings.resolution.height,
        dm.native_width,
        dm.native_height,
        dm.settings.aspect_mode
    )

    // Calculate scale factor for HiDPI
    if dm.settings.high_dpi {
        let scale_x = (dm.native_width as f32) / (dm.settings.resolution.width as f32)
        let scale_y = (dm.native_height as f32) / (dm.settings.resolution.height as f32)
        dm.scale_factor = min(scale_x, scale_y)
    } else {
        dm.scale_factor = 1.0
    }
}

fn toggle_fullscreen(dm: DisplayManager) {
    if dm.settings.mode == DisplayMode::WINDOWED {
        dm.settings.mode = DisplayMode::FULLSCREEN
    } else {
        dm.settings.mode = DisplayMode::WINDOWED
    }

    set_display_mode(dm, dm.settings.mode)
}

// Find closest supported resolution
fn find_closest_resolution(target_width: i32, target_height: i32) -> Resolution {
    let resolutions = get_supported_resolutions()
    let best: Resolution = RESOLUTION_800x600
    let best_diff = 999999999

    for res in resolutions {
        let diff = abs(res.width - target_width) + abs(res.height - target_height)
        if diff < best_diff {
            best_diff = diff
            best = res
        }
    }

    return best
}

// Get available resolutions for current display
fn get_available_resolutions(dm: DisplayManager) -> [Resolution] {
    let all_res = get_supported_resolutions()
    let available: [Resolution] = []

    for res in all_res {
        // Only include resolutions that fit on screen
        if res.width <= dm.native_width && res.height <= dm.native_height {
            available = available + [res]
        }
    }

    return available
}

// ============================================================================
// Coordinate Conversion (for mouse input, etc.)
// ============================================================================

fn screen_to_game_x(dm: DisplayManager, screen_x: i32) -> i32 {
    // Convert screen coordinates to game coordinates
    let viewport_x = screen_x - dm.current_viewport.x
    let game_x = ((viewport_x as f32) / (dm.current_viewport.width as f32) * (dm.settings.resolution.width as f32)) as i32
    return game_x
}

fn screen_to_game_y(dm: DisplayManager, screen_y: i32) -> i32 {
    let viewport_y = screen_y - dm.current_viewport.y
    let game_y = ((viewport_y as f32) / (dm.current_viewport.height as f32) * (dm.settings.resolution.height as f32)) as i32
    return game_y
}

fn game_to_screen_x(dm: DisplayManager, game_x: i32) -> i32 {
    let viewport_x = ((game_x as f32) / (dm.settings.resolution.width as f32) * (dm.current_viewport.width as f32)) as i32
    return viewport_x + dm.current_viewport.x
}

fn game_to_screen_y(dm: DisplayManager, game_y: i32) -> i32 {
    let viewport_y = ((game_y as f32) / (dm.settings.resolution.height as f32) * (dm.current_viewport.height as f32)) as i32
    return viewport_y + dm.current_viewport.y
}

// Check if screen point is inside game viewport
fn is_in_viewport(dm: DisplayManager, screen_x: i32, screen_y: i32) -> Bool {
    return screen_x >= dm.current_viewport.x &&
           screen_x < dm.current_viewport.x + dm.current_viewport.width &&
           screen_y >= dm.current_viewport.y &&
           screen_y < dm.current_viewport.y + dm.current_viewport.height
}

// ============================================================================
// Utility Functions
// ============================================================================

fn min(a: f32, b: f32) -> f32 {
    if a < b {
        return a
    }
    return b
}

fn abs(x: i32) -> i32 {
    if x < 0 {
        return -x
    }
    return x
}

// ============================================================================
// Tests
// ============================================================================

fn test_resolution_creation() -> Bool {
    let res = create_resolution(1920, 1080, "1920x1080")

    assert(res.width == 1920, "Width should be 1920")
    assert(res.height == 1080, "Height should be 1080")

    // 16:9 aspect ratio
    let expected_aspect = 1920.0 / 1080.0
    let diff = res.aspect_ratio - expected_aspect
    assert(diff > -0.01 && diff < 0.01, "Aspect ratio should be ~1.78")

    return true
}

fn test_letterbox_calculation() -> Bool {
    // 4:3 content in 16:9 window
    let viewport = calculate_letterbox(800, 600, 1920, 1080)

    // Should have pillarboxing (wider window)
    assert(viewport.width == 1920, "Width should fill window")
    assert(viewport.height < 1080, "Height should be less than window")
    assert(viewport.y > 0, "Should have top margin")

    return true
}

fn test_pillarbox_calculation() -> Bool {
    // 16:9 content in 4:3 window
    let viewport = calculate_pillarbox(1920, 1080, 800, 600)

    // Should have letterboxing (taller window relatively)
    assert(viewport.height == 600, "Height should fill window")
    assert(viewport.width < 800, "Width should be less than window")
    assert(viewport.x > 0, "Should have left margin")

    return true
}

fn test_display_manager() -> Bool {
    let dm = create_display_manager()

    init_display(dm, 1920, 1080)

    assert(dm.is_initialized, "Should be initialized")
    assert(dm.native_width == 1920, "Native width should be 1920")
    assert(dm.native_height == 1080, "Native height should be 1080")

    return true
}

fn test_coordinate_conversion() -> Bool {
    let dm = create_display_manager()
    init_display(dm, 1920, 1080)

    // With default 800x600 in 1920x1080, should have letterboxing
    let screen_x = dm.current_viewport.x + dm.current_viewport.width / 2
    let screen_y = dm.current_viewport.y + dm.current_viewport.height / 2

    let game_x = screen_to_game_x(dm, screen_x)
    let game_y = screen_to_game_y(dm, screen_y)

    // Center of viewport should map to center of game resolution
    assert(game_x == 400, "Game X should be 400 (center of 800)")
    assert(game_y == 300, "Game Y should be 300 (center of 600)")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_resolution_creation(), "Resolution creation test failed")
    assert(test_letterbox_calculation(), "Letterbox calculation test failed")
    assert(test_pillarbox_calculation(), "Pillarbox calculation test failed")
    assert(test_display_manager(), "Display manager test failed")
    assert(test_coordinate_conversion(), "Coordinate conversion test failed")
    return true
}
