// KindOf system for C&C Generals Zero Hour
// Based on Thyme's kindof.h - Object categorization/flags
// Written in Home language

// KindOf flags for categorizing objects
// These are bitflags that describe what type of object this is
enum KindOf {
    // Basic types
    OBSTACLE = 0,              // Blocks pathing
    SELECTABLE = 1,            // Can be selected by player
    IMMOBILE = 2,              // Cannot move
    CAN_ATTACK = 3,            // Can attack other units
    STICK_TO_TERRAIN_SLOPE = 4, // Rotates to match terrain
    CAN_CAST_REFLECTIONS = 5,  // Has water reflections
    SHRUBBERY = 6,             // Tree/shrub

    // Major categories
    STRUCTURE = 7,             // Building
    INFANTRY = 8,              // Infantry unit
    VEHICLE = 9,               // Ground vehicle
    AIRCRAFT = 10,             // Flying unit
    HUGE_VEHICLE = 11,         // Large vehicle (Overlord tank)

    // Special roles
    DOZER = 12,                // Construction dozer
    HARVESTER = 13,            // Supply truck
    COMMANDCENTER = 14,        // Command center building
    LINEBUILD = 15,            // Can build in a line (walls)
    SALVAGER = 16,             // Salvages wreckage
    WEAPON_SALVAGER = 17,      // GLA weapon salvager
    TRANSPORT = 18,            // Can transport units

    // Bridges
    BRIDGE = 19,               // Bridge
    LANDMARK_BRIDGE = 20,      // Story bridge
    BRIDGE_TOWER = 21,         // Bridge support

    // Projectiles
    PROJECTILE = 22,           // Is a projectile
    PRELOAD = 23,              // Preload at game start
    NO_GARRISON = 24,          // Cannot garrison buildings
    WAVEGUIDE = 25,            // Waveguide object
    WAVE_EFFECT = 26,          // Wave effect

    // Physics/collision
    NO_COLLIDE = 27,           // Doesn't collide

    // Support structures
    REPAIR_PAD = 28,           // Repairs vehicles
    HEAL_PAD = 29,             // Heals infantry
    STEALTH_GARRISON = 30,     // Stealth tunnel entrance
    CASH_GENERATOR = 31,       // Generates money

    // Rendering/gameplay
    DRAWABLE_ONLY = 32,        // Only visual, no logic
    MP_COUNT_FOR_VICTORY = 33, // Counts for victory conditions
    REBUILD_HOLE = 34,         // Can rebuild building foundations
    SCORE = 35,                // Counts for score
    SCORE_CREATE = 36,         // Score when created
    SCORE_DESTROY = 37,        // Score when destroyed
    NO_HEAL_ICON = 38,         // Don't show heal cursor

    // Infantry abilities
    CAN_RAPPEL = 39,           // Can rappel from helicopters
    PARACHUTABLE = 40,         // Can parachute
    CAN_BE_REPULSED = 41,      // Affected by push effects

    // Special
    MOB_NEXUS = 42,            // Crowd control nexus
    IGNORED_IN_GUI = 43,       // Hidden from UI
    CRATE = 44,                // Supply crate
    CAPTURABLE = 45,           // Can be captured
    CLEARED_BY_BUILD = 46,     // Removed when building placed

    // Missiles/weapons
    SMALL_MISSILE = 47,        // Small missile
    ALWAYS_VISIBLE = 48,       // Always visible (no FOW)
    UNATTACKABLE = 49,         // Cannot be attacked
    MINE = 50,                 // Land mine
    CLEANUP_HAZARD = 51,       // Toxic/hazard
    PORTABLE_STRUCTURE = 52,   // Can be packed/unpacked

    // Selection
    ALWAYS_SELECTABLE = 53,    // Can always select
    ATTACK_NEEDS_LINE_OF_SIGHT = 54, // Must have LOS to attack

    // Walls
    WALK_ON_TOP_OF_WALL = 55,  // Infantry can walk on wall
    DEFENSIVE_WALL = 56,       // Is a wall

    // Fake/Special buildings
    FS_POWER = 57,             // Fake power plant
    FS_FACTORY = 58,           // Fake factory
    FS_BASE_DEFENSE = 59,      // Fake defense
    FS_TECHNOLOGY = 60,        // Fake tech building

    // Aircraft behavior
    AIRCRAFT_PATH_AROUND = 61, // Aircraft avoid this

    // Misc
    LOW_OVERLAPPABLE = 62,     // Can be overlapped
    FORCEATTACKABLE = 63,      // Can force-attack
    AUTO_RALLYPOINT = 64,      // Auto rally point
    TECH_BUILDING = 65,        // Tech building (neutral)
    POWERED = 66,              // Requires power
    PRODUCED_AT_HELIPAD = 67,  // Builds at helipad
    DRONE = 68,                // Is a drone
    CAN_SEE_THROUGH_STRUCTURE = 69, // Can see through buildings
    BALLISTIC_MISSILE = 70,    // Ballistic missile
    CLICK_THROUGH = 71,        // Click goes through
    SUPPLY_SOURCE_ON_PREVIEW = 72, // Shows supply range
    PARACHUTE = 73,            // Is a parachute
    GARRISONABLE_UNTIL_DESTROYED = 74, // Can garrison until dead
    BOAT = 75,                 // Naval unit
    IMMUNE_TO_CAPTURE = 76,    // Cannot be captured
    HULK = 77,                 // Is a wreck/hulk
    SHOW_PORTRAIT_WHEN_CONTROLLED = 78, // Show portrait

    // Spawning
    SPAWNS_ARE_THE_WEAPONS = 79, // Spawned units are weapons
    CANNOT_BUILD_NEAR_SUPPLIES = 80, // Can't build near supply

    // Supply
    SUPPLY_SOURCE = 81,        // Supply dock/center
    REVEAL_TO_ALL = 82,        // Visible to all players

    // Special infantry
    DISGUISER = 83,            // Can disguise (Lotus)
    INERT = 84,                // Inert/inactive
    HERO = 85,                 // Hero unit
    IGNORES_SELECT_ALL = 86,   // Not included in select all
    DONT_AUTO_CRUSH_INFANTRY = 87, // Won't auto-crush
    CLIFF_JUMPER = 88,         // Can jump cliffs

    // More Fake/Special buildings
    FS_SUPPLY_DROPZONE = 89,   // Fake supply drop
    FS_SUPERWEAPON = 90,       // Fake superweapon
    FS_BLACK_MARKET = 91,      // Fake black market
    FS_SUPPLY_CENTER = 92,     // Fake supply center
    FS_STRATEGY_CENTER = 93,   // Fake strategy center

    // Special abilities
    MONEY_HACKER = 94,         // Hacker unit
    ARMOR_SALVAGER = 95,       // Armor salvager
    REVEALS_ENEMY_PATHS = 96,  // Reveals enemy moves
    BOOBY_TRAP = 97,           // Booby trap
    FS_FAKE = 98,              // Generic fake
    FS_INTERNET_CENTER = 99,   // Fake internet center
    BLAST_CRATER = 100,        // Crater left by explosion
    PROP = 101,                // Prop/decoration
    OPTIMIZED_TREE = 102,      // Optimized tree rendering

    // More Fake buildings
    FS_ADVANCED_TECH = 103,    // Fake advanced tech
    FS_BARRACKS = 104,         // Fake barracks
    FS_WARFACTORY = 105,       // Fake war factory
    FS_AIRFIELD = 106,         // Fake airfield

    // Carriers
    AIRCRAFT_CARRIER = 107,    // Aircraft carrier

    // Selection/control
    NO_SELECT = 108,           // Cannot select
    REJECT_UNMANNED = 109,     // Reject if no pilot
    CANNOT_RETALIATE = 110,    // Won't retaliate
    TECH_BASE_DEFENSE = 111,   // Tech defense building

    // Special properties
    EMP_HARDENED = 112,        // Immune to EMP
    DEMOTRAP = 113,            // Demo trap
    CONSERVATIVE_BUILDING = 114, // Conservative faction
    IGNORE_DOCKING_BONES = 115, // Ignore docking
}

// Bitmask for KindOf flags
struct KindOfMask {
    bits: Int,  // Bitfield storing all flags

    fn init() -> KindOfMask {
        return KindOfMask { bits: 0 }
    }

    fn set(self, kind: KindOf) {
        let bit = 1 << (kind as Int)
        self.bits = self.bits | bit
    }

    fn clear(self, kind: KindOf) {
        let bit = 1 << (kind as Int)
        self.bits = self.bits & (~bit)
    }

    fn test(self, kind: KindOf) -> Bool {
        let bit = 1 << (kind as Int)
        return (self.bits & bit) != 0
    }

    fn test_any(self, other: KindOfMask) -> Bool {
        return (self.bits & other.bits) != 0
    }

    fn test_all(self, other: KindOfMask) -> Bool {
        return (self.bits & other.bits) == other.bits
    }

    fn is_empty(self) -> Bool {
        return self.bits == 0
    }

    fn clear_all(self) {
        self.bits = 0
    }
}

// Common KindOf combinations
fn kindof_mask_structure() -> KindOfMask {
    let mask = KindOfMask::init()
    mask.set(KindOf::STRUCTURE)
    mask.set(KindOf::SELECTABLE)
    mask.set(KindOf::IMMOBILE)
    return mask
}

fn kindof_mask_infantry() -> KindOfMask {
    let mask = KindOfMask::init()
    mask.set(KindOf::INFANTRY)
    mask.set(KindOf::SELECTABLE)
    mask.set(KindOf::CAN_ATTACK)
    return mask
}

fn kindof_mask_vehicle() -> KindOfMask {
    let mask = KindOfMask::init()
    mask.set(KindOf::VEHICLE)
    mask.set(KindOf::SELECTABLE)
    mask.set(KindOf::CAN_ATTACK)
    return mask
}

fn kindof_mask_aircraft() -> KindOfMask {
    let mask = KindOfMask::init()
    mask.set(KindOf::AIRCRAFT)
    mask.set(KindOf::SELECTABLE)
    mask.set(KindOf::CAN_ATTACK)
    return mask
}

fn kindof_mask_dozer() -> KindOfMask {
    let mask = KindOfMask::init()
    mask.set(KindOf::VEHICLE)
    mask.set(KindOf::DOZER)
    mask.set(KindOf::SELECTABLE)
    return mask
}

fn kindof_mask_harvester() -> KindOfMask {
    let mask = KindOfMask::init()
    mask.set(KindOf::VEHICLE)
    mask.set(KindOf::HARVESTER)
    mask.set(KindOf::SELECTABLE)
    return mask
}

fn kindof_mask_command_center() -> KindOfMask {
    let mask = KindOfMask::init()
    mask.set(KindOf::STRUCTURE)
    mask.set(KindOf::COMMANDCENTER)
    mask.set(KindOf::SELECTABLE)
    mask.set(KindOf::IMMOBILE)
    return mask
}

// Fake structure mask (all FS_ types)
fn kindof_mask_fake_structure() -> KindOfMask {
    let mask = KindOfMask::init()
    mask.set(KindOf::FS_POWER)
    mask.set(KindOf::FS_FACTORY)
    mask.set(KindOf::FS_BASE_DEFENSE)
    mask.set(KindOf::FS_TECHNOLOGY)
    mask.set(KindOf::FS_SUPPLY_DROPZONE)
    mask.set(KindOf::FS_SUPERWEAPON)
    mask.set(KindOf::FS_BLACK_MARKET)
    mask.set(KindOf::FS_SUPPLY_CENTER)
    mask.set(KindOf::FS_STRATEGY_CENTER)
    mask.set(KindOf::FS_FAKE)
    mask.set(KindOf::FS_INTERNET_CENTER)
    mask.set(KindOf::FS_ADVANCED_TECH)
    mask.set(KindOf::FS_BARRACKS)
    mask.set(KindOf::FS_WARFACTORY)
    mask.set(KindOf::FS_AIRFIELD)
    return mask
}

// Helper functions
fn is_structure(mask: KindOfMask) -> Bool {
    return mask.test(KindOf::STRUCTURE)
}

fn is_infantry(mask: KindOfMask) -> Bool {
    return mask.test(KindOf::INFANTRY)
}

fn is_vehicle(mask: KindOfMask) -> Bool {
    return mask.test(KindOf::VEHICLE)
}

fn is_aircraft(mask: KindOfMask) -> Bool {
    return mask.test(KindOf::AIRCRAFT)
}

fn is_mobile(mask: KindOfMask) -> Bool {
    return !mask.test(KindOf::IMMOBILE)
}

fn can_attack(mask: KindOfMask) -> Bool {
    return mask.test(KindOf::CAN_ATTACK)
}

fn is_selectable(mask: KindOfMask) -> Bool {
    if mask.test(KindOf::NO_SELECT) {
        return false
    }
    return mask.test(KindOf::SELECTABLE) || mask.test(KindOf::ALWAYS_SELECTABLE)
}

fn is_hero(mask: KindOfMask) -> Bool {
    return mask.test(KindOf::HERO)
}

fn is_dozer(mask: KindOfMask) -> Bool {
    return mask.test(KindOf::DOZER)
}

fn is_harvester(mask: KindOfMask) -> Bool {
    return mask.test(KindOf::HARVESTER)
}

fn can_be_captured(mask: KindOfMask) -> Bool {
    if mask.test(KindOf::IMMUNE_TO_CAPTURE) {
        return false
    }
    return mask.test(KindOf::CAPTURABLE)
}

fn is_fake_structure(mask: KindOfMask) -> Bool {
    let fake_mask = kindof_mask_fake_structure()
    return mask.test_any(fake_mask)
}

// Tests
test "KindOfMask: set and test" {
    let mask = KindOfMask::init()
    assert !mask.test(KindOf::STRUCTURE)

    mask.set(KindOf::STRUCTURE)
    assert mask.test(KindOf::STRUCTURE)

    mask.clear(KindOf::STRUCTURE)
    assert !mask.test(KindOf::STRUCTURE)
}

test "KindOfMask: multiple flags" {
    let mask = KindOfMask::init()
    mask.set(KindOf::STRUCTURE)
    mask.set(KindOf::SELECTABLE)
    mask.set(KindOf::IMMOBILE)

    assert mask.test(KindOf::STRUCTURE)
    assert mask.test(KindOf::SELECTABLE)
    assert mask.test(KindOf::IMMOBILE)
    assert !mask.test(KindOf::VEHICLE)
}

test "KindOfMask: test_any" {
    let mask1 = KindOfMask::init()
    mask1.set(KindOf::STRUCTURE)
    mask1.set(KindOf::SELECTABLE)

    let mask2 = KindOfMask::init()
    mask2.set(KindOf::SELECTABLE)
    mask2.set(KindOf::VEHICLE)

    assert mask1.test_any(mask2)  // Both have SELECTABLE
}

test "KindOfMask: test_all" {
    let mask1 = KindOfMask::init()
    mask1.set(KindOf::STRUCTURE)
    mask1.set(KindOf::SELECTABLE)
    mask1.set(KindOf::IMMOBILE)

    let mask2 = KindOfMask::init()
    mask2.set(KindOf::STRUCTURE)
    mask2.set(KindOf::SELECTABLE)

    assert mask1.test_all(mask2)  // mask1 has all of mask2's flags
    assert !mask2.test_all(mask1) // mask2 doesn't have all of mask1's flags
}

test "KindOfMask: predefined masks" {
    let infantry = kindof_mask_infantry()
    assert is_infantry(infantry)
    assert !is_structure(infantry)
    assert can_attack(infantry)
    assert is_mobile(infantry)

    let structure = kindof_mask_structure()
    assert is_structure(structure)
    assert !is_infantry(structure)
    assert !is_mobile(structure)
}

test "KindOfMask: dozer" {
    let dozer = kindof_mask_dozer()
    assert is_dozer(dozer)
    assert is_vehicle(dozer)
    assert is_selectable(dozer)
}

test "KindOfMask: hero" {
    let mask = KindOfMask::init()
    mask.set(KindOf::INFANTRY)
    mask.set(KindOf::HERO)
    mask.set(KindOf::SELECTABLE)

    assert is_hero(mask)
    assert is_infantry(mask)
}

test "KindOfMask: capture immunity" {
    let mask = KindOfMask::init()
    mask.set(KindOf::STRUCTURE)
    mask.set(KindOf::CAPTURABLE)

    assert can_be_captured(mask)

    mask.set(KindOf::IMMUNE_TO_CAPTURE)
    assert !can_be_captured(mask)
}

test "KindOfMask: fake structures" {
    let mask = KindOfMask::init()
    mask.set(KindOf::FS_BARRACKS)

    assert is_fake_structure(mask)
}

test "KindOfMask: selection" {
    let mask1 = KindOfMask::init()
    mask1.set(KindOf::SELECTABLE)
    assert is_selectable(mask1)

    let mask2 = KindOfMask::init()
    mask2.set(KindOf::NO_SELECT)
    assert !is_selectable(mask2)

    let mask3 = KindOfMask::init()
    mask3.set(KindOf::ALWAYS_SELECTABLE)
    assert is_selectable(mask3)
}
