// Unit AI Behaviors for C&C Generals Zero Hour
// Micro-management behaviors: kiting, focus fire, auto-abilities, retreat logic, threat assessment
// Written in Home language

// Behavior types
enum BehaviorType {
    IDLE = 0,
    ATTACK = 1,
    KITE = 2,
    FOCUS_FIRE = 3,
    RETREAT = 4,
    AUTO_ABILITY = 5,
    GUARD = 6,
    PATROL = 7,
}

// Threat level
enum ThreatLevel {
    NONE = 0,
    LOW = 1,
    MEDIUM = 2,
    HIGH = 3,
    CRITICAL = 4,
}

// Target priority
enum TargetPriority {
    CLOSEST = 0,
    WEAKEST = 1,
    STRONGEST = 2,
    MOST_DANGEROUS = 3,
    SUPPORT_UNITS = 4,
}

// Kiting behavior - attack while maintaining distance
struct KitingBehavior {
    unit_id: i32,
    target_id: i32,
    optimal_range: f64,
    current_range: f64,
    is_retreating: bool,
    cooldown_remaining: f64,

    fn init(unit_id: i32): KitingBehavior {
        return KitingBehavior {
            unit_id: unit_id,
            target_id: -1,
            optimal_range: 10.0,
            current_range: 0.0,
            is_retreating: false,
            cooldown_remaining: 0.0,
        }
    }

    fn update(&self, delta_time: f64, unit_pos: Vec2, target_pos: Vec2, weapon_range: f64, attack_cooldown: f64): BehaviorCommand? {
        self.optimal_range = weapon_range * 0.9
        self.current_range = self.distance(unit_pos, target_pos)
        self.cooldown_remaining = attack_cooldown

        // Too close and weapon is on cooldown - retreat
        if self.current_range < self.optimal_range && self.cooldown_remaining > 0.0 {
            self.is_retreating = true
            let retreat_dir = self.normalize(self.subtract(unit_pos, target_pos))
            let retreat_pos = self.add(unit_pos, self.scale(retreat_dir, 5.0))
            return BehaviorCommand::init(BehaviorCommandType::MOVE, retreat_pos.x, retreat_pos.y, -1)
        }

        // In range and weapon ready - attack
        if self.current_range <= weapon_range && self.cooldown_remaining <= 0.0 {
            self.is_retreating = false
            return BehaviorCommand::init(BehaviorCommandType::ATTACK, target_pos.x, target_pos.y, self.target_id)
        }

        // Too far - move closer
        if self.current_range > weapon_range {
            self.is_retreating = false
            let approach_dir = self.normalize(self.subtract(target_pos, unit_pos))
            let approach_pos = self.add(unit_pos, self.scale(approach_dir, 3.0))
            return BehaviorCommand::init(BehaviorCommandType::MOVE, approach_pos.x, approach_pos.y, -1)
        }

        return null
    }

    fn set_target(&self, target_id: i32) {
        self.target_id = target_id
    }

    fn has_target(&self): bool {
        return self.target_id != -1
    }

    fn distance(&self, a: Vec2, b: Vec2): f64 {
        let dx = b.x - a.x
        let dy = b.y - a.y
        return self.sqrt(dx * dx + dy * dy)
    }

    fn normalize(&self, v: Vec2): Vec2 {
        let len = self.sqrt(v.x * v.x + v.y * v.y)
        if len == 0.0 {
            return Vec2::init(0.0, 0.0)
        }
        return Vec2::init(v.x / len, v.y / len)
    }

    fn subtract(&self, a: Vec2, b: Vec2): Vec2 {
        return Vec2::init(a.x - b.x, a.y - b.y)
    }

    fn add(&self, a: Vec2, b: Vec2): Vec2 {
        return Vec2::init(a.x + b.x, a.y + b.y)
    }

    fn scale(&self, v: Vec2, s: f64): Vec2 {
        return Vec2::init(v.x * s, v.y * s)
    }

    fn sqrt(&self, x: f64): f64 {
        // Simple approximation
        if x <= 0.0 {
            return 0.0
        }
        let guess = x / 2.0
        let epsilon = 0.01
        let max_iter = 10
        let iter = 0
        while iter < max_iter {
            let next = (guess + x / guess) / 2.0
            if self.abs(next - guess) < epsilon {
                return next
            }
            guess = next
            iter = iter + 1
        }
        return guess
    }

    fn abs(&self, x: f64): f64 {
        if x < 0.0 {
            return -x
        }
        return x
    }
}

// Focus fire behavior - coordinate attacks on single target
struct FocusFireBehavior {
    unit_ids: Vec<i32>,
    current_target_id: i32,
    target_priority: TargetPriority,
    retarget_on_death: bool,

    fn init(): FocusFireBehavior {
        return FocusFireBehavior {
            unit_ids: Vec::new(),
            current_target_id: -1,
            target_priority: TargetPriority::MOST_DANGEROUS,
            retarget_on_death: true,
        }
    }

    fn add_unit(&self, unit_id: i32) {
        self.unit_ids.add(unit_id)
    }

    fn remove_unit(&self, unit_id: i32) {
        let index = self.unit_ids.index_of(unit_id)
        if index != -1 {
            self.unit_ids.remove_at(index)
        }
    }

    fn select_target(&self, available_targets: Vec<TargetInfo>): i32 {
        if available_targets.count() == 0 {
            return -1
        }

        match self.target_priority {
            TargetPriority::CLOSEST => return self.find_closest_target(available_targets),
            TargetPriority::WEAKEST => return self.find_weakest_target(available_targets),
            TargetPriority::STRONGEST => return self.find_strongest_target(available_targets),
            TargetPriority::MOST_DANGEROUS => return self.find_most_dangerous_target(available_targets),
            TargetPriority::SUPPORT_UNITS => return self.find_support_unit(available_targets),
            _ => return available_targets.get(0).id,
        }
    }

    fn find_closest_target(&self, targets: Vec<TargetInfo>): i32 {
        let closest_id = -1
        let min_distance = 999999.0

        for i in 0..targets.count() {
            let target = targets.get(i)
            if target.distance < min_distance {
                min_distance = target.distance
                closest_id = target.id
            }
        }

        return closest_id
    }

    fn find_weakest_target(&self, targets: Vec<TargetInfo>): i32 {
        let weakest_id = -1
        let min_health = 999999.0

        for i in 0..targets.count() {
            let target = targets.get(i)
            if target.health < min_health {
                min_health = target.health
                weakest_id = target.id
            }
        }

        return weakest_id
    }

    fn find_strongest_target(&self, targets: Vec<TargetInfo>): i32 {
        let strongest_id = -1
        let max_health = 0.0

        for i in 0..targets.count() {
            let target = targets.get(i)
            if target.health > max_health {
                max_health = target.health
                strongest_id = target.id
            }
        }

        return strongest_id
    }

    fn find_most_dangerous_target(&self, targets: Vec<TargetInfo>): i32 {
        let dangerous_id = -1
        let max_threat = 0.0

        for i in 0..targets.count() {
            let target = targets.get(i)
            if target.threat_value > max_threat {
                max_threat = target.threat_value
                dangerous_id = target.id
            }
        }

        return dangerous_id
    }

    fn find_support_unit(&self, targets: Vec<TargetInfo>): i32 {
        // Prioritize healers, supply units, etc.
        for i in 0..targets.count() {
            let target = targets.get(i)
            if target.is_support {
                return target.id
            }
        }

        // Fall back to closest if no support found
        return self.find_closest_target(targets)
    }

    fn update_target(&self, available_targets: Vec<TargetInfo>, current_target_alive: bool) {
        if self.current_target_id == -1 || (!current_target_alive && self.retarget_on_death) {
            self.current_target_id = self.select_target(available_targets)
        }
    }

    fn get_target(&self): i32 {
        return self.current_target_id
    }

    fn set_priority(&self, priority: TargetPriority) {
        self.target_priority = priority
    }

    fn get_unit_count(&self): i32 {
        return self.unit_ids.count()
    }
}

// Retreat behavior - run away when heavily damaged
struct RetreatBehavior {
    unit_id: i32,
    health_threshold: f64,
    is_retreating: bool,
    rally_point: Vec2?,
    min_safe_distance: f64,

    fn init(unit_id: i32): RetreatBehavior {
        return RetreatBehavior {
            unit_id: unit_id,
            health_threshold: 0.25,
            is_retreating: false,
            rally_point: null,
            min_safe_distance: 20.0,
        }
    }

    fn should_retreat(&self, current_health: f64, max_health: f64): bool {
        let health_percent = current_health / max_health
        return health_percent <= self.health_threshold
    }

    fn update(&self, current_health: f64, max_health: f64, unit_pos: Vec2, nearest_enemy_pos: Vec2?): BehaviorCommand? {
        if self.should_retreat(current_health, max_health) {
            self.is_retreating = true

            // Retreat to rally point if set
            if let Some(rally) = self.rally_point {
                return BehaviorCommand::init(BehaviorCommandType::MOVE, rally.x, rally.y, -1)
            }

            // Otherwise retreat away from nearest enemy
            if let Some(enemy_pos) = nearest_enemy_pos {
                let retreat_dir = Vec2::init(unit_pos.x - enemy_pos.x, unit_pos.y - enemy_pos.y)
                let len = self.sqrt(retreat_dir.x * retreat_dir.x + retreat_dir.y * retreat_dir.y)
                if len > 0.0 {
                    retreat_dir.x = retreat_dir.x / len
                    retreat_dir.y = retreat_dir.y / len
                }
                let retreat_pos = Vec2::init(
                    unit_pos.x + retreat_dir.x * self.min_safe_distance,
                    unit_pos.y + retreat_dir.y * self.min_safe_distance
                )
                return BehaviorCommand::init(BehaviorCommandType::MOVE, retreat_pos.x, retreat_pos.y, -1)
            }
        } else {
            self.is_retreating = false
        }

        return null
    }

    fn set_rally_point(&self, x: f64, y: f64) {
        self.rally_point = Vec2::init(x, y)
    }

    fn clear_rally_point(&self) {
        self.rally_point = null
    }

    fn set_health_threshold(&self, threshold: f64) {
        self.health_threshold = threshold
    }

    fn sqrt(&self, x: f64): f64 {
        if x <= 0.0 {
            return 0.0
        }
        let guess = x / 2.0
        let epsilon = 0.01
        let max_iter = 10
        let iter = 0
        while iter < max_iter {
            let next = (guess + x / guess) / 2.0
            if self.abs(next - guess) < epsilon {
                return next
            }
            guess = next
            iter = iter + 1
        }
        return guess
    }

    fn abs(&self, x: f64): f64 {
        if x < 0.0 {
            return -x
        }
        return x
    }
}

// Auto-ability behavior - automatically use unit abilities
struct AutoAbilityBehavior {
    unit_id: i32,
    ability_id: i32,
    auto_cast_enabled: bool,
    cooldown_remaining: f64,
    condition_type: AbilityConditionType,
    condition_value: f64,

    fn init(unit_id: i32, ability_id: i32): AutoAbilityBehavior {
        return AutoAbilityBehavior {
            unit_id: unit_id,
            ability_id: ability_id,
            auto_cast_enabled: false,
            cooldown_remaining: 0.0,
            condition_type: AbilityConditionType::ALWAYS,
            condition_value: 0.0,
        }
    }

    fn update(&self, delta_time: f64, context: AbilityContext): BehaviorCommand? {
        if !self.auto_cast_enabled {
            return null
        }

        if self.cooldown_remaining > 0.0 {
            self.cooldown_remaining = self.cooldown_remaining - delta_time
            return null
        }

        if self.should_cast(context) {
            self.cooldown_remaining = context.ability_cooldown
            return BehaviorCommand::init(BehaviorCommandType::USE_ABILITY, context.target_x, context.target_y, context.target_id)
        }

        return null
    }

    fn should_cast(&self, context: AbilityContext): bool {
        match self.condition_type {
            AbilityConditionType::ALWAYS => return true,
            AbilityConditionType::HEALTH_BELOW => return context.unit_health < self.condition_value,
            AbilityConditionType::HEALTH_ABOVE => return context.unit_health > self.condition_value,
            AbilityConditionType::ENEMIES_NEARBY => return context.nearby_enemy_count >= self.condition_value as Int,
            AbilityConditionType::ALLIES_NEARBY => return context.nearby_ally_count >= self.condition_value as Int,
            _ => return false,
        }
    }

    fn enable_auto_cast(&self) {
        self.auto_cast_enabled = true
    }

    fn disable_auto_cast(&self) {
        self.auto_cast_enabled = false
    }

    fn set_condition(&self, condition_type: AbilityConditionType, value: f64) {
        self.condition_type = condition_type
        self.condition_value = value
    }

    fn is_ready(&self): bool {
        return self.cooldown_remaining <= 0.0
    }
}

// Threat assessment - evaluate danger of enemies
struct ThreatAssessment {
    unit_id: i32,
    threat_sources: Vec<ThreatSource>,
    total_threat: f64,
    highest_threat_id: i32,

    fn init(unit_id: i32): ThreatAssessment {
        return ThreatAssessment {
            unit_id: unit_id,
            threat_sources: Vec::new(),
            total_threat: 0.0,
            highest_threat_id: -1,
        }
    }

    fn add_threat_source(&self, enemy_id: i32, damage: f64, distance: f64, is_anti_armor: bool, is_aoe: bool) {
        let threat = self.calculate_threat(damage, distance, is_anti_armor, is_aoe)
        let source = ThreatSource::init(enemy_id, threat, damage, distance)
        self.threat_sources.add(source)
        self.update_total_threat()
    }

    fn calculate_threat(&self, damage: f64, distance: f64, is_anti_armor: bool, is_aoe: bool): f64 {
        let base_threat = damage

        // Distance modifier - closer = more threatening
        let distance_mod = 1.0
        if distance < 10.0 {
            distance_mod = 2.0
        } else if distance < 20.0 {
            distance_mod = 1.5
        }

        // Type modifiers
        let type_mod = 1.0
        if is_anti_armor {
            type_mod = type_mod * 1.5
        }
        if is_aoe {
            type_mod = type_mod * 1.3
        }

        return base_threat * distance_mod * type_mod
    }

    fn update_total_threat(&self) {
        self.total_threat = 0.0
        self.highest_threat_id = -1
        let max_threat = 0.0

        for i in 0..self.threat_sources.count() {
            let source = self.threat_sources.get(i)
            self.total_threat = self.total_threat + source.threat_value

            if source.threat_value > max_threat {
                max_threat = source.threat_value
                self.highest_threat_id = source.enemy_id
            }
        }
    }

    fn get_threat_level(&self): ThreatLevel {
        if self.total_threat == 0.0 {
            return ThreatLevel::NONE
        } else if self.total_threat < 50.0 {
            return ThreatLevel::LOW
        } else if self.total_threat < 150.0 {
            return ThreatLevel::MEDIUM
        } else if self.total_threat < 300.0 {
            return ThreatLevel::HIGH
        } else {
            return ThreatLevel::CRITICAL
        }
    }

    fn get_highest_threat(&self): i32 {
        return self.highest_threat_id
    }

    fn clear_threats(&self) {
        self.threat_sources.clear()
        self.total_threat = 0.0
        self.highest_threat_id = -1
    }

    fn get_threat_count(&self): i32 {
        return self.threat_sources.count()
    }
}

// Behavior manager - orchestrates all unit behaviors
struct BehaviorManager {
    behaviors: Vec<UnitBehavior>,
    focus_fire_groups: Vec<FocusFireBehavior>,

    fn init(): BehaviorManager {
        return BehaviorManager {
            behaviors: Vec::new(),
            focus_fire_groups: Vec::new(),
        }
    }

    fn add_unit_behavior(&self, unit_id: i32, behavior_type: BehaviorType) {
        let behavior = UnitBehavior::init(unit_id, behavior_type)
        self.behaviors.add(behavior)
    }

    fn remove_unit_behavior(&self, unit_id: i32) {
        for i in 0..self.behaviors.count() {
            let behavior = self.behaviors.get(i)
            if behavior.unit_id == unit_id {
                self.behaviors.remove_at(i)
                return
            }
        }
    }

    fn update_behaviors(&self, delta_time: f64): Vec<BehaviorCommand> {
        let commands = Vec::new()

        for i in 0..self.behaviors.count() {
            let behavior = self.behaviors.get(i)
            if let Some(cmd) = behavior.update(delta_time) {
                commands.add(cmd)
            }
        }

        return commands
    }

    fn create_focus_fire_group(&self): i32 {
        let group = FocusFireBehavior::init()
        self.focus_fire_groups.add(group)
        return self.focus_fire_groups.count() - 1
    }

    fn add_unit_to_focus_group(&self, group_id: i32, unit_id: i32) {
        if group_id >= 0 && group_id < self.focus_fire_groups.count() {
            let group = self.focus_fire_groups.get(group_id)
            group.add_unit(unit_id)
        }
    }

    fn get_behavior_count(&self): i32 {
        return self.behaviors.count()
    }

    fn get_focus_group_count(&self): i32 {
        return self.focus_fire_groups.count()
    }
}

// Helper structs
struct UnitBehavior {
    unit_id: i32,
    behavior_type: BehaviorType,
    kiting: KitingBehavior?,
    retreat: RetreatBehavior?,
    auto_ability: AutoAbilityBehavior?,
    threat: ThreatAssessment?,

    fn init(unit_id: i32, behavior_type: BehaviorType): UnitBehavior {
        let behavior = UnitBehavior {
            unit_id: unit_id,
            behavior_type: behavior_type,
            kiting: null,
            retreat: null,
            auto_ability: null,
            threat: null,
        }

        match behavior_type {
            BehaviorType::KITE => behavior.kiting = KitingBehavior::init(unit_id),
            BehaviorType::RETREAT => behavior.retreat = RetreatBehavior::init(unit_id),
            BehaviorType::AUTO_ABILITY => behavior.auto_ability = AutoAbilityBehavior::init(unit_id, 0),
            _ => {},
        }

        behavior.threat = ThreatAssessment::init(unit_id)

        return behavior
    }

    fn update(&self, delta_time: f64): BehaviorCommand? {
        // Placeholder for actual update logic
        return null
    }
}

struct Vec2 {
    x: f64,
    y: f64,

    fn init(x: f64, y: f64): Vec2 {
        return Vec2 { x: x, y: y }
    }
}

struct TargetInfo {
    id: i32,
    health: f64,
    distance: f64,
    threat_value: f64,
    is_support: bool,

    fn init(id: i32, health: f64, distance: f64): TargetInfo {
        return TargetInfo {
            id: id,
            health: health,
            distance: distance,
            threat_value: 0.0,
            is_support: false,
        }
    }
}

struct ThreatSource {
    enemy_id: i32,
    threat_value: f64,
    damage: f64,
    distance: f64,

    fn init(enemy_id: i32, threat_value: f64, damage: f64, distance: f64): ThreatSource {
        return ThreatSource {
            enemy_id: enemy_id,
            threat_value: threat_value,
            damage: damage,
            distance: distance,
        }
    }
}

enum BehaviorCommandType {
    MOVE = 0,
    ATTACK = 1,
    USE_ABILITY = 2,
    STOP = 3,
}

struct BehaviorCommand {
    command_type: BehaviorCommandType,
    target_x: f64,
    target_y: f64,
    target_id: i32,

    fn init(command_type: BehaviorCommandType, x: f64, y: f64, target_id: i32): BehaviorCommand {
        return BehaviorCommand {
            command_type: command_type,
            target_x: x,
            target_y: y,
            target_id: target_id,
        }
    }
}

enum AbilityConditionType {
    ALWAYS = 0,
    HEALTH_BELOW = 1,
    HEALTH_ABOVE = 2,
    ENEMIES_NEARBY = 3,
    ALLIES_NEARBY = 4,
}

struct AbilityContext {
    unit_health: f64,
    ability_cooldown: f64,
    nearby_enemy_count: i32,
    nearby_ally_count: i32,
    target_x: f64,
    target_y: f64,
    target_id: i32,

    fn init(): AbilityContext {
        return AbilityContext {
            unit_health: 100.0,
            ability_cooldown: 0.0,
            nearby_enemy_count: 0,
            nearby_ally_count: 0,
            target_x: 0.0,
            target_y: 0.0,
            target_id: -1,
        }
    }
}

// Tests
test "KitingBehavior: init" {
    let kiting = KitingBehavior::init(1)

    assert kiting.unit_id == 1
    assert kiting.target_id == -1
    assert !kiting.is_retreating
}

test "KitingBehavior: set target" {
    let kiting = KitingBehavior::init(1)

    kiting.set_target(42)

    assert kiting.has_target()
    assert kiting.target_id == 42
}

test "KitingBehavior: distance calculation" {
    let kiting = KitingBehavior::init(1)
    let a = Vec2::init(0.0, 0.0)
    let b = Vec2::init(3.0, 4.0)

    let dist = kiting.distance(a, b)

    assert dist == 5.0
}

test "KitingBehavior: normalize vector" {
    let kiting = KitingBehavior::init(1)
    let v = Vec2::init(3.0, 4.0)

    let n = kiting.normalize(v)

    assert n.x > 0.5 && n.x < 0.7
    assert n.y > 0.7 && n.y < 0.9
}

test "FocusFireBehavior: init" {
    let focus = FocusFireBehavior::init()

    assert focus.current_target_id == -1
    assert focus.target_priority == TargetPriority::MOST_DANGEROUS
}

test "FocusFireBehavior: add units" {
    let focus = FocusFireBehavior::init()

    focus.add_unit(1)
    focus.add_unit(2)
    focus.add_unit(3)

    assert focus.get_unit_count() == 3
}

test "FocusFireBehavior: remove unit" {
    let focus = FocusFireBehavior::init()

    focus.add_unit(1)
    focus.add_unit(2)
    focus.remove_unit(1)

    assert focus.get_unit_count() == 1
}

test "FocusFireBehavior: find closest target" {
    let focus = FocusFireBehavior::init()
    let targets = Vec::new()

    targets.add(TargetInfo::init(1, 100.0, 50.0))
    targets.add(TargetInfo::init(2, 100.0, 20.0))
    targets.add(TargetInfo::init(3, 100.0, 80.0))

    let closest = focus.find_closest_target(targets)

    assert closest == 2
}

test "FocusFireBehavior: find weakest target" {
    let focus = FocusFireBehavior::init()
    let targets = Vec::new()

    targets.add(TargetInfo::init(1, 100.0, 50.0))
    targets.add(TargetInfo::init(2, 25.0, 20.0))
    targets.add(TargetInfo::init(3, 75.0, 80.0))

    let weakest = focus.find_weakest_target(targets)

    assert weakest == 2
}

test "FocusFireBehavior: find strongest target" {
    let focus = FocusFireBehavior::init()
    let targets = Vec::new()

    targets.add(TargetInfo::init(1, 100.0, 50.0))
    targets.add(TargetInfo::init(2, 250.0, 20.0))
    targets.add(TargetInfo::init(3, 75.0, 80.0))

    let strongest = focus.find_strongest_target(targets)

    assert strongest == 2
}

test "FocusFireBehavior: set priority" {
    let focus = FocusFireBehavior::init()

    focus.set_priority(TargetPriority::WEAKEST)

    assert focus.target_priority == TargetPriority::WEAKEST
}

test "RetreatBehavior: init" {
    let retreat = RetreatBehavior::init(1)

    assert retreat.unit_id == 1
    assert retreat.health_threshold == 0.25
    assert !retreat.is_retreating
}

test "RetreatBehavior: should retreat" {
    let retreat = RetreatBehavior::init(1)

    assert retreat.should_retreat(20.0, 100.0)
    assert !retreat.should_retreat(50.0, 100.0)
}

test "RetreatBehavior: set rally point" {
    let retreat = RetreatBehavior::init(1)

    retreat.set_rally_point(100.0, 200.0)

    assert retreat.rally_point != null
}

test "RetreatBehavior: clear rally point" {
    let retreat = RetreatBehavior::init(1)

    retreat.set_rally_point(100.0, 200.0)
    retreat.clear_rally_point()

    assert retreat.rally_point == null
}

test "RetreatBehavior: set health threshold" {
    let retreat = RetreatBehavior::init(1)

    retreat.set_health_threshold(0.5)

    assert retreat.health_threshold == 0.5
}

test "AutoAbilityBehavior: init" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    assert auto_ability.unit_id == 1
    assert auto_ability.ability_id == 5
    assert !auto_ability.auto_cast_enabled
}

test "AutoAbilityBehavior: enable auto cast" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    auto_ability.enable_auto_cast()

    assert auto_ability.auto_cast_enabled
}

test "AutoAbilityBehavior: disable auto cast" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    auto_ability.enable_auto_cast()
    auto_ability.disable_auto_cast()

    assert !auto_ability.auto_cast_enabled
}

test "AutoAbilityBehavior: set condition" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    auto_ability.set_condition(AbilityConditionType::HEALTH_BELOW, 50.0)

    assert auto_ability.condition_type == AbilityConditionType::HEALTH_BELOW
    assert auto_ability.condition_value == 50.0
}

test "AutoAbilityBehavior: is ready" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    assert auto_ability.is_ready()

    auto_ability.cooldown_remaining = 5.0
    assert !auto_ability.is_ready()
}

test "AutoAbilityBehavior: should cast always" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)
    auto_ability.set_condition(AbilityConditionType::ALWAYS, 0.0)

    let context = AbilityContext::init()

    assert auto_ability.should_cast(context)
}

test "AutoAbilityBehavior: should cast health below" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)
    auto_ability.set_condition(AbilityConditionType::HEALTH_BELOW, 50.0)

    let context = AbilityContext::init()
    context.unit_health = 30.0

    assert auto_ability.should_cast(context)
}

test "ThreatAssessment: init" {
    let threat = ThreatAssessment::init(1)

    assert threat.unit_id == 1
    assert threat.total_threat == 0.0
    assert threat.highest_threat_id == -1
}

test "ThreatAssessment: add threat source" {
    let threat = ThreatAssessment::init(1)

    threat.add_threat_source(10, 50.0, 15.0, false, false)

    assert threat.get_threat_count() == 1
    assert threat.total_threat > 0.0
}

test "ThreatAssessment: calculate threat" {
    let threat = ThreatAssessment::init(1)

    let base_threat = threat.calculate_threat(50.0, 15.0, false, false)
    let armor_threat = threat.calculate_threat(50.0, 15.0, true, false)

    assert armor_threat > base_threat
}

test "ThreatAssessment: get threat level" {
    let threat = ThreatAssessment::init(1)

    assert threat.get_threat_level() == ThreatLevel::NONE

    threat.add_threat_source(10, 100.0, 5.0, true, true)
    assert threat.get_threat_level() != ThreatLevel::NONE
}

test "ThreatAssessment: get highest threat" {
    let threat = ThreatAssessment::init(1)

    threat.add_threat_source(10, 50.0, 15.0, false, false)
    threat.add_threat_source(20, 100.0, 5.0, true, false)

    let highest = threat.get_highest_threat()

    assert highest == 20
}

test "ThreatAssessment: clear threats" {
    let threat = ThreatAssessment::init(1)

    threat.add_threat_source(10, 50.0, 15.0, false, false)
    threat.clear_threats()

    assert threat.get_threat_count() == 0
    assert threat.total_threat == 0.0
}

test "BehaviorManager: init" {
    let manager = BehaviorManager::init()

    assert manager.get_behavior_count() == 0
    assert manager.get_focus_group_count() == 0
}

test "BehaviorManager: add unit behavior" {
    let manager = BehaviorManager::init()

    manager.add_unit_behavior(1, BehaviorType::KITE)
    manager.add_unit_behavior(2, BehaviorType::RETREAT)

    assert manager.get_behavior_count() == 2
}

test "BehaviorManager: remove unit behavior" {
    let manager = BehaviorManager::init()

    manager.add_unit_behavior(1, BehaviorType::KITE)
    manager.remove_unit_behavior(1)

    assert manager.get_behavior_count() == 0
}

test "BehaviorManager: create focus fire group" {
    let manager = BehaviorManager::init()

    let group_id = manager.create_focus_fire_group()

    assert group_id == 0
    assert manager.get_focus_group_count() == 1
}

test "BehaviorManager: add unit to focus group" {
    let manager = BehaviorManager::init()

    let group_id = manager.create_focus_fire_group()
    manager.add_unit_to_focus_group(group_id, 1)
    manager.add_unit_to_focus_group(group_id, 2)

    let group = manager.focus_fire_groups.get(group_id)
    assert group.get_unit_count() == 2
}

test "BehaviorManager: update behaviors" {
    let manager = BehaviorManager::init()

    manager.add_unit_behavior(1, BehaviorType::KITE)

    let commands = manager.update_behaviors(0.016)

    assert commands.count() >= 0
}

test "BehaviorCommand: init" {
    let cmd = BehaviorCommand::init(BehaviorCommandType::MOVE, 10.0, 20.0, -1)

    assert cmd.command_type == BehaviorCommandType::MOVE
    assert cmd.target_x == 10.0
    assert cmd.target_y == 20.0
}

test "Vec2: init" {
    let v = Vec2::init(5.0, 10.0)

    assert v.x == 5.0
    assert v.y == 10.0
}

test "TargetInfo: init" {
    let target = TargetInfo::init(1, 100.0, 50.0)

    assert target.id == 1
    assert target.health == 100.0
    assert target.distance == 50.0
}
