// Unit AI Behaviors for C&C Generals Zero Hour
// Micro-management behaviors: kiting, focus fire, auto-abilities, retreat logic, threat assessment
// Written in Home language

// Behavior types
enum BehaviorType {
    IDLE = 0,
    ATTACK = 1,
    KITE = 2,
    FOCUS_FIRE = 3,
    RETREAT = 4,
    AUTO_ABILITY = 5,
    GUARD = 6,
    PATROL = 7,
}

// Threat level
enum ThreatLevel {
    NONE = 0,
    LOW = 1,
    MEDIUM = 2,
    HIGH = 3,
    CRITICAL = 4,
}

// Target priority
enum TargetPriority {
    CLOSEST = 0,
    WEAKEST = 1,
    STRONGEST = 2,
    MOST_DANGEROUS = 3,
    SUPPORT_UNITS = 4,
}

// Kiting behavior - attack while maintaining distance
struct KitingBehavior {
    unit_id: i32,
    target_id: i32,
    optimal_range: f64,
    current_range: f64,
    is_retreating: bool,
    cooldown_remaining: f64,
}

// Focus fire behavior - coordinate attacks on single target
struct FocusFireBehavior {
    unit_ids: Vec<i32>,
    current_target_id: i32,
    target_priority: TargetPriority,
    retarget_on_death: bool,
}

// Retreat behavior - run away when heavily damaged
struct RetreatBehavior {
    unit_id: i32,
    health_threshold: f64,
    is_retreating: bool,
    rally_point: Vec2?,
    min_safe_distance: f64,
}

// Auto-ability behavior - automatically use unit abilities
struct AutoAbilityBehavior {
    unit_id: i32,
    ability_id: i32,
    auto_cast_enabled: bool,
    cooldown_remaining: f64,
    condition_type: AbilityConditionType,
    condition_value: f64,
}

// Threat assessment - evaluate danger of enemies
struct ThreatAssessment {
    unit_id: i32,
    threat_sources: Vec<ThreatSource>,
    total_threat: f64,
    highest_threat_id: i32,
}

// Behavior manager - orchestrates all unit behaviors
struct BehaviorManager {
    behaviors: Vec<UnitBehavior>,
    focus_fire_groups: Vec<FocusFireBehavior>,
}

// Helper structs
struct UnitBehavior {
    unit_id: i32,
    behavior_type: BehaviorType,
    kiting: KitingBehavior?,
    retreat: RetreatBehavior?,
    auto_ability: AutoAbilityBehavior?,
    threat: ThreatAssessment?,
}

struct Vec2 {
    x: f64,
    y: f64,
}

struct TargetInfo {
    id: i32,
    health: f64,
    distance: f64,
    threat_value: f64,
    is_support: bool,
}

struct ThreatSource {
    enemy_id: i32,
    threat_value: f64,
    damage: f64,
    distance: f64,
}

enum BehaviorCommandType {
    MOVE = 0,
    ATTACK = 1,
    USE_ABILITY = 2,
    STOP = 3,
}

struct BehaviorCommand {
    command_type: BehaviorCommandType,
    target_x: f64,
    target_y: f64,
    target_id: i32,
}

enum AbilityConditionType {
    ALWAYS = 0,
    HEALTH_BELOW = 1,
    HEALTH_ABOVE = 2,
    ENEMIES_NEARBY = 3,
    ALLIES_NEARBY = 4,
}

struct AbilityContext {
    unit_health: f64,
    ability_cooldown: f64,
    nearby_enemy_count: i32,
    nearby_ally_count: i32,
    target_x: f64,
    target_y: f64,
    target_id: i32,
}

// Tests
test "KitingBehavior: init" {
    let kiting = KitingBehavior::init(1)

    assert kiting.unit_id == 1
    assert kiting.target_id == -1
    assert !kiting.is_retreating
}

test "KitingBehavior: set target" {
    let kiting = KitingBehavior::init(1)

    kiting.set_target(42)

    assert kiting.has_target()
    assert kiting.target_id == 42
}

test "KitingBehavior: distance calculation" {
    let kiting = KitingBehavior::init(1)
    let a = Vec2::init(0.0, 0.0)
    let b = Vec2::init(3.0, 4.0)

    let dist = kiting.distance(a, b)

    assert dist == 5.0
}

test "KitingBehavior: normalize vector" {
    let kiting = KitingBehavior::init(1)
    let v = Vec2::init(3.0, 4.0)

    let n = kiting.normalize(v)

    assert n.x > 0.5 && n.x < 0.7
    assert n.y > 0.7 && n.y < 0.9
}

test "FocusFireBehavior: init" {
    let focus = FocusFireBehavior::init()

    assert focus.current_target_id == -1
    assert focus.target_priority == TargetPriority::MOST_DANGEROUS
}

test "FocusFireBehavior: add units" {
    let focus = FocusFireBehavior::init()

    focus.add_unit(1)
    focus.add_unit(2)
    focus.add_unit(3)

    assert focus.get_unit_count() == 3
}

test "FocusFireBehavior: remove unit" {
    let focus = FocusFireBehavior::init()

    focus.add_unit(1)
    focus.add_unit(2)
    focus.remove_unit(1)

    assert focus.get_unit_count() == 1
}

test "FocusFireBehavior: find closest target" {
    let focus = FocusFireBehavior::init()
    let targets = Vec::new()

    targets.add(TargetInfo::init(1, 100.0, 50.0))
    targets.add(TargetInfo::init(2, 100.0, 20.0))
    targets.add(TargetInfo::init(3, 100.0, 80.0))

    let closest = focus.find_closest_target(targets)

    assert closest == 2
}

test "FocusFireBehavior: find weakest target" {
    let focus = FocusFireBehavior::init()
    let targets = Vec::new()

    targets.add(TargetInfo::init(1, 100.0, 50.0))
    targets.add(TargetInfo::init(2, 25.0, 20.0))
    targets.add(TargetInfo::init(3, 75.0, 80.0))

    let weakest = focus.find_weakest_target(targets)

    assert weakest == 2
}

test "FocusFireBehavior: find strongest target" {
    let focus = FocusFireBehavior::init()
    let targets = Vec::new()

    targets.add(TargetInfo::init(1, 100.0, 50.0))
    targets.add(TargetInfo::init(2, 250.0, 20.0))
    targets.add(TargetInfo::init(3, 75.0, 80.0))

    let strongest = focus.find_strongest_target(targets)

    assert strongest == 2
}

test "FocusFireBehavior: set priority" {
    let focus = FocusFireBehavior::init()

    focus.set_priority(TargetPriority::WEAKEST)

    assert focus.target_priority == TargetPriority::WEAKEST
}

test "RetreatBehavior: init" {
    let retreat = RetreatBehavior::init(1)

    assert retreat.unit_id == 1
    assert retreat.health_threshold == 0.25
    assert !retreat.is_retreating
}

test "RetreatBehavior: should retreat" {
    let retreat = RetreatBehavior::init(1)

    assert retreat.should_retreat(20.0, 100.0)
    assert !retreat.should_retreat(50.0, 100.0)
}

test "RetreatBehavior: set rally point" {
    let retreat = RetreatBehavior::init(1)

    retreat.set_rally_point(100.0, 200.0)

    assert retreat.rally_point != null
}

test "RetreatBehavior: clear rally point" {
    let retreat = RetreatBehavior::init(1)

    retreat.set_rally_point(100.0, 200.0)
    retreat.clear_rally_point()

    assert retreat.rally_point == null
}

test "RetreatBehavior: set health threshold" {
    let retreat = RetreatBehavior::init(1)

    retreat.set_health_threshold(0.5)

    assert retreat.health_threshold == 0.5
}

test "AutoAbilityBehavior: init" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    assert auto_ability.unit_id == 1
    assert auto_ability.ability_id == 5
    assert !auto_ability.auto_cast_enabled
}

test "AutoAbilityBehavior: enable auto cast" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    auto_ability.enable_auto_cast()

    assert auto_ability.auto_cast_enabled
}

test "AutoAbilityBehavior: disable auto cast" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    auto_ability.enable_auto_cast()
    auto_ability.disable_auto_cast()

    assert !auto_ability.auto_cast_enabled
}

test "AutoAbilityBehavior: set condition" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    auto_ability.set_condition(AbilityConditionType::HEALTH_BELOW, 50.0)

    assert auto_ability.condition_type == AbilityConditionType::HEALTH_BELOW
    assert auto_ability.condition_value == 50.0
}

test "AutoAbilityBehavior: is ready" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)

    assert auto_ability.is_ready()

    auto_ability.cooldown_remaining = 5.0
    assert !auto_ability.is_ready()
}

test "AutoAbilityBehavior: should cast always" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)
    auto_ability.set_condition(AbilityConditionType::ALWAYS, 0.0)

    let context = AbilityContext::init()

    assert auto_ability.should_cast(context)
}

test "AutoAbilityBehavior: should cast health below" {
    let auto_ability = AutoAbilityBehavior::init(1, 5)
    auto_ability.set_condition(AbilityConditionType::HEALTH_BELOW, 50.0)

    let context = AbilityContext::init()
    context.unit_health = 30.0

    assert auto_ability.should_cast(context)
}

test "ThreatAssessment: init" {
    let threat = ThreatAssessment::init(1)

    assert threat.unit_id == 1
    assert threat.total_threat == 0.0
    assert threat.highest_threat_id == -1
}

test "ThreatAssessment: add threat source" {
    let threat = ThreatAssessment::init(1)

    threat.add_threat_source(10, 50.0, 15.0, false, false)

    assert threat.get_threat_count() == 1
    assert threat.total_threat > 0.0
}

test "ThreatAssessment: calculate threat" {
    let threat = ThreatAssessment::init(1)

    let base_threat = threat.calculate_threat(50.0, 15.0, false, false)
    let armor_threat = threat.calculate_threat(50.0, 15.0, true, false)

    assert armor_threat > base_threat
}

test "ThreatAssessment: get threat level" {
    let threat = ThreatAssessment::init(1)

    assert threat.get_threat_level() == ThreatLevel::NONE

    threat.add_threat_source(10, 100.0, 5.0, true, true)
    assert threat.get_threat_level() != ThreatLevel::NONE
}

test "ThreatAssessment: get highest threat" {
    let threat = ThreatAssessment::init(1)

    threat.add_threat_source(10, 50.0, 15.0, false, false)
    threat.add_threat_source(20, 100.0, 5.0, true, false)

    let highest = threat.get_highest_threat()

    assert highest == 20
}

test "ThreatAssessment: clear threats" {
    let threat = ThreatAssessment::init(1)

    threat.add_threat_source(10, 50.0, 15.0, false, false)
    threat.clear_threats()

    assert threat.get_threat_count() == 0
    assert threat.total_threat == 0.0
}

test "BehaviorManager: init" {
    let manager = BehaviorManager::init()

    assert manager.get_behavior_count() == 0
    assert manager.get_focus_group_count() == 0
}

test "BehaviorManager: add unit behavior" {
    let manager = BehaviorManager::init()

    manager.add_unit_behavior(1, BehaviorType::KITE)
    manager.add_unit_behavior(2, BehaviorType::RETREAT)

    assert manager.get_behavior_count() == 2
}

test "BehaviorManager: remove unit behavior" {
    let manager = BehaviorManager::init()

    manager.add_unit_behavior(1, BehaviorType::KITE)
    manager.remove_unit_behavior(1)

    assert manager.get_behavior_count() == 0
}

test "BehaviorManager: create focus fire group" {
    let manager = BehaviorManager::init()

    let group_id = manager.create_focus_fire_group()

    assert group_id == 0
    assert manager.get_focus_group_count() == 1
}

test "BehaviorManager: add unit to focus group" {
    let manager = BehaviorManager::init()

    let group_id = manager.create_focus_fire_group()
    manager.add_unit_to_focus_group(group_id, 1)
    manager.add_unit_to_focus_group(group_id, 2)

    let group = manager.focus_fire_groups.get(group_id)
    assert group.get_unit_count() == 2
}

test "BehaviorManager: update behaviors" {
    let manager = BehaviorManager::init()

    manager.add_unit_behavior(1, BehaviorType::KITE)

    let commands = manager.update_behaviors(0.016)

    assert commands.count() >= 0
}

test "BehaviorCommand: init" {
    let cmd = BehaviorCommand::init(BehaviorCommandType::MOVE, 10.0, 20.0, -1)

    assert cmd.command_type == BehaviorCommandType::MOVE
    assert cmd.target_x == 10.0
    assert cmd.target_y == 20.0
}

test "Vec2: init" {
    let v = Vec2::init(5.0, 10.0)

    assert v.x == 5.0
    assert v.y == 10.0
}

test "TargetInfo: init" {
    let target = TargetInfo::init(1, 100.0, 50.0)

    assert target.id == 1
    assert target.health == 100.0
    assert target.distance == 50.0
}
