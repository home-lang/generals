// UI system for C&C Generals Zero Hour
// Command bar, minimap, unit selection, menus
// Written in Home language

from basics import Collection

// UI element types
enum UIElementType {
    WINDOW = 0,
    BUTTON = 1,
    LABEL = 2,
    IMAGE = 3,
    PROGRESS_BAR = 4,
    LIST = 5,
    PANEL = 6,
}

// UI anchor points
enum UIAnchor {
    TOP_LEFT = 0,
    TOP_CENTER = 1,
    TOP_RIGHT = 2,
    CENTER_LEFT = 3,
    CENTER = 4,
    CENTER_RIGHT = 5,
    BOTTOM_LEFT = 6,
    BOTTOM_CENTER = 7,
    BOTTOM_RIGHT = 8,
}

// Base UI element
struct UIElement {
    id: Int,
    element_type: UIElementType,
    position: Vec2,
    size: Vec2,
    anchor: UIAnchor,
    visible: Bool,
    enabled: Bool,
    parent_id: Int,

    fn init(id: Int, element_type: UIElementType) -> UIElement {
        return UIElement {
            id: id,
            element_type: element_type,
            position: Vec2::init(0.0, 0.0),
            size: Vec2::init(100.0, 100.0),
            anchor: UIAnchor::TOP_LEFT,
            visible: true,
            enabled: true,
            parent_id: -1,
        }
    }

    fn set_position(self, x: Float, y: Float) {
        self.position = Vec2::init(x, y)
    }

    fn set_size(self, w: Float, h: Float) {
        self.size = Vec2::init(w, h)
    }

    fn contains_point(self, x: Float, y: Float) -> Bool {
        return x >= self.position.x &&
               x <= self.position.x + self.size.x &&
               y >= self.position.y &&
               y <= self.position.y + self.size.y
    }

    fn show(self) {
        self.visible = true
    }

    fn hide(self) {
        self.visible = false
    }
}

// Button with click callback
struct UIButton {
    element: UIElement,
    text: String,
    icon: String?,
    is_hovered: Bool,
    is_pressed: Bool,

    fn init(id: Int, text: String) -> UIButton {
        return UIButton {
            element: UIElement::init(id, UIElementType::BUTTON),
            text: text,
            icon: null,
            is_hovered: false,
            is_pressed: false,
        }
    }

    fn set_icon(self, icon: String) {
        self.icon = icon
    }

    fn on_mouse_enter(self) {
        self.is_hovered = true
    }

    fn on_mouse_exit(self) {
        self.is_hovered = false
        self.is_pressed = false
    }

    fn on_mouse_down(self) {
        if self.element.enabled {
            self.is_pressed = true
        }
    }

    fn on_mouse_up(self) -> Bool {
        let was_pressed = self.is_pressed
        self.is_pressed = false
        return was_pressed && self.is_hovered
    }
}

// Label for text display
struct UILabel {
    element: UIElement,
    text: String,
    font_size: Int,
    color: Color,
    alignment: TextAlignment,

    fn init(id: Int, text: String) -> UILabel {
        return UILabel {
            element: UIElement::init(id, UIElementType::LABEL),
            text: text,
            font_size: 14,
            color: Color::white(),
            alignment: TextAlignment::LEFT,
        }
    }

    fn set_text(self, text: String) {
        self.text = text
    }

    fn set_color(self, r: Float, g: Float, b: Float, a: Float) {
        self.color = Color::init(r, g, b, a)
    }
}

enum TextAlignment {
    LEFT = 0,
    CENTER = 1,
    RIGHT = 2,
}

// Progress bar
struct UIProgressBar {
    element: UIElement,
    current_value: Float,
    max_value: Float,
    bar_color: Color,
    background_color: Color,

    fn init(id: Int, max_value: Float) -> UIProgressBar {
        return UIProgressBar {
            element: UIElement::init(id, UIElementType::PROGRESS_BAR),
            current_value: 0.0,
            max_value: max_value,
            bar_color: Color::green(),
            background_color: Color::dark_gray(),
        }
    }

    fn set_value(self, value: Float) {
        self.current_value = min_float(value, self.max_value)
    }

    fn get_percentage(self) -> Float {
        if self.max_value == 0.0 {
            return 0.0
        }
        return (self.current_value / self.max_value) * 100.0
    }

    fn is_full(self) -> Bool {
        return self.current_value >= self.max_value
    }
}

// Minimap display
struct Minimap {
    element: UIElement,
    map_width: Int,
    map_height: Int,
    zoom_level: Float,
    camera_view_rect: Rect,

    fn init(id: Int, map_width: Int, map_height: Int) -> Minimap {
        let mut element = UIElement::init(id, UIElementType::IMAGE)
        element.set_size(200.0, 200.0)
        element.anchor = UIAnchor::BOTTOM_LEFT

        return Minimap {
            element: element,
            map_width: map_width,
            map_height: map_height,
            zoom_level: 1.0,
            camera_view_rect: Rect::init(0.0, 0.0, 100.0, 100.0),
        }
    }

    fn world_to_minimap(self, world_x: Float, world_y: Float) -> Vec2 {
        let scale_x = self.element.size.x / (self.map_width as Float)
        let scale_y = self.element.size.y / (self.map_height as Float)

        return Vec2::init(
            self.element.position.x + (world_x * scale_x),
            self.element.position.y + (world_y * scale_y)
        )
    }

    fn minimap_to_world(self, minimap_x: Float, minimap_y: Float) -> Vec2 {
        let rel_x = minimap_x - self.element.position.x
        let rel_y = minimap_y - self.element.position.y

        let scale_x = (self.map_width as Float) / self.element.size.x
        let scale_y = (self.map_height as Float) / self.element.size.y

        return Vec2::init(rel_x * scale_x, rel_y * scale_y)
    }

    fn update_camera_view(self, camera_x: Float, camera_y: Float, view_width: Float, view_height: Float) {
        let pos = self.world_to_minimap(camera_x, camera_y)
        self.camera_view_rect.x = pos.x
        self.camera_view_rect.y = pos.y
        self.camera_view_rect.width = view_width
        self.camera_view_rect.height = view_height
    }
}

// Command bar for building/unit commands
struct CommandBar {
    element: UIElement,
    buttons: Collection<UIButton>,
    selected_objects: Collection<Int>,
    active_player: Int,

    fn init(id: Int) -> CommandBar {
        let mut element = UIElement::init(id, UIElementType::PANEL)
        element.set_size(800.0, 100.0)
        element.anchor = UIAnchor::BOTTOM_CENTER

        return CommandBar {
            element: element,
            buttons: Collection::new(),
            selected_objects: Collection::new(),
            active_player: 0,
        }
    }

    fn add_button(self, button: UIButton) {
        self.buttons.add(button)
    }

    fn set_selected_objects(self, object_ids: Collection<Int>) {
        self.selected_objects = object_ids
        self.rebuild_buttons()
    }

    fn rebuild_buttons(self) {
        self.buttons.clear()

        // TODO: Add buttons based on selected objects
        // For buildings: add unit production buttons
        // For units: add ability buttons
    }

    fn get_button_at(self, x: Float, y: Float) -> UIButton? {
        for button in self.buttons {
            if button.element.contains_point(x, y) {
                return button
            }
        }
        return null
    }

    fn has_selection(self) -> Bool {
        return self.selected_objects.count() > 0
    }
}

// Unit selection display
struct SelectionDisplay {
    element: UIElement,
    selected_units: Collection<Int>,
    unit_portraits: Collection<String>,
    max_portraits: Int,

    fn init(id: Int) -> SelectionDisplay {
        let mut element = UIElement::init(id, UIElementType::PANEL)
        element.set_size(600.0, 80.0)
        element.anchor = UIAnchor::TOP_CENTER

        return SelectionDisplay {
            element: element,
            selected_units: Collection::new(),
            unit_portraits: Collection::new(),
            max_portraits: 12,
        }
    }

    fn set_selection(self, unit_ids: Collection<Int>) {
        self.selected_units = unit_ids
        self.update_portraits()
    }

    fn update_portraits(self) {
        self.unit_portraits.clear()

        let count = min_int(self.selected_units.count(), self.max_portraits)
        for i in 0..count {
            // TODO: Get portrait name from unit
            self.unit_portraits.add("portrait_unknown")
        }
    }

    fn get_selection_count(self) -> Int {
        return self.selected_units.count()
    }

    fn clear_selection(self) {
        self.selected_units.clear()
        self.unit_portraits.clear()
    }
}

// Resource display
struct ResourceDisplay {
    element: UIElement,
    money_label: UILabel,
    power_label: UILabel,

    fn init(id: Int) -> ResourceDisplay {
        let mut element = UIElement::init(id, UIElementType::PANEL)
        element.set_size(200.0, 60.0)
        element.anchor = UIAnchor::TOP_RIGHT

        return ResourceDisplay {
            element: element,
            money_label: UILabel::init(0, "$0"),
            power_label: UILabel::init(1, "Power: 0/0"),
        }
    }

    fn update(self, money: Float, power_used: Int, power_available: Int) {
        self.money_label.set_text("$" + format_float(money, 0))
        self.power_label.set_text("Power: " + power_used + "/" + power_available)
    }
}

// Main menu
struct MainMenu {
    element: UIElement,
    buttons: Collection<UIButton>,
    is_open: Bool,

    fn init(id: Int) -> MainMenu {
        let mut element = UIElement::init(id, UIElementType::WINDOW)
        element.set_size(400.0, 500.0)
        element.anchor = UIAnchor::CENTER

        let menu = MainMenu {
            element: element,
            buttons: Collection::new(),
            is_open: false,
        }

        menu.create_buttons()
        return menu
    }

    fn create_buttons(self) {
        let new_game = UIButton::init(0, "New Game")
        let load_game = UIButton::init(1, "Load Game")
        let options = UIButton::init(2, "Options")
        let quit = UIButton::init(3, "Quit")

        self.buttons.add(new_game)
        self.buttons.add(load_game)
        self.buttons.add(options)
        self.buttons.add(quit)
    }

    fn open(self) {
        self.is_open = true
        self.element.show()
    }

    fn close(self) {
        self.is_open = false
        self.element.hide()
    }

    fn toggle(self) {
        if self.is_open {
            self.close()
        } else {
            self.open()
        }
    }
}

// UI Manager - coordinates all UI elements
struct UIManager {
    elements: Collection<UIElement>,
    command_bar: CommandBar,
    minimap: Minimap,
    selection_display: SelectionDisplay,
    resource_display: ResourceDisplay,
    main_menu: MainMenu,
    next_element_id: Int,

    fn init(map_width: Int, map_height: Int) -> UIManager {
        return UIManager {
            elements: Collection::new(),
            command_bar: CommandBar::init(0),
            minimap: Minimap::init(1, map_width, map_height),
            selection_display: SelectionDisplay::init(2),
            resource_display: ResourceDisplay::init(3),
            main_menu: MainMenu::init(4),
            next_element_id: 5,
        }
    }

    fn update(self, delta_time: Float) {
        // Update any animated UI elements
    }

    fn handle_click(self, x: Float, y: Float) -> Bool {
        // Check command bar buttons
        if let Some(button) = self.command_bar.get_button_at(x, y) {
            return true
        }

        // Check minimap
        if self.minimap.element.contains_point(x, y) {
            let world_pos = self.minimap.minimap_to_world(x, y)
            // TODO: Move camera to clicked position
            return true
        }

        return false
    }

    fn update_selection(self, object_ids: Collection<Int>) {
        self.selection_display.set_selection(object_ids)
        self.command_bar.set_selected_objects(object_ids)
    }

    fn update_resources(self, player: player::Player) {
        self.resource_display.update(
            player.money,
            player.power_consumed,
            player.power_available
        )
    }

    fn show_menu(self) {
        self.main_menu.open()
    }

    fn hide_menu(self) {
        self.main_menu.close()
    }
}

// Helper structs
struct Vec2 {
    x: Float,
    y: Float,

    fn init(x: Float, y: Float) -> Vec2 {
        return Vec2 { x: x, y: y }
    }
}

struct Color {
    r: Float,
    g: Float,
    b: Float,
    a: Float,

    fn init(r: Float, g: Float, b: Float, a: Float) -> Color {
        return Color { r: r, g: g, b: b, a: a }
    }

    fn white() -> Color {
        return Color::init(1.0, 1.0, 1.0, 1.0)
    }

    fn black() -> Color {
        return Color::init(0.0, 0.0, 0.0, 1.0)
    }

    fn red() -> Color {
        return Color::init(1.0, 0.0, 0.0, 1.0)
    }

    fn green() -> Color {
        return Color::init(0.0, 1.0, 0.0, 1.0)
    }

    fn blue() -> Color {
        return Color::init(0.0, 0.0, 1.0, 1.0)
    }

    fn dark_gray() -> Color {
        return Color::init(0.3, 0.3, 0.3, 1.0)
    }
}

struct Rect {
    x: Float,
    y: Float,
    width: Float,
    height: Float,

    fn init(x: Float, y: Float, width: Float, height: Float) -> Rect {
        return Rect { x: x, y: y, width: width, height: height }
    }
}

// Helper functions
fn min_float(a: Float, b: Float) -> Float {
    if a < b { return a } else { return b }
}

fn min_int(a: Int, b: Int) -> Int {
    if a < b { return a } else { return b }
}

fn format_float(value: Float, decimals: Int) -> String {
    // Simplified float formatting
    return value as Int + ""
}

// Tests
test "UIElement: init and positioning" {
    let element = UIElement::init(0, UIElementType::BUTTON)

    assert element.visible
    assert element.enabled
    assert element.parent_id == -1

    element.set_position(100.0, 200.0)
    element.set_size(50.0, 30.0)

    assert element.position.x == 100.0
    assert element.size.y == 30.0
}

test "UIElement: contains point" {
    let element = UIElement::init(0, UIElementType::BUTTON)
    element.set_position(100.0, 100.0)
    element.set_size(50.0, 30.0)

    assert element.contains_point(125.0, 115.0)
    assert !element.contains_point(50.0, 50.0)
    assert !element.contains_point(200.0, 100.0)
}

test "UIElement: show and hide" {
    let element = UIElement::init(0, UIElementType::WINDOW)

    assert element.visible

    element.hide()
    assert !element.visible

    element.show()
    assert element.visible
}

test "UIButton: init and interaction" {
    let button = UIButton::init(0, "Attack")

    assert button.text == "Attack"
    assert !button.is_hovered
    assert !button.is_pressed

    button.on_mouse_enter()
    assert button.is_hovered

    button.on_mouse_down()
    assert button.is_pressed

    let clicked = button.on_mouse_up()
    assert clicked
    assert !button.is_pressed
}

test "UIButton: disabled button" {
    let button = UIButton::init(0, "Build")
    button.element.enabled = false

    button.on_mouse_down()
    assert !button.is_pressed  // Should not press when disabled
}

test "UILabel: init and text" {
    let label = UILabel::init(0, "Health: 100")

    assert label.text == "Health: 100"
    assert label.font_size == 14

    label.set_text("Health: 50")
    assert label.text == "Health: 50"
}

test "UILabel: color" {
    let label = UILabel::init(0, "Test")
    label.set_color(1.0, 0.0, 0.0, 1.0)

    assert label.color.r == 1.0
    assert label.color.g == 0.0
}

test "UIProgressBar: value and percentage" {
    let bar = UIProgressBar::init(0, 100.0)

    assert bar.get_percentage() == 0.0
    assert !bar.is_full()

    bar.set_value(50.0)
    assert bar.get_percentage() == 50.0

    bar.set_value(100.0)
    assert bar.is_full()

    bar.set_value(150.0)
    assert bar.current_value == 100.0  // Clamped to max
}

test "Minimap: coordinate conversion" {
    let minimap = Minimap::init(0, 1000, 1000)
    minimap.element.set_position(10.0, 10.0)
    minimap.element.set_size(200.0, 200.0)

    let minimap_pos = minimap.world_to_minimap(500.0, 500.0)
    assert minimap_pos.x == 110.0  // 10 + (500 * 0.2)
    assert minimap_pos.y == 110.0

    let world_pos = minimap.minimap_to_world(110.0, 110.0)
    assert world_pos.x == 500.0
    assert world_pos.y == 500.0
}

test "CommandBar: init" {
    let bar = CommandBar::init(0)

    assert bar.element.anchor == UIAnchor::BOTTOM_CENTER
    assert !bar.has_selection()
}

test "CommandBar: selection" {
    let bar = CommandBar::init(0)

    let objects = Collection::new()
    objects.add(100)
    objects.add(101)
    objects.add(102)

    bar.set_selected_objects(objects)
    assert bar.has_selection()
    assert bar.selected_objects.count() == 3
}

test "SelectionDisplay: portraits" {
    let display = SelectionDisplay::init(0)

    assert display.get_selection_count() == 0

    let units = Collection::new()
    for i in 0..5 {
        units.add(100 + i)
    }

    display.set_selection(units)
    assert display.get_selection_count() == 5
    assert display.unit_portraits.count() == 5

    display.clear_selection()
    assert display.get_selection_count() == 0
}

test "SelectionDisplay: max portraits" {
    let display = SelectionDisplay::init(0)

    let units = Collection::new()
    for i in 0..20 {
        units.add(i)
    }

    display.set_selection(units)
    assert display.unit_portraits.count() == display.max_portraits
}

test "MainMenu: toggle" {
    let menu = MainMenu::init(0)

    assert !menu.is_open

    menu.open()
    assert menu.is_open
    assert menu.element.visible

    menu.close()
    assert !menu.is_open
    assert !menu.element.visible

    menu.toggle()
    assert menu.is_open
}

test "MainMenu: buttons" {
    let menu = MainMenu::init(0)

    assert menu.buttons.count() == 4
    assert menu.buttons.get(0).text == "New Game"
}

test "UIManager: init" {
    let manager = UIManager::init(1000, 1000)

    assert manager.next_element_id > 4
    assert manager.minimap.map_width == 1000
}

test "UIManager: update selection" {
    let manager = UIManager::init(1000, 1000)

    let objects = Collection::new()
    objects.add(100)
    objects.add(101)

    manager.update_selection(objects)

    assert manager.selection_display.get_selection_count() == 2
    assert manager.command_bar.has_selection()
}

test "Color: presets" {
    let white = Color::white()
    assert white.r == 1.0
    assert white.g == 1.0
    assert white.b == 1.0

    let red = Color::red()
    assert red.r == 1.0
    assert red.g == 0.0

    let green = Color::green()
    assert green.g == 1.0
}

test "Vec2: init" {
    let vec = Vec2::init(10.0, 20.0)

    assert vec.x == 10.0
    assert vec.y == 20.0
}

test "Rect: init" {
    let rect = Rect::init(5.0, 10.0, 100.0, 50.0)

    assert rect.x == 5.0
    assert rect.width == 100.0
}
