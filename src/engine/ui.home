// UI system for C&C Generals Zero Hour
// Command bar, minimap, unit selection, menus
// Written in Home language


// UI element types
enum UIElementType {
    WINDOW = 0,
    BUTTON = 1,
    LABEL = 2,
    IMAGE = 3,
    PROGRESS_BAR = 4,
    LIST = 5,
    PANEL = 6,
}

// UI anchor points
enum UIAnchor {
    TOP_LEFT = 0,
    TOP_CENTER = 1,
    TOP_RIGHT = 2,
    CENTER_LEFT = 3,
    CENTER = 4,
    CENTER_RIGHT = 5,
    BOTTOM_LEFT = 6,
    BOTTOM_CENTER = 7,
    BOTTOM_RIGHT = 8,
}

// Base UI element
struct UIElement {
    id: i32,
    element_type: UIElementType,
    position: Vec2,
    size: Vec2,
    anchor: UIAnchor,
    visible: bool,
    enabled: bool,
    parent_id: i32,
}

// Button with click callback
struct UIButton {
    element: UIElement,
    text: string,
    icon: string?,
    is_hovered: bool,
    is_pressed: bool,
}

// Label for text display
struct UILabel {
    element: UIElement,
    text: string,
    font_size: i32,
    color: Color,
    alignment: TextAlignment,
}

enum TextAlignment {
    LEFT = 0,
    CENTER = 1,
    RIGHT = 2,
}

// Progress bar
struct UIProgressBar {
    element: UIElement,
    current_value: f64,
    max_value: f64,
    bar_color: Color,
    background_color: Color,
}

// Minimap display
struct Minimap {
    element: UIElement,
    map_width: i32,
    map_height: i32,
    zoom_level: f64,
    camera_view_rect: Rect,
}

// Command bar for building/unit commands
struct CommandBar {
    element: UIElement,
    buttons: Vec<UIButton>,
    selected_objects: Vec<i32>,
    active_player: i32,
}

// Unit selection display
struct SelectionDisplay {
    element: UIElement,
    selected_units: Vec<i32>,
    unit_portraits: Vec<string>,
    max_portraits: i32,
}

// Resource display
struct ResourceDisplay {
    element: UIElement,
    money_label: UILabel,
    power_label: UILabel,
}

// Main menu
struct MainMenu {
    element: UIElement,
    buttons: Vec<UIButton>,
    is_open: bool,
}

// UI Manager - coordinates all UI elements
struct UIManager {
    elements: Vec<UIElement>,
    command_bar: CommandBar,
    minimap: Minimap,
    selection_display: SelectionDisplay,
    resource_display: ResourceDisplay,
    main_menu: MainMenu,
    next_element_id: i32,
}

// Helper structs
struct Vec2 {
    x: f64,
    y: f64,
}

struct Color {
    r: f64,
    g: f64,
    b: f64,
    a: f64,
}

struct Rect {
    x: f64,
    y: f64,
    width: f64,
    height: f64,
}

// Helper functions
fn min_float(a: f64, b: f64): f64 {
    if (a < b) { return a } else { return b }
}

fn min_int(a: i32, b: i32): i32 {
    if (a < b) { return a } else { return b }
}

fn format_float(value: f64, decimals: i32): string {
    // Simplified float formatting
    return value as Int + ""
}

// Tests
test "UIElement: init and positioning" {
    let element = UIElement::init(0, UIElementType::BUTTON)

    assert element.visible
    assert element.enabled
    assert element.parent_id == -1

    element.set_position(100.0, 200.0)
    element.set_size(50.0, 30.0)

    assert element.position.x == 100.0
    assert element.size.y == 30.0
}

test "UIElement: contains point" {
    let element = UIElement::init(0, UIElementType::BUTTON)
    element.set_position(100.0, 100.0)
    element.set_size(50.0, 30.0)

    assert element.contains_point(125.0, 115.0)
    assert !element.contains_point(50.0, 50.0)
    assert !element.contains_point(200.0, 100.0)
}

test "UIElement: show and hide" {
    let element = UIElement::init(0, UIElementType::WINDOW)

    assert element.visible

    element.hide()
    assert !element.visible

    element.show()
    assert element.visible
}

test "UIButton: init and interaction" {
    let button = UIButton::init(0, "Attack")

    assert button.text == "Attack"
    assert !button.is_hovered
    assert !button.is_pressed

    button.on_mouse_enter()
    assert button.is_hovered

    button.on_mouse_down()
    assert button.is_pressed

    let clicked = button.on_mouse_up()
    assert clicked
    assert !button.is_pressed
}

test "UIButton: disabled button" {
    let button = UIButton::init(0, "Build")
    button.element.enabled = false

    button.on_mouse_down()
    assert !button.is_pressed  // Should not press when disabled
}

test "UILabel: init and text" {
    let label = UILabel::init(0, "Health: 100")

    assert label.text == "Health: 100"
    assert label.font_size == 14

    label.set_text("Health: 50")
    assert label.text == "Health: 50"
}

test "UILabel: color" {
    let label = UILabel::init(0, "Test")
    label.set_color(1.0, 0.0, 0.0, 1.0)

    assert label.color.r == 1.0
    assert label.color.g == 0.0
}

test "UIProgressBar: value and percentage" {
    let bar = UIProgressBar::init(0, 100.0)

    assert bar.get_percentage() == 0.0
    assert !bar.is_full()

    bar.set_value(50.0)
    assert bar.get_percentage() == 50.0

    bar.set_value(100.0)
    assert bar.is_full()

    bar.set_value(150.0)
    assert bar.current_value == 100.0  // Clamped to max
}

test "Minimap: coordinate conversion" {
    let minimap = Minimap::init(0, 1000, 1000)
    minimap.element.set_position(10.0, 10.0)
    minimap.element.set_size(200.0, 200.0)

    let minimap_pos = minimap.world_to_minimap(500.0, 500.0)
    assert minimap_pos.x == 110.0  // 10 + (500 * 0.2)
    assert minimap_pos.y == 110.0

    let world_pos = minimap.minimap_to_world(110.0, 110.0)
    assert world_pos.x == 500.0
    assert world_pos.y == 500.0
}

test "CommandBar: init" {
    let bar = CommandBar::init(0)

    assert bar.element.anchor == UIAnchor::BOTTOM_CENTER
    assert !bar.has_selection()
}

test "CommandBar: selection" {
    let bar = CommandBar::init(0)

    let objects = Vec::new()
    objects.add(100)
    objects.add(101)
    objects.add(102)

    bar.set_selected_objects(objects)
    assert bar.has_selection()
    assert bar.selected_objects.count() == 3
}

test "SelectionDisplay: portraits" {
    let display = SelectionDisplay::init(0)

    assert display.get_selection_count() == 0

    let units = Vec::new()
    for i in 0..5 {
        units.add(100 + i)
    }

    display.set_selection(units)
    assert display.get_selection_count() == 5
    assert display.unit_portraits.count() == 5

    display.clear_selection()
    assert display.get_selection_count() == 0
}

test "SelectionDisplay: max portraits" {
    let display = SelectionDisplay::init(0)

    let units = Vec::new()
    for i in 0..20 {
        units.add(i)
    }

    display.set_selection(units)
    assert display.unit_portraits.count() == display.max_portraits
}

test "MainMenu: toggle" {
    let menu = MainMenu::init(0)

    assert !menu.is_open

    menu.open()
    assert menu.is_open
    assert menu.element.visible

    menu.close()
    assert !menu.is_open
    assert !menu.element.visible

    menu.toggle()
    assert menu.is_open
}

test "MainMenu: buttons" {
    let menu = MainMenu::init(0)

    assert menu.buttons.count() == 4
    assert menu.buttons.get(0).text == "New Game"
}

test "UIManager: init" {
    let manager = UIManager::init(1000, 1000)

    assert manager.next_element_id > 4
    assert manager.minimap.map_width == 1000
}

test "UIManager: update selection" {
    let manager = UIManager::init(1000, 1000)

    let objects = Vec::new()
    objects.add(100)
    objects.add(101)

    manager.update_selection(objects)

    assert manager.selection_display.get_selection_count() == 2
    assert manager.command_bar.has_selection()
}

test "Color: presets" {
    let white = Color::white()
    assert white.r == 1.0
    assert white.g == 1.0
    assert white.b == 1.0

    let red = Color::red()
    assert red.r == 1.0
    assert red.g == 0.0

    let green = Color::green()
    assert green.g == 1.0
}

test "Vec2: init" {
    let vec = Vec2::init(10.0, 20.0)

    assert vec.x == 10.0
    assert vec.y == 20.0
}

test "Rect: init" {
    let rect = Rect::init(5.0, 10.0, 100.0, 50.0)

    assert rect.x == 5.0
    assert rect.width == 100.0
}
