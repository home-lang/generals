// Weather system for C&C Generals Zero Hour
// Rain, snow, sandstorms, dynamic weather effects
// Written in Home language

// Weather types
enum WeatherType {
    CLEAR = 0,
    RAIN = 1,
    HEAVY_RAIN = 2,
    SNOW = 3,
    SANDSTORM = 4,
    FOG = 5,
}

// Weather intensity
enum WeatherIntensity {
    NONE = 0,
    LIGHT = 1,
    MODERATE = 2,
    HEAVY = 3,
}

// Weather state
struct WeatherState {
    weather_type: WeatherType,
    intensity: WeatherIntensity,
    duration: f64,
    elapsed_time: f64,
    is_active: bool,
    wind_direction: f64,
    wind_speed: f64,
    visibility_modifier: f64,

    fn init(weather_type: WeatherType, intensity: WeatherIntensity, duration: f64): WeatherState {
        return WeatherState {
            weather_type: weather_type,
            intensity: intensity,
            duration: duration,
            elapsed_time: 0.0,
            is_active: true,
            wind_direction: 0.0,
            wind_speed: 0.0,
            visibility_modifier: 1.0,
        }
    }

    fn update(&self, delta_time: f64) {
        if !self.is_active {
            return
        }

        self.elapsed_time = self.elapsed_time + delta_time

        if self.elapsed_time >= self.duration {
            self.is_active = false
        }

        self.update_visibility()
    }

    fn update_visibility(&self) {
        match self.weather_type {
            WeatherType::CLEAR => self.visibility_modifier = 1.0,
            WeatherType::RAIN => {
                self.visibility_modifier = match self.intensity {
                    WeatherIntensity::LIGHT => 0.9,
                    WeatherIntensity::MODERATE => 0.8,
                    WeatherIntensity::HEAVY => 0.6,
                    _ => 1.0,
                }
            },
            WeatherType::SNOW => {
                self.visibility_modifier = match self.intensity {
                    WeatherIntensity::LIGHT => 0.85,
                    WeatherIntensity::MODERATE => 0.7,
                    WeatherIntensity::HEAVY => 0.5,
                    _ => 1.0,
                }
            },
            WeatherType::SANDSTORM => {
                self.visibility_modifier = match self.intensity {
                    WeatherIntensity::LIGHT => 0.7,
                    WeatherIntensity::MODERATE => 0.5,
                    WeatherIntensity::HEAVY => 0.3,
                    _ => 1.0,
                }
            },
            WeatherType::FOG => self.visibility_modifier = 0.5,
            _ => {},
        }
    }

    fn get_progress(&self): f64 {
        if self.duration == 0.0 {
            return 0.0
        }
        return (self.elapsed_time / self.duration) * 100.0
    }

    fn is_expired(&self): bool {
        return !self.is_active
    }

    fn set_wind(&self, direction: f64, speed: f64) {
        self.wind_direction = direction
        self.wind_speed = speed
    }
}

// Weather transition
struct WeatherTransition {
    from_weather: WeatherType,
    to_weather: WeatherType,
    duration: f64,
    elapsed: f64,
    is_complete: bool,

    fn init(from: WeatherType, to: WeatherType, duration: f64): WeatherTransition {
        return WeatherTransition {
            from_weather: from,
            to_weather: to,
            duration: duration,
            elapsed: 0.0,
            is_complete: false,
        }
    }

    fn update(&self, delta_time: f64) {
        self.elapsed = self.elapsed + delta_time

        if self.elapsed >= self.duration {
            self.is_complete = true
        }
    }

    fn get_blend_factor(&self): f64 {
        if self.duration == 0.0 {
            return 1.0
        }
        return self.elapsed / self.duration
    }
}

// Weather effect (visual)
struct WeatherEffect {
    particle_count: i32,
    particle_speed: f64,
    particle_size: f64,
    color: Color,
    spawn_rate: f64,

    fn init(): WeatherEffect {
        return WeatherEffect {
            particle_count: 0,
            particle_speed: 0.0,
            particle_size: 1.0,
            color: Color::init(1.0, 1.0, 1.0, 1.0),
            spawn_rate: 0.0,
        }
    }

    fn for_rain(intensity: WeatherIntensity): WeatherEffect {
        let effect = WeatherEffect::init()

        effect.particle_count = match intensity {
            WeatherIntensity::LIGHT => 500,
            WeatherIntensity::MODERATE => 1000,
            WeatherIntensity::HEAVY => 2000,
            _ => 0,
        }

        effect.particle_speed = 50.0
        effect.particle_size = 0.2
        effect.color = Color::init(0.7, 0.7, 0.8, 0.6)
        effect.spawn_rate = effect.particle_count as Float / 10.0

        return effect
    }

    fn for_snow(intensity: WeatherIntensity): WeatherEffect {
        let effect = WeatherEffect::init()

        effect.particle_count = match intensity {
            WeatherIntensity::LIGHT => 300,
            WeatherIntensity::MODERATE => 600,
            WeatherIntensity::HEAVY => 1200,
            _ => 0,
        }

        effect.particle_speed = 10.0
        effect.particle_size = 0.5
        effect.color = Color::init(1.0, 1.0, 1.0, 0.8)
        effect.spawn_rate = effect.particle_count as Float / 15.0

        return effect
    }

    fn for_sandstorm(intensity: WeatherIntensity): WeatherEffect {
        let effect = WeatherEffect::init()

        effect.particle_count = match intensity {
            WeatherIntensity::LIGHT => 800,
            WeatherIntensity::MODERATE => 1500,
            WeatherIntensity::HEAVY => 3000,
            _ => 0,
        }

        effect.particle_speed = 30.0
        effect.particle_size = 0.8
        effect.color = Color::init(0.8, 0.7, 0.5, 0.5)
        effect.spawn_rate = effect.particle_count as Float / 5.0

        return effect
    }
}

// Weather manager
struct WeatherManager {
    current_state: WeatherState,
    transition: WeatherTransition?,
    effects: Vec<WeatherEffect>,
    auto_weather_enabled: bool,
    weather_change_interval: f64,
    time_since_weather_change: f64,

    fn init(): WeatherManager {
        return WeatherManager {
            current_state: WeatherState::init(WeatherType::CLEAR, WeatherIntensity::NONE, 0.0),
            transition: null,
            effects: Vec::new(),
            auto_weather_enabled: false,
            weather_change_interval: 600.0,
            time_since_weather_change: 0.0,
        }
    }

    fn set_weather(&self, weather_type: WeatherType, intensity: WeatherIntensity, duration: f64) {
        self.current_state = WeatherState::init(weather_type, intensity, duration)
        self.update_effects()
        self.time_since_weather_change = 0.0
    }

    fn transition_to_weather(&self, weather_type: WeatherType, intensity: WeatherIntensity, duration: f64, transition_time: f64) {
        self.transition = WeatherTransition::init(self.current_state.weather_type, weather_type, transition_time)

        // Will apply new state after transition
        let new_state = WeatherState::init(weather_type, intensity, duration)
    }

    fn update(&self, delta_time: f64) {
        // Update transition
        if let Some(trans) = self.transition {
            trans.update(delta_time)

            if trans.is_complete {
                self.transition = null
            }
        }

        // Update current weather
        self.current_state.update(delta_time)

        // Auto weather changes
        if self.auto_weather_enabled {
            self.time_since_weather_change = self.time_since_weather_change + delta_time

            if self.time_since_weather_change >= self.weather_change_interval {
                self.random_weather_change()
            }
        }
    }

    fn update_effects(&self) {
        self.effects.clear()

        match self.current_state.weather_type {
            WeatherType::RAIN => {
                let effect = WeatherEffect::for_rain(self.current_state.intensity)
                self.effects.add(effect)
            },
            WeatherType::HEAVY_RAIN => {
                let effect = WeatherEffect::for_rain(WeatherIntensity::HEAVY)
                self.effects.add(effect)
            },
            WeatherType::SNOW => {
                let effect = WeatherEffect::for_snow(self.current_state.intensity)
                self.effects.add(effect)
            },
            WeatherType::SANDSTORM => {
                let effect = WeatherEffect::for_sandstorm(self.current_state.intensity)
                self.effects.add(effect)
            },
            _ => {},
        }
    }

    fn random_weather_change(&self) {
        // TODO: Actually randomize
        self.set_weather(WeatherType::RAIN, WeatherIntensity::MODERATE, 300.0)
    }

    fn clear_weather(&self) {
        self.set_weather(WeatherType::CLEAR, WeatherIntensity::NONE, 0.0)
    }

    fn get_current_weather(&self): WeatherType {
        return self.current_state.weather_type
    }

    fn get_visibility_modifier(&self): f64 {
        return self.current_state.visibility_modifier
    }

    fn enable_auto_weather(&self) {
        self.auto_weather_enabled = true
    }

    fn disable_auto_weather(&self) {
        self.auto_weather_enabled = false
    }

    fn set_wind(&self, direction: f64, speed: f64) {
        self.current_state.set_wind(direction, speed)
    }

    fn get_effect_count(&self): i32 {
        return self.effects.count()
    }
}

// Helper structs
struct Color {
    r: f64,
    g: f64,
    b: f64,
    a: f64,

    fn init(r: f64, g: f64, b: f64, a: f64): Color {
        return Color { r: r, g: g, b: b, a: a }
    }
}

// Tests
test "WeatherState: init" {
    let state = WeatherState::init(WeatherType::RAIN, WeatherIntensity::MODERATE, 100.0)

    assert state.weather_type == WeatherType::RAIN
    assert state.intensity == WeatherIntensity::MODERATE
    assert state.duration == 100.0
    assert state.is_active
}

test "WeatherState: update" {
    let state = WeatherState::init(WeatherType::RAIN, WeatherIntensity::LIGHT, 10.0)

    state.update(5.0)
    assert state.elapsed_time == 5.0
    assert state.is_active

    state.update(6.0)
    assert state.is_expired()
}

test "WeatherState: visibility modifier" {
    let clear = WeatherState::init(WeatherType::CLEAR, WeatherIntensity::NONE, 0.0)
    clear.update_visibility()
    assert clear.visibility_modifier == 1.0

    let heavy_rain = WeatherState::init(WeatherType::RAIN, WeatherIntensity::HEAVY, 100.0)
    heavy_rain.update_visibility()
    assert heavy_rain.visibility_modifier < 1.0
}

test "WeatherState: get progress" {
    let state = WeatherState::init(WeatherType::SNOW, WeatherIntensity::LIGHT, 100.0)

    state.update(50.0)
    assert state.get_progress() == 50.0
}

test "WeatherState: set wind" {
    let state = WeatherState::init(WeatherType::RAIN, WeatherIntensity::MODERATE, 100.0)

    state.set_wind(45.0, 15.0)
    assert state.wind_direction == 45.0
    assert state.wind_speed == 15.0
}

test "WeatherTransition: init" {
    let transition = WeatherTransition::init(WeatherType::CLEAR, WeatherType::RAIN, 10.0)

    assert transition.from_weather == WeatherType::CLEAR
    assert transition.to_weather == WeatherType::RAIN
    assert !transition.is_complete
}

test "WeatherTransition: update" {
    let transition = WeatherTransition::init(WeatherType::CLEAR, WeatherType::RAIN, 5.0)

    transition.update(3.0)
    assert !transition.is_complete
    assert transition.get_blend_factor() == 0.6

    transition.update(3.0)
    assert transition.is_complete
}

test "WeatherEffect: init" {
    let effect = WeatherEffect::init()

    assert effect.particle_count == 0
    assert effect.particle_speed == 0.0
}

test "WeatherEffect: rain" {
    let light = WeatherEffect::for_rain(WeatherIntensity::LIGHT)
    let heavy = WeatherEffect::for_rain(WeatherIntensity::HEAVY)

    assert light.particle_count < heavy.particle_count
    assert light.particle_speed > 0.0
}

test "WeatherEffect: snow" {
    let moderate = WeatherEffect::for_snow(WeatherIntensity::MODERATE)

    assert moderate.particle_count > 0
    assert moderate.particle_speed < 50.0  // Slower than rain
}

test "WeatherEffect: sandstorm" {
    let heavy = WeatherEffect::for_sandstorm(WeatherIntensity::HEAVY)

    assert heavy.particle_count > 1000
    assert heavy.particle_speed > 0.0
}

test "WeatherManager: init" {
    let manager = WeatherManager::init()

    assert manager.current_state.weather_type == WeatherType::CLEAR
    assert !manager.auto_weather_enabled
}

test "WeatherManager: set weather" {
    let manager = WeatherManager::init()

    manager.set_weather(WeatherType::RAIN, WeatherIntensity::MODERATE, 100.0)

    assert manager.get_current_weather() == WeatherType::RAIN
    assert manager.current_state.intensity == WeatherIntensity::MODERATE
}

test "WeatherManager: update effects" {
    let manager = WeatherManager::init()

    manager.set_weather(WeatherType::RAIN, WeatherIntensity::HEAVY, 100.0)

    assert manager.get_effect_count() > 0
}

test "WeatherManager: clear weather" {
    let manager = WeatherManager::init()

    manager.set_weather(WeatherType::SNOW, WeatherIntensity::HEAVY, 100.0)
    manager.clear_weather()

    assert manager.get_current_weather() == WeatherType::CLEAR
}

test "WeatherManager: visibility modifier" {
    let manager = WeatherManager::init()

    assert manager.get_visibility_modifier() == 1.0

    manager.set_weather(WeatherType::SANDSTORM, WeatherIntensity::HEAVY, 100.0)

    assert manager.get_visibility_modifier() < 1.0
}

test "WeatherManager: set wind" {
    let manager = WeatherManager::init()

    manager.set_wind(90.0, 20.0)

    assert manager.current_state.wind_direction == 90.0
    assert manager.current_state.wind_speed == 20.0
}

test "WeatherManager: auto weather" {
    let manager = WeatherManager::init()
    manager.weather_change_interval = 1.0

    manager.enable_auto_weather()
    assert manager.auto_weather_enabled

    manager.update(1.5)
    assert manager.time_since_weather_change < 1.0  // Reset after change
}

test "WeatherManager: disable auto weather" {
    let manager = WeatherManager::init()

    manager.enable_auto_weather()
    manager.disable_auto_weather()

    assert !manager.auto_weather_enabled
}

test "WeatherManager: transition" {
    let manager = WeatherManager::init()

    manager.transition_to_weather(WeatherType::RAIN, WeatherIntensity::LIGHT, 100.0, 5.0)

    assert manager.transition != null

    let trans = manager.transition?
    assert trans.to_weather == WeatherType::RAIN
}

test "WeatherManager: update completes expired weather" {
    let manager = WeatherManager::init()

    manager.set_weather(WeatherType::RAIN, WeatherIntensity::MODERATE, 1.0)

    manager.update(1.5)
    assert manager.current_state.is_expired()
}
