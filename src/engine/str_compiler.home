// STR Compiler - Multi-Language String File Support
// Parses the generals.str master file format and compiles to CSF
// Used by the C&C Generals patch project for localization
//
// Format:
// - Comments start with //
// - Entries have format: LABEL:\nUS: "text"\nDE: "text"\n...END
// - Language codes: US, DE, FR, ES, IT, KO, ZH, BP, PL, RU, AR, UA, SE

from basics import Collection, Map

// Supported language codes
const LANG_US: String = "US"  // English (United States)
const LANG_DE: String = "DE"  // German
const LANG_FR: String = "FR"  // French
const LANG_ES: String = "ES"  // Spanish
const LANG_IT: String = "IT"  // Italian
const LANG_KO: String = "KO"  // Korean
const LANG_ZH: String = "ZH"  // Chinese (Traditional)
const LANG_BP: String = "BP"  // Brazilian Portuguese
const LANG_PL: String = "PL"  // Polish
const LANG_RU: String = "RU"  // Russian
const LANG_AR: String = "AR"  // Arabic
const LANG_UA: String = "UA"  // Ukrainian
const LANG_SE: String = "SE"  // Swedish

// All supported languages
const ALL_LANGUAGES: [String; 13] = [
    "US", "DE", "FR", "ES", "IT", "KO", "ZH", "BP", "PL", "RU", "AR", "UA", "SE"
]

// Language to folder name mapping
fn language_to_folder(lang_code: String) -> String {
    match lang_code {
        "US" => "English",
        "DE" => "German",
        "FR" => "French",
        "ES" => "Spanish",
        "IT" => "Italian",
        "KO" => "Korean",
        "ZH" => "Chinese",
        "BP" => "Brazilian",
        "PL" => "Polish",
        "RU" => "Russian",
        "AR" => "Arabic",
        "UA" => "Ukrainian",
        "SE" => "Swedish",
        _ => "English",
    }
}

// Single localized string entry
struct LocalizedString {
    label: String,
    translations: Map<String, String>,  // Language code -> text
    extra_value: String,                  // Optional extra value (used by some strings)
}

// Complete string database
struct StringDatabase {
    entries: Collection<LocalizedString>,
    labels: Map<String, Int>,  // Label -> index in entries
    source_file: String,
}

/// Create empty string database
fn create_string_database() -> StringDatabase {
    return StringDatabase {
        entries: Collection<LocalizedString>{},
        labels: Map<String, Int>{},
        source_file: "",
    }
}

/// Create empty localized string
fn create_localized_string(label: String) -> LocalizedString {
    return LocalizedString {
        label: label,
        translations: Map<String, String>{},
        extra_value: "",
    }
}

// ============================================================================
// STR Parser
// ============================================================================

/// Check if line is a comment
fn is_comment_line(line: String) -> Bool {
    let trimmed = trim(line)
    return trimmed.starts_with("//")
}

/// Check if line is empty or whitespace only
fn is_empty_line(line: String) -> Bool {
    return trim(line).len() == 0
}

/// Check if line starts a new string entry (LABEL:)
fn is_label_line(line: String) -> Bool {
    let trimmed = trim(line)
    // Label lines end with : and don't start with language codes
    if !trimmed.ends_with(":") {
        return false
    }
    // Check it's not a language line like "US:"
    for lang in ALL_LANGUAGES {
        if trimmed.starts_with(lang + ":") {
            return false
        }
    }
    return true
}

/// Check if line is a language definition (XX: "text")
fn is_language_line(line: String) -> Bool {
    let trimmed = trim(line)
    for lang in ALL_LANGUAGES {
        if trimmed.starts_with(lang + ":") {
            return true
        }
    }
    return false
}

/// Check if line is END marker
fn is_end_line(line: String) -> Bool {
    return trim(line) == "END"
}

/// Extract label from label line
fn extract_label(line: String) -> String {
    let trimmed = trim(line)
    if trimmed.ends_with(":") {
        return trimmed.substring(0, trimmed.len() - 1)
    }
    return trimmed
}

/// Extract language code and text from language line
fn extract_language_text(line: String) -> (String, String) {
    let trimmed = trim(line)

    // Find the language code
    for lang in ALL_LANGUAGES {
        let prefix = lang + ":"
        if trimmed.starts_with(prefix) {
            let rest = trim(trimmed.substring(prefix.len(), trimmed.len()))

            // Extract quoted text
            if rest.starts_with("\"") {
                let end_quote = find_closing_quote(rest, 1)
                if end_quote > 0 {
                    let text = rest.substring(1, end_quote)
                    return (lang, unescape_string(text))
                }
            }
            return (lang, rest)
        }
    }

    return ("", "")
}

/// Find closing quote, handling escaped quotes
fn find_closing_quote(s: String, start: Int) -> Int {
    let i = start
    while i < s.len() {
        let c = s.char_at(i)
        if c == 92 {  // backslash
            i = i + 2  // Skip escaped character
        } else if c == 34 {  // quote
            return i
        } else {
            i = i + 1
        }
    }
    return -1
}

/// Unescape special characters in string
fn unescape_string(s: String) -> String {
    let result = ""
    let i = 0

    while i < s.len() {
        let c = s.char_at(i)

        if c == 92 && i + 1 < s.len() {  // backslash
            let next = s.char_at(i + 1)
            if next == 110 {  // \n
                result = result + "\n"
                i = i + 2
            } else if next == 34 {  // \"
                result = result + "\""
                i = i + 2
            } else if next == 92 {  // \\
                result = result + "\\"
                i = i + 2
            } else if next == 116 {  // \t
                result = result + "\t"
                i = i + 2
            } else {
                result = result + String::char_from_code(c)
                i = i + 1
            }
        } else {
            result = result + String::char_from_code(c)
            i = i + 1
        }
    }

    return result
}

/// Trim whitespace from string
fn trim(s: String) -> String {
    let start = 0
    let end = s.len()

    while start < end && is_whitespace(s.char_at(start)) {
        start = start + 1
    }
    while end > start && is_whitespace(s.char_at(end - 1)) {
        end = end - 1
    }

    return s.substring(start, end)
}

fn is_whitespace(c: Int) -> Bool {
    return c == 32 || c == 9 || c == 10 || c == 13
}

/// Parse STR file content into string database
fn parse_str_file(content: String) -> StringDatabase {
    let db = create_string_database()
    let lines = split_lines(content)

    let current_entry: LocalizedString = create_localized_string("")
    let in_entry = false

    for i in 0..lines.len() {
        let line = lines.get(i)

        // Skip comments and empty lines outside entries
        if is_comment_line(line) {
            continue
        }

        if is_empty_line(line) {
            continue
        }

        if is_label_line(line) {
            // Save previous entry if exists
            if in_entry && current_entry.label.len() > 0 {
                let index = db.entries.len()
                db.entries.add(current_entry)
                db.labels.set(current_entry.label, index)
            }

            // Start new entry
            current_entry = create_localized_string(extract_label(line))
            in_entry = true

        } else if is_language_line(line) && in_entry {
            let (lang, text) = extract_language_text(line)
            if lang.len() > 0 {
                current_entry.translations.set(lang, text)
            }

        } else if is_end_line(line) && in_entry {
            // Save current entry
            if current_entry.label.len() > 0 {
                let index = db.entries.len()
                db.entries.add(current_entry)
                db.labels.set(current_entry.label, index)
            }
            current_entry = create_localized_string("")
            in_entry = false
        }
    }

    // Save last entry if not ended
    if in_entry && current_entry.label.len() > 0 {
        let index = db.entries.len()
        db.entries.add(current_entry)
        db.labels.set(current_entry.label, index)
    }

    return db
}

/// Split string into lines
fn split_lines(text: String) -> Collection<String> {
    let lines = Collection<String>{}
    let current = ""

    for i in 0..text.len() {
        let c = text.char_at(i)

        if c == 10 {  // \n
            lines.add(current)
            current = ""
        } else if c == 13 {  // \r
            // Skip \r, handle \r\n
        } else {
            current = current + String::char_from_code(c)
        }
    }

    if current.len() > 0 {
        lines.add(current)
    }

    return lines
}

// ============================================================================
// CSF Compiler
// ============================================================================

// CSF file format constants
const CSF_MAGIC: Int = 0x43534620        // "CSF " - file signature
const CSF_VERSION: Int = 3               // CSF version
const CSF_LABEL_MAGIC: Int = 0x4C424C20  // "LBL " - label header
const CSF_STRING_MAGIC: Int = 0x53545220 // "STR " - string header
const CSF_WSTRING_MAGIC: Int = 0x53545257 // "STRW" - wide string header

/// Compile string database to CSF format for specific language
fn compile_to_csf(db: StringDatabase, language: String) -> Collection<Int> {
    let data = Collection<Int>{}

    // Count strings for this language
    let string_count = 0
    for entry in db.entries {
        if entry.translations.has(language) || entry.translations.has("US") {
            string_count = string_count + 1
        }
    }

    // Write CSF header
    write_u32_le(data, CSF_MAGIC)         // Magic
    write_u32_le(data, CSF_VERSION)       // Version
    write_u32_le(data, string_count)      // Number of labels
    write_u32_le(data, string_count)      // Number of strings
    write_u32_le(data, 0)                 // Unused
    write_u32_le(data, get_language_id(language))  // Language ID

    // Write each string entry
    for entry in db.entries {
        // Get text for this language, fall back to English
        let text = ""
        if entry.translations.has(language) {
            text = entry.translations.get(language)
        } else if entry.translations.has("US") {
            text = entry.translations.get("US")
        } else {
            continue  // Skip entries with no translation
        }

        // Write label header
        write_u32_le(data, CSF_LABEL_MAGIC)
        write_u32_le(data, 1)  // Number of strings for this label

        // Write label name length and name
        let label_bytes = string_to_bytes(entry.label)
        write_u32_le(data, label_bytes.len())
        for b in label_bytes {
            data.add(b)
        }

        // Write string header
        write_u32_le(data, CSF_STRING_MAGIC)

        // Convert text to UTF-16LE and XOR with 0xFF (CSF encoding)
        let utf16 = string_to_utf16le(text)
        write_u32_le(data, utf16.len() / 2)  // Character count

        for b in utf16 {
            data.add(b ^ 0xFF)  // XOR encoding
        }
    }

    return data
}

/// Write 32-bit little-endian integer
fn write_u32_le(data: Collection<Int>, value: Int) {
    data.add(value & 0xFF)
    data.add((value >> 8) & 0xFF)
    data.add((value >> 16) & 0xFF)
    data.add((value >> 24) & 0xFF)
}

/// Convert string to bytes (ASCII)
fn string_to_bytes(s: String) -> Collection<Int> {
    let bytes = Collection<Int>{}
    for i in 0..s.len() {
        bytes.add(s.char_at(i) & 0xFF)
    }
    return bytes
}

/// Convert string to UTF-16LE
fn string_to_utf16le(s: String) -> Collection<Int> {
    let bytes = Collection<Int>{}
    for i in 0..s.len() {
        let c = s.char_at(i)
        bytes.add(c & 0xFF)
        bytes.add((c >> 8) & 0xFF)
    }
    return bytes
}

/// Get CSF language ID
fn get_language_id(lang: String) -> Int {
    match lang {
        "US" => 0,
        "DE" => 2,
        "FR" => 3,
        "ES" => 4,
        "IT" => 5,
        "KO" => 7,
        "ZH" => 8,
        "BP" => 9,
        "PL" => 10,
        "RU" => 11,
        "AR" => 12,
        "UA" => 13,
        "SE" => 14,
        _ => 0,
    }
}

// ============================================================================
// String Database Operations
// ============================================================================

/// Get string for label and language
fn get_string(db: StringDatabase, label: String, language: String) -> String {
    if !db.labels.has(label) {
        return ""
    }

    let index = db.labels.get(label)
    let entry = db.entries.get(index)

    if entry.translations.has(language) {
        return entry.translations.get(language)
    }

    // Fall back to English
    if entry.translations.has("US") {
        return entry.translations.get("US")
    }

    return ""
}

/// Get all available languages for a label
fn get_available_languages(db: StringDatabase, label: String) -> Collection<String> {
    let result = Collection<String>{}

    if !db.labels.has(label) {
        return result
    }

    let index = db.labels.get(label)
    let entry = db.entries.get(index)

    for lang in ALL_LANGUAGES {
        if entry.translations.has(lang) {
            result.add(lang)
        }
    }

    return result
}

/// Check if label exists
fn has_label(db: StringDatabase, label: String) -> Bool {
    return db.labels.has(label)
}

/// Get total number of entries
fn get_entry_count(db: StringDatabase) -> Int {
    return db.entries.len()
}

/// Get all labels
fn get_all_labels(db: StringDatabase) -> Collection<String> {
    let result = Collection<String>{}
    for entry in db.entries {
        result.add(entry.label)
    }
    return result
}

// ============================================================================
// Tests
// ============================================================================

fn test_parse_simple() -> Bool {
    let content = "OBJECT:TestObject:\nUS: \"Hello World\"\nDE: \"Hallo Welt\"\nEND\n"
    let db = parse_str_file(content)

    assert(get_entry_count(db) == 1, "Should have 1 entry")
    assert(has_label(db, "OBJECT:TestObject"), "Should have label")
    assert(get_string(db, "OBJECT:TestObject", "US") == "Hello World", "US string should match")
    assert(get_string(db, "OBJECT:TestObject", "DE") == "Hallo Welt", "DE string should match")

    return true
}

fn test_fallback_to_english() -> Bool {
    let content = "TEST:\nUS: \"English Only\"\nEND\n"
    let db = parse_str_file(content)

    // French should fall back to English
    assert(get_string(db, "TEST", "FR") == "English Only", "Should fall back to English")

    return true
}

fn test_escape_sequences() -> Bool {
    let content = "TEST:\nUS: \"Line1\\nLine2\"\nEND\n"
    let db = parse_str_file(content)

    let text = get_string(db, "TEST", "US")
    assert(text.contains("\n"), "Should contain newline")

    return true
}

fn test_language_id() -> Bool {
    assert(get_language_id("US") == 0, "US should be 0")
    assert(get_language_id("DE") == 2, "DE should be 2")
    assert(get_language_id("RU") == 11, "RU should be 11")
    return true
}

fn test_language_to_folder() -> Bool {
    assert(language_to_folder("US") == "English", "US -> English")
    assert(language_to_folder("DE") == "German", "DE -> German")
    assert(language_to_folder("RU") == "Russian", "RU -> Russian")
    return true
}

fn run_all_tests() -> Bool {
    assert(test_parse_simple(), "Simple parse test failed")
    assert(test_fallback_to_english(), "Fallback test failed")
    assert(test_escape_sequences(), "Escape sequences test failed")
    assert(test_language_id(), "Language ID test failed")
    assert(test_language_to_folder(), "Language folder test failed")
    return true
}
