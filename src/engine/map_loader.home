// MAP File Loader - C&C Generals Map Format Support
// Loads game maps including terrain, objects, and metadata
// Reference: EA SAGE engine map format


// Map file sections
const MAP_VERSION: i32 = 5  // C&C Generals Zero Hour map version

// Terrain blend tile types
enum TerrainType {
    Grass,
    Dirt,
    Sand,
    Rock,
    Water,
    Snow,
    Concrete,
    Asphalt,
    Mud,
    Shore,
    Cliff,
    Ice,
}

// Map object types
enum MapObjectType {
    Unit,
    Building,
    Prop,
    Tree,
    Rock,
    Waypoint,
    CameraPoint,
    ScriptArea,
    Light,
    Particle,
    Sound,
}

// Map coordinates
struct MapCoord {
    x: f64,
    y: f64,
    z: f64,
}

fn create_coord(x: f64, y: f64, z: f64): MapCoord {
    return MapCoord { x: x, y: y, z: z }
}

// Height map cell
struct HeightCell {
    height: f64,
    terrain_type: TerrainType,
    passable: bool,
    buildable: bool,
}

// Map object placement
struct MapObject {
    object_type: MapObjectType,
    type_name: string,      // Object definition name (e.g., "AmericaTank")
    position: MapCoord,
    rotation: f64,        // Y-axis rotation in degrees
    team: i32,              // Owner team/player
    health: f64,          // Initial health percentage (0-100)
    is_selected: bool,
    script_name: string,    // For script triggers
    properties: HashMap<String, String>,  // Additional object properties
}

// Waypoint for pathfinding and scripts
struct Waypoint {
    name: string,
    position: MapCoord,
    linked_waypoints: Vec<string>,
    is_visible: bool,
}

// Script area (rectangular trigger zone)
struct ScriptArea {
    name: string,
    min_corner: MapCoord,
    max_corner: MapCoord,
    is_water: bool,
    is_no_build: bool,
}

// Player starting position
struct StartPosition {
    player_index: i32,
    position: MapCoord,
    rotation: f64,
}

// Terrain texture layer
struct TerrainLayer {
    texture_name: string,
    blend_texture: string,
    tile_size: f64,
}

// Complete map data
struct GameMap {
    // Metadata
    name: string,
    description: string,
    author: string,
    version: i32,

    // Dimensions
    width: i32,             // Map width in cells
    height: i32,            // Map height in cells
    cell_size: f64,       // Size of each cell in world units

    // Height map
    height_map: Vec<HeightCell>,
    min_height: f64,
    max_height: f64,

    // Terrain
    terrain_layers: Vec<TerrainLayer>,

    // Objects
    objects: Vec<MapObject>,
    waypoints: Vec<Waypoint>,
    script_areas: Vec<ScriptArea>,

    // Players
    start_positions: Vec<StartPosition>,
    max_players: i32,

    // Water
    water_height: f64,
    has_water: bool,

    // Environment
    ambient_color: (Int, Int, Int),
    sun_direction: MapCoord,
    sun_color: (Int, Int, Int),

    // Bounds
    playable_min: MapCoord,
    playable_max: MapCoord,
}

/// Create empty game map
fn create_game_map(): GameMap {
    return GameMap {
        name: "Untitled",
        description: "",
        author: "",
        version: MAP_VERSION,
        width: 256,
        height: 256,
        cell_size: 10.0,
        height_map: Vec<HeightCell>{},
        min_height: 0.0,
        max_height: 100.0,
        terrain_layers: Vec<TerrainLayer>{},
        objects: Vec<MapObject>{},
        waypoints: Vec<Waypoint>{},
        script_areas: Vec<ScriptArea>{},
        start_positions: Vec<StartPosition>{},
        max_players: 8,
        water_height: 0.0,
        has_water: false,
        ambient_color: (128, 128, 128),
        sun_direction: create_coord(0.5, -1.0, 0.5),
        sun_color: (255, 255, 200),
        playable_min: create_coord(0.0, 0.0, 0.0),
        playable_max: create_coord(2560.0, 0.0, 2560.0),
    }
}

/// Read 32-bit little-endian integer
fn read_u32_le(data: Vec<i32>, offset: i32): i32 {
    if offset + 4 > data.len() {
        return 0
    }
    return data.get(offset) |
           (data.get(offset + 1) << 8) |
           (data.get(offset + 2) << 16) |
           (data.get(offset + 3) << 24)
}

/// Read 16-bit little-endian integer
fn read_u16_le(data: Vec<i32>, offset: i32): i32 {
    if offset + 2 > data.len() {
        return 0
    }
    return data.get(offset) | (data.get(offset + 1) << 8)
}

/// Read float (IEEE 754)
fn read_float_le(data: Vec<i32>, offset: i32): f64 {
    // Simplified - in real implementation would parse IEEE 754
    let bits = read_u32_le(data, offset)
    // Convert bits to float (simplified)
    return (bits as Float) / 1000000.0
}

/// Read null-terminated string
fn read_string(data: Vec<i32>, offset: i32, max_len: i32): string {
    let result = ""
    let i = 0

    while i < max_len && offset + i < data.len() {
        let c = data.get(offset + i)
        if c == 0 {
            break
        }
        result = result + String::char_from_code(c)
        i = i + 1
    }

    return result
}

/// Initialize height map with flat terrain
fn initialize_height_map(map: GameMap) {
    let total_cells = map.width * map.height

    for i in 0..total_cells {
        let cell = HeightCell {
            height: 0.0,
            terrain_type: TerrainType::Grass,
            passable: true,
            buildable: true,
        }
        map.height_map.add(cell)
    }
}

/// Get height at cell coordinates
fn get_height_at(map: GameMap, x: i32, y: i32): f64 {
    if x < 0 || x >= map.width || y < 0 || y >= map.height {
        return 0.0
    }

    let index = y * map.width + x
    if index >= map.height_map.len() {
        return 0.0
    }

    return map.height_map.get(index).height
}

/// Get height at world coordinates (with interpolation)
fn get_height_at_world(map: GameMap, wx: f64, wy: f64): f64 {
    let cell_x = (wx / map.cell_size) as Int
    let cell_y = (wy / map.cell_size) as Int

    // Bilinear interpolation
    let fx = (wx / map.cell_size) - (cell_x as Float)
    let fy = (wy / map.cell_size) - (cell_y as Float)

    let h00 = get_height_at(map, cell_x, cell_y)
    let h10 = get_height_at(map, cell_x + 1, cell_y)
    let h01 = get_height_at(map, cell_x, cell_y + 1)
    let h11 = get_height_at(map, cell_x + 1, cell_y + 1)

    let h0 = h00 * (1.0 - fx) + h10 * fx
    let h1 = h01 * (1.0 - fx) + h11 * fx

    return h0 * (1.0 - fy) + h1 * fy
}

/// Set height at cell coordinates
fn set_height_at(map: GameMap, x: i32, y: i32, height: f64) {
    if x < 0 || x >= map.width || y < 0 || y >= map.height {
        return
    }

    let index = y * map.width + x
    if index >= map.height_map.len() {
        return
    }

    map.height_map.get(index).height = height

    // Update bounds
    if height < map.min_height {
        map.min_height = height
    }
    if height > map.max_height {
        map.max_height = height
    }
}

/// Check if cell is passable
fn is_passable(map: GameMap, x: i32, y: i32): bool {
    if x < 0 || x >= map.width || y < 0 || y >= map.height {
        return false
    }

    let index = y * map.width + x
    if index >= map.height_map.len() {
        return false
    }

    return map.height_map.get(index).passable
}

/// Check if cell is buildable
fn is_buildable(map: GameMap, x: i32, y: i32): bool {
    if x < 0 || x >= map.width || y < 0 || y >= map.height {
        return false
    }

    let index = y * map.width + x
    if index >= map.height_map.len() {
        return false
    }

    return map.height_map.get(index).buildable
}

/// Add object to map
fn add_object(map: GameMap, obj: MapObject) {
    map.objects.add(obj)
}

/// Add waypoint to map
fn add_waypoint(map: GameMap, waypoint: Waypoint) {
    map.waypoints.add(waypoint)
}

/// Add script area to map
fn add_script_area(map: GameMap, area: ScriptArea) {
    map.script_areas.add(area)
}

/// Find waypoint by name
fn find_waypoint(map: GameMap, name: string): Waypoint {
    for wp in map.waypoints {
        if wp.name == name {
            return wp
        }
    }
    return Waypoint {
        name: "",
        position: create_coord(0.0, 0.0, 0.0),
        linked_waypoints: Vec<string>{},
        is_visible: false,
    }
}

/// Get objects in area
fn get_objects_in_area(map: GameMap, min: MapCoord, max: MapCoord): Vec<MapObject> {
    let result = Vec<MapObject>{}

    for obj in map.objects {
        if obj.position.x >= min.x && obj.position.x <= max.x &&
           obj.position.z >= min.z && obj.position.z <= max.z {
            result.add(obj)
        }
    }

    return result
}

/// Create a map object
fn create_map_object(type_name: string, x: f64, y: f64, z: f64, team: i32): MapObject {
    return MapObject {
        object_type: MapObjectType::Unit,
        type_name: type_name,
        position: create_coord(x, y, z),
        rotation: 0.0,
        team: team,
        health: 100.0,
        is_selected: false,
        script_name: "",
        properties: HashMap<String, String>{},
    }
}

/// Load map from data (simplified parser)
fn load_map(data: Vec<i32>): (GameMap, Bool) {
    let map = create_game_map()

    if data.len() < 32 {
        return (map, false)
    }

    // Parse header (simplified)
    // Real implementation would parse the full SAGE map format

    // Initialize with default height map
    initialize_height_map(map)

    return (map, true)
}

/// Generate random terrain heights
fn generate_random_terrain(map: GameMap, amplitude: f64, frequency: f64) {
    for y in 0..map.height {
        for x in 0..map.width {
            // Simple sine-based terrain generation
            let fx = (x as Float) * frequency
            let fy = (y as Float) * frequency

            let h = sin(fx) * cos(fy) * amplitude
            h = h + sin(fx * 2.0) * sin(fy * 2.0) * (amplitude * 0.5)

            set_height_at(map, x, y, h)
        }
    }
}

/// Simple sine function
fn sin(x: f64): f64 {
    // Taylor series approximation
    let x_mod = x - ((x / 6.28318) as Int as Float) * 6.28318
    let x2 = x_mod * x_mod
    let x3 = x2 * x_mod
    let x5 = x3 * x2
    let x7 = x5 * x2
    return x_mod - x3 / 6.0 + x5 / 120.0 - x7 / 5040.0
}

/// Simple cosine function
fn cos(x: f64): f64 {
    return sin(x + 1.5708)
}

// ============================================================================
// Map Manager
// ============================================================================

struct MapManager {
    maps: HashMap<String, GameMap>,
    current_map: string,
    map_directory: string,

    fn init(): MapManager {
        return MapManager {
            maps: HashMap<String, GameMap>{},
            current_map: "",
            map_directory: "assets/maps",
        }
    }

    fn load_map(&self, name: string, data: Vec<i32>): bool {
        let (map, success) = load_map(data)
        if success {
            map.name = name
            self.maps.set(name, map)
        }
        return success
    }

    fn set_current_map(&self, name: string): bool {
        if self.maps.has(name) {
            self.current_map = name
            return true
        }
        return false
    }

    fn get_current_map(&self): GameMap {
        if self.current_map != "" && self.maps.has(self.current_map) {
            return self.maps.get(self.current_map)
        }
        return create_game_map()
    }

    fn has_map(&self, name: string): bool {
        return self.maps.has(name)
    }

    fn get_map_list(&self): Vec<string> {
        let result = Vec<string>{}
        for key in self.maps.keys() {
            result.add(key)
        }
        return result
    }
}

// ============================================================================
// Tests
// ============================================================================

fn test_map_creation(): bool {
    let map = create_game_map()
    assert(map.width == 256, "Default width should be 256")
    assert(map.height == 256, "Default height should be 256")
    assert(map.max_players == 8, "Default max players should be 8")
    return true
}

fn test_height_map(): bool {
    let map = create_game_map()
    map.width = 10
    map.height = 10
    initialize_height_map(map)

    assert(map.height_map.len() == 100, "Should have 100 cells (10x10)")

    set_height_at(map, 5, 5, 50.0)
    let h = get_height_at(map, 5, 5)
    assert(h == 50.0, "Height should be 50.0")

    return true
}

fn test_object_creation(): bool {
    let obj = create_map_object("AmericaTank", 100.0, 0.0, 200.0, 1)
    assert(obj.type_name == "AmericaTank", "Type name should match")
    assert(obj.team == 1, "Team should be 1")
    assert(obj.health == 100.0, "Default health should be 100")
    return true
}

fn test_passability(): bool {
    let map = create_game_map()
    map.width = 10
    map.height = 10
    initialize_height_map(map)

    assert(is_passable(map, 5, 5) == true, "Should be passable by default")
    assert(is_buildable(map, 5, 5) == true, "Should be buildable by default")

    // Out of bounds
    assert(is_passable(map, -1, 0) == false, "Out of bounds should not be passable")

    return true
}

fn test_map_manager(): bool {
    let manager = MapManager::init()
    assert(manager.current_map == "", "Should start with no current map")

    let map = create_game_map()
    map.name = "TestMap"
    manager.maps.set("TestMap", map)

    assert(manager.has_map("TestMap") == true, "Should have TestMap")
    assert(manager.set_current_map("TestMap") == true, "Should set current map")

    return true
}

fn run_all_tests(): bool {
    assert(test_map_creation(), "Map creation test failed")
    assert(test_height_map(), "Height map test failed")
    assert(test_object_creation(), "Object creation test failed")
    assert(test_passability(), "Passability test failed")
    assert(test_map_manager(), "Map manager test failed")
    return true
}
