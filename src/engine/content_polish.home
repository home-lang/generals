// Content Polish System
// Final polish layer including localization, tutorials, and content validation

enum Language {
    ENGLISH,
    FRENCH,
    GERMAN,
    SPANISH,
    ITALIAN,
    RUSSIAN,
    CHINESE,
    JAPANESE,
    KOREAN,
}

struct LocalizedString {
    key: String,
    translations: Collection<String>,  // Indexed by Language enum

    fn init(key: String) -> LocalizedString {
        let str = LocalizedString {
            key: key,
            translations: Collection::init(),
        }

        // Initialize with empty strings for all languages
        for i in 0..9 {
            str.translations.add("")
        }

        return str
    }

    fn set_translation(self, lang: Language, text: String) {
        let index = 0
        if lang == Language::FRENCH { index = 1 }
        else if lang == Language::GERMAN { index = 2 }
        else if lang == Language::SPANISH { index = 3 }
        else if lang == Language::ITALIAN { index = 4 }
        else if lang == Language::RUSSIAN { index = 5 }
        else if lang == Language::CHINESE { index = 6 }
        else if lang == Language::JAPANESE { index = 7 }
        else if lang == Language::KOREAN { index = 8 }

        self.translations.set(index, text)
    }

    fn get_translation(self, lang: Language) -> String {
        let index = 0
        if lang == Language::FRENCH { index = 1 }
        else if lang == Language::GERMAN { index = 2 }
        else if lang == Language::SPANISH { index = 3 }
        else if lang == Language::ITALIAN { index = 4 }
        else if lang == Language::RUSSIAN { index = 5 }
        else if lang == Language::CHINESE { index = 6 }
        else if lang == Language::JAPANESE { index = 7 }
        else if lang == Language::KOREAN { index = 8 }

        let text = self.translations.get(index)
        if text == "" {
            return self.translations.get(0)  // Fallback to English
        }

        return text
    }
}

struct LocalizationDatabase {
    strings: Collection<LocalizedString>,
    current_language: Language,

    fn init() -> LocalizationDatabase {
        let db = LocalizationDatabase {
            strings: Collection::init(),
            current_language: Language::ENGLISH,
        }
        return db
    }

    fn add_string(self, key: String, english: String) -> LocalizedString {
        let str = LocalizedString::init(key)
        str.set_translation(Language::ENGLISH, english)
        self.strings.add(str)
        return str
    }

    fn get_string(self, key: String) -> String {
        for i in 0..self.strings.len() {
            let str = self.strings.get(i)
            if str.key == key {
                return str.get_translation(self.current_language)
            }
        }
        return key  // Return key if not found
    }

    fn set_language(self, lang: Language) {
        self.current_language = lang
    }
}

// Tutorial System
enum TutorialStep {
    SHOW_MESSAGE,
    HIGHLIGHT_UI,
    WAIT_FOR_ACTION,
    SPAWN_UNIT,
    OBJECTIVE,
}

struct TutorialInstruction {
    step_type: TutorialStep,
    message: String,
    ui_element: String,
    required_action: String,
    timeout: Float,
    is_optional: Bool,

    fn init(step_type: TutorialStep, message: String) -> TutorialInstruction {
        let instruction = TutorialInstruction {
            step_type: step_type,
            message: message,
            ui_element: "",
            required_action: "",
            timeout: 0.0,
            is_optional: false,
        }
        return instruction
    }
}

struct Tutorial {
    id: String,
    name: String,
    description: String,
    instructions: Collection<TutorialInstruction>,
    current_step: Int,
    is_complete: Bool,

    fn init(id: String, name: String) -> Tutorial {
        let tutorial = Tutorial {
            id: id,
            name: name,
            description: "",
            instructions: Collection::init(),
            current_step: 0,
            is_complete: false,
        }
        return tutorial
    }

    fn add_instruction(self, instruction: TutorialInstruction) {
        self.instructions.add(instruction)
    }

    fn get_current_instruction(self) -> TutorialInstruction? {
        if self.current_step >= self.instructions.len() {
            return null
        }

        return self.instructions.get(self.current_step)
    }

    fn advance(self) -> Bool {
        self.current_step = self.current_step + 1

        if self.current_step >= self.instructions.len() {
            self.is_complete = true
            return false
        }

        return true
    }

    fn reset(self) {
        self.current_step = 0
        self.is_complete = false
    }
}

// Content Validation
struct ContentValidator {
    errors: Collection<String>,
    warnings: Collection<String>,

    fn init() -> ContentValidator {
        let validator = ContentValidator {
            errors: Collection::init(),
            warnings: Collection::init(),
        }
        return validator
    }

    fn validate_unit_templates(self, registry: UnitTemplateRegistry) -> Bool {
        let all_valid = true

        for i in 0..registry.templates.len() {
            let unit = registry.templates.get(i)

            // Check required fields
            if unit.name == "" {
                self.errors.add("Unit " + unit.id + " has no name")
                all_valid = false
            }

            if unit.max_health <= 0.0 {
                self.errors.add("Unit " + unit.id + " has invalid health")
                all_valid = false
            }

            if unit.cost < 0 {
                self.warnings.add("Unit " + unit.id + " has negative cost")
            }

            // Check weapons
            if unit.weapons.len() == 0 {
                if unit.tier != UnitTier::WORKER {
                    self.warnings.add("Unit " + unit.id + " has no weapons")
                }
            }
        }

        return all_valid
    }

    fn validate_building_templates(self, registry: BuildingTemplateRegistry) -> Bool {
        let all_valid = true

        for i in 0..registry.templates.len() {
            let building = registry.templates.get(i)

            if building.name == "" {
                self.errors.add("Building " + building.id + " has no name")
                all_valid = false
            }

            if building.max_health <= 0.0 {
                self.errors.add("Building " + building.id + " has invalid health")
                all_valid = false
            }

            if building.build_time <= 0.0 {
                self.warnings.add("Building " + building.id + " has no build time")
            }
        }

        return all_valid
    }

    fn validate_abilities(self, registry: AbilityRegistry) -> Bool {
        let all_valid = true

        for i in 0..registry.abilities.len() {
            let ability = registry.abilities.get(i)

            if ability.name == "" {
                self.errors.add("Ability " + ability.id + " has no name")
                all_valid = false
            }

            if ability.cooldown < 0.0 {
                self.errors.add("Ability " + ability.id + " has negative cooldown")
                all_valid = false
            }
        }

        return all_valid
    }

    fn validate_maps(self, registry: MapRegistry) -> Bool {
        let all_valid = true

        for i in 0..registry.maps.len() {
            let map = registry.maps.get(i)

            if !map.is_valid() {
                self.errors.add("Map " + map.id + " is invalid")
                all_valid = false
            }

            if map.spawn_points.len() < map.min_players {
                self.errors.add("Map " + map.id + " doesn't have enough spawn points")
                all_valid = false
            }

            if map.resources.len() == 0 {
                self.warnings.add("Map " + map.id + " has no resources")
            }
        }

        return all_valid
    }

    fn get_error_count(self) -> Int {
        return self.errors.len()
    }

    fn get_warning_count(self) -> Int {
        return self.warnings.len()
    }

    fn print_report(self) {
        // Would print to console
        // For now, just returns stats
    }
}

// Loading Screen Tips
struct LoadingTip {
    text: String,
    category: String,

    fn init(text: String, category: String) -> LoadingTip {
        let tip = LoadingTip {
            text: text,
            category: category,
        }
        return tip
    }
}

struct LoadingTipManager {
    tips: Collection<LoadingTip>,

    fn init() -> LoadingTipManager {
        let manager = LoadingTipManager {
            tips: Collection::init(),
        }

        // Add gameplay tips
        manager.tips.add(LoadingTip::init("Build Supply Centers early for a strong economy", "economy"))
        manager.tips.add(LoadingTip::init("Use formations to keep your units organized", "strategy"))
        manager.tips.add(LoadingTip::init("Scout early to find your opponent's base", "strategy"))
        manager.tips.add(LoadingTip::init("Veterancy increases unit effectiveness", "combat"))
        manager.tips.add(LoadingTip::init("Control groups (1-9) help manage large armies", "ui"))
        manager.tips.add(LoadingTip::init("The minimap shows enemy activity in revealed areas", "ui"))
        manager.tips.add(LoadingTip::init("General's Powers can turn the tide of battle", "powers"))
        manager.tips.add(LoadingTip::init("Upgrade your units at the Strategy Center", "upgrades"))
        manager.tips.add(LoadingTip::init("Air units are effective against slow-moving targets", "combat"))
        manager.tips.add(LoadingTip::init("Infantry can garrison buildings for protection", "combat"))

        // Add faction tips
        manager.tips.add(LoadingTip::init("USA excels at air superiority and high-tech warfare", "faction"))
        manager.tips.add(LoadingTip::init("China has powerful tanks and nuclear weapons", "faction"))
        manager.tips.add(LoadingTip::init("GLA uses guerrilla tactics and stealth units", "faction"))

        return manager
    }

    fn get_random_tip(self) -> String {
        if self.tips.len() == 0 {
            return ""
        }

        // Simple random (would use proper RNG)
        let index = 0  // Would be random
        return self.tips.get(index).text
    }

    fn get_tips_by_category(self, category: String) -> Collection<LoadingTip> {
        let result = Collection::init()

        for i in 0..self.tips.len() {
            let tip = self.tips.get(i)
            if tip.category == category {
                result.add(tip)
            }
        }

        return result
    }
}

// Achievement Definitions (Extended)
struct AchievementDefinition {
    id: String,
    name: String,
    description: String,
    icon: String,
    points: Int,
    hidden: Bool,
    requirement_type: String,
    requirement_value: Int,

    fn init(id: String, name: String, desc: String) -> AchievementDefinition {
        let achievement = AchievementDefinition {
            id: id,
            name: name,
            description: desc,
            icon: "",
            points: 10,
            hidden: false,
            requirement_type: "",
            requirement_value: 0,
        }
        return achievement
    }
}

fn create_achievement_definitions() -> Collection<AchievementDefinition> {
    let achievements = Collection::init()

    // Campaign achievements
    let usa_campaign = AchievementDefinition::init("usa_campaign", "American Hero", "Complete the USA campaign")
    usa_campaign.points = 50
    achievements.add(usa_campaign)

    let china_campaign = AchievementDefinition::init("china_campaign", "Dragon's Fury", "Complete the China campaign")
    china_campaign.points = 50
    achievements.add(china_campaign)

    let gla_campaign = AchievementDefinition::init("gla_campaign", "Liberation", "Complete the GLA campaign")
    gla_campaign.points = 50
    achievements.add(gla_campaign)

    // Combat achievements
    let first_blood = AchievementDefinition::init("first_blood", "First Blood", "Destroy your first enemy unit")
    first_blood.points = 5
    achievements.add(first_blood)

    let destructor = AchievementDefinition::init("destructor", "Destructor", "Destroy 1000 enemy units")
    destructor.points = 30
    destructor.requirement_type = "units_destroyed"
    destructor.requirement_value = 1000
    achievements.add(destructor)

    // Economy achievements
    let millionaire = AchievementDefinition::init("millionaire", "Millionaire", "Accumulate $1,000,000")
    millionaire.points = 25
    millionaire.requirement_type = "total_money"
    millionaire.requirement_value = 1000000
    achievements.add(millionaire)

    // Special achievements
    let nuke_strike = AchievementDefinition::init("nuke_strike", "Nuclear Option", "Use a Nuclear Missile")
    nuke_strike.points = 15
    achievements.add(nuke_strike)

    let air_superiority = AchievementDefinition::init("air_superiority", "Air Superiority", "Win with 50+ aircraft")
    air_superiority.points = 20
    achievements.add(air_superiority)

    return achievements
}

// Statistics Tracking (Extended)
struct GameStatistics {
    games_played: Int,
    games_won: Int,
    games_lost: Int,
    total_playtime: Float,

    units_built: Int,
    units_lost: Int,
    units_killed: Int,

    buildings_built: Int,
    buildings_lost: Int,
    buildings_destroyed: Int,

    total_money_earned: Int,
    total_money_spent: Int,

    powers_used: Int,
    upgrades_researched: Int,

    favorite_faction: String,
    favorite_unit: String,

    fn init() -> GameStatistics {
        let stats = GameStatistics {
            games_played: 0,
            games_won: 0,
            games_lost: 0,
            total_playtime: 0.0,
            units_built: 0,
            units_lost: 0,
            units_killed: 0,
            buildings_built: 0,
            buildings_lost: 0,
            buildings_destroyed: 0,
            total_money_earned: 0,
            total_money_spent: 0,
            powers_used: 0,
            upgrades_researched: 0,
            favorite_faction: "",
            favorite_unit: "",
        }
        return stats
    }

    fn get_win_rate(self) -> Float {
        if self.games_played == 0 {
            return 0.0
        }

        return self.games_won / self.games_played
    }

    fn get_kd_ratio(self) -> Float {
        if self.units_lost == 0 {
            return self.units_killed
        }

        return self.units_killed / self.units_lost
    }
}

// Tests
fn test_localized_string() -> Bool {
    let str = LocalizedString::init("hello")
    str.set_translation(Language::ENGLISH, "Hello")
    str.set_translation(Language::FRENCH, "Bonjour")
    str.set_translation(Language::GERMAN, "Hallo")

    assert(str.get_translation(Language::ENGLISH) == "Hello", "English")
    assert(str.get_translation(Language::FRENCH) == "Bonjour", "French")
    assert(str.get_translation(Language::GERMAN) == "Hallo", "German")

    return true
}

fn test_localization_database() -> Bool {
    let db = LocalizationDatabase::init()
    db.add_string("welcome", "Welcome to Generals")

    let text = db.get_string("welcome")
    assert(text == "Welcome to Generals", "English default")

    db.set_language(Language::FRENCH)
    // Would fallback to English since we didn't set French
    let french = db.get_string("welcome")
    assert(french == "Welcome to Generals", "Fallback to English")

    return true
}

fn test_tutorial() -> Bool {
    let tutorial = Tutorial::init("basics", "Basic Training")

    let step1 = TutorialInstruction::init(TutorialStep::SHOW_MESSAGE, "Welcome to Generals!")
    tutorial.add_instruction(step1)

    let step2 = TutorialInstruction::init(TutorialStep::WAIT_FOR_ACTION, "Build a Barracks")
    tutorial.add_instruction(step2)

    assert(tutorial.instructions.len() == 2, "Two instructions")
    assert(!tutorial.is_complete, "Not complete")

    let current = tutorial.get_current_instruction()
    assert(current != null, "Has current instruction")

    tutorial.advance()
    assert(tutorial.current_step == 1, "Advanced to step 1")

    tutorial.advance()
    assert(tutorial.is_complete, "Complete after all steps")

    return true
}

fn test_content_validator() -> Bool {
    let validator = ContentValidator::init()

    assert(validator.get_error_count() == 0, "No errors initially")
    assert(validator.get_warning_count() == 0, "No warnings initially")

    validator.errors.add("Test error")
    assert(validator.get_error_count() == 1, "One error")

    validator.warnings.add("Test warning")
    assert(validator.get_warning_count() == 1, "One warning")

    return true
}

fn test_loading_tips() -> Bool {
    let manager = LoadingTipManager::init()

    assert(manager.tips.len() > 0, "Has tips")

    let tip = manager.get_random_tip()
    assert(tip != "", "Got a tip")

    let strategy_tips = manager.get_tips_by_category("strategy")
    assert(strategy_tips.len() > 0, "Has strategy tips")

    return true
}

fn test_achievement_definitions() -> Bool {
    let achievements = create_achievement_definitions()

    assert(achievements.len() > 0, "Has achievements")

    let first = achievements.get(0)
    assert(first.name != "", "Has name")
    assert(first.points > 0, "Has points")

    return true
}

fn test_game_statistics() -> Bool {
    let stats = GameStatistics::init()

    assert(stats.games_played == 0, "No games played")
    assert(stats.get_win_rate() == 0.0, "No win rate")

    stats.games_played = 10
    stats.games_won = 7
    assert(stats.get_win_rate() == 0.7, "70% win rate")

    stats.units_killed = 100
    stats.units_lost = 50
    assert(stats.get_kd_ratio() == 2.0, "2.0 K/D ratio")

    return true
}

fn test_tutorial_step_types() -> Bool {
    let msg = TutorialInstruction::init(TutorialStep::SHOW_MESSAGE, "Test message")
    assert(msg.step_type == TutorialStep::SHOW_MESSAGE, "Message step")

    let action = TutorialInstruction::init(TutorialStep::WAIT_FOR_ACTION, "Do something")
    assert(action.step_type == TutorialStep::WAIT_FOR_ACTION, "Action step")

    return true
}

fn test_loading_tip_categories() -> Bool {
    let manager = LoadingTipManager::init()

    let economy = manager.get_tips_by_category("economy")
    let strategy = manager.get_tips_by_category("strategy")
    let faction = manager.get_tips_by_category("faction")

    assert(economy.len() > 0, "Has economy tips")
    assert(strategy.len() > 0, "Has strategy tips")
    assert(faction.len() > 0, "Has faction tips")

    return true
}

fn test_language_fallback() -> Bool {
    let str = LocalizedString::init("test")
    str.set_translation(Language::ENGLISH, "Test")

    // Request German without setting it - should fallback to English
    let german = str.get_translation(Language::GERMAN)
    assert(german == "Test", "Fallback works")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_localized_string(), "Test 1: Localized string")
    assert(test_localization_database(), "Test 2: Localization database")
    assert(test_tutorial(), "Test 3: Tutorial")
    assert(test_content_validator(), "Test 4: Content validator")
    assert(test_loading_tips(), "Test 5: Loading tips")
    assert(test_achievement_definitions(), "Test 6: Achievement definitions")
    assert(test_game_statistics(), "Test 7: Game statistics")
    assert(test_tutorial_step_types(), "Test 8: Tutorial step types")
    assert(test_loading_tip_categories(), "Test 9: Loading tip categories")
    assert(test_language_fallback(), "Test 10: Language fallback")
    return true
}
