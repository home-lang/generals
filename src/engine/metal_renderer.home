// Metal 3D Renderer - Pure Home Implementation
// Full 3D rendering pipeline for C&C Generals Zero Hour on macOS
//
// Features:
// - Vertex/Index buffer management
// - Shader compilation and management
// - Texture loading and binding
// - Render pipeline state management
// - Depth buffer handling
// - Multi-pass rendering (shadows, main, post-process)
//
// Reference: thyme/src/w3d/renderer/


// ============================================================================
// VERTEX FORMATS
// ============================================================================

// Standard vertex format for W3D models
struct Vertex3D {
    position: Vec3,      // Position in model space
    normal: Vec3,        // Normal vector
    tex_coord: Vec2,     // Texture coordinates
    color: Vec4,         // Vertex color
    bone_indices: Vec4,  // Up to 4 bone influences
    bone_weights: Vec4,  // Weights for each bone

    fn init(pos: Vec3, normal: Vec3, uv: Vec2): Vertex3D {
        let v = Vertex3D {
            position: pos,
            normal: normal,
            tex_coord: uv,
            color: Vec4::init(1.0, 1.0, 1.0, 1.0),
            bone_indices: Vec4::init(0.0, 0.0, 0.0, 0.0),
            bone_weights: Vec4::init(1.0, 0.0, 0.0, 0.0),
        }
        return v
    }

    // Size in bytes for Metal buffer layout
    fn stride(): i32 {
        // 3+3+2+4+4+4 = 20 floats = 80 bytes
        return 80
    }
}

// Terrain vertex format
struct VertexTerrain {
    position: Vec3,
    normal: Vec3,
    tex_coord0: Vec2,  // Base texture
    tex_coord1: Vec2,  // Blend texture
    blend_weight: f64,

    fn init(pos: Vec3, normal: Vec3, uv0: Vec2, uv1: Vec2): VertexTerrain {
        let v = VertexTerrain {
            position: pos,
            normal: normal,
            tex_coord0: uv0,
            tex_coord1: uv1,
            blend_weight: 0.0,
        }
        return v
    }

    fn stride(): i32 {
        // 3+3+2+2+1 = 11 floats = 44 bytes
        return 44
    }
}

// Particle vertex (billboards)
struct VertexParticle {
    position: Vec3,
    size: Vec2,
    color: Vec4,
    tex_coord: Vec2,
    rotation: f64,

    fn init(pos: Vec3, size: Vec2, color: Vec4): VertexParticle {
        let v = VertexParticle {
            position: pos,
            size: size,
            color: color,
            tex_coord: Vec2::init(0.0, 0.0),
            rotation: 0.0,
        }
        return v
    }

    fn stride(): i32 {
        return 48
    }
}

// ============================================================================
// GPU BUFFERS
// ============================================================================

enum BufferUsage {
    Static,   // Never changes after creation
    Dynamic,  // Updated occasionally
    Stream,   // Updated every frame
}

struct VertexBuffer {
    id: i32,
    size: i32,
    stride: i32,
    usage: BufferUsage,
    vertex_count: i32,

    fn init(id: i32, vertex_count: i32, stride: i32, usage: BufferUsage): VertexBuffer {
        let buffer = VertexBuffer {
            id: id,
            size: vertex_count * stride,
            stride: stride,
            usage: usage,
            vertex_count: vertex_count,
        }
        return buffer
    }
}

struct IndexBuffer {
    id: i32,
    size: i32,
    index_count: i32,
    index_type: IndexType,

    fn init(id: i32, index_count: i32, index_type: IndexType): IndexBuffer {
        let element_size = if index_type == IndexType::UInt16 { 2 } else { 4 }
        let buffer = IndexBuffer {
            id: id,
            size: index_count * element_size,
            index_count: index_count,
            index_type: index_type,
        }
        return buffer
    }
}

enum IndexType {
    UInt16,
    UInt32,
}

struct UniformBuffer {
    id: i32,
    size: i32,
    slot: i32,

    fn init(id: i32, size: i32, slot: i32): UniformBuffer {
        let buffer = UniformBuffer {
            id: id,
            size: size,
            slot: slot,
        }
        return buffer
    }
}

// ============================================================================
// TEXTURES
// ============================================================================

enum TextureFormat {
    RGBA8,
    BGRA8,
    RGB8,
    DXT1,  // BC1
    DXT3,  // BC2
    DXT5,  // BC3
    Depth32F,
    Depth24Stencil8,
}

enum TextureFilter {
    Nearest,
    Linear,
    Trilinear,
    Anisotropic,
}

enum TextureWrap {
    Repeat,
    Clamp,
    Mirror,
}

struct Texture2D {
    id: i32,
    width: i32,
    height: i32,
    format: TextureFormat,
    mip_levels: i32,
    filter: TextureFilter,
    wrap_u: TextureWrap,
    wrap_v: TextureWrap,
    name: string,

    fn init(id: i32, width: i32, height: i32, format: TextureFormat): Texture2D {
        let tex = Texture2D {
            id: id,
            width: width,
            height: height,
            format: format,
            mip_levels: 1,
            filter: TextureFilter::Linear,
            wrap_u: TextureWrap::Repeat,
            wrap_v: TextureWrap::Repeat,
            name: "",
        }
        return tex
    }

    fn set_filter(&self, filter: TextureFilter) {
        self.filter = filter
    }

    fn set_wrap(&self, wrap_u: TextureWrap, wrap_v: TextureWrap) {
        self.wrap_u = wrap_u
        self.wrap_v = wrap_v
    }

    fn generate_mipmaps(&self) {
        // Calculate mip levels based on dimensions
        let max_dim = max(self.width, self.height)
        self.mip_levels = floor(log2(max_dim)) + 1
    }
}

struct RenderTarget {
    id: i32,
    width: i32,
    height: i32,
    color_texture: Texture2D?,
    depth_texture: Texture2D?,
    has_depth: bool,

    fn init(id: i32, width: i32, height: i32, has_depth: bool): RenderTarget {
        let rt = RenderTarget {
            id: id,
            width: width,
            height: height,
            color_texture: null,
            depth_texture: null,
            has_depth: has_depth,
        }
        return rt
    }
}

// ============================================================================
// SHADERS
// ============================================================================

enum ShaderType {
    Vertex,
    Fragment,
    Compute,
}

struct ShaderProgram {
    id: i32,
    name: string,
    vertex_function: string,
    fragment_function: string,
    uniforms: Vec<UniformInfo>,

    fn init(id: i32, name: string): ShaderProgram {
        let shader = ShaderProgram {
            id: id,
            name: name,
            vertex_function: "",
            fragment_function: "",
            uniforms: Vec::init(),
        }
        return shader
    }

    fn add_uniform(&self, info: UniformInfo) {
        self.uniforms.add(info)
    }
}

struct UniformInfo {
    name: string,
    type_name: string,
    slot: i32,
    size: i32,

    fn init(name: string, type_name: string, slot: i32): UniformInfo {
        let info = UniformInfo {
            name: name,
            type_name: type_name,
            slot: slot,
            size: 0,
        }
        return info
    }
}

// ============================================================================
// RENDER STATES
// ============================================================================

enum BlendFactor {
    Zero,
    One,
    SrcColor,
    OneMinusSrcColor,
    SrcAlpha,
    OneMinusSrcAlpha,
    DstColor,
    OneMinusDstColor,
    DstAlpha,
    OneMinusDstAlpha,
}

enum BlendOp {
    Add,
    Subtract,
    ReverseSubtract,
    Min,
    Max,
}

struct BlendState {
    enabled: bool,
    src_factor: BlendFactor,
    dst_factor: BlendFactor,
    op: BlendOp,
    alpha_src_factor: BlendFactor,
    alpha_dst_factor: BlendFactor,
    alpha_op: BlendOp,

    fn disabled(): BlendState {
        let state = BlendState {
            enabled: false,
            src_factor: BlendFactor::One,
            dst_factor: BlendFactor::Zero,
            op: BlendOp::Add,
            alpha_src_factor: BlendFactor::One,
            alpha_dst_factor: BlendFactor::Zero,
            alpha_op: BlendOp::Add,
        }
        return state
    }

    fn alpha_blend(): BlendState {
        let state = BlendState {
            enabled: true,
            src_factor: BlendFactor::SrcAlpha,
            dst_factor: BlendFactor::OneMinusSrcAlpha,
            op: BlendOp::Add,
            alpha_src_factor: BlendFactor::One,
            alpha_dst_factor: BlendFactor::OneMinusSrcAlpha,
            alpha_op: BlendOp::Add,
        }
        return state
    }

    fn additive(): BlendState {
        let state = BlendState {
            enabled: true,
            src_factor: BlendFactor::SrcAlpha,
            dst_factor: BlendFactor::One,
            op: BlendOp::Add,
            alpha_src_factor: BlendFactor::SrcAlpha,
            alpha_dst_factor: BlendFactor::One,
            alpha_op: BlendOp::Add,
        }
        return state
    }
}

enum CompareFunc {
    Never,
    Less,
    Equal,
    LessEqual,
    Greater,
    NotEqual,
    GreaterEqual,
    Always,
}

struct DepthState {
    test_enabled: bool,
    write_enabled: bool,
    compare_func: CompareFunc,

    fn default(): DepthState {
        let state = DepthState {
            test_enabled: true,
            write_enabled: true,
            compare_func: CompareFunc::Less,
        }
        return state
    }

    fn disabled(): DepthState {
        let state = DepthState {
            test_enabled: false,
            write_enabled: false,
            compare_func: CompareFunc::Always,
        }
        return state
    }

    fn read_only(): DepthState {
        let state = DepthState {
            test_enabled: true,
            write_enabled: false,
            compare_func: CompareFunc::Less,
        }
        return state
    }
}

enum CullMode {
    None,
    Front,
    Back,
}

enum FillMode {
    Solid,
    Wireframe,
}

struct RasterizerState {
    cull_mode: CullMode,
    fill_mode: FillMode,
    front_face_ccw: bool,
    depth_bias: f64,
    depth_bias_clamp: f64,
    slope_scale_depth_bias: f64,

    fn default(): RasterizerState {
        let state = RasterizerState {
            cull_mode: CullMode::Back,
            fill_mode: FillMode::Solid,
            front_face_ccw: true,
            depth_bias: 0.0,
            depth_bias_clamp: 0.0,
            slope_scale_depth_bias: 0.0,
        }
        return state
    }
}

// ============================================================================
// PIPELINE STATE
// ============================================================================

struct PipelineState {
    id: i32,
    shader: ShaderProgram,
    blend_state: BlendState,
    depth_state: DepthState,
    rasterizer_state: RasterizerState,
    vertex_layout: VertexLayout,

    fn init(id: i32, shader: ShaderProgram): PipelineState {
        let pipeline = PipelineState {
            id: id,
            shader: shader,
            blend_state: BlendState::disabled(),
            depth_state: DepthState::default(),
            rasterizer_state: RasterizerState::default(),
            vertex_layout: VertexLayout::init(),
        }
        return pipeline
    }
}

struct VertexLayout {
    attributes: Vec<VertexAttribute>,
    stride: i32,

    fn init(): VertexLayout {
        let layout = VertexLayout {
            attributes: Vec::init(),
            stride: 0,
        }
        return layout
    }

    fn add_attribute(&self, attr: VertexAttribute) {
        self.attributes.add(attr)
        self.stride = self.stride + attr.size
    }
}

struct VertexAttribute {
    name: string,
    format: VertexFormat,
    offset: i32,
    size: i32,

    fn init(name: string, format: VertexFormat, offset: i32): VertexAttribute {
        let attr = VertexAttribute {
            name: name,
            format: format,
            offset: offset,
            size: format_size(format),
        }
        return attr
    }
}

enum VertexFormat {
    Float1,
    Float2,
    Float3,
    Float4,
    Int1,
    Int2,
    Int4,
    UByte4Norm,
}

fn format_size(format: VertexFormat): i32 {
    match format {
        VertexFormat::Float1 => 4,
        VertexFormat::Float2 => 8,
        VertexFormat::Float3 => 12,
        VertexFormat::Float4 => 16,
        VertexFormat::Int1 => 4,
        VertexFormat::Int2 => 8,
        VertexFormat::Int4 => 16,
        VertexFormat::UByte4Norm => 4,
    }
}

// ============================================================================
// UNIFORM DATA STRUCTURES
// ============================================================================

// Per-frame constants
struct FrameUniforms {
    view_matrix: Mat4,
    projection_matrix: Mat4,
    view_projection: Mat4,
    camera_position: Vec4,
    time: f64,
    delta_time: f64,
    frame_index: i32,
    padding: f64,

    fn init(): FrameUniforms {
        let uniforms = FrameUniforms {
            view_matrix: Mat4::identity(),
            projection_matrix: Mat4::identity(),
            view_projection: Mat4::identity(),
            camera_position: Vec4::init(0.0, 0.0, 0.0, 1.0),
            time: 0.0,
            delta_time: 0.016,
            frame_index: 0,
            padding: 0.0,
        }
        return uniforms
    }
}

// Per-object constants
struct ObjectUniforms {
    model_matrix: Mat4,
    normal_matrix: Mat4,  // Inverse transpose of model matrix
    color_tint: Vec4,
    uv_offset: Vec2,
    uv_scale: Vec2,

    fn init(): ObjectUniforms {
        let uniforms = ObjectUniforms {
            model_matrix: Mat4::identity(),
            normal_matrix: Mat4::identity(),
            color_tint: Vec4::init(1.0, 1.0, 1.0, 1.0),
            uv_offset: Vec2::init(0.0, 0.0),
            uv_scale: Vec2::init(1.0, 1.0),
        }
        return uniforms
    }
}

// Lighting constants
struct LightUniforms {
    sun_direction: Vec4,
    sun_color: Vec4,
    ambient_color: Vec4,
    fog_color: Vec4,
    fog_params: Vec4,  // near, far, density, enabled
    point_lights: Vec<PointLightData>,

    fn init(): LightUniforms {
        let uniforms = LightUniforms {
            sun_direction: Vec4::init(0.5, -1.0, 0.5, 0.0),
            sun_color: Vec4::init(1.0, 0.95, 0.9, 1.0),
            ambient_color: Vec4::init(0.2, 0.25, 0.3, 1.0),
            fog_color: Vec4::init(0.7, 0.8, 0.9, 1.0),
            fog_params: Vec4::init(100.0, 1000.0, 0.001, 1.0),
            point_lights: Vec::init(),
        }
        return uniforms
    }
}

struct PointLightData {
    position: Vec4,
    color: Vec4,
    attenuation: Vec4,  // constant, linear, quadratic, range

    fn init(pos: Vec3, color: Vec3, range: f64): PointLightData {
        let light = PointLightData {
            position: Vec4::init(pos.x, pos.y, pos.z, 1.0),
            color: Vec4::init(color.x, color.y, color.z, 1.0),
            attenuation: Vec4::init(1.0, 0.0, 1.0 / (range * range), range),
        }
        return light
    }
}

// Skeletal animation uniforms
struct SkinningUniforms {
    bone_matrices: Vec<Mat4>,
    max_bones: i32,

    fn init(max_bones: i32): SkinningUniforms {
        let uniforms = SkinningUniforms {
            bone_matrices: Vec::init(),
            max_bones: max_bones,
        }
        // Initialize identity matrices
        for i in 0..max_bones {
            uniforms.bone_matrices.add(Mat4::identity())
        }
        return uniforms
    }

    fn set_bone(&self, index: i32, matrix: Mat4) {
        if index >= 0 and index < self.max_bones {
            self.bone_matrices.set(index, matrix)
        }
    }
}

// ============================================================================
// DRAW COMMANDS
// ============================================================================

enum PrimitiveType {
    Triangles,
    TriangleStrip,
    Lines,
    LineStrip,
    Points,
}

struct DrawCall {
    pipeline: i32,               // Pipeline state ID
    vertex_buffer: i32,          // Vertex buffer ID
    index_buffer: i32,           // Index buffer ID (-1 for non-indexed)
    primitive_type: PrimitiveType,
    vertex_start: i32,
    vertex_count: i32,
    index_start: i32,
    index_count: i32,
    instance_count: i32,
    textures: Vec<i32>,   // Texture IDs for each slot
    uniform_buffer: i32,         // Object uniforms buffer

    fn init(pipeline: i32, vertex_buffer: i32): DrawCall {
        let call = DrawCall {
            pipeline: pipeline,
            vertex_buffer: vertex_buffer,
            index_buffer: -1,
            primitive_type: PrimitiveType::Triangles,
            vertex_start: 0,
            vertex_count: 0,
            index_start: 0,
            index_count: 0,
            instance_count: 1,
            textures: Vec::init(),
            uniform_buffer: -1,
        }
        return call
    }

    fn set_indexed(&self, index_buffer: i32, index_count: i32) {
        self.index_buffer = index_buffer
        self.index_count = index_count
    }

    fn add_texture(&self, texture_id: i32) {
        self.textures.add(texture_id)
    }
}

// ============================================================================
// METAL RENDERER
// ============================================================================

struct MetalRenderer {
    // Resource management
    next_buffer_id: i32,
    next_texture_id: i32,
    next_shader_id: i32,
    next_pipeline_id: i32,

    // Cached resources
    vertex_buffers: HashMap<Int, VertexBuffer>,
    index_buffers: HashMap<Int, IndexBuffer>,
    uniform_buffers: HashMap<Int, UniformBuffer>,
    textures: HashMap<Int, Texture2D>,
    shaders: HashMap<Int, ShaderProgram>,
    pipelines: HashMap<Int, PipelineState>,
    render_targets: HashMap<Int, RenderTarget>,

    // Current state
    current_pipeline: i32,
    current_render_target: i32,

    // Frame data
    frame_uniforms: FrameUniforms,
    light_uniforms: LightUniforms,
    draw_queue: Vec<DrawCall>,

    // Stats
    draw_call_count: i32,
    triangle_count: i32,
    texture_switches: i32,

    fn init(): MetalRenderer {
        let renderer = MetalRenderer {
            next_buffer_id: 1,
            next_texture_id: 1,
            next_shader_id: 1,
            next_pipeline_id: 1,
            vertex_buffers: HashMap::init(),
            index_buffers: HashMap::init(),
            uniform_buffers: HashMap::init(),
            textures: HashMap::init(),
            shaders: HashMap::init(),
            pipelines: HashMap::init(),
            render_targets: HashMap::init(),
            current_pipeline: -1,
            current_render_target: -1,
            frame_uniforms: FrameUniforms::init(),
            light_uniforms: LightUniforms::init(),
            draw_queue: Vec::init(),
            draw_call_count: 0,
            triangle_count: 0,
            texture_switches: 0,
        }
        return renderer
    }

    // ========================================================================
    // RESOURCE CREATION
    // ========================================================================

    fn create_vertex_buffer(&self, vertex_count: i32, stride: i32, usage: BufferUsage): i32 {
        let id = self.next_buffer_id
        self.next_buffer_id = self.next_buffer_id + 1

        let buffer = VertexBuffer::init(id, vertex_count, stride, usage)
        self.vertex_buffers.set(id, buffer)

        return id
    }

    fn create_index_buffer(&self, index_count: i32, index_type: IndexType): i32 {
        let id = self.next_buffer_id
        self.next_buffer_id = self.next_buffer_id + 1

        let buffer = IndexBuffer::init(id, index_count, index_type)
        self.index_buffers.set(id, buffer)

        return id
    }

    fn create_uniform_buffer(&self, size: i32, slot: i32): i32 {
        let id = self.next_buffer_id
        self.next_buffer_id = self.next_buffer_id + 1

        let buffer = UniformBuffer::init(id, size, slot)
        self.uniform_buffers.set(id, buffer)

        return id
    }

    fn create_texture(&self, width: i32, height: i32, format: TextureFormat): i32 {
        let id = self.next_texture_id
        self.next_texture_id = self.next_texture_id + 1

        let texture = Texture2D::init(id, width, height, format)
        self.textures.set(id, texture)

        return id
    }

    fn create_shader(&self, name: string, vertex_func: string, fragment_func: string): i32 {
        let id = self.next_shader_id
        self.next_shader_id = self.next_shader_id + 1

        let shader = ShaderProgram::init(id, name)
        shader.vertex_function = vertex_func
        shader.fragment_function = fragment_func
        self.shaders.set(id, shader)

        return id
    }

    fn create_pipeline(&self, shader_id: i32): i32 {
        let shader = self.shaders.get(shader_id)
        if shader == null {
            return -1
        }

        let id = self.next_pipeline_id
        self.next_pipeline_id = self.next_pipeline_id + 1

        let pipeline = PipelineState::init(id, shader)
        self.pipelines.set(id, pipeline)

        return id
    }

    fn create_render_target(&self, width: i32, height: i32, has_depth: bool): i32 {
        let id = self.next_texture_id
        self.next_texture_id = self.next_texture_id + 1

        let rt = RenderTarget::init(id, width, height, has_depth)

        // Create color texture
        let color_id = self.create_texture(width, height, TextureFormat::BGRA8)
        rt.color_texture = self.textures.get(color_id)

        // Create depth texture if needed
        if has_depth {
            let depth_id = self.create_texture(width, height, TextureFormat::Depth32F)
            rt.depth_texture = self.textures.get(depth_id)
        }

        self.render_targets.set(id, rt)
        return id
    }

    // ========================================================================
    // RESOURCE DESTRUCTION
    // ========================================================================

    fn destroy_vertex_buffer(&self, id: i32) {
        self.vertex_buffers.remove(id)
    }

    fn destroy_index_buffer(&self, id: i32) {
        self.index_buffers.remove(id)
    }

    fn destroy_texture(&self, id: i32) {
        self.textures.remove(id)
    }

    fn destroy_shader(&self, id: i32) {
        self.shaders.remove(id)
    }

    fn destroy_pipeline(&self, id: i32) {
        self.pipelines.remove(id)
    }

    // ========================================================================
    // FRAME OPERATIONS
    // ========================================================================

    fn begin_frame(&self, view: Mat4, projection: Mat4, camera_pos: Vec3, time: f64, dt: f64) {
        self.frame_uniforms.view_matrix = view
        self.frame_uniforms.projection_matrix = projection
        self.frame_uniforms.view_projection = Mat4::multiply(projection, view)
        self.frame_uniforms.camera_position = Vec4::init(camera_pos.x, camera_pos.y, camera_pos.z, 1.0)
        self.frame_uniforms.time = time
        self.frame_uniforms.delta_time = dt
        self.frame_uniforms.frame_index = self.frame_uniforms.frame_index + 1

        // Reset stats
        self.draw_call_count = 0
        self.triangle_count = 0
        self.texture_switches = 0

        // Clear draw queue
        self.draw_queue.clear()
    }

    fn end_frame(&self) {
        // Sort draw queue by pipeline and material to minimize state changes
        self.sort_draw_queue()

        // Execute all draw calls
        for call in self.draw_queue {
            self.execute_draw_call(call)
        }
    }

    fn sort_draw_queue(&self) {
        // Sort by: render target -> pipeline -> textures to minimize state changes
        let n = self.draw_queue.len()
        for i in 0..n {
            for j in 0..(n - i - 1) {
                let a = self.draw_queue.get(j)
                let b = self.draw_queue.get(j + 1)
                if a.pipeline > b.pipeline {
                    self.draw_queue.swap(j, j + 1)
                }
            }
        }
    }

    fn execute_draw_call(&self, call: DrawCall) {
        // Set pipeline if changed
        if call.pipeline != self.current_pipeline {
            self.current_pipeline = call.pipeline
            // Native: set pipeline state
        }

        // Bind textures
        for i in 0..call.textures.len() {
            let tex_id = call.textures.get(i)
            // Native: bind texture to slot i
            self.texture_switches = self.texture_switches + 1
        }

        // Draw
        if call.index_buffer >= 0 {
            // Indexed draw
            // Native: drawIndexedPrimitives
            self.triangle_count = self.triangle_count + (call.index_count / 3)
        } else {
            // Non-indexed draw
            // Native: drawPrimitives
            self.triangle_count = self.triangle_count + (call.vertex_count / 3)
        }

        self.draw_call_count = self.draw_call_count + 1
    }

    // ========================================================================
    // DRAWING
    // ========================================================================

    fn submit_draw(&self, call: DrawCall) {
        self.draw_queue.add(call)
    }

    fn set_render_target(&self, target_id: i32) {
        self.current_render_target = target_id
        // Native: setRenderTargetAttachments
    }

    fn clear(&self, r: f64, g: f64, b: f64, a: f64, depth: f64) {
        // Native: clearWithColor
    }

    // ========================================================================
    // UTILITY
    // ========================================================================

    fn get_stats(&self): RenderStats {
        let stats = RenderStats {
            draw_calls: self.draw_call_count,
            triangles: self.triangle_count,
            texture_switches: self.texture_switches,
        }
        return stats
    }
}

struct RenderStats {
    draw_calls: i32,
    triangles: i32,
    texture_switches: i32,
}

// ============================================================================
// STANDARD SHADERS (Metal Shading Language embedded as strings)
// ============================================================================

// These would be compiled at runtime by Metal
const SHADER_STANDARD_VERTEX: string = """
#include <metal_stdlib>
using namespace metal;

struct VertexIn {
    float3 position [[attribute(0)]];
    float3 normal [[attribute(1)]];
    float2 texCoord [[attribute(2)]];
    float4 color [[attribute(3)]];
};

struct VertexOut {
    float4 position [[position]];
    float3 worldPos;
    float3 normal;
    float2 texCoord;
    float4 color;
};

struct FrameUniforms {
    float4x4 viewProjection;
    float4 cameraPosition;
    float time;
};

struct ObjectUniforms {
    float4x4 model;
    float4x4 normalMatrix;
    float4 colorTint;
};

vertex VertexOut vertex_main(
    VertexIn in [[stage_in]],
    constant FrameUniforms& frame [[buffer(0)]],
    constant ObjectUniforms& object [[buffer(1)]]
) {
    VertexOut out;
    float4 worldPos = object.model * float4(in.position, 1.0);
    out.position = frame.viewProjection * worldPos;
    out.worldPos = worldPos.xyz;
    out.normal = (object.normalMatrix * float4(in.normal, 0.0)).xyz;
    out.texCoord = in.texCoord;
    out.color = in.color * object.colorTint;
    return out;
}
"""

const SHADER_STANDARD_FRAGMENT: string = """
#include <metal_stdlib>
using namespace metal;

struct VertexOut {
    float4 position [[position]];
    float3 worldPos;
    float3 normal;
    float2 texCoord;
    float4 color;
};

struct LightUniforms {
    float4 sunDirection;
    float4 sunColor;
    float4 ambientColor;
};

fragment float4 fragment_main(
    VertexOut in [[stage_in]],
    constant LightUniforms& lights [[buffer(0)]],
    texture2d<float> diffuseTexture [[texture(0)]],
    sampler textureSampler [[sampler(0)]]
) {
    float4 texColor = diffuseTexture.sample(textureSampler, in.texCoord);
    float3 N = normalize(in.normal);
    float3 L = normalize(-lights.sunDirection.xyz);
    float NdotL = max(dot(N, L), 0.0);
    float3 diffuse = lights.sunColor.rgb * NdotL;
    float3 ambient = lights.ambientColor.rgb;
    float3 finalColor = texColor.rgb * in.color.rgb * (diffuse + ambient);
    return float4(finalColor, texColor.a * in.color.a);
}
"""

const SHADER_TERRAIN_VERTEX: string = """
// Terrain vertex shader with texture blending
"""

const SHADER_TERRAIN_FRAGMENT: string = """
// Terrain fragment shader with multi-texture blending
"""

const SHADER_PARTICLE_VERTEX: string = """
// Billboard particle vertex shader
"""

const SHADER_PARTICLE_FRAGMENT: string = """
// Particle fragment shader with alpha
"""

const SHADER_SKINNED_VERTEX: string = """
// Skeletal animation vertex shader
"""

// ============================================================================
// MATH TYPES (if not imported from elsewhere)
// ============================================================================

struct Vec2 {
    x: f64,
    y: f64,

    fn init(x: f64, y: f64): Vec2 {
        let v = Vec2 { x: x, y: y }
        return v
    }
}

struct Vec3 {
    x: f64,
    y: f64,
    z: f64,

    fn init(x: f64, y: f64, z: f64): Vec3 {
        let v = Vec3 { x: x, y: y, z: z }
        return v
    }
}

struct Vec4 {
    x: f64,
    y: f64,
    z: f64,
    w: f64,

    fn init(x: f64, y: f64, z: f64, w: f64): Vec4 {
        let v = Vec4 { x: x, y: y, z: z, w: w }
        return v
    }
}

struct Mat4 {
    m: Vec<f64>,  // 16 elements, column-major

    fn identity(): Mat4 {
        let mat = Mat4 { m: Vec::init() }
        for i in 0..16 {
            if i == 0 or i == 5 or i == 10 or i == 15 {
                mat.m.add(1.0)
            } else {
                mat.m.add(0.0)
            }
        }
        return mat
    }

    fn multiply(a: Mat4, b: Mat4): Mat4 {
        let result = Mat4 { m: Vec::init() }
        for i in 0..16 {
            result.m.add(0.0)
        }

        for col in 0..4 {
            for row in 0..4 {
                let sum = 0.0
                for k in 0..4 {
                    sum = sum + a.m.get(row + k * 4) * b.m.get(k + col * 4)
                }
                result.m.set(row + col * 4, sum)
            }
        }

        return result
    }
}

fn max(a: i32, b: i32): i32 {
    if a > b { return a }
    return b
}

fn floor(x: f64): i32 {
    return x  // Simplified
}

fn log2(x: f64): f64 {
    return x  // Simplified
}

// ============================================================================
// TESTS
// ============================================================================

fn test_vertex_stride(): bool {
    let stride = Vertex3D::stride()
    assert(stride == 80, "Vertex3D stride is 80 bytes")
    return true
}

fn test_blend_state(): bool {
    let disabled = BlendState::disabled()
    assert(disabled.enabled == false, "Disabled blend state")

    let alpha = BlendState::alpha_blend()
    assert(alpha.enabled == true, "Alpha blend enabled")
    assert(alpha.src_factor == BlendFactor::SrcAlpha, "Alpha blend src factor")

    return true
}

fn test_depth_state(): bool {
    let default = DepthState::default()
    assert(default.test_enabled == true, "Depth test enabled by default")
    assert(default.write_enabled == true, "Depth write enabled by default")

    let read_only = DepthState::read_only()
    assert(read_only.write_enabled == false, "Read-only depth state")

    return true
}

fn test_renderer_creation(): bool {
    let renderer = MetalRenderer::init()
    assert(renderer.next_buffer_id == 1, "Initial buffer ID")
    assert(renderer.draw_call_count == 0, "Initial draw call count")
    return true
}

fn test_buffer_creation(): bool {
    let renderer = MetalRenderer::init()

    let vb_id = renderer.create_vertex_buffer(100, 80, BufferUsage::Static)
    assert(vb_id == 1, "First buffer ID is 1")

    let ib_id = renderer.create_index_buffer(300, IndexType::UInt16)
    assert(ib_id == 2, "Second buffer ID is 2")

    return true
}

fn test_texture_creation(): bool {
    let renderer = MetalRenderer::init()

    let tex_id = renderer.create_texture(512, 512, TextureFormat::RGBA8)
    assert(tex_id == 1, "Texture ID is 1")

    let texture = renderer.textures.get(tex_id)
    assert(texture != null, "Texture exists")
    assert(texture.width == 512, "Texture width")
    assert(texture.height == 512, "Texture height")

    return true
}

fn test_draw_call(): bool {
    let call = DrawCall::init(1, 1)
    assert(call.pipeline == 1, "Pipeline ID set")
    assert(call.vertex_buffer == 1, "Vertex buffer ID set")
    assert(call.instance_count == 1, "Default instance count")

    call.set_indexed(2, 300)
    assert(call.index_buffer == 2, "Index buffer set")
    assert(call.index_count == 300, "Index count set")

    return true
}

fn test_frame_uniforms(): bool {
    let uniforms = FrameUniforms::init()
    assert(uniforms.time == 0.0, "Initial time")
    assert(uniforms.delta_time == 0.016, "Default delta time")
    return true
}

fn test_skinning_uniforms(): bool {
    let skinning = SkinningUniforms::init(64)
    assert(skinning.max_bones == 64, "Max bones set")
    assert(skinning.bone_matrices.len() == 64, "Bone matrices initialized")
    return true
}

fn run_all_tests(): bool {
    assert(test_vertex_stride(), "Test 1: Vertex stride")
    assert(test_blend_state(), "Test 2: Blend state")
    assert(test_depth_state(), "Test 3: Depth state")
    assert(test_renderer_creation(), "Test 4: Renderer creation")
    assert(test_buffer_creation(), "Test 5: Buffer creation")
    assert(test_texture_creation(), "Test 6: Texture creation")
    assert(test_draw_call(), "Test 7: Draw call")
    assert(test_frame_uniforms(), "Test 8: Frame uniforms")
    assert(test_skinning_uniforms(), "Test 9: Skinning uniforms")
    return true
}
