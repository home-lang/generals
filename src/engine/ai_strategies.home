// AI Personalities and Strategies
// Implements distinct AI playstyles and strategic decision-making

enum AIPersonality {
    AGGRESSIVE,     // Rush and constant pressure
    DEFENSIVE,      // Turtle and tech up
    BALANCED,       // Mixed approach
    RUSHER,         // Early game all-in
    TURTLE,         // Heavy defense focus
    ECONOMIC,       // Economy focus
    SPECIAL_POWERS, // Focuses on general powers
}

enum AIStrategy {
    EARLY_RUSH,
    TECH_RUSH,
    MASS_PRODUCTION,
    AIR_SUPERIORITY,
    ARTILLERY_SPAM,
    INFANTRY_SWARM,
    TANK_PUSH,
    DEFENSIVE_HOLD,
    GUERRILLA,
    SUPERWEAPON,
}

enum AIThreatLevel {
    NONE,
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL,
}

enum AIDecision {
    BUILD_ECONOMY,
    BUILD_ARMY,
    ATTACK,
    DEFEND,
    EXPAND,
    TECH_UP,
    USE_POWER,
    RETREAT,
}

struct AIPersonalityProfile {
    personality: AIPersonality,
    aggression: f64,         // 0.0 - 1.0
    economy_focus: f64,      // 0.0 - 1.0
    defense_focus: f64,      // 0.0 - 1.0
    tech_focus: f64,         // 0.0 - 1.0
    expand_desire: f64,      // 0.0 - 1.0
    power_usage: f64,        // 0.0 - 1.0

    // Build priorities
    infantry_weight: f64,
    vehicle_weight: f64,
    aircraft_weight: f64,
    defense_weight: f64,

    // Attack thresholds
    min_army_size: i32,
    attack_threshold: f64,
    retreat_threshold: f64,

    fn init(personality: AIPersonality): AIPersonalityProfile {
        let profile = AIPersonalityProfile {
            personality: personality,
            aggression: 0.5,
            economy_focus: 0.5,
            defense_focus: 0.5,
            tech_focus: 0.5,
            expand_desire: 0.5,
            power_usage: 0.5,
            infantry_weight: 1.0,
            vehicle_weight: 1.0,
            aircraft_weight: 1.0,
            defense_weight: 1.0,
            min_army_size: 10,
            attack_threshold: 0.6,
            retreat_threshold: 0.3,
        }
        return profile
    }
}

fn create_aggressive_profile(): AIPersonalityProfile {
    let profile = AIPersonalityProfile::init(AIPersonality::AGGRESSIVE)
    profile.aggression = 0.9
    profile.economy_focus = 0.3
    profile.defense_focus = 0.2
    profile.tech_focus = 0.3
    profile.expand_desire = 0.7

    profile.vehicle_weight = 1.5
    profile.aircraft_weight = 1.2
    profile.defense_weight = 0.5

    profile.min_army_size = 5
    profile.attack_threshold = 0.4
    profile.retreat_threshold = 0.2

    return profile
}

fn create_defensive_profile(): AIPersonalityProfile {
    let profile = AIPersonalityProfile::init(AIPersonality::DEFENSIVE)
    profile.aggression = 0.2
    profile.economy_focus = 0.7
    profile.defense_focus = 0.9
    profile.tech_focus = 0.8
    profile.expand_desire = 0.3

    profile.infantry_weight = 0.8
    profile.vehicle_weight = 1.0
    profile.defense_weight = 2.0

    profile.min_army_size = 20
    profile.attack_threshold = 0.8
    profile.retreat_threshold = 0.5

    return profile
}

fn create_balanced_profile(): AIPersonalityProfile {
    let profile = AIPersonalityProfile::init(AIPersonality::BALANCED)
    profile.aggression = 0.5
    profile.economy_focus = 0.5
    profile.defense_focus = 0.5
    profile.tech_focus = 0.5
    profile.expand_desire = 0.5

    profile.min_army_size = 10
    profile.attack_threshold = 0.6
    profile.retreat_threshold = 0.3

    return profile
}

fn create_rusher_profile(): AIPersonalityProfile {
    let profile = AIPersonalityProfile::init(AIPersonality::RUSHER)
    profile.aggression = 1.0
    profile.economy_focus = 0.2
    profile.defense_focus = 0.1
    profile.tech_focus = 0.1
    profile.expand_desire = 0.4

    profile.infantry_weight = 2.0
    profile.vehicle_weight = 1.5
    profile.aircraft_weight = 0.5
    profile.defense_weight = 0.3

    profile.min_army_size = 3
    profile.attack_threshold = 0.2
    profile.retreat_threshold = 0.1

    return profile
}

fn create_turtle_profile(): AIPersonalityProfile {
    let profile = AIPersonalityProfile::init(AIPersonality::TURTLE)
    profile.aggression = 0.1
    profile.economy_focus = 0.9
    profile.defense_focus = 1.0
    profile.tech_focus = 0.9
    profile.expand_desire = 0.2
    profile.power_usage = 0.8

    profile.infantry_weight = 0.6
    profile.vehicle_weight = 0.8
    profile.aircraft_weight = 0.7
    profile.defense_weight = 3.0

    profile.min_army_size = 30
    profile.attack_threshold = 0.9
    profile.retreat_threshold = 0.6

    return profile
}

fn create_economic_profile(): AIPersonalityProfile {
    let profile = AIPersonalityProfile::init(AIPersonality::ECONOMIC)
    profile.aggression = 0.4
    profile.economy_focus = 1.0
    profile.defense_focus = 0.4
    profile.tech_focus = 0.6
    profile.expand_desire = 0.8

    profile.vehicle_weight = 1.2
    profile.aircraft_weight = 1.3
    profile.defense_weight = 0.8

    profile.min_army_size = 15
    profile.attack_threshold = 0.7
    profile.retreat_threshold = 0.4

    return profile
}

fn create_special_powers_profile(): AIPersonalityProfile {
    let profile = AIPersonalityProfile::init(AIPersonality::SPECIAL_POWERS)
    profile.aggression = 0.6
    profile.economy_focus = 0.7
    profile.defense_focus = 0.5
    profile.tech_focus = 0.4
    profile.expand_desire = 0.5
    profile.power_usage = 1.0

    profile.min_army_size = 8
    profile.attack_threshold = 0.5
    profile.retreat_threshold = 0.3

    return profile
}

struct StrategyPlan {
    strategy: AIStrategy,
    priority: f64,
    is_active: bool,
    progress: f64,
    required_buildings: Vec<string>,
    required_units: Vec<string>,
    target_unit_count: i32,

    fn init(strategy: AIStrategy): StrategyPlan {
        let plan = StrategyPlan {
            strategy: strategy,
            priority: 1.0,
            is_active: false,
            progress: 0.0,
            required_buildings: Vec::init(),
            required_units: Vec::init(),
            target_unit_count: 20,
        }
        return plan
    }
}

fn create_early_rush_plan(): StrategyPlan {
    let plan = StrategyPlan::init(AIStrategy::EARLY_RUSH)
    plan.required_buildings.add("barracks")
    plan.required_units.add("ranger")
    plan.required_units.add("humvee")
    plan.target_unit_count = 8
    plan.priority = 0.9
    return plan
}

fn create_tank_push_plan(): StrategyPlan {
    let plan = StrategyPlan::init(AIStrategy::TANK_PUSH)
    plan.required_buildings.add("war_factory")
    plan.required_buildings.add("strategy_center")
    plan.required_units.add("crusader")
    plan.required_units.add("paladin")
    plan.target_unit_count = 15
    plan.priority = 0.8
    return plan
}

fn create_air_superiority_plan(): StrategyPlan {
    let plan = StrategyPlan::init(AIStrategy::AIR_SUPERIORITY)
    plan.required_buildings.add("airfield")
    plan.required_units.add("raptor")
    plan.required_units.add("comanche")
    plan.target_unit_count = 12
    plan.priority = 0.7
    return plan
}

fn create_superweapon_plan(): StrategyPlan {
    let plan = StrategyPlan::init(AIStrategy::SUPERWEAPON)
    plan.required_buildings.add("particle_cannon")
    plan.target_unit_count = 0  // Defensive holding
    plan.priority = 0.6
    return plan
}

fn create_artillery_spam_plan(): StrategyPlan {
    let plan = StrategyPlan::init(AIStrategy::ARTILLERY_SPAM)
    plan.required_buildings.add("war_factory")
    plan.required_units.add("tomahawk")
    plan.required_units.add("crusader")
    plan.target_unit_count = 10
    plan.priority = 0.7
    return plan
}

fn create_infantry_swarm_plan(): StrategyPlan {
    let plan = StrategyPlan::init(AIStrategy::INFANTRY_SWARM)
    plan.required_buildings.add("barracks")
    plan.required_units.add("tank_hunter")
    plan.required_units.add("red_guard")
    plan.target_unit_count = 30
    plan.priority = 0.6
    return plan
}

struct ThreatAssessment {
    enemy_player_id: i32,
    threat_level: AIThreatLevel,
    army_strength: f64,
    base_strength: f64,
    tech_level: f64,
    distance: f64,
    is_attacking: bool,

    fn init(enemy_id: i32): ThreatAssessment {
        let assessment = ThreatAssessment {
            enemy_player_id: enemy_id,
            threat_level: AIThreatLevel::NONE,
            army_strength: 0.0,
            base_strength: 0.0,
            tech_level: 0.0,
            distance: 1000.0,
            is_attacking: false,
        }
        return assessment
    }

    fn calculate_threat(&self): AIThreatLevel {
        let total_threat = self.army_strength + self.base_strength + self.tech_level

        if self.is_attacking {
            total_threat = total_threat * 1.5
        }

        // Distance penalty
        let distance_factor = 1000.0 / (self.distance + 1.0)
        total_threat = total_threat * distance_factor

        if total_threat > 800.0 {
            return AIThreatLevel::CRITICAL
        } else if total_threat > 500.0 {
            return AIThreatLevel::HIGH
        } else if total_threat > 200.0 {
            return AIThreatLevel::MEDIUM
        } else if total_threat > 50.0 {
            return AIThreatLevel::LOW
        }

        return AIThreatLevel::NONE
    }
}

struct AIState {
    player_id: i32,
    profile: AIPersonalityProfile,
    current_strategy: StrategyPlan,
    active_plans: Vec<StrategyPlan>,

    // Resources
    current_money: i32,
    income_rate: f64,
    supply_used: i32,
    supply_cap: i32,

    // Military
    army_size: i32,
    army_strength: f64,
    defense_strength: f64,

    // Threats
    threats: Vec<ThreatAssessment>,
    highest_threat: AIThreatLevel,

    // Decisions
    current_decision: AIDecision,
    decision_timer: f64,

    fn init(player_id: i32, personality: AIPersonality): AIState {
        let profile = create_balanced_profile()

        if personality == AIPersonality::AGGRESSIVE {
            profile = create_aggressive_profile()
        } else if personality == AIPersonality::DEFENSIVE {
            profile = create_defensive_profile()
        } else if personality == AIPersonality::RUSHER {
            profile = create_rusher_profile()
        } else if personality == AIPersonality::TURTLE {
            profile = create_turtle_profile()
        } else if personality == AIPersonality::ECONOMIC {
            profile = create_economic_profile()
        } else if personality == AIPersonality::SPECIAL_POWERS {
            profile = create_special_powers_profile()
        }

        let state = AIState {
            player_id: player_id,
            profile: profile,
            current_strategy: create_tank_push_plan(),
            active_plans: Vec::init(),
            current_money: 0,
            income_rate: 0.0,
            supply_used: 0,
            supply_cap: 0,
            army_size: 0,
            army_strength: 0.0,
            defense_strength: 0.0,
            threats: Vec::init(),
            highest_threat: AIThreatLevel::NONE,
            current_decision: AIDecision::BUILD_ECONOMY,
            decision_timer: 0.0,
        }

        return state
    }

    fn should_attack(&self): bool {
        // Check army size threshold
        if self.army_size < self.profile.min_army_size {
            return false
        }

        // Calculate strength ratio
        let total_enemy_strength = 0.0
        for i in 0..self.threats.len() {
            let threat = self.threats.get(i)
            total_enemy_strength = total_enemy_strength + threat.army_strength
        }

        if total_enemy_strength == 0.0 {
            return true  // No threats, safe to attack
        }

        let strength_ratio = self.army_strength / total_enemy_strength

        return strength_ratio >= self.profile.attack_threshold
    }

    fn should_retreat(&self): bool {
        let total_enemy_strength = 0.0
        for i in 0..self.threats.len() {
            let threat = self.threats.get(i)
            if threat.is_attacking {
                total_enemy_strength = total_enemy_strength + threat.army_strength
            }
        }

        if total_enemy_strength == 0.0 {
            return false
        }

        let strength_ratio = self.army_strength / total_enemy_strength

        return strength_ratio < self.profile.retreat_threshold
    }

    fn should_use_power(&self): bool {
        // Higher power usage personality = more frequent use
        if self.profile.power_usage < 0.5 {
            return false
        }

        // Only use powers when attacking or defending
        if self.current_decision == AIDecision::ATTACK {
            return true
        }

        if self.highest_threat == AIThreatLevel::HIGH || self.highest_threat == AIThreatLevel::CRITICAL {
            return true
        }

        return false
    }

    fn get_build_priority(&self): AIDecision {
        // Economic focus check
        if self.income_rate < 300.0 && self.profile.economy_focus > 0.6 {
            return AIDecision::BUILD_ECONOMY
        }

        // Defense check under threat
        if self.highest_threat == AIThreatLevel::HIGH || self.highest_threat == AIThreatLevel::CRITICAL {
            if self.defense_strength < 500.0 {
                return AIDecision::DEFEND
            }
        }

        // Tech up if turtle/defensive
        if self.profile.tech_focus > 0.7 && self.current_money > 5000 {
            return AIDecision::TECH_UP
        }

        // Default to building army
        return AIDecision::BUILD_ARMY
    }
}

struct AIController {
    ai_states: Vec<AIState>,
    update_interval: f64,
    time_since_update: f64,

    fn init(): AIController {
        let controller = AIController {
            ai_states: Vec::init(),
            update_interval: 2.0,  // Update every 2 seconds
            time_since_update: 0.0,
        }
        return controller
    }

    fn add_ai_player(&self, player_id: i32, personality: AIPersonality) {
        let state = AIState::init(player_id, personality)
        self.ai_states.add(state)
    }

    fn get_ai_state(&self, player_id: i32): AIState? {
        for i in 0..self.ai_states.len() {
            let state = self.ai_states.get(i)
            if state.player_id == player_id {
                return state
            }
        }
        return null
    }

    fn update(&self, dt: f64) {
        self.time_since_update = self.time_since_update + dt

        if self.time_since_update < self.update_interval {
            return
        }

        self.time_since_update = 0.0

        // Update all AI players
        for i in 0..self.ai_states.len() {
            let state = self.ai_states.get(i)
            self.update_ai_decision(state)
        }
    }

    fn update_ai_decision(&self, state: AIState) {
        // Update threat assessments
        state.highest_threat = AIThreatLevel::NONE
        for i in 0..state.threats.len() {
            let threat = state.threats.get(i)
            let level = threat.calculate_threat()
            threat.threat_level = level

            if level > state.highest_threat {
                state.highest_threat = level
            }
        }

        // Check retreat condition first
        if state.should_retreat() {
            state.current_decision = AIDecision::RETREAT
            return
        }

        // Check attack condition
        if state.should_attack() {
            state.current_decision = AIDecision::ATTACK

            if state.should_use_power() {
                state.current_decision = AIDecision::USE_POWER
            }
            return
        }

        // Get build priority
        state.current_decision = state.get_build_priority()
    }

    fn select_strategy(&self, state: AIState, faction: string): StrategyPlan {
        // Early game rush for aggressive personalities
        if state.profile.personality == AIPersonality::RUSHER {
            return create_early_rush_plan()
        }

        // Turtle goes for superweapon
        if state.profile.personality == AIPersonality::TURTLE {
            return create_superweapon_plan()
        }

        // Air superiority for balanced/economic
        if state.profile.aircraft_weight > 1.2 {
            return create_air_superiority_plan()
        }

        // Default to tank push
        return create_tank_push_plan()
    }
}

// Tests
fn test_personality_profiles(): bool {
    let aggressive = create_aggressive_profile()
    assert(aggressive.aggression == 0.9, "Aggressive has high aggression")
    assert(aggressive.defense_focus == 0.2, "Aggressive has low defense")

    let defensive = create_defensive_profile()
    assert(defensive.defense_focus == 0.9, "Defensive has high defense")
    assert(defensive.aggression == 0.2, "Defensive has low aggression")

    let rusher = create_rusher_profile()
    assert(rusher.min_army_size == 3, "Rusher attacks early")

    return true
}

fn test_threat_assessment(): bool {
    let threat = ThreatAssessment::init(2)
    threat.army_strength = 500.0
    threat.base_strength = 300.0
    threat.tech_level = 100.0
    threat.distance = 200.0

    let level = threat.calculate_threat()
    assert(level != AIThreatLevel::NONE, "Has threat")

    threat.is_attacking = true
    let higher_level = threat.calculate_threat()
    assert(higher_level > level, "Attacking increases threat")

    return true
}

fn test_ai_state(): bool {
    let state = AIState::init(1, AIPersonality::BALANCED)
    assert(state.player_id == 1, "Player ID set")
    assert(state.profile.personality == AIPersonality::BALANCED, "Balanced profile")

    return true
}

fn test_attack_decision(): bool {
    let state = AIState::init(1, AIPersonality::AGGRESSIVE)
    state.army_size = 15
    state.army_strength = 1000.0

    // No threats, should attack
    assert(state.should_attack(), "Should attack with no threats")

    // Add threat
    let threat = ThreatAssessment::init(2)
    threat.army_strength = 2000.0
    state.threats.add(threat)

    // Now shouldn't attack (outnumbered)
    assert(!state.should_attack(), "Should not attack when outnumbered")

    return true
}

fn test_retreat_decision(): bool {
    let state = AIState::init(1, AIPersonality::DEFENSIVE)
    state.army_strength = 200.0

    let threat = ThreatAssessment::init(2)
    threat.army_strength = 1000.0
    threat.is_attacking = true
    state.threats.add(threat)

    assert(state.should_retreat(), "Should retreat when overwhelmed")

    return true
}

fn test_strategy_plans(): bool {
    let rush = create_early_rush_plan()
    assert(rush.strategy == AIStrategy::EARLY_RUSH, "Rush strategy")
    assert(rush.target_unit_count == 8, "Rush unit count")

    let tank = create_tank_push_plan()
    assert(tank.required_buildings.len() == 2, "Tank push buildings")

    let air = create_air_superiority_plan()
    assert(air.required_buildings.len() == 1, "Air superiority buildings")

    return true
}

fn test_ai_controller(): bool {
    let controller = AIController::init()

    controller.add_ai_player(1, AIPersonality::AGGRESSIVE)
    controller.add_ai_player(2, AIPersonality::DEFENSIVE)

    let state1 = controller.get_ai_state(1)
    assert(state1 != null, "Found AI state 1")
    assert(state1.profile.personality == AIPersonality::AGGRESSIVE, "Correct personality")

    let state2 = controller.get_ai_state(2)
    assert(state2 != null, "Found AI state 2")
    assert(state2.profile.personality == AIPersonality::DEFENSIVE, "Defensive personality")

    return true
}

fn test_build_priority(): bool {
    let state = AIState::init(1, AIPersonality::ECONOMIC)
    state.income_rate = 100.0  // Low income

    let priority = state.get_build_priority()
    assert(priority == AIDecision::BUILD_ECONOMY, "Should build economy")

    state.income_rate = 500.0
    let priority2 = state.get_build_priority()
    assert(priority2 == AIDecision::BUILD_ARMY, "Should build army")

    return true
}

fn test_power_usage(): bool {
    let state = AIState::init(1, AIPersonality::SPECIAL_POWERS)
    state.current_decision = AIDecision::ATTACK

    assert(state.should_use_power(), "Should use power when attacking")

    let defensive_state = AIState::init(2, AIPersonality::DEFENSIVE)
    defensive_state.current_decision = AIDecision::ATTACK

    assert(!defensive_state.should_use_power(), "Defensive doesn't use powers often")

    return true
}

fn test_decision_updates(): bool {
    let controller = AIController::init()
    controller.add_ai_player(1, AIPersonality::BALANCED)

    let state = controller.get_ai_state(1)
    state.army_size = 20
    state.army_strength = 1000.0

    controller.update_ai_decision(state)

    // With good army, should attack
    assert(state.current_decision == AIDecision::ATTACK, "Should decide to attack")

    return true
}

fn run_all_tests(): bool {
    assert(test_personality_profiles(), "Test 1: Personality profiles")
    assert(test_threat_assessment(), "Test 2: Threat assessment")
    assert(test_ai_state(), "Test 3: AI state")
    assert(test_attack_decision(), "Test 4: Attack decision")
    assert(test_retreat_decision(), "Test 5: Retreat decision")
    assert(test_strategy_plans(), "Test 6: Strategy plans")
    assert(test_ai_controller(), "Test 7: AI controller")
    assert(test_build_priority(), "Test 8: Build priority")
    assert(test_power_usage(), "Test 9: Power usage")
    assert(test_decision_updates(), "Test 10: Decision updates")
    return true
}
