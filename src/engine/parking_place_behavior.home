// Parking Place Behavior - Aircraft Parking and Docking
// Based on Thyme engine ParkingPlaceBehavior
// Handles landing pad management, aircraft queueing, repair/rearm

from behavior_module import BehaviorModule, create_behavior_module, ModuleType

// ============================================================================
// Parking Configuration
// ============================================================================

enum ParkingSpotState {
    Empty,          // No aircraft
    Reserved,       // Reserved for incoming aircraft
    Occupied,       // Aircraft parked
    Departing,      // Aircraft leaving
}

enum AircraftState {
    Approaching,    // Flying to pad
    Landing,        // Landing sequence
    Parked,         // On the pad
    Rearming,       // Being rearmed
    Repairing,      // Being repaired
    Refueling,      // Being refueled
    TakingOff,      // Takeoff sequence
    Departing,      // Left the pad
}

struct ParkingSpot {
    spot_id: i32,
    state: ParkingSpotState,
    aircraft_id: i32,
    position_x: f64,
    position_y: f64,
    position_z: f64,
    heading: f64,             // Direction aircraft faces when parked
    approach_path_id: i32,      // Index into approach paths
    departure_path_id: i32,     // Index into departure paths
    is_vtol_only: bool,         // Only VTOL aircraft can use
    spot_size: i32,             // 1=small, 2=medium, 3=large
}

fn create_parking_spot(id: i32): ParkingSpot {
    return ParkingSpot {
        spot_id: id,
        state: ParkingSpotState::Empty,
        aircraft_id: 0,
        position_x: 0.0,
        position_y: 0.0,
        position_z: 0.0,
        heading: 0.0,
        approach_path_id: 0,
        departure_path_id: 0,
        is_vtol_only: false,
        spot_size: 1,
    }
}

struct AircraftInfo {
    aircraft_id: i32,
    state: AircraftState,
    assigned_spot: i32,
    ammo_current: i32,
    ammo_max: i32,
    health_current: f64,
    health_max: f64,
    fuel_current: f64,
    fuel_max: f64,
    is_vtol: bool,
    size_class: i32,
    rearm_time_remaining: f64,
    repair_time_remaining: f64,
    refuel_time_remaining: f64,
}

fn create_aircraft_info(id: i32): AircraftInfo {
    return AircraftInfo {
        aircraft_id: id,
        state: AircraftState::Approaching,
        assigned_spot: -1,
        ammo_current: 0,
        ammo_max: 4,
        health_current: 100.0,
        health_max: 100.0,
        fuel_current: 100.0,
        fuel_max: 100.0,
        is_vtol: false,
        size_class: 1,
        rearm_time_remaining: 0.0,
        repair_time_remaining: 0.0,
        refuel_time_remaining: 0.0,
    }
}

struct ParkingConfig {
    num_spots: i32,
    heal_rate: f64,           // Health per second
    rearm_rate: f64,          // Ammo per second
    refuel_rate: f64,         // Fuel per second
    approach_height: f64,     // Height for approach
    landing_speed: f64,       // Speed during landing
    takeoff_speed: f64,       // Speed during takeoff
    queue_max_size: i32,        // Max aircraft waiting
    auto_repair: bool,          // Automatically repair
    auto_rearm: bool,           // Automatically rearm
    auto_refuel: bool,          // Automatically refuel
    allows_vtol: bool,          // Can VTOL aircraft use
    allows_runway: bool,        // Can runway aircraft use
    fx_landing: string,
    fx_takeoff: string,
}

fn default_parking_config(): ParkingConfig {
    return ParkingConfig {
        num_spots: 4,
        heal_rate: 10.0,
        rearm_rate: 1.0,
        refuel_rate: 20.0,
        approach_height: 100.0,
        landing_speed: 50.0,
        takeoff_speed: 75.0,
        queue_max_size: 8,
        auto_repair: true,
        auto_rearm: true,
        auto_refuel: true,
        allows_vtol: true,
        allows_runway: true,
        fx_landing: "FX_AircraftLand",
        fx_takeoff: "FX_AircraftTakeoff",
    }
}

// ============================================================================
// Parking Place Behavior
// ============================================================================

struct ParkingPlaceBehavior {
    base: BehaviorModule,
    config: ParkingConfig,

    // Spots
    spots: Vec<ParkingSpot>,

    // Aircraft tracking
    aircraft: HashMap<Int, AircraftInfo>,
    queue: Vec<i32>,     // Aircraft waiting for spot

    // Statistics
    total_landings: i32,
    total_takeoffs: i32,
    total_repairs: i32,
    total_rearms: i32,
}

fn create_parking_place_behavior(tag: string): ParkingPlaceBehavior {
    let config = default_parking_config()
    let spots = Vec<ParkingSpot>{}

    // Create parking spots in a row
    for i in 0..config.num_spots {
        let spot = create_parking_spot(i)
        spot.position_x = i as Float * 30.0
        spot.position_y = 0.0
        spot.heading = 0.0
        spot.approach_path_id = i
        spot.departure_path_id = i
        spots.add(spot)
    }

    return ParkingPlaceBehavior {
        base: create_behavior_module(tag, ModuleType::Behavior),
        config: config,
        spots: spots,
        aircraft: HashMap<Int, AircraftInfo>{},
        queue: Vec<i32>{},
        total_landings: 0,
        total_takeoffs: 0,
        total_repairs: 0,
        total_rearms: 0,
    }
}

// ============================================================================
// Spot Management
// ============================================================================

/// Find available spot for aircraft
fn find_available_spot(parking: ParkingPlaceBehavior, is_vtol: bool, size_class: i32): i32 {
    for i in 0..parking.spots.len() {
        let spot = parking.spots.get(i)
        if spot.state == ParkingSpotState::Empty {
            // Check VTOL compatibility
            if spot.is_vtol_only && !is_vtol {
                continue
            }
            if !parking.config.allows_vtol && is_vtol {
                continue
            }
            if !parking.config.allows_runway && !is_vtol {
                continue
            }

            // Check size
            if spot.spot_size < size_class {
                continue
            }

            return i
        }
    }
    return -1
}

/// Reserve a spot for incoming aircraft
fn reserve_spot(parking: ParkingPlaceBehavior, spot_idx: i32, aircraft_id: i32): bool {
    if spot_idx < 0 || spot_idx >= parking.spots.len() {
        return false
    }

    let spot = parking.spots.get(spot_idx)
    if spot.state != ParkingSpotState::Empty {
        return false
    }

    spot.state = ParkingSpotState::Reserved
    spot.aircraft_id = aircraft_id
    return true
}

/// Occupy a spot (aircraft has landed)
fn occupy_spot(parking: ParkingPlaceBehavior, spot_idx: i32, aircraft_id: i32) {
    if spot_idx < 0 || spot_idx >= parking.spots.len() {
        return
    }

    let spot = parking.spots.get(spot_idx)
    spot.state = ParkingSpotState::Occupied
    spot.aircraft_id = aircraft_id

    // Update aircraft info
    if parking.aircraft.has(aircraft_id) {
        let info = parking.aircraft.get(aircraft_id)
        info.state = AircraftState::Parked
        info.assigned_spot = spot_idx
    }

    parking.total_landings = parking.total_landings + 1
}

/// Release a spot
fn release_spot(parking: ParkingPlaceBehavior, spot_idx: i32) {
    if spot_idx < 0 || spot_idx >= parking.spots.len() {
        return
    }

    let spot = parking.spots.get(spot_idx)
    let aircraft_id = spot.aircraft_id

    spot.state = ParkingSpotState::Empty
    spot.aircraft_id = 0

    // Check queue for next aircraft
    if parking.queue.len() > 0 {
        let next_id = parking.queue.get(0)
        parking.queue = remove_from_queue(parking.queue, next_id)
        if parking.aircraft.has(next_id) {
            let info = parking.aircraft.get(next_id)
            reserve_spot(parking, spot_idx, next_id)
        }
    }

    parking.total_takeoffs = parking.total_takeoffs + 1
}

// ============================================================================
// Aircraft Management
// ============================================================================

/// Request landing
fn request_landing(parking: ParkingPlaceBehavior, aircraft_id: i32, is_vtol: bool, size_class: i32): i32 {
    // Create aircraft info
    let info = create_aircraft_info(aircraft_id)
    info.is_vtol = is_vtol
    info.size_class = size_class
    parking.aircraft.set(aircraft_id, info)

    // Try to find available spot
    let spot_idx = find_available_spot(parking, is_vtol, size_class)

    if spot_idx >= 0 {
        // Reserve the spot
        reserve_spot(parking, spot_idx, aircraft_id)
        info.assigned_spot = spot_idx
        info.state = AircraftState::Approaching
        return spot_idx
    } else {
        // Add to queue
        if parking.queue.len() < parking.config.queue_max_size {
            parking.queue.add(aircraft_id)
            return -2  // Queued
        }
        return -1  // No space
    }
}

/// Complete landing
fn complete_landing(parking: ParkingPlaceBehavior, aircraft_id: i32) {
    if !parking.aircraft.has(aircraft_id) {
        return
    }

    let info = parking.aircraft.get(aircraft_id)
    occupy_spot(parking, info.assigned_spot, aircraft_id)
    info.state = AircraftState::Parked

    // Start auto-servicing
    if parking.config.auto_repair && info.health_current < info.health_max {
        info.state = AircraftState::Repairing
        info.repair_time_remaining = (info.health_max - info.health_current) / parking.config.heal_rate
    } else if parking.config.auto_rearm && info.ammo_current < info.ammo_max {
        info.state = AircraftState::Rearming
        info.rearm_time_remaining = (info.ammo_max - info.ammo_current) as Float / parking.config.rearm_rate
    } else if parking.config.auto_refuel && info.fuel_current < info.fuel_max {
        info.state = AircraftState::Refueling
        info.refuel_time_remaining = (info.fuel_max - info.fuel_current) / parking.config.refuel_rate
    }
}

/// Request takeoff
fn request_takeoff(parking: ParkingPlaceBehavior, aircraft_id: i32): bool {
    if !parking.aircraft.has(aircraft_id) {
        return false
    }

    let info = parking.aircraft.get(aircraft_id)
    if info.state != AircraftState::Parked {
        return false  // Still being serviced
    }

    info.state = AircraftState::TakingOff

    let spot_idx = info.assigned_spot
    if spot_idx >= 0 && spot_idx < parking.spots.len() {
        let spot = parking.spots.get(spot_idx)
        spot.state = ParkingSpotState::Departing
    }

    return true
}

/// Complete takeoff
fn complete_takeoff(parking: ParkingPlaceBehavior, aircraft_id: i32) {
    if !parking.aircraft.has(aircraft_id) {
        return
    }

    let info = parking.aircraft.get(aircraft_id)
    release_spot(parking, info.assigned_spot)
    info.state = AircraftState::Departing
    info.assigned_spot = -1

    // Remove aircraft tracking
    parking.aircraft.remove(aircraft_id)
}

/// Cancel landing/queue
fn cancel_landing(parking: ParkingPlaceBehavior, aircraft_id: i32) {
    // Remove from queue
    parking.queue = remove_from_queue(parking.queue, aircraft_id)

    // Release reserved spot
    if parking.aircraft.has(aircraft_id) {
        let info = parking.aircraft.get(aircraft_id)
        if info.assigned_spot >= 0 {
            let spot = parking.spots.get(info.assigned_spot)
            if spot.state == ParkingSpotState::Reserved {
                spot.state = ParkingSpotState::Empty
                spot.aircraft_id = 0
            }
        }
        parking.aircraft.remove(aircraft_id)
    }
}

// ============================================================================
// Servicing
// ============================================================================

/// Update aircraft servicing
fn update_servicing(parking: ParkingPlaceBehavior, delta: f64) {
    for aircraft_id in parking.aircraft.keys() {
        let info = parking.aircraft.get(aircraft_id)

        if info.state == AircraftState::Repairing {
            info.health_current = info.health_current + parking.config.heal_rate * delta
            info.repair_time_remaining = info.repair_time_remaining - delta

            if info.health_current >= info.health_max {
                info.health_current = info.health_max
                parking.total_repairs = parking.total_repairs + 1

                // Move to next service
                if parking.config.auto_rearm && info.ammo_current < info.ammo_max {
                    info.state = AircraftState::Rearming
                    info.rearm_time_remaining = (info.ammo_max - info.ammo_current) as Float / parking.config.rearm_rate
                } else if parking.config.auto_refuel && info.fuel_current < info.fuel_max {
                    info.state = AircraftState::Refueling
                } else {
                    info.state = AircraftState::Parked
                }
            }

        } else if info.state == AircraftState::Rearming {
            info.rearm_time_remaining = info.rearm_time_remaining - delta

            if info.rearm_time_remaining <= 0.0 {
                info.ammo_current = info.ammo_max
                parking.total_rearms = parking.total_rearms + 1

                // Move to next service
                if parking.config.auto_refuel && info.fuel_current < info.fuel_max {
                    info.state = AircraftState::Refueling
                    info.refuel_time_remaining = (info.fuel_max - info.fuel_current) / parking.config.refuel_rate
                } else {
                    info.state = AircraftState::Parked
                }
            }

        } else if info.state == AircraftState::Refueling {
            info.fuel_current = info.fuel_current + parking.config.refuel_rate * delta
            info.refuel_time_remaining = info.refuel_time_remaining - delta

            if info.fuel_current >= info.fuel_max {
                info.fuel_current = info.fuel_max
                info.state = AircraftState::Parked
            }
        }
    }
}

/// Update parking place
fn update_parking_place(parking: ParkingPlaceBehavior, delta: f64) {
    update_servicing(parking, delta)
}

// ============================================================================
// Queries
// ============================================================================

/// Get number of free spots
fn get_free_spot_count(parking: ParkingPlaceBehavior): i32 {
    let count = 0
    for i in 0..parking.spots.len() {
        let spot = parking.spots.get(i)
        if spot.state == ParkingSpotState::Empty {
            count = count + 1
        }
    }
    return count
}

/// Get queue length
fn get_queue_length(parking: ParkingPlaceBehavior): i32 {
    return parking.queue.len()
}

/// Get aircraft state
fn get_aircraft_state(parking: ParkingPlaceBehavior, aircraft_id: i32): AircraftState {
    if parking.aircraft.has(aircraft_id) {
        return parking.aircraft.get(aircraft_id).state
    }
    return AircraftState::Departing
}

/// Check if aircraft is ready
fn is_aircraft_ready(parking: ParkingPlaceBehavior, aircraft_id: i32): bool {
    if !parking.aircraft.has(aircraft_id) {
        return false
    }
    return parking.aircraft.get(aircraft_id).state == AircraftState::Parked
}

/// Get spot position
fn get_spot_position(parking: ParkingPlaceBehavior, spot_idx: i32): (Float, Float, Float) {
    if spot_idx < 0 || spot_idx >= parking.spots.len() {
        return (0.0, 0.0, 0.0)
    }
    let spot = parking.spots.get(spot_idx)
    return (spot.position_x, spot.position_y, spot.position_z)
}

/// Get approach position (above landing pad)
fn get_approach_position(parking: ParkingPlaceBehavior, spot_idx: i32): (Float, Float, Float) {
    if spot_idx < 0 || spot_idx >= parking.spots.len() {
        return (0.0, 0.0, 0.0)
    }
    let spot = parking.spots.get(spot_idx)
    return (spot.position_x, spot.position_y, spot.position_z + parking.config.approach_height)
}

// ============================================================================
// Helper Functions
// ============================================================================

fn remove_from_queue(queue: Vec<i32>, id: i32): Vec<i32> {
    let new_queue = Vec<i32>{}
    for item in queue {
        if item != id {
            new_queue.add(item)
        }
    }
    return new_queue
}

// ============================================================================
// Tests
// ============================================================================

fn test_parking_creation(): bool {
    let parking = create_parking_place_behavior("TestParking")

    assert(parking.spots.len() == 4, "Should have 4 spots")
    assert(get_free_spot_count(parking) == 4, "All spots should be free")

    return true
}

fn test_landing_request(): bool {
    let parking = create_parking_place_behavior("LandingTest")

    let spot = request_landing(parking, 100, true, 1)
    assert(spot >= 0, "Should get valid spot")
    assert(get_free_spot_count(parking) == 3, "Should have 3 free spots")

    let spot2 = request_landing(parking, 101, true, 1)
    assert(spot2 >= 0, "Should get second spot")
    assert(spot2 != spot, "Should be different spot")

    return true
}

fn test_full_landing_cycle(): bool {
    let parking = create_parking_place_behavior("CycleTest")

    // Request landing
    let spot = request_landing(parking, 100, true, 1)

    // Complete landing
    complete_landing(parking, 100)
    assert(get_aircraft_state(parking, 100) != AircraftState::Approaching, "Should not be approaching")

    // Wait for servicing (simulate)
    for i in 0..100 {
        update_servicing(parking, 0.1)
    }

    // Request takeoff
    if parking.aircraft.has(100) {
        let info = parking.aircraft.get(100)
        info.state = AircraftState::Parked
    }

    let can_takeoff = request_takeoff(parking, 100)
    assert(can_takeoff == true, "Should be able to takeoff")

    // Complete takeoff
    complete_takeoff(parking, 100)
    assert(get_free_spot_count(parking) == 4, "All spots should be free again")

    return true
}

fn test_queue(): bool {
    let parking = create_parking_place_behavior("QueueTest")

    // Fill all spots
    for i in 0..4 {
        request_landing(parking, 100 + i, true, 1)
    }
    assert(get_free_spot_count(parking) == 0, "All spots taken")

    // Request one more (should queue)
    let result = request_landing(parking, 200, true, 1)
    assert(result == -2, "Should be queued")
    assert(get_queue_length(parking) == 1, "Queue should have 1")

    return true
}

fn test_servicing(): bool {
    let parking = create_parking_place_behavior("ServicingTest")

    // Request and complete landing
    request_landing(parking, 100, true, 1)
    complete_landing(parking, 100)

    // Set aircraft as damaged
    if parking.aircraft.has(100) {
        let info = parking.aircraft.get(100)
        info.health_current = 50.0
        info.health_max = 100.0
        info.state = AircraftState::Repairing
        info.repair_time_remaining = 5.0
    }

    // Update servicing
    for i in 0..60 {
        update_servicing(parking, 0.1)
    }

    // Check health restored
    if parking.aircraft.has(100) {
        let info = parking.aircraft.get(100)
        assert(info.health_current == 100.0, "Should be fully repaired")
    }

    return true
}

fn run_all_tests(): bool {
    assert(test_parking_creation(), "Parking creation test failed")
    assert(test_landing_request(), "Landing request test failed")
    assert(test_full_landing_cycle(), "Full landing cycle test failed")
    assert(test_queue(), "Queue test failed")
    assert(test_servicing(), "Servicing test failed")
    return true
}
