// Dock Update - Docking Bay Management System
// Based on Thyme engine DockUpdate
// Handles dock slots, repair/rearm operations for aircraft and vehicles

from update_module import UpdateModule, create_update_module, UpdateType

// ============================================================================
// Dock Configuration
// ============================================================================

enum DockType {
    Airfield,           // Aircraft landing/takeoff
    WarFactory,         // Vehicle repair bay
    NavalYard,          // Ship dock
    ServiceDepot,       // General repair
    SupplyCenter,       // Supply truck loading
    Helipad,            // Helicopter pad
}

enum DockSlotState {
    Empty,              // No unit docked
    Reserved,           // Unit incoming
    Occupied,           // Unit present
    Servicing,          // Active repair/rearm
    Departing,          // Unit leaving
}

enum ServiceType {
    None,
    Repair,             // Health restoration
    Rearm,              // Ammo restoration
    Refuel,             // Fuel restoration
    Upgrade,            // Applying upgrade
    Loading,            // Loading cargo/supplies
    Unloading,          // Unloading cargo
}

struct DockSlot {
    slot_id: i32,
    state: DockSlotState,
    docked_unit_id: i32,

    // Position
    position_x: f64,
    position_y: f64,
    position_z: f64,
    heading: f64,

    // Service state
    current_service: ServiceType,
    service_progress: f64,        // 0.0 to 1.0
    service_time_remaining: f64,

    // Slot properties
    slot_size: i32,                 // Unit size this slot can accept
    accepts_aircraft: bool,
    accepts_vehicles: bool,
    accepts_infantry: bool,
}

fn create_dock_slot(id: i32): DockSlot {
    return DockSlot {
        slot_id: id,
        state: DockSlotState::Empty,
        docked_unit_id: 0,
        position_x: 0.0,
        position_y: 0.0,
        position_z: 0.0,
        heading: 0.0,
        current_service: ServiceType::None,
        service_progress: 0.0,
        service_time_remaining: 0.0,
        slot_size: 1,
        accepts_aircraft: true,
        accepts_vehicles: false,
        accepts_infantry: false,
    }
}

struct DockConfig {
    dock_type: DockType,
    name: string,

    // Slots
    num_slots: i32,
    slot_spacing: f64,

    // Repair
    repair_rate: f64,             // HP per second
    repair_cost_per_hp: f64,      // Cost per HP repaired

    // Rearm
    rearm_rate: f64,              // Ammo per second
    rearm_cost_per_ammo: f64,     // Cost per ammo

    // Refuel
    refuel_rate: f64,             // Fuel per second
    refuel_cost_per_unit: f64,    // Cost per fuel unit

    // Timing
    min_dock_time: f64,           // Minimum time at dock
    max_queue_size: i32,            // Max waiting units

    // Requirements
    requires_power: bool,

    // Service options
    auto_repair: bool,
    auto_rearm: bool,
    auto_refuel: bool,

    // Visual
    service_fx: string,
    complete_fx: string,
}

fn create_airfield_config(): DockConfig {
    return DockConfig {
        dock_type: DockType::Airfield,
        name: "Airfield",
        num_slots: 4,
        slot_spacing: 40.0,
        repair_rate: 20.0,
        repair_cost_per_hp: 0.1,
        rearm_rate: 2.0,
        rearm_cost_per_ammo: 50.0,
        refuel_rate: 30.0,
        refuel_cost_per_unit: 0.5,
        min_dock_time: 2.0,
        max_queue_size: 8,
        requires_power: true,
        auto_repair: true,
        auto_rearm: true,
        auto_refuel: true,
        service_fx: "FX_AirfieldService",
        complete_fx: "FX_AirfieldComplete",
    }
}

fn create_war_factory_config(): DockConfig {
    return DockConfig {
        dock_type: DockType::WarFactory,
        name: "War Factory",
        num_slots: 1,
        slot_spacing: 0.0,
        repair_rate: 50.0,
        repair_cost_per_hp: 0.15,
        rearm_rate: 0.0,
        rearm_cost_per_ammo: 0.0,
        refuel_rate: 0.0,
        refuel_cost_per_unit: 0.0,
        min_dock_time: 1.0,
        max_queue_size: 4,
        requires_power: true,
        auto_repair: true,
        auto_rearm: false,
        auto_refuel: false,
        service_fx: "FX_WarFactoryRepair",
        complete_fx: "FX_WarFactoryComplete",
    }
}

fn create_service_depot_config(): DockConfig {
    return DockConfig {
        dock_type: DockType::ServiceDepot,
        name: "Service Depot",
        num_slots: 2,
        slot_spacing: 30.0,
        repair_rate: 100.0,
        repair_cost_per_hp: 0.1,
        rearm_rate: 5.0,
        rearm_cost_per_ammo: 25.0,
        refuel_rate: 50.0,
        refuel_cost_per_unit: 0.25,
        min_dock_time: 0.5,
        max_queue_size: 6,
        requires_power: false,
        auto_repair: true,
        auto_rearm: true,
        auto_refuel: true,
        service_fx: "FX_ServiceDepotRepair",
        complete_fx: "FX_ServiceDepotComplete",
    }
}

fn create_supply_center_config(): DockConfig {
    return DockConfig {
        dock_type: DockType::SupplyCenter,
        name: "Supply Center",
        num_slots: 2,
        slot_spacing: 25.0,
        repair_rate: 0.0,
        repair_cost_per_hp: 0.0,
        rearm_rate: 0.0,
        rearm_cost_per_ammo: 0.0,
        refuel_rate: 0.0,
        refuel_cost_per_unit: 0.0,
        min_dock_time: 3.0,
        max_queue_size: 4,
        requires_power: false,
        auto_repair: false,
        auto_rearm: false,
        auto_refuel: false,
        service_fx: "FX_SupplyLoading",
        complete_fx: "FX_SupplyComplete",
    }
}

// ============================================================================
// Unit Dock Info
// ============================================================================

struct UnitDockInfo {
    unit_id: i32,
    unit_type: string,

    // Current stats
    health_current: f64,
    health_max: f64,
    ammo_current: i32,
    ammo_max: i32,
    fuel_current: f64,
    fuel_max: f64,

    // Size
    size_class: i32,
    is_aircraft: bool,
    is_vehicle: bool,
    is_infantry: bool,

    // State
    assigned_slot: i32,
    service_requested: ServiceType,
}

fn create_unit_dock_info(unit_id: i32): UnitDockInfo {
    return UnitDockInfo {
        unit_id: unit_id,
        unit_type: "",
        health_current: 100.0,
        health_max: 100.0,
        ammo_current: 4,
        ammo_max: 4,
        fuel_current: 100.0,
        fuel_max: 100.0,
        size_class: 1,
        is_aircraft: false,
        is_vehicle: false,
        is_infantry: false,
        assigned_slot: -1,
        service_requested: ServiceType::None,
    }
}

// ============================================================================
// Dock Update Module
// ============================================================================

struct DockUpdateModule {
    base: UpdateModule,
    config: DockConfig,

    // Slots
    slots: Vec<DockSlot>,

    // Queue
    queue: Vec<UnitDockInfo>,

    // Units being serviced
    units: HashMap<Int, UnitDockInfo>,

    // Owner
    owner_player_id: i32,
    building_id: i32,

    // Power state
    has_power: bool,

    // Statistics
    total_serviced: i32,
    total_repair_cost: f64,
    total_rearm_cost: f64,
}

fn create_dock_update(tag: string, config: DockConfig): DockUpdateModule {
    let slots = Vec<DockSlot>{}

    // Create slots
    for i in 0..config.num_slots {
        let slot = create_dock_slot(i)
        slot.position_x = i as Float * config.slot_spacing
        slot.accepts_aircraft = config.dock_type == DockType::Airfield ||
                                config.dock_type == DockType::Helipad
        slot.accepts_vehicles = config.dock_type == DockType::WarFactory ||
                                config.dock_type == DockType::ServiceDepot ||
                                config.dock_type == DockType::SupplyCenter
        slots.add(slot)
    }

    return DockUpdateModule {
        base: create_update_module(tag, UpdateType::Economy),
        config: config,
        slots: slots,
        queue: Vec<UnitDockInfo>{},
        units: HashMap<Int, UnitDockInfo>{},
        owner_player_id: 0,
        building_id: 0,
        has_power: true,
        total_serviced: 0,
        total_repair_cost: 0.0,
        total_rearm_cost: 0.0,
    }
}

// ============================================================================
// Slot Management
// ============================================================================

/// Find available slot for unit
fn find_available_slot(dock: DockUpdateModule, unit_info: UnitDockInfo): i32 {
    for i in 0..dock.slots.len() {
        let slot = dock.slots.get(i)
        if slot.state != DockSlotState::Empty {
            continue
        }

        // Check compatibility
        if unit_info.is_aircraft && !slot.accepts_aircraft {
            continue
        }
        if unit_info.is_vehicle && !slot.accepts_vehicles {
            continue
        }
        if unit_info.is_infantry && !slot.accepts_infantry {
            continue
        }

        // Check size
        if unit_info.size_class > slot.slot_size {
            continue
        }

        return i
    }
    return -1
}

/// Reserve slot for incoming unit
fn reserve_slot(dock: DockUpdateModule, slot_idx: i32, unit_id: i32): bool {
    if slot_idx < 0 || slot_idx >= dock.slots.len() {
        return false
    }

    let slot = dock.slots.get(slot_idx)
    if slot.state != DockSlotState::Empty {
        return false
    }

    slot.state = DockSlotState::Reserved
    slot.docked_unit_id = unit_id
    return true
}

/// Occupy slot (unit has arrived)
fn occupy_slot(dock: DockUpdateModule, slot_idx: i32, unit_info: UnitDockInfo) {
    if slot_idx < 0 || slot_idx >= dock.slots.len() {
        return
    }

    let slot = dock.slots.get(slot_idx)
    slot.state = DockSlotState::Occupied
    slot.docked_unit_id = unit_info.unit_id

    // Store unit info
    dock.units.set(unit_info.unit_id, unit_info)
    unit_info.assigned_slot = slot_idx

    // Start auto-service if enabled
    start_auto_service(dock, slot_idx)
}

/// Release slot (unit departing)
fn release_slot(dock: DockUpdateModule, slot_idx: i32) {
    if slot_idx < 0 || slot_idx >= dock.slots.len() {
        return
    }

    let slot = dock.slots.get(slot_idx)
    let unit_id = slot.docked_unit_id

    // Remove unit tracking
    if dock.units.has(unit_id) {
        dock.units.remove(unit_id)
    }

    slot.state = DockSlotState::Empty
    slot.docked_unit_id = 0
    slot.current_service = ServiceType::None
    slot.service_progress = 0.0

    dock.total_serviced = dock.total_serviced + 1

    // Check queue for next unit
    process_queue(dock)
}

// ============================================================================
// Queue Management
// ============================================================================

/// Request docking
fn request_dock(dock: DockUpdateModule, unit_info: UnitDockInfo): i32 {
    // Returns: slot index if immediately available, -1 if queued, -2 if rejected

    // Check power
    if dock.config.requires_power && !dock.has_power {
        return -2
    }

    // Try to find slot
    let slot_idx = find_available_slot(dock, unit_info)

    if slot_idx >= 0 {
        reserve_slot(dock, slot_idx, unit_info.unit_id)
        return slot_idx
    }

    // Add to queue
    if dock.queue.len() < dock.config.max_queue_size {
        dock.queue.add(unit_info)
        return -1  // Queued
    }

    return -2  // Rejected
}

/// Cancel dock request
fn cancel_dock_request(dock: DockUpdateModule, unit_id: i32) {
    // Remove from queue
    let new_queue = Vec<UnitDockInfo>{}
    for info in dock.queue {
        if info.unit_id != unit_id {
            new_queue.add(info)
        }
    }
    dock.queue = new_queue

    // Release any reserved slot
    for i in 0..dock.slots.len() {
        let slot = dock.slots.get(i)
        if slot.docked_unit_id == unit_id && slot.state == DockSlotState::Reserved {
            slot.state = DockSlotState::Empty
            slot.docked_unit_id = 0
        }
    }
}

/// Process queue when slot becomes available
fn process_queue(dock: DockUpdateModule) {
    if dock.queue.len() == 0 {
        return
    }

    // Try to assign queued units to available slots
    let remaining = Vec<UnitDockInfo>{}

    for unit_info in dock.queue {
        let slot_idx = find_available_slot(dock, unit_info)
        if slot_idx >= 0 {
            reserve_slot(dock, slot_idx, unit_info.unit_id)
            // Unit will need to be notified to approach
        } else {
            remaining.add(unit_info)
        }
    }

    dock.queue = remaining
}

// ============================================================================
// Service Operations
// ============================================================================

/// Start automatic service based on config
fn start_auto_service(dock: DockUpdateModule, slot_idx: i32) {
    if slot_idx < 0 || slot_idx >= dock.slots.len() {
        return
    }

    let slot = dock.slots.get(slot_idx)
    if !dock.units.has(slot.docked_unit_id) {
        return
    }

    let unit_info = dock.units.get(slot.docked_unit_id)

    // Determine what service is needed
    if dock.config.auto_repair && unit_info.health_current < unit_info.health_max {
        start_service(dock, slot_idx, ServiceType::Repair)
    } else if dock.config.auto_rearm && unit_info.ammo_current < unit_info.ammo_max {
        start_service(dock, slot_idx, ServiceType::Rearm)
    } else if dock.config.auto_refuel && unit_info.fuel_current < unit_info.fuel_max {
        start_service(dock, slot_idx, ServiceType::Refuel)
    } else {
        // No service needed, unit can depart
        slot.state = DockSlotState::Departing
    }
}

/// Start specific service
fn start_service(dock: DockUpdateModule, slot_idx: i32, service: ServiceType) {
    if slot_idx < 0 || slot_idx >= dock.slots.len() {
        return
    }

    let slot = dock.slots.get(slot_idx)
    slot.state = DockSlotState::Servicing
    slot.current_service = service
    slot.service_progress = 0.0

    // Calculate service time
    if !dock.units.has(slot.docked_unit_id) {
        return
    }

    let unit_info = dock.units.get(slot.docked_unit_id)

    if service == ServiceType::Repair {
        let hp_needed = unit_info.health_max - unit_info.health_current
        slot.service_time_remaining = hp_needed / dock.config.repair_rate
    } else if service == ServiceType::Rearm {
        let ammo_needed = (unit_info.ammo_max - unit_info.ammo_current) as Float
        slot.service_time_remaining = ammo_needed / dock.config.rearm_rate
    } else if service == ServiceType::Refuel {
        let fuel_needed = unit_info.fuel_max - unit_info.fuel_current
        slot.service_time_remaining = fuel_needed / dock.config.refuel_rate
    }

    // Enforce minimum dock time
    if slot.service_time_remaining < dock.config.min_dock_time {
        slot.service_time_remaining = dock.config.min_dock_time
    }
}

// ============================================================================
// Update
// ============================================================================

/// Update service progress
fn update_dock_service(dock: DockUpdateModule, delta: f64, available_funds: f64): Vec<(Int, ServiceType, Float)> {
    // Returns (unit_id, service_type, cost) for completed services
    let completed = Vec<(Int, ServiceType, Float)>{}

    if dock.config.requires_power && !dock.has_power {
        return completed  // No service without power
    }

    for i in 0..dock.slots.len() {
        let slot = dock.slots.get(i)

        if slot.state != DockSlotState::Servicing {
            continue
        }

        if !dock.units.has(slot.docked_unit_id) {
            continue
        }

        let unit_info = dock.units.get(slot.docked_unit_id)
        let cost = 0.0

        // Apply service
        if slot.current_service == ServiceType::Repair {
            let repair_amount = dock.config.repair_rate * delta
            let actual_repair = min_float(repair_amount, unit_info.health_max - unit_info.health_current)
            cost = actual_repair * dock.config.repair_cost_per_hp

            if cost <= available_funds {
                unit_info.health_current = unit_info.health_current + actual_repair
                dock.total_repair_cost = dock.total_repair_cost + cost
            }

        } else if slot.current_service == ServiceType::Rearm {
            let rearm_amount = dock.config.rearm_rate * delta
            let actual_rearm = min_float(rearm_amount, (unit_info.ammo_max - unit_info.ammo_current) as Float)
            cost = actual_rearm * dock.config.rearm_cost_per_ammo

            if cost <= available_funds {
                unit_info.ammo_current = unit_info.ammo_current + actual_rearm as Int
                dock.total_rearm_cost = dock.total_rearm_cost + cost
            }

        } else if slot.current_service == ServiceType::Refuel {
            let refuel_amount = dock.config.refuel_rate * delta
            let actual_refuel = min_float(refuel_amount, unit_info.fuel_max - unit_info.fuel_current)
            cost = actual_refuel * dock.config.refuel_cost_per_unit

            if cost <= available_funds {
                unit_info.fuel_current = unit_info.fuel_current + actual_refuel
            }
        }

        // Update progress
        slot.service_time_remaining = slot.service_time_remaining - delta
        if slot.service_time_remaining > 0.0 {
            let total_time = slot.service_time_remaining + (1.0 - slot.service_progress) * slot.service_time_remaining / slot.service_progress
            slot.service_progress = 1.0 - (slot.service_time_remaining / total_time)
        }

        // Check if service complete
        let is_complete = false

        if slot.current_service == ServiceType::Repair && unit_info.health_current >= unit_info.health_max {
            is_complete = true
        } else if slot.current_service == ServiceType::Rearm && unit_info.ammo_current >= unit_info.ammo_max {
            is_complete = true
        } else if slot.current_service == ServiceType::Refuel && unit_info.fuel_current >= unit_info.fuel_max {
            is_complete = true
        } else if slot.service_time_remaining <= 0.0 {
            is_complete = true
        }

        if is_complete {
            completed.add((unit_info.unit_id, slot.current_service, cost))

            // Check for next auto-service
            start_auto_service(dock, i)
        }
    }

    return completed
}

/// Update dock
fn update_dock(dock: DockUpdateModule, delta: f64, available_funds: f64): Vec<(Int, ServiceType, Float)> {
    return update_dock_service(dock, delta, available_funds)
}

// ============================================================================
// Queries
// ============================================================================

/// Get free slot count
fn get_free_slot_count(dock: DockUpdateModule): i32 {
    let count = 0
    for i in 0..dock.slots.len() {
        if dock.slots.get(i).state == DockSlotState::Empty {
            count = count + 1
        }
    }
    return count
}

/// Get queue length
fn get_queue_length(dock: DockUpdateModule): i32 {
    return dock.queue.len()
}

/// Get slot state
fn get_slot_state(dock: DockUpdateModule, slot_idx: i32): DockSlotState {
    if slot_idx >= 0 && slot_idx < dock.slots.len() {
        return dock.slots.get(slot_idx).state
    }
    return DockSlotState::Empty
}

/// Get unit service progress
fn get_service_progress(dock: DockUpdateModule, unit_id: i32): f64 {
    for i in 0..dock.slots.len() {
        let slot = dock.slots.get(i)
        if slot.docked_unit_id == unit_id {
            return slot.service_progress
        }
    }
    return 0.0
}

/// Check if unit is docked
fn is_unit_docked(dock: DockUpdateModule, unit_id: i32): bool {
    return dock.units.has(unit_id)
}

/// Get slot position
fn get_slot_position(dock: DockUpdateModule, slot_idx: i32): (Float, Float, Float) {
    if slot_idx >= 0 && slot_idx < dock.slots.len() {
        let slot = dock.slots.get(slot_idx)
        return (slot.position_x, slot.position_y, slot.position_z)
    }
    return (0.0, 0.0, 0.0)
}

// ============================================================================
// Power Management
// ============================================================================

/// Set power state
fn set_dock_power_state(dock: DockUpdateModule, has_power: bool) {
    dock.has_power = has_power
}

// ============================================================================
// Helper Functions
// ============================================================================

fn min_float(a: f64, b: f64): f64 {
    if a < b { return a }
    return b
}

// ============================================================================
// Tests
// ============================================================================

fn test_dock_creation(): bool {
    let dock = create_dock_update("TestDock", create_airfield_config())

    assert(dock.slots.len() == 4, "Should have 4 slots")
    assert(get_free_slot_count(dock) == 4, "All slots should be free")

    return true
}

fn test_dock_request(): bool {
    let dock = create_dock_update("RequestTest", create_airfield_config())

    let unit_info = create_unit_dock_info(100)
    unit_info.is_aircraft = true

    let slot = request_dock(dock, unit_info)
    assert(slot >= 0, "Should get a slot")
    assert(get_free_slot_count(dock) == 3, "One slot should be reserved")

    return true
}

fn test_dock_queue(): bool {
    let dock = create_dock_update("QueueTest", create_airfield_config())

    // Fill all slots
    for i in 0..4 {
        let unit_info = create_unit_dock_info(100 + i)
        unit_info.is_aircraft = true
        request_dock(dock, unit_info)
    }

    assert(get_free_slot_count(dock) == 0, "All slots should be taken")

    // Request another (should queue)
    let unit_info = create_unit_dock_info(200)
    unit_info.is_aircraft = true
    let result = request_dock(dock, unit_info)

    assert(result == -1, "Should be queued")
    assert(get_queue_length(dock) == 1, "Queue should have 1")

    return true
}

fn test_dock_service(): bool {
    let dock = create_dock_update("ServiceTest", create_service_depot_config())

    let unit_info = create_unit_dock_info(100)
    unit_info.is_vehicle = true
    unit_info.health_current = 50.0
    unit_info.health_max = 100.0

    let slot = request_dock(dock, unit_info)
    occupy_slot(dock, slot, unit_info)

    // Update service
    for i in 0..20 {
        update_dock(dock, 0.1, 1000.0)
    }

    // Check health improved
    if dock.units.has(100) {
        let info = dock.units.get(100)
        assert(info.health_current > 50.0, "Health should improve")
    }

    return true
}

fn test_dock_release(): bool {
    let dock = create_dock_update("ReleaseTest", create_airfield_config())

    let unit_info = create_unit_dock_info(100)
    unit_info.is_aircraft = true

    let slot = request_dock(dock, unit_info)
    occupy_slot(dock, slot, unit_info)

    assert(get_free_slot_count(dock) == 3, "One slot occupied")

    release_slot(dock, slot)
    assert(get_free_slot_count(dock) == 4, "All slots should be free")

    return true
}

fn run_all_tests(): bool {
    assert(test_dock_creation(), "Dock creation test failed")
    assert(test_dock_request(), "Dock request test failed")
    assert(test_dock_queue(), "Dock queue test failed")
    assert(test_dock_service(), "Dock service test failed")
    assert(test_dock_release(), "Dock release test failed")
    return true
}
