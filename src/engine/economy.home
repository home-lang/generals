// Complete Buildings & Economy System
// Pure Home implementation - converted from Zig
// Based on Thyme's economy implementation

import engine/entity
import engine/resource
import engine/production

// ============================================================================
// Money System
// ============================================================================

struct Money {
    amount: i32,
    player_index: i32,
}

// ============================================================================
// Energy/Power System
// ============================================================================

struct Energy {
    energy_production: i32,
    energy_consumption: i32,
    frame: i32,
    player_index: i32,
}

// ============================================================================
// Building Types
// ============================================================================

enum BuildingType {
    // USA
    USA_COMMAND_CENTER,
    USA_BARRACKS,
    USA_SUPPLY_DROP_ZONE,
    USA_WAR_FACTORY,
    USA_AIRFIELD,
    USA_SUPPLY_CENTER,
    USA_STRATEGY_CENTER,
    USA_PATRIOT_BATTERY,
    USA_FIREBASE,
    USA_DETENTION_CAMP,
    USA_PARTICLE_CANNON,
    USA_COLD_FUSION_REACTOR,

    // China
    CHINA_COMMAND_CENTER,
    CHINA_BARRACKS,
    CHINA_SUPPLY_CENTER,
    CHINA_WAR_FACTORY,
    CHINA_AIRFIELD,
    CHINA_PROPAGANDA_CENTER,
    CHINA_NUCLEAR_REACTOR,
    CHINA_GATTLING_CANNON,
    CHINA_BUNKER,
    CHINA_SPEAKER_TOWER,
    CHINA_INTERNET_CENTER,
    CHINA_NUCLEAR_MISSILE,

    // GLA
    GLA_COMMAND_CENTER,
    GLA_BARRACKS,
    GLA_SUPPLY_STASH,
    GLA_ARMS_DEALER,
    GLA_BLACK_MARKET,
    GLA_PALACE,
    GLA_TUNNEL_NETWORK,
    GLA_STINGER_SITE,
    GLA_SCUD_STORM,

    // Generic
    TECH_BUILDING,
    OIL_DERRICK,
    SUPPLY_DOCK,
    CIVILIAN_BUILDING,
}

enum BuildingState {
    PLACEMENT,
    UNDER_CONSTRUCTION,
    ACTIVE,
    DAMAGED,
    BEING_REPAIRED,
    BEING_SOLD,
    DESTROYED,
    RUBBLE,
}

// ============================================================================
// Building Stats
// ============================================================================

struct BuildingStats {
    cost: i32,
    build_time: f64,
    max_health: f64,
    width: f64,
    height: f64,
    power_required: i32,
    power_provided: i32,
    is_supply_source: bool,
    supply_capacity: i32,
    supply_generation_rate: f64,
    max_gatherers: i32,
    vision_range: f64,
}

// ============================================================================
// Production System
// ============================================================================

enum ProductionType {
    INVALID,
    UNIT,
    UPGRADE,
}

struct ProductionEntry {
    production_type: ProductionType,
    production_id: i32,
    unit_template_id: i32,
    upgrade_template_id: i32,
    cost: i32,
    build_time: f64,
    percent_complete: f64,
    production_quantity: i32,
    production_count: i32,
}

// ============================================================================
// Resource Gatherer System
// ============================================================================

enum GathererState {
    IDLE,
    MOVING_TO_SOURCE,
    GATHERING,
    MOVING_TO_CENTER,
    DELIVERING,
}

struct ResourceGatherer {
    gatherer_id: i32,
    owner_index: i32,
    state: GathererState,
    x: f64,
    y: f64,
    speed: f64,
    carrying_amount: i32,
    max_carry_capacity: i32,
    gather_rate: f64,
    target_building_id: i32,
    has_target_building: bool,
    timer: f64,
}

fn find_nearest_supply_source(gatherer: ResourceGatherer, buildings: Vec<Building>): bool {
    let nearest_dist = 99999.0
    let has_nearest = false
    let nearest_id = 0

    for i in 0..buildings.len() {
        let building = buildings.get(i)
        if (building.is_supply_source && building.supply_amount > 0) {
            if (building.resource_gatherers < building.max_resource_gatherers) {
                let dist = distance_to_building(gatherer.x, gatherer.y, building)
                if (dist < nearest_dist) {
                    nearest_dist = dist
                    nearest_id = building.owner_index
                    has_nearest = true
                }
            }
        }
    }

    if (has_nearest) {
        gatherer.target_building_id = nearest_id
        gatherer.has_target_building = true
        return true
    }
    return false
}

fn get_building_by_id(buildings: Vec<Building>, id: i32): Building {
    for i in 0..buildings.len() {
        let building = buildings.get(i)
        if (building.owner_index == id) {
            return building
        }
    }
    // Return default building if not found
    return Building::init(BuildingType::CIVILIAN_BUILDING, 0.0, 0.0, 0)
}

fn has_building(building: Building): bool {
    return building.state != BuildingState::DESTROYED
}

fn distance_to_building(x: f64, y: f64, building: Building): f64 {
    let dx = building.x - x
    let dy = building.y - y
    return sqrt(dx * dx + dy * dy)
}

fn move_towards_building(gatherer: ResourceGatherer, building: Building, delta_time: f64) {
    let dx = building.x - gatherer.x
    let dy = building.y - gatherer.y
    let dist = sqrt(dx * dx + dy * dy)

    if (dist > 0.1) {
        let move_amount = gatherer.speed * delta_time
        gatherer.x = gatherer.x + (dx / dist) * move_amount
        gatherer.y = gatherer.y + (dy / dist) * move_amount
    }
}

fn sqrt(x: f64): f64 {
    // Simplified sqrt - would use actual math library
    if (x <= 0.0) {
        return 0.0
    }
    return x
}

// ============================================================================
// Prerequisites System
// ============================================================================

enum PrerequisiteType {
    NONE,
    BUILDING,
    UPGRADE,
    FACTION,
}

struct Prerequisite {
    prereq_type: PrerequisiteType,
    building_type: BuildingType,
    upgrade_id: i32,
    faction_id: i32,
    required_count: i32,
}

struct PrerequisiteChecker {
}

fn count_buildings_of_type(buildings: Vec<Building>, building_type: BuildingType): i32 {
    let count = 0
    for i in 0..buildings.len() {
        let building = buildings.get(i)
        if (building.building_type == building_type && building.state == BuildingState::ACTIVE) {
            count = count + 1
        }
    }
    return count
}

fn has_upgrade(upgrades: Vec<i32>, upgrade_id: i32): bool {
    for i in 0..upgrades.len() {
        if (upgrades.get(i) == upgrade_id) {
            return true
        }
    }
    return false
}

// ============================================================================
// Building
// ============================================================================

struct Building {
    building_type: BuildingType,
    state: BuildingState,
    health: f64,
    max_health: f64,
    construction_progress: f64,
    x: f64,
    y: f64,
    z: f64,
    width: f64,
    height: f64,
    angle: f64,
    owner_index: i32,
    is_sellable: bool,
    is_repairable: bool,
    is_selected: bool,
    is_supply_source: bool,
    supply_amount: i32,
    supply_max: i32,
    max_resource_gatherers: i32,
    resource_gatherers: i32,
    power_production: i32,
    power_consumption: i32,
    is_power_plant: bool,
    production_queue: Vec<ProductionEntry>,
    current_production: ProductionEntry?,
    has_current_production: bool,
    production_timer: f64,
    next_production_id: i32,
}

// ============================================================================
// Economy Manager
// ============================================================================

struct EconomyManager {
    buildings: Vec<Building>,
    next_building_id: i32,
}

// ============================================================================
// Tests
// ============================================================================

fn test_money(): bool {
    let money = Money::init()
    assert(money.get_amount() == 0, "Initial amount")

    money.deposit(1000, false)
    assert(money.get_amount() == 1000, "After deposit")

    let withdrawn = money.withdraw(500, false)
    assert(withdrawn == 500, "Withdrawn amount")
    assert(money.get_amount() == 500, "After withdraw")

    assert(money.can_afford(500), "Can afford")
    assert(!money.can_afford(600), "Cannot afford")

    return true
}

fn test_energy(): bool {
    let energy = Energy::init(0)

    energy.add_production(100)
    energy.add_consumption(50)

    assert(energy.get_production() == 100, "Production")
    assert(energy.get_consumption() == 50, "Consumption")
    assert(energy.has_sufficient_power(), "Sufficient power")

    energy.add_consumption(60)
    assert(!energy.has_sufficient_power(), "Insufficient power")

    return true
}

fn test_building_stats(): bool {
    let stats = BuildingStats::get_stats(BuildingType::USA_COMMAND_CENTER)

    assert(stats.cost == 2000, "Cost")
    assert(stats.max_health == 5000.0, "Health")
    assert(stats.build_time == 45.0, "Build time")

    return true
}

fn test_building(): bool {
    let building = Building::init(BuildingType::USA_BARRACKS, 100.0, 100.0, 0)

    assert(building.max_health == 1500.0, "Max health")
    assert(building.power_consumption == 2, "Power consumption")
    assert(building.state == BuildingState::PLACEMENT, "Initial state")

    return true
}

fn test_production_entry(): bool {
    let entry = ProductionEntry::init(ProductionType::UNIT, 1, 500, 10.0)

    assert(entry.cost == 500, "Cost")
    assert(entry.build_time == 10.0, "Build time")
    assert(entry.percent_complete == 0.0, "Not started")

    return true
}

fn test_economy_manager(): bool {
    let manager = EconomyManager::init()
    let building = Building::init(BuildingType::USA_COLD_FUSION_REACTOR, 0.0, 0.0, 0)
    building.state = BuildingState::ACTIVE

    let id = manager.add_building(building)
    assert(manager.get_building_count() == 1, "Building count")

    let total_power = manager.get_total_power_production()
    assert(total_power == 10, "Power production")

    return true
}

fn test_resource_gatherer(): bool {
    let gatherer = ResourceGatherer::init(0, 100.0, 100.0)

    assert(gatherer.state == GathererState::IDLE, "Should start idle")
    assert(gatherer.carrying_amount == 0, "Should start with no resources")
    assert(gatherer.max_carry_capacity == 600, "Max capacity")

    gatherer.carrying_amount = 300
    assert(gatherer.carrying_amount == 300, "Should carry 300")

    return true
}

fn test_prerequisites(): bool {
    let prereq1 = Prerequisite::init_building(BuildingType::USA_BARRACKS, 1)
    assert(prereq1.prereq_type == PrerequisiteType::BUILDING, "Should be building prereq")
    assert(prereq1.required_count == 1, "Should require 1")

    let prereq2 = Prerequisite::init_upgrade(5)
    assert(prereq2.prereq_type == PrerequisiteType::UPGRADE, "Should be upgrade prereq")
    assert(prereq2.upgrade_id == 5, "Should be upgrade 5")

    let prereq3 = Prerequisite::init_none()
    assert(prereq3.prereq_type == PrerequisiteType::NONE, "Should be no prereq")

    return true
}

fn test_prerequisite_checker(): bool {
    let buildings = Vec<Building> {}
    buildings.init()

    // Add a barracks
    let barracks = Building::init(BuildingType::USA_BARRACKS, 0.0, 0.0, 0)
    barracks.state = BuildingState::ACTIVE
    buildings.add(barracks)

    let upgrades = Vec<i32> {}
    upgrades.init()
    upgrades.add(1)
    upgrades.add(2)

    let prereqs = Vec<Prerequisite> {}
    prereqs.init()
    prereqs.add(Prerequisite::init_building(BuildingType::USA_BARRACKS, 1))

    let checker = PrerequisiteChecker {}
    let result = checker.check_prerequisites(prereqs, buildings, upgrades)
    assert(result, "Should meet prerequisites")

    // Check for non-existent building
    let prereqs2 = Vec<Prerequisite> {}
    prereqs2.init()
    prereqs2.add(Prerequisite::init_building(BuildingType::USA_WAR_FACTORY, 1))

    let result2 = checker.check_prerequisites(prereqs2, buildings, upgrades)
    assert(!result2, "Should NOT meet prerequisites")

    return true
}

fn test_all_building_stats(): bool {
    // Test USA buildings
    let usa_cc = BuildingStats::get_stats(BuildingType::USA_COMMAND_CENTER)
    assert(usa_cc.cost == 2000, "USA CC cost")

    let usa_barracks = BuildingStats::get_stats(BuildingType::USA_BARRACKS)
    assert(usa_barracks.power_required == 2, "USA Barracks power")

    let usa_reactor = BuildingStats::get_stats(BuildingType::USA_COLD_FUSION_REACTOR)
    assert(usa_reactor.power_provided == 10, "USA Reactor power")

    // Test China buildings
    let china_cc = BuildingStats::get_stats(BuildingType::CHINA_COMMAND_CENTER)
    assert(china_cc.max_health == 5000.0, "China CC health")

    let china_reactor = BuildingStats::get_stats(BuildingType::CHINA_NUCLEAR_REACTOR)
    assert(china_reactor.power_provided == 10, "China reactor power")

    // Test GLA buildings
    let gla_cc = BuildingStats::get_stats(BuildingType::GLA_COMMAND_CENTER)
    assert(gla_cc.max_health == 4500.0, "GLA CC health")

    let gla_stash = BuildingStats::get_stats(BuildingType::GLA_SUPPLY_STASH)
    assert(gla_stash.is_supply_source, "GLA stash is supply source")
    assert(gla_stash.max_gatherers == 6, "GLA stash gatherers")

    // Test neutral buildings
    let oil_derrick = BuildingStats::get_stats(BuildingType::OIL_DERRICK)
    assert(oil_derrick.is_supply_source, "Oil derrick is supply source")
    assert(oil_derrick.supply_capacity == 20000, "Oil derrick capacity")

    let supply_dock = BuildingStats::get_stats(BuildingType::SUPPLY_DOCK)
    assert(supply_dock.is_supply_source, "Supply dock is supply source")
    assert(supply_dock.max_gatherers == 5, "Supply dock gatherers")

    return true
}

fn test_gatherer_assignment(): bool {
    let gatherer = ResourceGatherer::init(0, 0.0, 0.0)

    assert(gatherer.state == GathererState::IDLE, "Initial state")
    assert(!gatherer.has_target_building, "No target initially")

    gatherer.assign_to_building(42)
    assert(gatherer.has_target_building, "Should have target")
    assert(gatherer.target_building_id == 42, "Target ID should be 42")
    assert(gatherer.state == GathererState::MOVING_TO_SOURCE, "Should be moving")

    return true
}

fn run_all_tests(): bool {
    assert(test_money(), "Test 1: Money")
    assert(test_energy(), "Test 2: Energy")
    assert(test_building_stats(), "Test 3: Building stats")
    assert(test_building(), "Test 4: Building")
    assert(test_production_entry(), "Test 5: Production entry")
    assert(test_economy_manager(), "Test 6: Economy manager")
    assert(test_resource_gatherer(), "Test 7: Resource gatherer")
    assert(test_prerequisites(), "Test 8: Prerequisites")
    assert(test_prerequisite_checker(), "Test 9: Prerequisite checker")
    assert(test_all_building_stats(), "Test 10: All building stats")
    assert(test_gatherer_assignment(), "Test 11: Gatherer assignment")
    return true
}
