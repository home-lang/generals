// C&C Generals Zero Hour - Home Port
// Timing & Frame Management System
//
// Original: FramePacer.cpp, GameLogic.cpp (Westwood Studios/EA)
// Ported to Home with high-resolution timing

import basics/allocator

// Time units
const NANOSECONDS_PER_SECOND: u64 = 1000000000
const MICROSECONDS_PER_SECOND: u64 = 1000000
const MILLISECONDS_PER_SECOND: u64 = 1000

// Frame timing modes
enum TimingMode {
    Variable      // Variable delta time (can cause instability)
    Fixed         // Fixed timestep (stable physics)
    SemiFixed     // Fixed with accumulator (best of both)
}

// Frame rate limiter
struct FrameLimiter {
    target_fps: u32
    target_frame_time: f64  // In seconds
    min_frame_time: f64
    max_frame_time: f64
}

// High-resolution timer
struct Timer {
    start_time: u64  // In nanoseconds
    is_running: bool
}

// Frame timing tracker
struct FrameTimer {
    mode: TimingMode
    limiter: FrameLimiter
    current_time: u64
    last_time: u64
    delta_time: f64
    unscaled_delta_time: f64
    time_scale: f64
    fixed_timestep: f64
    accumulator: f64
    max_accumulator: f64
    frame_count: u64
    fps_update_interval: f64
    fps_update_timer: f64
    fps_frame_count: u32
    current_fps: f32
    delta_history_index: usize
    smooth_delta: bool
}

// Stopwatch for profiling
struct Stopwatch {
    name: string
    sample_count: usize
    capacity: usize
    current_sample: Timer
    allocator: Allocator
}

// Platform-specific time functions
fn get_nanoseconds(): u64 {
    // TODO: Platform-specific high-resolution timer
    // Windows: QueryPerformanceCounter
    // macOS: mach_absolute_time
    // Linux: clock_gettime(CLOCK_MONOTONIC)
    return 0
}

fn sleep_seconds(seconds: f64) {
    // TODO: Platform-specific sleep
    // Windows: Sleep(milliseconds)
    // POSIX: nanosleep
    let ns = seconds_to_nanoseconds(seconds)
    sleep_nanoseconds(ns)
}

fn sleep_nanoseconds(nanoseconds: u64) {
    // TODO: Platform-specific nanosleep
}

// Time conversion utilities
fn nanoseconds_to_seconds(ns: u64): f64 {
    return @intToFloat(f64, ns) / @intToFloat(f64, NANOSECONDS_PER_SECOND)
}

fn seconds_to_nanoseconds(seconds: f64): u64 {
    return @floatToInt(u64, seconds * @intToFloat(f64, NANOSECONDS_PER_SECOND))
}

fn milliseconds_to_seconds(ms: u64): f64 {
    return @intToFloat(f64, ms) / @intToFloat(f64, MILLISECONDS_PER_SECOND)
}

fn seconds_to_milliseconds(seconds: f64): u64 {
    return @floatToInt(u64, seconds * @intToFloat(f64, MILLISECONDS_PER_SECOND))
}

fn clamp_f64(value: f64, min: f64, max: f64): f64 {
    if (value < min) {
        return min
    }
    if (value > max) {
        return max
    }
    return value
}

// Global frame timer
var g_frame_timer: ?FrameTimer = null

export fn init_timing(mode: TimingMode, target_fps: u32) {
    g_frame_timer = FrameTimer.init(mode, target_fps)
}

export fn tick_timing() {
    if (g_frame_timer) {
        g_frame_timer.?.tick()
    }
}

export fn get_delta_time(): f32 {
    if (g_frame_timer) {
        return g_frame_timer.?.get_delta_time()
    }
    return 0.0
}

export fn get_fixed_delta_time(): f32 {
    if (g_frame_timer) {
        return g_frame_timer.?.get_fixed_delta_time()
    }
    return 0.016667  // 60 FPS
}

export fn should_update_fixed(): bool {
    if (g_frame_timer) {
        return g_frame_timer.?.should_update_fixed()
    }
    return true
}

export fn consume_fixed_update() {
    if (g_frame_timer) {
        g_frame_timer.?.consume_fixed_update()
    }
}

export fn get_fps(): f32 {
    if (g_frame_timer) {
        return g_frame_timer.?.get_fps()
    }
    return 0.0
}

export fn get_frame_count(): u64 {
    if (g_frame_timer) {
        return g_frame_timer.?.get_frame_count()
    }
    return 0
}

export fn set_time_scale(scale: f32) {
    if (g_frame_timer) {
        g_frame_timer.?.set_time_scale(@floatCast(f64, scale))
    }
}

export fn pause_time() {
    if (g_frame_timer) {
        g_frame_timer.?.pause()
    }
}

export fn resume_time() {
    if (g_frame_timer) {
        g_frame_timer.?.resume()
    }
}

export fn wait_for_next_frame() {
    if (g_frame_timer) {
        g_frame_timer.?.wait_for_next_frame()
    }
}
