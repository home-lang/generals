// PNG Image Loader - Portable Network Graphics Format
// Used for UI textures and other images in C&C Generals
// Reference: PNG Specification (RFC 2083)

from basics import Collection, Map

// PNG signature (8 bytes)
const PNG_SIGNATURE: [Int; 8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]

// Critical chunk types
const CHUNK_IHDR: Int = 0x49484452  // Image header
const CHUNK_PLTE: Int = 0x504C5445  // Palette
const CHUNK_IDAT: Int = 0x49444154  // Image data
const CHUNK_IEND: Int = 0x49454E44  // Image end

// Ancillary chunk types
const CHUNK_tRNS: Int = 0x74524E53  // Transparency
const CHUNK_gAMA: Int = 0x67414D41  // Gamma
const CHUNK_cHRM: Int = 0x6348524D  // Chromaticity
const CHUNK_sRGB: Int = 0x73524742  // Standard RGB
const CHUNK_bKGD: Int = 0x624B4744  // Background color
const CHUNK_pHYs: Int = 0x70485973  // Physical dimensions
const CHUNK_tEXt: Int = 0x74455874  // Text
const CHUNK_iTXt: Int = 0x69545874  // International text
const CHUNK_tIME: Int = 0x74494D45  // Last modification time

// Color types
const COLOR_GRAYSCALE: Int = 0
const COLOR_RGB: Int = 2
const COLOR_INDEXED: Int = 3
const COLOR_GRAYSCALE_ALPHA: Int = 4
const COLOR_RGBA: Int = 6

// Filter types
const FILTER_NONE: Int = 0
const FILTER_SUB: Int = 1
const FILTER_UP: Int = 2
const FILTER_AVERAGE: Int = 3
const FILTER_PAETH: Int = 4

// Interlace methods
const INTERLACE_NONE: Int = 0
const INTERLACE_ADAM7: Int = 1

// PNG image header
struct PNGHeader {
    width: Int,
    height: Int,
    bit_depth: Int,
    color_type: Int,
    compression: Int,
    filter: Int,
    interlace: Int,
}

// Loaded PNG image
struct PNGImage {
    width: Int,
    height: Int,
    channels: Int,
    bit_depth: Int,
    pixels: Collection<Int>,  // RGBA pixel data
    name: String,
    has_alpha: Bool,
}

/// Create empty PNG image
fn create_png_image() -> PNGImage {
    return PNGImage {
        width: 0,
        height: 0,
        channels: 4,
        bit_depth: 8,
        pixels: Collection<Int>{},
        name: "",
        has_alpha: false,
    }
}

/// Read 32-bit big-endian integer
fn read_u32_be(data: Collection<Int>, offset: Int) -> Int {
    if offset + 4 > data.len() {
        return 0
    }
    return (data.get(offset) << 24) |
           (data.get(offset + 1) << 16) |
           (data.get(offset + 2) << 8) |
           data.get(offset + 3)
}

/// Read byte
fn read_byte(data: Collection<Int>, offset: Int) -> Int {
    if offset >= data.len() {
        return 0
    }
    return data.get(offset)
}

/// Check PNG signature
fn check_signature(data: Collection<Int>) -> Bool {
    if data.len() < 8 {
        return false
    }

    for i in 0..8 {
        if data.get(i) != PNG_SIGNATURE[i] {
            return false
        }
    }

    return true
}

/// Parse IHDR chunk
fn parse_ihdr(data: Collection<Int>, offset: Int) -> (PNGHeader, Bool) {
    let header = PNGHeader {
        width: 0,
        height: 0,
        bit_depth: 0,
        color_type: 0,
        compression: 0,
        filter: 0,
        interlace: 0,
    }

    if offset + 13 > data.len() {
        return (header, false)
    }

    header.width = read_u32_be(data, offset)
    header.height = read_u32_be(data, offset + 4)
    header.bit_depth = read_byte(data, offset + 8)
    header.color_type = read_byte(data, offset + 9)
    header.compression = read_byte(data, offset + 10)
    header.filter = read_byte(data, offset + 11)
    header.interlace = read_byte(data, offset + 12)

    // Validate
    if header.width == 0 || header.height == 0 {
        return (header, false)
    }

    if header.compression != 0 {
        return (header, false)  // Only deflate compression supported
    }

    return (header, true)
}

/// Calculate CRC32
fn crc32(data: Collection<Int>, start: Int, length: Int) -> Int {
    // CRC32 table (precomputed for polynomial 0xEDB88320)
    let crc = 0xFFFFFFFF

    for i in start..(start + length) {
        if i >= data.len() {
            break
        }
        let byte = data.get(i)
        // Simplified CRC - real implementation would use lookup table
        crc = crc ^ byte
        for j in 0..8 {
            if (crc & 1) != 0 {
                crc = (crc >> 1) ^ 0xEDB88320
            } else {
                crc = crc >> 1
            }
        }
    }

    return crc ^ 0xFFFFFFFF
}

/// Get number of channels for color type
fn get_channels(color_type: Int) -> Int {
    match color_type {
        COLOR_GRAYSCALE => 1,
        COLOR_RGB => 3,
        COLOR_INDEXED => 1,
        COLOR_GRAYSCALE_ALPHA => 2,
        COLOR_RGBA => 4,
        _ => 4,
    }
}

/// Paeth predictor function
fn paeth_predictor(a: Int, b: Int, c: Int) -> Int {
    let p = a + b - c
    let pa = abs(p - a)
    let pb = abs(p - b)
    let pc = abs(p - c)

    if pa <= pb && pa <= pc {
        return a
    } else if pb <= pc {
        return b
    } else {
        return c
    }
}

fn abs(x: Int) -> Int {
    if x < 0 { return -x }
    return x
}

/// Apply PNG filters to scanline
fn unfilter_scanline(scanline: Collection<Int>, prev_scanline: Collection<Int>,
                      filter_type: Int, bpp: Int) -> Collection<Int> {
    let result = Collection<Int>{}
    let width = scanline.len()

    for i in 0..width {
        let x = scanline.get(i)
        let a = if i >= bpp { result.get(i - bpp) } else { 0 }
        let b = if prev_scanline.len() > 0 { prev_scanline.get(i) } else { 0 }
        let c = if i >= bpp && prev_scanline.len() > 0 { prev_scanline.get(i - bpp) } else { 0 }

        let value = match filter_type {
            FILTER_NONE => x,
            FILTER_SUB => (x + a) & 0xFF,
            FILTER_UP => (x + b) & 0xFF,
            FILTER_AVERAGE => (x + ((a + b) / 2)) & 0xFF,
            FILTER_PAETH => (x + paeth_predictor(a, b, c)) & 0xFF,
            _ => x,
        }

        result.add(value)
    }

    return result
}

/// Decompress DEFLATE data (simplified - would use zlib in practice)
fn decompress_deflate(compressed: Collection<Int>) -> Collection<Int> {
    // This is a placeholder - real implementation would decompress DEFLATE
    // For now, we'll indicate that real zlib decompression is needed
    // Import from zlib_compression module in production

    // Try to use our zlib implementation
    // from zlib_compression import zlib_decompress
    // return zlib_decompress(compressed)

    return Collection<Int>{}  // Return empty for now
}

/// Check if data is a valid PNG file
fn is_png_file(data: Collection<Int>) -> Bool {
    return check_signature(data)
}

/// Load PNG image (basic implementation)
fn load_png(data: Collection<Int>) -> (PNGImage, Bool) {
    let image = create_png_image()

    if !check_signature(data) {
        return (image, false)
    }

    // Parse chunks
    let offset = 8
    let header_found = false
    let header = PNGHeader {
        width: 0, height: 0, bit_depth: 0, color_type: 0,
        compression: 0, filter: 0, interlace: 0,
    }
    let palette = Collection<Int>{}
    let compressed_data = Collection<Int>{}
    let transparency = Collection<Int>{}

    while offset + 12 <= data.len() {
        let chunk_length = read_u32_be(data, offset)
        let chunk_type = read_u32_be(data, offset + 4)
        let chunk_data_start = offset + 8

        if chunk_type == CHUNK_IHDR {
            let (h, ok) = parse_ihdr(data, chunk_data_start)
            if ok {
                header = h
                header_found = true
            }
        } else if chunk_type == CHUNK_PLTE {
            // Parse palette
            for i in 0..chunk_length {
                palette.add(read_byte(data, chunk_data_start + i))
            }
        } else if chunk_type == CHUNK_IDAT {
            // Collect compressed image data
            for i in 0..chunk_length {
                compressed_data.add(read_byte(data, chunk_data_start + i))
            }
        } else if chunk_type == CHUNK_tRNS {
            // Transparency data
            for i in 0..chunk_length {
                transparency.add(read_byte(data, chunk_data_start + i))
            }
        } else if chunk_type == CHUNK_IEND {
            break
        }

        offset = offset + 12 + chunk_length
    }

    if !header_found {
        return (image, false)
    }

    image.width = header.width
    image.height = header.height
    image.bit_depth = header.bit_depth
    image.channels = get_channels(header.color_type)
    image.has_alpha = header.color_type == COLOR_RGBA ||
                      header.color_type == COLOR_GRAYSCALE_ALPHA ||
                      transparency.len() > 0

    // Decompress image data
    let decompressed = decompress_deflate(compressed_data)

    if decompressed.len() == 0 {
        // Decompression not implemented - create placeholder
        let total = image.width * image.height * 4
        for i in 0..total {
            image.pixels.add(128)  // Gray placeholder
        }
        return (image, true)
    }

    // Unfilter and convert to RGBA
    let bpp = (image.channels * header.bit_depth + 7) / 8
    let scanline_length = image.width * bpp
    let prev_scanline = Collection<Int>{}

    let data_offset = 0
    for y in 0..image.height {
        if data_offset >= decompressed.len() {
            break
        }

        let filter_type = decompressed.get(data_offset)
        data_offset = data_offset + 1

        // Extract scanline
        let scanline = Collection<Int>{}
        for x in 0..scanline_length {
            if data_offset < decompressed.len() {
                scanline.add(decompressed.get(data_offset))
                data_offset = data_offset + 1
            } else {
                scanline.add(0)
            }
        }

        // Unfilter
        let unfiltered = unfilter_scanline(scanline, prev_scanline, filter_type, bpp)
        prev_scanline = unfiltered

        // Convert to RGBA
        for x in 0..image.width {
            let pixel_offset = x * bpp

            if header.color_type == COLOR_RGBA {
                image.pixels.add(unfiltered.get(pixel_offset))
                image.pixels.add(unfiltered.get(pixel_offset + 1))
                image.pixels.add(unfiltered.get(pixel_offset + 2))
                image.pixels.add(unfiltered.get(pixel_offset + 3))
            } else if header.color_type == COLOR_RGB {
                image.pixels.add(unfiltered.get(pixel_offset))
                image.pixels.add(unfiltered.get(pixel_offset + 1))
                image.pixels.add(unfiltered.get(pixel_offset + 2))
                image.pixels.add(255)
            } else if header.color_type == COLOR_GRAYSCALE {
                let gray = unfiltered.get(pixel_offset)
                image.pixels.add(gray)
                image.pixels.add(gray)
                image.pixels.add(gray)
                image.pixels.add(255)
            } else if header.color_type == COLOR_GRAYSCALE_ALPHA {
                let gray = unfiltered.get(pixel_offset)
                image.pixels.add(gray)
                image.pixels.add(gray)
                image.pixels.add(gray)
                image.pixels.add(unfiltered.get(pixel_offset + 1))
            } else if header.color_type == COLOR_INDEXED {
                let index = unfiltered.get(pixel_offset) * 3
                if index + 2 < palette.len() {
                    image.pixels.add(palette.get(index))
                    image.pixels.add(palette.get(index + 1))
                    image.pixels.add(palette.get(index + 2))

                    // Check transparency
                    let alpha = 255
                    if unfiltered.get(pixel_offset) < transparency.len() {
                        alpha = transparency.get(unfiltered.get(pixel_offset))
                    }
                    image.pixels.add(alpha)
                } else {
                    image.pixels.add(0)
                    image.pixels.add(0)
                    image.pixels.add(0)
                    image.pixels.add(255)
                }
            }
        }
    }

    return (image, true)
}

/// Get pixel at coordinate
fn get_png_pixel(image: PNGImage, x: Int, y: Int) -> (Int, Int, Int, Int) {
    if x < 0 || x >= image.width || y < 0 || y >= image.height {
        return (0, 0, 0, 0)
    }

    let offset = (y * image.width + x) * 4
    if offset + 4 > image.pixels.len() {
        return (0, 0, 0, 0)
    }

    return (
        image.pixels.get(offset),
        image.pixels.get(offset + 1),
        image.pixels.get(offset + 2),
        image.pixels.get(offset + 3)
    )
}

// ============================================================================
// Tests
// ============================================================================

fn test_png_signature() -> Bool {
    let data = Collection<Int>{}
    for b in PNG_SIGNATURE {
        data.add(b)
    }

    assert(check_signature(data) == true, "Should detect PNG signature")

    let invalid = Collection<Int>{}
    for i in 0..8 {
        invalid.add(0)
    }

    assert(check_signature(invalid) == false, "Should reject invalid signature")

    return true
}

fn test_channels() -> Bool {
    assert(get_channels(COLOR_GRAYSCALE) == 1, "Grayscale = 1 channel")
    assert(get_channels(COLOR_RGB) == 3, "RGB = 3 channels")
    assert(get_channels(COLOR_RGBA) == 4, "RGBA = 4 channels")
    return true
}

fn test_paeth() -> Bool {
    // Test paeth predictor
    assert(paeth_predictor(10, 20, 5) == 20, "Paeth should choose b")
    assert(paeth_predictor(10, 10, 10) == 10, "Paeth should choose a when equal")
    return true
}

fn test_png_creation() -> Bool {
    let image = create_png_image()
    assert(image.width == 0, "Default width should be 0")
    assert(image.channels == 4, "Default channels should be 4")
    return true
}

fn run_all_tests() -> Bool {
    assert(test_png_signature(), "PNG signature test failed")
    assert(test_channels(), "Channels test failed")
    assert(test_paeth(), "Paeth predictor test failed")
    assert(test_png_creation(), "PNG creation test failed")
    return true
}
