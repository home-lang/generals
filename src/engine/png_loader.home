// PNG Image Loader - Portable Network Graphics Format
// Used for UI textures and other images in C&C Generals
// Reference: PNG Specification (RFC 2083)


// PNG signature (8 bytes)
const PNG_SIGNATURE: [Int; 8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]

// Critical chunk types
const CHUNK_IHDR: i32 = 0x49484452  // Image header
const CHUNK_PLTE: i32 = 0x504C5445  // Palette
const CHUNK_IDAT: i32 = 0x49444154  // Image data
const CHUNK_IEND: i32 = 0x49454E44  // Image end

// Ancillary chunk types
const CHUNK_tRNS: i32 = 0x74524E53  // Transparency
const CHUNK_gAMA: i32 = 0x67414D41  // Gamma
const CHUNK_cHRM: i32 = 0x6348524D  // Chromaticity
const CHUNK_sRGB: i32 = 0x73524742  // Standard RGB
const CHUNK_bKGD: i32 = 0x624B4744  // Background color
const CHUNK_pHYs: i32 = 0x70485973  // Physical dimensions
const CHUNK_tEXt: i32 = 0x74455874  // Text
const CHUNK_iTXt: i32 = 0x69545874  // International text
const CHUNK_tIME: i32 = 0x74494D45  // Last modification time

// Color types
const COLOR_GRAYSCALE: i32 = 0
const COLOR_RGB: i32 = 2
const COLOR_INDEXED: i32 = 3
const COLOR_GRAYSCALE_ALPHA: i32 = 4
const COLOR_RGBA: i32 = 6

// Filter types
const FILTER_NONE: i32 = 0
const FILTER_SUB: i32 = 1
const FILTER_UP: i32 = 2
const FILTER_AVERAGE: i32 = 3
const FILTER_PAETH: i32 = 4

// Interlace methods
const INTERLACE_NONE: i32 = 0
const INTERLACE_ADAM7: i32 = 1

// PNG image header
struct PNGHeader {
    width: i32,
    height: i32,
    bit_depth: i32,
    color_type: i32,
    compression: i32,
    filter: i32,
    interlace: i32,
}

// Loaded PNG image
struct PNGImage {
    width: i32,
    height: i32,
    channels: i32,
    bit_depth: i32,
    pixels: Vec<i32>,  // RGBA pixel data
    name: string,
    has_alpha: bool,
}

// Create empty PNG image
fn create_png_image(): PNGImage {
    return PNGImage {
        width: 0,
        height: 0,
        channels: 4,
        bit_depth: 8,
        pixels: Vec<i32>{},
        name: "",
        has_alpha: false,
    }
}

// Read 32-bit big-endian integer
fn read_u32_be(data: Vec<i32>, offset: i32): i32 {
    if (offset + 4 > data.len()) {
        return 0
    }
    return (data.get(offset) << 24) |
           (data.get(offset + 1) << 16) |
           (data.get(offset + 2) << 8) |
           data.get(offset + 3)
}

// Read byte
fn read_byte(data: Vec<i32>, offset: i32): i32 {
    if (offset >= data.len()) {
        return 0
    }
    return data.get(offset)
}

// Check PNG signature
fn check_signature(data: Vec<i32>): bool {
    if (data.len() < 8) {
        return false
    }

    for i in 0..8 {
        if (data.get(i) != PNG_SIGNATURE[i]) {
            return false
        }
    }

    return true
}

// Parse IHDR chunk
fn parse_ihdr(data: Vec<i32>, offset: i32): (PNGHeader, Bool) {
    let header = PNGHeader {
        width: 0,
        height: 0,
        bit_depth: 0,
        color_type: 0,
        compression: 0,
        filter: 0,
        interlace: 0,
    }

    if (offset + 13 > data.len()) {
        return (header, false)
    }

    header.width = read_u32_be(data, offset)
    header.height = read_u32_be(data, offset + 4)
    header.bit_depth = read_byte(data, offset + 8)
    header.color_type = read_byte(data, offset + 9)
    header.compression = read_byte(data, offset + 10)
    header.filter = read_byte(data, offset + 11)
    header.interlace = read_byte(data, offset + 12)

    // Validate
    if (header.width == 0 || header.height == 0) {
        return (header, false)
    }

    if (header.compression != 0) {
        return (header, false)  // Only deflate compression supported
    }

    return (header, true)
}

// Calculate CRC32
fn crc32(data: Vec<i32>, start: i32, length: i32): i32 {
    // CRC32 table (precomputed for polynomial 0xEDB88320)
    let crc = 0xFFFFFFFF

    for i in start..(start + length) {
        if (i >= data.len()) {
            break
        }
        let byte = data.get(i)
        // Simplified CRC - real implementation would use lookup table
        crc = crc ^ byte
        for j in 0..8 {
            if (crc & 1) != 0 {
                crc = (crc >> 1) ^ 0xEDB88320
            } else {
                crc = crc >> 1
            }
        }
    }

    return crc ^ 0xFFFFFFFF
}

// Get number of channels for color type
fn get_channels(color_type: i32): i32 {
    match color_type {
        COLOR_GRAYSCALE => 1,
        COLOR_RGB => 3,
        COLOR_INDEXED => 1,
        COLOR_GRAYSCALE_ALPHA => 2,
        COLOR_RGBA => 4,
        _ => 4,
    }
}

// Paeth predictor function
fn paeth_predictor(a: i32, b: i32, c: i32): i32 {
    let p = a + b - c
    let pa = abs(p - a)
    let pb = abs(p - b)
    let pc = abs(p - c)

    if (pa <= pb && pa <= pc) {
        return a
    } else if (pb <= pc) {
        return b
    } else {
        return c
    }
}

fn abs(x: i32): i32 {
    if (x < 0) { return -x }
    return x
}

// Apply PNG filters to scanline
fn unfilter_scanline(scanline: Vec<i32>, prev_scanline: Vec<i32>,
                      filter_type: i32, bpp: i32): Vec<i32> {
    let result = Vec<i32>{}
    let width = scanline.len()

    for i in 0..width {
        let x = scanline.get(i)
        let a = if i >= bpp { result.get(i - bpp) } else { 0 }
        let b = if prev_scanline.len() > 0 { prev_scanline.get(i) } else { 0 }
        let c = if i >= bpp && prev_scanline.len() > 0 { prev_scanline.get(i - bpp) } else { 0 }

        let value = match filter_type {
            FILTER_NONE => x,
            FILTER_SUB => (x + a) & 0xFF,
            FILTER_UP => (x + b) & 0xFF,
            FILTER_AVERAGE => (x + ((a + b) / 2)) & 0xFF,
            FILTER_PAETH => (x + paeth_predictor(a, b, c)) & 0xFF,
            _ => x,
        }

        result.add(value)
    }

    return result
}

// Decompress DEFLATE data (simplified - would use zlib in practice)
fn decompress_deflate(compressed: Vec<i32>): Vec<i32> {
    // This is a placeholder - real implementation would decompress DEFLATE
    // For now, we'll indicate that real zlib decompression is needed
    // Import from zlib_compression module in production

    // Try to use our zlib implementation
    // from zlib_compression import zlib_decompress
    // return zlib_decompress(compressed)

    return Vec<i32>{}  // Return empty for now
}

// Check if data is a valid PNG file
fn is_png_file(data: Vec<i32>): bool {
    return check_signature(data)
}

// Load PNG image (basic implementation)
fn load_png(data: Vec<i32>): (PNGImage, Bool) {
    let image = create_png_image()

    if (!check_signature(data)) {
        return (image, false)
    }

    // Parse chunks
    let offset = 8
    let header_found = false
    let header = PNGHeader {
        width: 0, height: 0, bit_depth: 0, color_type: 0,
        compression: 0, filter: 0, interlace: 0,
    }
    let palette = Vec<i32>{}
    let compressed_data = Vec<i32>{}
    let transparency = Vec<i32>{}

    while (offset + 12 <= data.len()) {
        let chunk_length = read_u32_be(data, offset)
        let chunk_type = read_u32_be(data, offset + 4)
        let chunk_data_start = offset + 8

        if (chunk_type == CHUNK_IHDR) {
            let (h, ok) = parse_ihdr(data, chunk_data_start)
            if (ok) {
                header = h
                header_found = true
            }
        } else if (chunk_type == CHUNK_PLTE) {
            // Parse palette
            for i in 0..chunk_length {
                palette.add(read_byte(data, chunk_data_start + i))
            }
        } else if (chunk_type == CHUNK_IDAT) {
            // Collect compressed image data
            for i in 0..chunk_length {
                compressed_data.add(read_byte(data, chunk_data_start + i))
            }
        } else if (chunk_type == CHUNK_tRNS) {
            // Transparency data
            for i in 0..chunk_length {
                transparency.add(read_byte(data, chunk_data_start + i))
            }
        } else if (chunk_type == CHUNK_IEND) {
            break
        }

        offset = offset + 12 + chunk_length
    }

    if (!header_found) {
        return (image, false)
    }

    image.width = header.width
    image.height = header.height
    image.bit_depth = header.bit_depth
    image.channels = get_channels(header.color_type)
    image.has_alpha = header.color_type == COLOR_RGBA ||
                      header.color_type == COLOR_GRAYSCALE_ALPHA ||
                      transparency.len() > 0

    // Decompress image data
    let decompressed = decompress_deflate(compressed_data)

    if (decompressed.len() == 0) {
        // Decompression not implemented - create placeholder
        let total = image.width * image.height * 4
        for i in 0..total {
            image.pixels.add(128)  // Gray placeholder
        }
        return (image, true)
    }

    // Unfilter and convert to RGBA
    let bpp = (image.channels * header.bit_depth + 7) / 8
    let scanline_length = image.width * bpp
    let prev_scanline = Vec<i32>{}

    let data_offset = 0
    for y in 0..image.height {
        if (data_offset >= decompressed.len()) {
            break
        }

        let filter_type = decompressed.get(data_offset)
        data_offset = data_offset + 1

        // Extract scanline
        let scanline = Vec<i32>{}
        for x in 0..scanline_length {
            if (data_offset < decompressed.len()) {
                scanline.add(decompressed.get(data_offset))
                data_offset = data_offset + 1
            } else {
                scanline.add(0)
            }
        }

        // Unfilter
        let unfiltered = unfilter_scanline(scanline, prev_scanline, filter_type, bpp)
        prev_scanline = unfiltered

        // Convert to RGBA
        for x in 0..image.width {
            let pixel_offset = x * bpp

            if (header.color_type == COLOR_RGBA) {
                image.pixels.add(unfiltered.get(pixel_offset))
                image.pixels.add(unfiltered.get(pixel_offset + 1))
                image.pixels.add(unfiltered.get(pixel_offset + 2))
                image.pixels.add(unfiltered.get(pixel_offset + 3))
            } else if (header.color_type == COLOR_RGB) {
                image.pixels.add(unfiltered.get(pixel_offset))
                image.pixels.add(unfiltered.get(pixel_offset + 1))
                image.pixels.add(unfiltered.get(pixel_offset + 2))
                image.pixels.add(255)
            } else if (header.color_type == COLOR_GRAYSCALE) {
                let gray = unfiltered.get(pixel_offset)
                image.pixels.add(gray)
                image.pixels.add(gray)
                image.pixels.add(gray)
                image.pixels.add(255)
            } else if (header.color_type == COLOR_GRAYSCALE_ALPHA) {
                let gray = unfiltered.get(pixel_offset)
                image.pixels.add(gray)
                image.pixels.add(gray)
                image.pixels.add(gray)
                image.pixels.add(unfiltered.get(pixel_offset + 1))
            } else if (header.color_type == COLOR_INDEXED) {
                let index = unfiltered.get(pixel_offset) * 3
                if (index + 2 < palette.len()) {
                    image.pixels.add(palette.get(index))
                    image.pixels.add(palette.get(index + 1))
                    image.pixels.add(palette.get(index + 2))

                    // Check transparency
                    let alpha = 255
                    if (unfiltered.get(pixel_offset) < transparency.len()) {
                        alpha = transparency.get(unfiltered.get(pixel_offset))
                    }
                    image.pixels.add(alpha)
                } else {
                    image.pixels.add(0)
                    image.pixels.add(0)
                    image.pixels.add(0)
                    image.pixels.add(255)
                }
            }
        }
    }

    return (image, true)
}

// Get pixel at coordinate
fn get_png_pixel(image: PNGImage, x: i32, y: i32): (Int, Int, Int, Int) {
    if (x < 0 || x >= image.width || y < 0 || y >= image.height) {
        return (0, 0, 0, 0)
    }

    let offset = (y * image.width + x) * 4
    if (offset + 4 > image.pixels.len()) {
        return (0, 0, 0, 0)
    }

    return (
        image.pixels.get(offset),
        image.pixels.get(offset + 1),
        image.pixels.get(offset + 2),
        image.pixels.get(offset + 3)
    )
}

// ============================================================================
// Tests
// ============================================================================

fn test_png_signature(): bool {
    let data = Vec<i32>{}
    for b in PNG_SIGNATURE {
        data.add(b)
    }

    assert(check_signature(data) == true, "Should detect PNG signature")

    let invalid = Vec<i32>{}
    for i in 0..8 {
        invalid.add(0)
    }

    assert(check_signature(invalid) == false, "Should reject invalid signature")

    return true
}

fn test_channels(): bool {
    assert(get_channels(COLOR_GRAYSCALE) == 1, "Grayscale = 1 channel")
    assert(get_channels(COLOR_RGB) == 3, "RGB = 3 channels")
    assert(get_channels(COLOR_RGBA) == 4, "RGBA = 4 channels")
    return true
}

fn test_paeth(): bool {
    // Test paeth predictor
    assert(paeth_predictor(10, 20, 5) == 20, "Paeth should choose b")
    assert(paeth_predictor(10, 10, 10) == 10, "Paeth should choose a when equal")
    return true
}

fn test_png_creation(): bool {
    let image = create_png_image()
    assert(image.width == 0, "Default width should be 0")
    assert(image.channels == 4, "Default channels should be 4")
    return true
}

fn run_all_tests(): bool {
    assert(test_png_signature(), "PNG signature test failed")
    assert(test_channels(), "Channels test failed")
    assert(test_paeth(), "Paeth predictor test failed")
    assert(test_png_creation(), "PNG creation test failed")
    return true
}
