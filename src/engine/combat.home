// Generals Game Engine - Combat System
// Unit combat, damage, and death handling
// Pure Home implementation - converted from Zig

// ============================================================================
// Damage Types (matching C&C Generals)
// ============================================================================

enum DamageType {
    ARMOR_PIERCING,  // Anti-tank rounds
    HOLLOW_POINT,    // Anti-infantry rounds
    SMALL_ARMS,      // Infantry weapons
    EXPLOSION,       // Explosives and artillery
    FIRE,            // Flame weapons
    LASER,           // Laser weapons (Particle Cannon)
    POISON,          // Chemical weapons (Toxin Tractor)
    SNIPER,          // Sniper rifles
    STRUCTURE,       // Building damage
    RADIATION,       // Nuclear damage
}

// ============================================================================
// Armor System (matching C&C Generals)
// ============================================================================

enum ArmorType {
    NONE,              // Unarmored
    INFANTRY,          // Soldiers
    INFANTRY_HERO,     // Black Lotus, Colonel Burton
    VEHICLE_LIGHT,     // Humvees, Technicals
    VEHICLE_MEDIUM,    // Crusader tanks, Battlemaster
    VEHICLE_HEAVY,     // Overlord tanks
    AIRCRAFT,          // Planes and helicopters
    BUILDING,          // Structures
    STRUCTURE_HEAVY,   // Bunkers, Command Centers
}

// ============================================================================
// Armor Multipliers (from Armor.ini)
// ============================================================================

struct ArmorMultipliers {
    fn get_multiplier(armor: ArmorType, damage: DamageType) -> Float {
        if armor == ArmorType::NONE {
            if damage == DamageType::ARMOR_PIERCING { return 1.0 }
            if damage == DamageType::HOLLOW_POINT { return 1.5 }
            if damage == DamageType::SMALL_ARMS { return 1.0 }
            if damage == DamageType::EXPLOSION { return 1.0 }
            if damage == DamageType::FIRE { return 1.0 }
            if damage == DamageType::LASER { return 1.0 }
            if damage == DamageType::POISON { return 1.5 }
            if damage == DamageType::SNIPER { return 2.0 }
            if damage == DamageType::STRUCTURE { return 1.0 }
            if damage == DamageType::RADIATION { return 1.0 }
        }

        if armor == ArmorType::INFANTRY {
            if damage == DamageType::ARMOR_PIERCING { return 0.5 }
            if damage == DamageType::HOLLOW_POINT { return 1.5 }
            if damage == DamageType::SMALL_ARMS { return 1.0 }
            if damage == DamageType::EXPLOSION { return 1.2 }
            if damage == DamageType::FIRE { return 1.5 }
            if damage == DamageType::LASER { return 0.8 }
            if damage == DamageType::POISON { return 2.0 }
            if damage == DamageType::SNIPER { return 1.5 }
            if damage == DamageType::STRUCTURE { return 0.5 }
            if damage == DamageType::RADIATION { return 1.5 }
        }

        if armor == ArmorType::INFANTRY_HERO {
            if damage == DamageType::ARMOR_PIERCING { return 0.3 }
            if damage == DamageType::HOLLOW_POINT { return 1.0 }
            if damage == DamageType::SMALL_ARMS { return 0.7 }
            if damage == DamageType::EXPLOSION { return 0.8 }
            if damage == DamageType::FIRE { return 1.0 }
            if damage == DamageType::LASER { return 0.6 }
            if damage == DamageType::POISON { return 0.5 }
            if damage == DamageType::SNIPER { return 1.2 }
            if damage == DamageType::STRUCTURE { return 0.3 }
            if damage == DamageType::RADIATION { return 1.0 }
        }

        if armor == ArmorType::VEHICLE_LIGHT {
            if damage == DamageType::ARMOR_PIERCING { return 1.5 }
            if damage == DamageType::HOLLOW_POINT { return 0.3 }
            if damage == DamageType::SMALL_ARMS { return 0.5 }
            if damage == DamageType::EXPLOSION { return 1.2 }
            if damage == DamageType::FIRE { return 0.8 }
            if damage == DamageType::LASER { return 1.0 }
            if damage == DamageType::POISON { return 0.0 }
            if damage == DamageType::SNIPER { return 0.5 }
            if damage == DamageType::STRUCTURE { return 0.8 }
            if damage == DamageType::RADIATION { return 1.0 }
        }

        if armor == ArmorType::VEHICLE_MEDIUM {
            if damage == DamageType::ARMOR_PIERCING { return 1.0 }
            if damage == DamageType::HOLLOW_POINT { return 0.1 }
            if damage == DamageType::SMALL_ARMS { return 0.25 }
            if damage == DamageType::EXPLOSION { return 1.0 }
            if damage == DamageType::FIRE { return 0.6 }
            if damage == DamageType::LASER { return 1.2 }
            if damage == DamageType::POISON { return 0.0 }
            if damage == DamageType::SNIPER { return 0.3 }
            if damage == DamageType::STRUCTURE { return 0.9 }
            if damage == DamageType::RADIATION { return 1.0 }
        }

        if armor == ArmorType::VEHICLE_HEAVY {
            if damage == DamageType::ARMOR_PIERCING { return 0.8 }
            if damage == DamageType::HOLLOW_POINT { return 0.05 }
            if damage == DamageType::SMALL_ARMS { return 0.1 }
            if damage == DamageType::EXPLOSION { return 0.9 }
            if damage == DamageType::FIRE { return 0.4 }
            if damage == DamageType::LASER { return 1.5 }
            if damage == DamageType::POISON { return 0.0 }
            if damage == DamageType::SNIPER { return 0.2 }
            if damage == DamageType::STRUCTURE { return 1.0 }
            if damage == DamageType::RADIATION { return 1.0 }
        }

        if armor == ArmorType::AIRCRAFT {
            if damage == DamageType::ARMOR_PIERCING { return 0.6 }
            if damage == DamageType::HOLLOW_POINT { return 0.2 }
            if damage == DamageType::SMALL_ARMS { return 0.4 }
            if damage == DamageType::EXPLOSION { return 1.5 }
            if damage == DamageType::FIRE { return 0.8 }
            if damage == DamageType::LASER { return 1.2 }
            if damage == DamageType::POISON { return 0.0 }
            if damage == DamageType::SNIPER { return 0.3 }
            if damage == DamageType::STRUCTURE { return 0.5 }
            if damage == DamageType::RADIATION { return 1.0 }
        }

        if armor == ArmorType::BUILDING {
            if damage == DamageType::ARMOR_PIERCING { return 0.5 }
            if damage == DamageType::HOLLOW_POINT { return 0.1 }
            if damage == DamageType::SMALL_ARMS { return 0.05 }
            if damage == DamageType::EXPLOSION { return 1.5 }
            if damage == DamageType::FIRE { return 1.2 }
            if damage == DamageType::LASER { return 1.0 }
            if damage == DamageType::POISON { return 0.0 }
            if damage == DamageType::SNIPER { return 0.1 }
            if damage == DamageType::STRUCTURE { return 1.0 }
            if damage == DamageType::RADIATION { return 1.2 }
        }

        if armor == ArmorType::STRUCTURE_HEAVY {
            if damage == DamageType::ARMOR_PIERCING { return 0.3 }
            if damage == DamageType::HOLLOW_POINT { return 0.05 }
            if damage == DamageType::SMALL_ARMS { return 0.02 }
            if damage == DamageType::EXPLOSION { return 1.0 }
            if damage == DamageType::FIRE { return 0.8 }
            if damage == DamageType::LASER { return 0.9 }
            if damage == DamageType::POISON { return 0.0 }
            if damage == DamageType::SNIPER { return 0.05 }
            if damage == DamageType::STRUCTURE { return 1.2 }
            if damage == DamageType::RADIATION { return 1.0 }
        }

        return 1.0  // Default
    }
}

// ============================================================================
// Weapon Types
// ============================================================================

enum WeaponType {
    RIFLE,
    MACHINE_GUN,
    CANNON,
    ROCKET,
    FLAMETHROWER,
    SNIPER,
}

// ============================================================================
// Weapon Bonus System
// ============================================================================

enum WeaponBonusCondition {
    GARRISONED,
    HORDE,
    VETERAN,
    ELITE,
    HERO,
    NATIONALISM,
    PLAYER_UPGRADE,
    DRONE_SPOTTING,
    ENTHUSIASTIC,
    FANATICISM,
    FRENZY_ONE,
    FRENZY_TWO,
    FRENZY_THREE,
}

enum WeaponBonusField {
    DAMAGE,
    RADIUS,
    RANGE,
    RATE_OF_FIRE,
    PRE_ATTACK,
}

struct WeaponBonus {
    damage_mult: Float,
    radius_mult: Float,
    range_mult: Float,
    rate_of_fire_mult: Float,
    pre_attack_mult: Float,

    fn init() -> WeaponBonus {
        let bonus = WeaponBonus {
            damage_mult: 1.0,
            radius_mult: 1.0,
            range_mult: 1.0,
            rate_of_fire_mult: 1.0,
            pre_attack_mult: 1.0,
        }
        return bonus
    }

    fn veteran() -> WeaponBonus {
        let bonus = WeaponBonus::init()
        bonus.damage_mult = 1.25
        return bonus
    }

    fn elite() -> WeaponBonus {
        let bonus = WeaponBonus::init()
        bonus.damage_mult = 1.50
        return bonus
    }

    fn hero() -> WeaponBonus {
        let bonus = WeaponBonus::init()
        bonus.damage_mult = 1.75
        return bonus
    }

    fn horde() -> WeaponBonus {
        let bonus = WeaponBonus::init()
        bonus.damage_mult = 1.25
        return bonus
    }
}

// ============================================================================
// Anti-Type Flags
// ============================================================================

struct AntiMask {
    airborne_vehicle: Bool,
    ground: Bool,
    projectile: Bool,
    small_missile: Bool,
    mine: Bool,
    airborne_infantry: Bool,
    ballistic_missile: Bool,
    parachute: Bool,

    fn init() -> AntiMask {
        let mask = AntiMask {
            airborne_vehicle: false,
            ground: true,
            projectile: false,
            small_missile: false,
            mine: false,
            airborne_infantry: false,
            ballistic_missile: false,
            parachute: false,
        }
        return mask
    }

    fn can_target_ground(self) -> Bool {
        return self.ground
    }

    fn can_target_air(self) -> Bool {
        return self.airborne_vehicle || self.airborne_infantry
    }
}

// ============================================================================
// Weapon Stats
// ============================================================================

struct WeaponStats {
    // Basic stats
    damage: Float,
    range: Float,
    fire_rate: Float,  // Seconds between shots
    projectile_speed: Float,
    area_of_effect: Float,  // 0 = single target
    weapon_type: WeaponType,

    // Enhanced properties
    damage_type: DamageType,
    anti_mask: AntiMask,
    clip_size: Int,  // 0 = infinite ammo
    clip_reload_time: Float,
    min_range: Float,
    scatter_radius: Float,
    piercing: Float,  // Armor penetration bonus

    fn rifle() -> WeaponStats {
        let weapon = WeaponStats {
            damage: 10.0,
            range: 200.0,
            fire_rate: 0.5,
            projectile_speed: 500.0,
            area_of_effect: 0.0,
            weapon_type: WeaponType::RIFLE,
            damage_type: DamageType::SMALL_ARMS,
            anti_mask: AntiMask::init(),
            clip_size: 30,
            clip_reload_time: 2.0,
            min_range: 0.0,
            scatter_radius: 5.0,
            piercing: 0.0,
        }
        weapon.anti_mask.ground = true
        return weapon
    }

    fn machine_gun() -> WeaponStats {
        let weapon = WeaponStats {
            damage: 5.0,
            range: 250.0,
            fire_rate: 0.1,
            projectile_speed: 600.0,
            area_of_effect: 0.0,
            weapon_type: WeaponType::MACHINE_GUN,
            damage_type: DamageType::SMALL_ARMS,
            anti_mask: AntiMask::init(),
            clip_size: 100,
            clip_reload_time: 3.0,
            min_range: 0.0,
            scatter_radius: 10.0,
            piercing: 0.0,
        }
        weapon.anti_mask.ground = true
        weapon.anti_mask.airborne_infantry = true
        return weapon
    }

    fn cannon() -> WeaponStats {
        let weapon = WeaponStats {
            damage: 50.0,
            range: 300.0,
            fire_rate: 2.0,
            projectile_speed: 400.0,
            area_of_effect: 30.0,
            weapon_type: WeaponType::CANNON,
            damage_type: DamageType::ARMOR_PIERCING,
            anti_mask: AntiMask::init(),
            clip_size: 0,  // Infinite
            clip_reload_time: 0.0,
            min_range: 0.0,
            scatter_radius: 0.0,
            piercing: 25.0,
        }
        weapon.anti_mask.ground = true
        return weapon
    }

    fn rocket() -> WeaponStats {
        let weapon = WeaponStats {
            damage: 75.0,
            range: 400.0,
            fire_rate: 3.0,
            projectile_speed: 300.0,
            area_of_effect: 50.0,
            weapon_type: WeaponType::ROCKET,
            damage_type: DamageType::EXPLOSION,
            anti_mask: AntiMask::init(),
            clip_size: 8,
            clip_reload_time: 5.0,
            min_range: 0.0,
            scatter_radius: 0.0,
            piercing: 0.0,
        }
        weapon.anti_mask.ground = true
        weapon.anti_mask.airborne_vehicle = true
        return weapon
    }
}

// ============================================================================
// Damage Calculator
// ============================================================================

struct DamageCalculator {
    fn calculate_damage(
        base_damage: Float,
        damage_type: DamageType,
        armor_type: ArmorType,
        piercing: Float,
        bonus: WeaponBonus,
    ) -> Float {
        // Apply weapon bonus
        let damage = base_damage * bonus.damage_mult

        // Apply armor multiplier
        let armor_mult = ArmorMultipliers::get_multiplier(armor_type, damage_type)
        damage = damage * armor_mult

        // Apply piercing (reduces armor effectiveness)
        if piercing > 0.0 {
            let pierce_factor = piercing / 100.0
            let armor_reduction = armor_mult - 1.0

            if armor_reduction < 0.0 {
                let reduced_armor = armor_reduction * (1.0 - pierce_factor)
                damage = base_damage * bonus.damage_mult * (1.0 + reduced_armor)
            }
        }

        // Random variation Â±10%
        let random_mult = 0.9 + (random() * 0.2)  // 0.9 to 1.1
        damage = damage * random_mult

        // Critical hit: 5% chance for 2x damage
        if random() < 0.05 {
            damage = damage * 2.0
        }

        return damage
    }

    fn should_hit(scatter_radius: Float, distance_to_target: Float) -> Bool {
        if scatter_radius <= 0.0 {
            return true
        }

        // Scatter increases with distance
        let effective_scatter = scatter_radius * (1.0 + distance_to_target / 100.0)

        // Roll for hit
        let scatter_roll = random() * effective_scatter
        return scatter_roll < scatter_radius
    }
}

// ============================================================================
// Combat Component
// ============================================================================

struct CombatComponent {
    weapon: WeaponStats,
    cooldown: Float,
    target_id: Int,
    has_target: Bool,
    aggressive: Bool,  // Auto-attack enemies in range

    fn init(weapon: WeaponStats) -> CombatComponent {
        let combat = CombatComponent {
            weapon: weapon,
            cooldown: 0.0,
            target_id: 0,
            has_target: false,
            aggressive: true,
        }
        return combat
    }

    fn can_fire(self) -> Bool {
        return self.cooldown <= 0.0
    }

    fn fire(self) {
        self.cooldown = self.weapon.fire_rate
    }

    fn update(self, dt: Float) {
        if self.cooldown > 0.0 {
            self.cooldown = self.cooldown - dt
            if self.cooldown < 0.0 {
                self.cooldown = 0.0
            }
        }
    }
}

// ============================================================================
// Unit Behavior
// ============================================================================

enum UnitBehavior {
    IDLE,
    MOVE,
    ATTACK,
    PATROL,
    GUARD,
    FOLLOW,
}

struct BehaviorComponent {
    state: UnitBehavior,
    patrol_points: Collection<Vector2>,
    patrol_count: Int,
    patrol_index: Int,
    guard_position: Vector2,
    follow_target_id: Int,
    has_follow_target: Bool,

    fn init() -> BehaviorComponent {
        let behavior = BehaviorComponent {
            state: UnitBehavior::IDLE,
            patrol_points: Collection::init(),
            patrol_count: 0,
            patrol_index: 0,
            guard_position: Vector2::init(0.0, 0.0),
            follow_target_id: 0,
            has_follow_target: false,
        }
        return behavior
    }

    fn set_patrol(self, points: Collection<Vector2>) {
        self.state = UnitBehavior::PATROL
        self.patrol_points = points
        self.patrol_count = points.len()
        self.patrol_index = 0
    }

    fn set_guard(self, position: Vector2) {
        self.state = UnitBehavior::GUARD
        self.guard_position = position
    }

    fn set_follow(self, target_id: Int) {
        self.state = UnitBehavior::FOLLOW
        self.follow_target_id = target_id
        self.has_follow_target = true
    }
}

// ============================================================================
// Combat System
// ============================================================================

struct CombatSystem {
    fn find_nearest_enemy(entities: Collection<Entity>, source_id: Int, max_range: Float) -> Int {
        let nearest_id = -1
        let nearest_dist = max_range

        let source = entities.get_by_id(source_id)
        if source == null {
            return -1
        }

        for i in 0..entities.len() {
            let target = entities.get(i)

            if !target.active { continue }
            if target.id == source_id { continue }
            if target.team == source.team { continue }

            let dx = target.position.x - source.position.x
            let dy = target.position.y - source.position.y
            let dist = sqrt(dx * dx + dy * dy)

            if dist < nearest_dist {
                nearest_dist = dist
                nearest_id = target.id
            }
        }

        return nearest_id
    }

    fn apply_damage(
        entity: Entity,
        base_damage: Float,
        damage_type: DamageType,
        piercing: Float,
        bonus: WeaponBonus,
    ) {
        // Determine armor type
        let armor_type = ArmorType::INFANTRY  // Default

        // Calculate effective damage
        let effective_damage = DamageCalculator::calculate_damage(
            base_damage,
            damage_type,
            armor_type,
            piercing,
            bonus
        )

        entity.health = entity.health - effective_damage

        // Check if unit died
        if entity.health <= 0.0 {
            entity.health = 0.0
            entity.active = false
        }
    }

    fn update_combat(entities: Collection<Entity>, dt: Float) {
        // Update attack cooldowns
        for i in 0..entities.len() {
            let entity = entities.get(i)
            if !entity.active { continue }

            if entity.has_combat {
                entity.combat.update(dt)
            }
        }

        // Process attacks
        for i in 0..entities.len() {
            let entity = entities.get(i)
            if !entity.active { continue }
            if !entity.has_combat { continue }

            // Find target if needed
            if entity.combat.aggressive && !entity.combat.has_target {
                let target_id = CombatSystem::find_nearest_enemy(
                    entities,
                    entity.id,
                    entity.combat.weapon.range
                )

                if target_id >= 0 {
                    entity.combat.target_id = target_id
                    entity.combat.has_target = true
                }
            }

            // Attack target if in range
            if entity.combat.has_target {
                let target = entities.get_by_id(entity.combat.target_id)

                if target == null || !target.active {
                    entity.combat.has_target = false
                    continue
                }

                // Check range
                let dx = target.position.x - entity.position.x
                let dy = target.position.y - entity.position.y
                let dist = sqrt(dx * dx + dy * dy)

                if dist <= entity.combat.weapon.range {
                    if entity.combat.can_fire() {
                        entity.combat.fire()

                        CombatSystem::apply_damage(
                            target,
                            entity.combat.weapon.damage,
                            entity.combat.weapon.damage_type,
                            entity.combat.weapon.piercing,
                            WeaponBonus::init()
                        )
                    }
                } else {
                    entity.combat.has_target = false
                }
            }
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

fn test_armor_multipliers() -> Bool {
    // Infantry takes more damage from hollow point
    let mult = ArmorMultipliers::get_multiplier(ArmorType::INFANTRY, DamageType::HOLLOW_POINT)
    assert(mult == 1.5, "Infantry vs hollow point")

    // Heavy armor resists small arms
    let mult2 = ArmorMultipliers::get_multiplier(ArmorType::VEHICLE_HEAVY, DamageType::SMALL_ARMS)
    assert(mult2 == 0.1, "Heavy armor vs small arms")

    return true
}

fn test_weapon_bonus() -> Bool {
    let veteran = WeaponBonus::veteran()
    assert(veteran.damage_mult == 1.25, "Veteran bonus")

    let elite = WeaponBonus::elite()
    assert(elite.damage_mult == 1.50, "Elite bonus")

    let hero = WeaponBonus::hero()
    assert(hero.damage_mult == 1.75, "Hero bonus")

    return true
}

fn test_anti_mask() -> Bool {
    let mask = AntiMask::init()
    mask.ground = true
    assert(mask.can_target_ground(), "Can target ground")
    assert(!mask.can_target_air(), "Cannot target air")

    mask.airborne_vehicle = true
    assert(mask.can_target_air(), "Can target air now")

    return true
}

fn test_weapon_stats() -> Bool {
    let rifle = WeaponStats::rifle()
    assert(rifle.damage == 10.0, "Rifle damage")
    assert(rifle.clip_size == 30, "Rifle clip")

    let cannon = WeaponStats::cannon()
    assert(cannon.piercing == 25.0, "Cannon piercing")

    return true
}

fn test_combat_component() -> Bool {
    let weapon = WeaponStats::rifle()
    let combat = CombatComponent::init(weapon)

    assert(combat.can_fire(), "Can fire initially")

    combat.fire()
    assert(!combat.can_fire(), "Cannot fire after shooting")

    combat.update(0.6)
    assert(combat.can_fire(), "Can fire after cooldown")

    return true
}

fn test_behavior_component() -> Bool {
    let behavior = BehaviorComponent::init()
    assert(behavior.state == UnitBehavior::IDLE, "Starts idle")

    behavior.set_guard(Vector2::init(100.0, 100.0))
    assert(behavior.state == UnitBehavior::GUARD, "Guard state")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_armor_multipliers(), "Test 1: Armor multipliers")
    assert(test_weapon_bonus(), "Test 2: Weapon bonus")
    assert(test_anti_mask(), "Test 3: Anti mask")
    assert(test_weapon_stats(), "Test 4: Weapon stats")
    assert(test_combat_component(), "Test 5: Combat component")
    assert(test_behavior_component(), "Test 6: Behavior component")
    return true
}
