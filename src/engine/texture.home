// Generals Texture Loading
// Supports TGA format (main format used by Generals)


// TGA file header (18 bytes)
struct TGAHeader {
    id_length: i32,           // u8
    color_map_type: i32,      // u8
    image_type: i32,          // u8
    color_map_start: i32,     // u16
    color_map_length: i32,    // u16
    color_map_depth: i32,     // u8
    x_offset: i32,            // u16
    y_offset: i32,            // u16
    width: i32,               // u16
    height: i32,              // u16
    pixel_depth: i32,         // u8
    image_descriptor: i32,    // u8
}

// TGA image types
enum TGAImageType {
    NO_IMAGE,
    COLOR_MAPPED,
    TRUE_COLOR,
    MONOCHROME,
    COLOR_MAPPED_RLE,
    TRUE_COLOR_RLE,
    MONOCHROME_RLE,
}

fn tga_image_type_to_int(image_type: TGAImageType): i32 {
    if (image_type == TGAImageType::NO_IMAGE) {
        return 0
    } else if (image_type == TGAImageType::COLOR_MAPPED) {
        return 1
    } else if (image_type == TGAImageType::TRUE_COLOR) {
        return 2
    } else if (image_type == TGAImageType::MONOCHROME) {
        return 3
    } else if (image_type == TGAImageType::COLOR_MAPPED_RLE) {
        return 9
    } else if (image_type == TGAImageType::TRUE_COLOR_RLE) {
        return 10
    } else if (image_type == TGAImageType::MONOCHROME_RLE) {
        return 11
    }
    return 0
}

// Texture pixel format
enum PixelFormat {
    RGB,
    RGBA,
    BGR,
    BGRA,
}

// Loaded texture data
struct Texture {
    width: i32,
    height: i32,
    format: PixelFormat,
    data: Vec<i32>,  // u8 bytes
}

fn create_texture(width: i32, height: i32, format: PixelFormat): Texture {
    let texture = Texture {}
    texture.width = width
    texture.height = height
    texture.format = format
    texture.data = Vec<i32> {}
    return texture
}

// Load texture from TGA file (simplified placeholder)
fn load_tga(file_path: string): Texture {
    // Placeholder - real implementation would:
    // 1. Read file from disk
    // 2. Parse TGA header (18 bytes)
    // 3. Validate image type (true color or true color RLE)
    // 4. Validate pixel depth (24 or 32 bits)
    // 5. Decompress RLE if needed
    // 6. Flip vertically if needed
    // 7. Return texture with pixel data

    let texture = create_texture(256, 256, PixelFormat::BGRA)

    // Create dummy 256x256 texture data (BGRA = 4 bytes per pixel)
    let num_pixels = 256 * 256 * 4
    for i in 0..num_pixels {
        texture.data.add(128)  // Gray placeholder
    }

    return texture
}

// Decompress RLE-encoded TGA data (simplified placeholder)
fn decompress_rle(source: Vec<i32>, dest: Vec<i32>, bytes_per_pixel: i32): bool {
    // Placeholder - real implementation would:
    // 1. Read packet headers
    // 2. Handle RLE packets (repeat pixel)
    // 3. Handle raw packets (copy directly)
    // 4. Fill destination buffer

    // For now, just copy data
    for i in 0..source.len() {
        if (i < dest.len()) {
            dest.set(i, source.get(i))
        }
    }

    return true
}

// Flip image vertically
fn flip_vertical(data: Vec<i32>, width: i32, height: i32, bytes_per_pixel: i32) {
    let row_size = width * bytes_per_pixel

    let y = 0
    while (y < (height / 2)) {
        let top_offset = y * row_size
        let bottom_offset = (height - 1 - y) * row_size

        // Swap rows
        for x in 0..row_size {
            let top_val = data.get(top_offset + x)
            let bottom_val = data.get(bottom_offset + x)
            data.set(top_offset + x, bottom_val)
            data.set(bottom_offset + x, top_val)
        }

        y = y + 1
    }
}

// Convert BGR to RGB (if needed for certain APIs)
fn convert_bgr_to_rgb(texture: Texture) {
    if (texture.format != PixelFormat::BGR && texture.format != PixelFormat::BGRA) {
        return  // Already in RGB format
    }

    let bytes_per_pixel = 3
    if (texture.format == PixelFormat::BGRA) {
        bytes_per_pixel = 4
    }

    let i = 0
    while (i < texture.data.len()) {
        // Swap B and R channels
        let b_val = texture.data.get(i)
        let r_val = texture.data.get(i + 2)
        texture.data.set(i, r_val)
        texture.data.set(i + 2, b_val)

        i = i + bytes_per_pixel
    }

    if (texture.format == PixelFormat::BGRA) {
        texture.format = PixelFormat::RGBA
    } else {
        texture.format = PixelFormat::RGB
    }
}

// Parse TGA header from byte data
fn parse_tga_header(data: Vec<i32>): TGAHeader {
    let header = TGAHeader {}

    if (data.len() < 18) {
        // Invalid header - return empty
        header.id_length = 0
        header.color_map_type = 0
        header.image_type = 0
        header.color_map_start = 0
        header.color_map_length = 0
        header.color_map_depth = 0
        header.x_offset = 0
        header.y_offset = 0
        header.width = 0
        header.height = 0
        header.pixel_depth = 0
        header.image_descriptor = 0
        return header
    }

    header.id_length = data.get(0)
    header.color_map_type = data.get(1)
    header.image_type = data.get(2)

    // u16 values need combining two bytes
    header.color_map_start = data.get(3) + (data.get(4) * 256)
    header.color_map_length = data.get(5) + (data.get(6) * 256)
    header.color_map_depth = data.get(7)

    header.x_offset = data.get(8) + (data.get(9) * 256)
    header.y_offset = data.get(10) + (data.get(11) * 256)
    header.width = data.get(12) + (data.get(13) * 256)
    header.height = data.get(14) + (data.get(15) * 256)

    header.pixel_depth = data.get(16)
    header.image_descriptor = data.get(17)

    return header
}

// Validate TGA header
fn validate_tga_header(header: TGAHeader): bool {
    // Check image type (true color or true color RLE)
    let true_color = tga_image_type_to_int(TGAImageType::TRUE_COLOR)
    let true_color_rle = tga_image_type_to_int(TGAImageType::TRUE_COLOR_RLE)

    if (header.image_type != true_color && header.image_type != true_color_rle) {
        return false
    }

    // Check pixel depth (24 or 32 bits)
    if (header.pixel_depth != 24 && header.pixel_depth != 32) {
        return false
    }

    // Check dimensions are reasonable
    if (header.width <= 0 || header.height <= 0) {
        return false
    }

    if (header.width > 4096 || header.height > 4096) {
        return false  // Sanity check
    }

    return true
}

// Get bytes per pixel from header
fn get_bytes_per_pixel(header: TGAHeader): i32 {
    return header.pixel_depth / 8
}

// Check if TGA origin is at top
fn is_origin_top(header: TGAHeader): bool {
    return (header.image_descriptor & 32) != 0  // Bit 5
}

// ============================================================================
// Tests
// ============================================================================

fn test_tga_header_size(): bool {
    // TGA header is 18 bytes
    let header = TGAHeader {}
    // Just verify we can create it
    assert(true, "TGA header should be creatable")
    return true
}

fn test_texture_creation(): bool {
    let texture = create_texture(256, 256, PixelFormat::RGBA)

    assert(texture.width == 256, "Width should be 256")
    assert(texture.height == 256, "Height should be 256")
    assert(texture.format == PixelFormat::RGBA, "Format should be RGBA")

    return true
}

fn test_parse_tga_header(): bool {
    let data = Vec<i32> {}

    // Create minimal valid TGA header (18 bytes)
    data.add(0)      // id_length
    data.add(0)      // color_map_type
    data.add(2)      // image_type (TRUE_COLOR)
    data.add(0)      // color_map_start low
    data.add(0)      // color_map_start high
    data.add(0)      // color_map_length low
    data.add(0)      // color_map_length high
    data.add(0)      // color_map_depth
    data.add(0)      // x_offset low
    data.add(0)      // x_offset high
    data.add(0)      // y_offset low
    data.add(0)      // y_offset high
    data.add(0)      // width low (256)
    data.add(1)      // width high
    data.add(0)      // height low (256)
    data.add(1)      // height high
    data.add(32)     // pixel_depth (32 bits)
    data.add(0)      // image_descriptor

    let header = parse_tga_header(data)

    assert(header.image_type == 2, "Image type should be 2 (TRUE_COLOR)")
    assert(header.width == 256, "Width should be 256")
    assert(header.height == 256, "Height should be 256")
    assert(header.pixel_depth == 32, "Pixel depth should be 32")

    return true
}

fn test_validate_tga_header(): bool {
    let header = TGAHeader {}
    header.id_length = 0
    header.color_map_type = 0
    header.image_type = 2  // TRUE_COLOR
    header.color_map_start = 0
    header.color_map_length = 0
    header.color_map_depth = 0
    header.x_offset = 0
    header.y_offset = 0
    header.width = 256
    header.height = 256
    header.pixel_depth = 32
    header.image_descriptor = 0

    assert(validate_tga_header(header), "Valid header should pass validation")

    // Test invalid pixel depth
    header.pixel_depth = 16
    assert(!validate_tga_header(header), "Invalid pixel depth should fail validation")

    return true
}

fn test_convert_bgr_to_rgb(): bool {
    let texture = create_texture(2, 2, PixelFormat::BGR)

    // Create BGR test data (2x2 = 4 pixels, 3 bytes each = 12 bytes)
    // BGR: Blue, Green, Red
    texture.data.add(255)  // B
    texture.data.add(0)    // G
    texture.data.add(0)    // R

    texture.data.add(0)    // B
    texture.data.add(255)  // G
    texture.data.add(0)    // R

    texture.data.add(0)    // B
    texture.data.add(0)    // G
    texture.data.add(255)  // R

    texture.data.add(128)  // B
    texture.data.add(128)  // G
    texture.data.add(128)  // R

    convert_bgr_to_rgb(texture)

    assert(texture.format == PixelFormat::RGB, "Format should be converted to RGB")

    // First pixel should now be RGB (was BGR with B=255)
    assert(texture.data.get(0) == 0, "R should be 0 (was B)")
    assert(texture.data.get(1) == 0, "G should be 0")
    assert(texture.data.get(2) == 255, "B should be 255 (was R)")

    return true
}

fn run_all_tests(): bool {
    assert(test_tga_header_size(), "TGA header size test failed")
    assert(test_texture_creation(), "Texture creation test failed")
    assert(test_parse_tga_header(), "Parse TGA header test failed")
    assert(test_validate_tga_header(), "Validate TGA header test failed")
    assert(test_convert_bgr_to_rgb(), "Convert BGR to RGB test failed")
    return true
}
