// Object INI Parser - Unit and Building Definition Parser
// Parses Object/*.ini files for unit/building/structure definitions
// Used for defining all game objects in C&C Generals


// Object categories (EditorSorting)
enum ObjectCategory {
    Unit,
    Infantry,
    Vehicle,
    Aircraft,
    Structure,
    Prop,
    System,
    Misc,
}

// Object sides/factions
enum ObjectSide {
    America,
    China,
    GLA,
    Civilian,
    Neutral,
}

// Weapon slot types
enum WeaponSlot {
    Primary,
    Secondary,
    Tertiary,
}

// ============================================================================
// Object Components
// ============================================================================

// Weapon set definition
struct WeaponSetDef {
    conditions: string,
    primary: string,
    secondary: string,
    tertiary: string,
    preferred_against: HashMap<String, String>,
}

// Armor set definition
struct ArmorSetDef {
    conditions: string,
    armor: string,
    damage_fx: string,
}

// Draw module definition
struct DrawModuleDef {
    module_type: string,
    tag: string,
    model: string,
    turret: string,
    show_sub_objects: Vec<string>,
    hide_sub_objects: Vec<string>,
    condition_states: Vec<ConditionStateDef>,
}

// Condition state for draw module
struct ConditionStateDef {
    conditions: Vec<string>,
    model: string,
    turret: string,
    show_sub_objects: Vec<string>,
    hide_sub_objects: Vec<string>,
    animation: string,
    animation_mode: string,
}

// Behavior module definition
struct BehaviorModuleDef {
    module_type: string,
    tag: string,
    properties: HashMap<String, String>,
}

// Body module definition
struct BodyModuleDef {
    module_type: string,
    tag: string,
    max_health: f64,
    initial_health: f64,
}

// Locomotor definition
struct LocomotorDef {
    set_name: string,
    speed: f64,
    turn_rate: f64,
    locomotor: string,
}

// ============================================================================
// Complete Object Definition
// ============================================================================

struct ObjectDef {
    name: string,
    display_name: string,
    side: ObjectSide,
    category: ObjectCategory,
    prerequisites: Vec<string>,
    select_portrait: string,
    button_image: string,
    upgrade_cameos: Vec<string>,
    build_cost: i32,
    build_time: f64,
    vision_range: f64,
    shroud_clearing_range: f64,
    transport_slot_count: i32,
    command_set: string,
    weapon_sets: Vec<WeaponSetDef>,
    armor_sets: Vec<ArmorSetDef>,
    draw_modules: Vec<DrawModuleDef>,
    behavior_modules: Vec<BehaviorModuleDef>,
    body_module: BodyModuleDef,
    locomotor_sets: Vec<LocomotorDef>,
    kindof: Vec<string>,
    is_selectable: bool,
    is_prerequsite_for: Vec<string>,
    unit_specific_sounds: HashMap<String, String>,
    raw_properties: HashMap<String, String>,
}

// Create empty object definition
fn create_object_def(name: string): ObjectDef {
    return ObjectDef {
        name: name,
        display_name: "",
        side: ObjectSide::Neutral,
        category: ObjectCategory::Misc,
        prerequisites: Vec<string>{},
        select_portrait: "",
        button_image: "",
        upgrade_cameos: Vec<string>{},
        build_cost: 0,
        build_time: 0.0,
        vision_range: 0.0,
        shroud_clearing_range: 0.0,
        transport_slot_count: 0,
        command_set: "",
        weapon_sets: Vec<WeaponSetDef>{},
        armor_sets: Vec<ArmorSetDef>{},
        draw_modules: Vec<DrawModuleDef>{},
        behavior_modules: Vec<BehaviorModuleDef>{},
        body_module: BodyModuleDef {
            module_type: "",
            tag: "",
            max_health: 100.0,
            initial_health: 100.0,
        },
        locomotor_sets: Vec<LocomotorDef>{},
        kindof: Vec<string>{},
        is_selectable: true,
        is_prerequsite_for: Vec<string>{},
        unit_specific_sounds: HashMap<String, String>{},
        raw_properties: HashMap<String, String>{},
    }
}

// ============================================================================
// Parser
// ============================================================================

// Trim whitespace
fn trim(s: string): string {
    let start = 0
    let end = s.len()
    while (start < end && is_whitespace(s.char_at(start))) {
        start = start + 1
    }
    while (end > start && is_whitespace(s.char_at(end - 1))) {
        end = end - 1
    }
    return s.substring(start, end)
}

fn is_whitespace(c: i32): bool {
    return c == 32 || c == 9 || c == 10 || c == 13
}

// Check if line is comment or empty
fn is_comment_or_empty(line: string): bool {
    let trimmed = trim(line)
    if (trimmed.len() == 0) {
        return true
    }
    return trimmed.starts_with(";") || trimmed.starts_with("//")
}

// Check if line starts Object block
fn is_object_start(line: string): bool {
    let trimmed = trim(line)
    return trimmed.starts_with("Object ")
}

// Check if line is End marker
fn is_end_marker(line: string): bool {
    return trim(line) == "End"
}

// Extract object name from Object line
fn extract_object_name(line: string): string {
    let trimmed = trim(line)
    if (trimmed.starts_with("Object ")) {
        return trim(trimmed.substring(7, trimmed.len()))
    }
    return ""
}

// Parse property line (key = value or key value)
fn parse_property(line: string): (String, String) {
    let trimmed = trim(line)

    // Find = sign or first space
    let eq_pos = -1
    let space_pos = -1

    for i in 0..trimmed.len() {
        let c = trimmed.char_at(i)
        if (c == 61 && eq_pos < 0) {  // "="
            eq_pos = i
        }
        if (c == 32 || c == 9) && space_pos < 0 && eq_pos < 0 {  // space/tab
            space_pos = i
        }
    }

    if (eq_pos > 0) {
        let key = trim(trimmed.substring(0, eq_pos))
        let value = trim(trimmed.substring(eq_pos + 1, trimmed.len()))
        return (key, value)
    } else if (space_pos > 0) {
        let key = trim(trimmed.substring(0, space_pos))
        let value = trim(trimmed.substring(space_pos, trimmed.len()))
        return (key, value)
    }

    return (trimmed, "")
}

// Parse integer value
fn parse_int(s: string): i32 {
    let result = 0
    let negative = false
    let start = 0

    if (s.len() > 0 && s.char_at(0) == 45) {  // "-"
        negative = true
        start = 1
    }

    for i in start..s.len() {
        let c = s.char_at(i)
        if (c >= 48 && c <= 57) {  // "0"-"9"
            result = result * 10 + (c - 48)
        } else {
            break
        }
    }

    if (negative) {
        return -result
    }
    return result
}

// Parse float value
fn parse_float(s: string): f64 {
    // Simplified float parsing
    let parts = split_by_char(s, 46)  // "."
    let integer_part = parse_int(parts.get(0))
    let decimal_part = 0.0

    if (parts.len() > 1) {
        let dec_str = parts.get(1)
        let dec_int = parse_int(dec_str)
        let divisor = 1.0
        for i in 0..dec_str.len() {
            divisor = divisor * 10.0
        }
        decimal_part = (dec_int as Float) / divisor
    }

    if (s.starts_with("-")) {
        return -((integer_part as Float) + decimal_part)
    }
    return (integer_part as Float) + decimal_part
}

// Split by character
fn split_by_char(s: string, ch: i32): Vec<string> {
    let parts = Vec<string>{}
    let current = ""

    for i in 0..s.len() {
        let c = s.char_at(i)
        if (c == ch) {
            parts.add(current)
            current = ""
        } else {
            current = current + String::char_from_code(c)
        }
    }

    parts.add(current)
    return parts
}

// Split by space
fn split_by_space(s: string): Vec<string> {
    let parts = Vec<string>{}
    let current = ""

    for i in 0..s.len() {
        let c = s.char_at(i)
        if (c == 32 || c == 9) {
            if (current.len() > 0) {
                parts.add(current)
                current = ""
            }
        } else {
            current = current + String::char_from_code(c)
        }
    }

    if (current.len() > 0) {
        parts.add(current)
    }

    return parts
}

// Parse side from string
fn parse_side(s: string): ObjectSide {
    let lower = s.to_lowercase()
    if (lower == "america" || lower == "usa") {
        return ObjectSide::America
    } else if (lower == "china") {
        return ObjectSide::China
    } else if (lower == "gla") {
        return ObjectSide::GLA
    } else if (lower == "civilian") {
        return ObjectSide::Civilian
    }
    return ObjectSide::Neutral
}

// Parse category from string
fn parse_category(s: string): ObjectCategory {
    let upper = s.to_uppercase()
    if (upper == "UNIT") {
        return ObjectCategory::Unit
    } else if (upper == "INFANTRY") {
        return ObjectCategory::Infantry
    } else if (upper == "VEHICLE") {
        return ObjectCategory::Vehicle
    } else if (upper == "AIRCRAFT") {
        return ObjectCategory::Aircraft
    } else if (upper == "STRUCTURE") {
        return ObjectCategory::Structure
    } else if (upper == "PROP") {
        return ObjectCategory::Prop
    } else if (upper == "SYSTEM") {
        return ObjectCategory::System
    }
    return ObjectCategory::Misc
}

// Split lines
fn split_lines(text: string): Vec<string> {
    let lines = Vec<string>{}
    let current = ""

    for i in 0..text.len() {
        let c = text.char_at(i)
        if (c == 10) {
            lines.add(current)
            current = ""
        } else if (c != 13) {
            current = current + String::char_from_code(c)
        }
    }

    if (current.len() > 0) {
        lines.add(current)
    }

    return lines
}

// Parse Object INI content
fn parse_object_ini(content: string): Vec<ObjectDef> {
    let objects = Vec<ObjectDef>{}
    let lines = split_lines(content)

    let current_object: ObjectDef = create_object_def("")
    let in_object = false
    let block_depth = 0
    let current_block = ""

    for i in 0..lines.len() {
        let line = lines.get(i)

        if (is_comment_or_empty(line)) {
            continue
        }

        let trimmed = trim(line)

        if (is_object_start(line) && !in_object) {
            current_object = create_object_def(extract_object_name(line))
            in_object = true
            block_depth = 0
            current_block = ""

        } else if (in_object) {
            // Track nested blocks
            if trimmed.starts_with("Draw ") || trimmed.starts_with("Body ") ||
               trimmed.starts_with("Behavior ") || trimmed.starts_with("WeaponSet") ||
               trimmed.starts_with("ArmorSet") || trimmed.starts_with("ConditionState") ||
               trimmed.starts_with("LocomotorSet") || trimmed.starts_with("UnitSpecificSounds") {
                block_depth = block_depth + 1
                current_block = trimmed
            } else if (is_end_marker(line)) {
                if (block_depth > 0) {
                    block_depth = block_depth - 1
                    current_block = ""
                } else {
                    // End of object
                    if (current_object.name.len() > 0) {
                        objects.add(current_object)
                    }
                    in_object = false
                }
            } else if (block_depth == 0) {
                // Top-level property
                let (key, value) = parse_property(trimmed)
                apply_property(current_object, key, value)
            }
        }
    }

    return objects
}

// Apply a property to object definition
fn apply_property(obj: ObjectDef, key: string, value: string) {
    if (key == "DisplayName") {
        obj.display_name = value
    } else if (key == "Side") {
        obj.side = parse_side(value)
    } else if (key == "EditorSorting") {
        obj.category = parse_category(value)
    } else if (key == "SelectPortrait") {
        obj.select_portrait = value
    } else if (key == "ButtonImage") {
        obj.button_image = value
    } else if (key == "BuildCost") {
        obj.build_cost = parse_int(value)
    } else if (key == "BuildTime") {
        obj.build_time = parse_float(value)
    } else if (key == "VisionRange") {
        obj.vision_range = parse_float(value)
    } else if (key == "ShroudClearingRange") {
        obj.shroud_clearing_range = parse_float(value)
    } else if (key == "TransportSlotCount") {
        obj.transport_slot_count = parse_int(value)
    } else if (key == "CommandSet") {
        obj.command_set = value
    } else if (key == "KindOf") {
        obj.kindof = split_by_space(value)
    } else if (key.starts_with("UpgradeCameo")) {
        obj.upgrade_cameos.add(value)
    } else if (key.starts_with("Prerequisite")) {
        obj.prerequisites.add(value)
    } else {
        // Store unparsed properties
        obj.raw_properties.set(key, value)
    }
}

// ============================================================================
// Object Database
// ============================================================================

struct ObjectDatabase {
    objects: HashMap<String, ObjectDef>,
    by_side: HashMap<String, Vec<string>>,
    by_category: HashMap<String, Vec<string>>,
}

// ============================================================================
// Tests
// ============================================================================

fn test_parse_simple(): bool {
    let content = """
Object TestUnit
  DisplayName = OBJECT:TestUnit
  Side = America
  EditorSorting = VEHICLE
  BuildCost = 1000
  BuildTime = 10.5
End
"""
    let objects = parse_object_ini(content)

    assert(objects.len() == 1, "Should have 1 object")

    let obj = objects.get(0)
    assert(obj.name == "TestUnit", "Name should match")
    assert(obj.side == ObjectSide::America, "Side should be America")
    assert(obj.category == ObjectCategory::Vehicle, "Category should be Vehicle")
    assert(obj.build_cost == 1000, "BuildCost should be 1000")

    return true
}

fn test_database(): bool {
    let db = ObjectDatabase::init()

    let content = """
Object Unit1
  Side = America
End

Object Unit2
  Side = China
End
"""
    let count = db.load_file(content)
    assert(count == 2, "Should load 2 objects")
    assert(db.has_object("Unit1"), "Should have Unit1")
    assert(db.has_object("Unit2"), "Should have Unit2")

    return true
}

fn test_parse_float(): bool {
    assert(parse_float("10.5") == 10.5, "Should parse 10.5")
    assert(parse_float("100") == 100.0, "Should parse 100")
    return true
}

fn run_all_tests(): bool {
    assert(test_parse_simple(), "Parse simple test failed")
    assert(test_database(), "Database test failed")
    assert(test_parse_float(), "Float parsing test failed")
    return true
}
