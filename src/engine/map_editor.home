// Map Editor for C&C Generals Zero Hour
// Terrain editing, texture painting, object placement, trigger editor, lighting
// Written in Home language

// Editor modes
enum EditorMode {
    TERRAIN = 0,
    TEXTURE = 1,
    OBJECTS = 2,
    TRIGGERS = 3,
    LIGHTING = 4,
    PLAYTEST = 5,
}

// Terrain edit modes
enum TerrainEditMode {
    RAISE = 0,
    LOWER = 1,
    FLATTEN = 2,
    SMOOTH = 3,
    RAMP = 4,
}

// Brush shapes
enum BrushShape {
    CIRCLE = 0,
    SQUARE = 1,
    CUSTOM = 2,
}

// Terrain brush
struct TerrainBrush {
    shape: BrushShape,
    radius: f64,
    strength: f64,
    falloff: f64,
    edit_mode: TerrainEditMode,
}

// Texture painter
struct TexturePainter {
    current_texture: i32,
    brush_size: f64,
    brush_strength: f64,
    blend_mode: TextureBlendMode,
}

// Object placement tool
struct ObjectPlacementTool {
    current_template: string,
    snap_to_grid: bool,
    grid_size: f64,
    rotation: f64,
    preview_object: PlacedObject?,
}

// Trigger editor
struct TriggerEditor {
    triggers: Vec<EditorTrigger>,
    selected_trigger: i32,
}

// Lighting editor
struct LightingEditor {
    lights: Vec<EditorLight>,
    ambient_light: Color,
    sun_direction: Vec3,
    sun_color: Color,
    sun_intensity: f64,
}

// Map validator
struct MapValidator {
    errors: Vec<ValidationError>,
    warnings: Vec<ValidationWarning>,
}

// Map editor main
struct MapEditor {
    mode: EditorMode,
    map: EditorMap,
    terrain_brush: TerrainBrush,
    texture_painter: TexturePainter,
    object_tool: ObjectPlacementTool,
    trigger_editor: TriggerEditor,
    lighting_editor: LightingEditor,
    validator: MapValidator,
    is_playtest_mode: bool,
}

// Helper structs
struct HeightMap {
    width: i32,
    height: i32,
    heights: Vec<Vec<f64>>,
}

struct TextureMap {
    width: i32,
    height: i32,
    texture_layers: Vec<TextureLayer>,
}

struct TextureLayer {
    texture_id: i32,
    weights: Vec<Vec<f64>>,
}

struct PlacedObject {
    template: string,
    x: f64,
    y: f64,
    rotation: f64,
}

struct EditorTrigger {
    id: i32,
    name: string,
    conditions: Vec<string>,
    actions: Vec<string>,
}

enum LightType {
    POINT = 0,
    SPOT = 1,
    DIRECTIONAL = 2,
}

struct EditorLight {
    id: i32,
    light_type: LightType,
    position: Vec3,
    direction: Vec3,
    color: Color,
    radius: f64,
    angle: f64,
}

struct EditorMap {
    width: i32,
    height: i32,
    heightmap: HeightMap,
    texture_map: TextureMap,
    objects: Vec<PlacedObject>,
    triggers: Vec<EditorTrigger>,
}

struct ValidationError {
    message: string,
}

struct ValidationWarning {
    message: string,
}

struct GridCell {
    x: i32,
    y: i32,
}

struct Color {
    r: f64,
    g: f64,
    b: f64,
    a: f64,
}

struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

enum TextureBlendMode {
    REPLACE = 0,
    ADD = 1,
    SUBTRACT = 2,
}

// Helper functions
fn max(a: i32, b: i32): i32 {
    if (a > b) {
        return a
    }
    return b
}

fn min(a: i32, b: i32): i32 {
    if (a < b) {
        return a
    }
    return b
}

fn sqrt(x: f64): f64 {
    if (x <= 0.0) {
        return 0.0
    }
    let guess = x / 2.0
    let epsilon = 0.01
    let max_iter = 10
    let iter = 0
    while (iter < max_iter) {
        let next = (guess + x / guess) / 2.0
        if (abs(next - guess) < epsilon) {
            return next
        }
        guess = next
        iter = iter + 1
    }
    return guess
}

fn abs(x: f64): f64 {
    if (x < 0.0) {
        return -x
    }
    return x
}

fn pow(base: f64, exp: f64): f64 {
    // Simple approximation for positive exponents
    if (exp == 0.0) {
        return 1.0
    }
    let result = base
    let count = exp as Int
    for i in 1..count {
        result = result * base
    }
    return result
}

// Tests
test "TerrainBrush: init" {
    let brush = TerrainBrush::init()

    assert brush.shape == BrushShape::CIRCLE
    assert brush.radius == 5.0
    assert brush.strength == 1.0
}

test "TerrainBrush: set radius" {
    let brush = TerrainBrush::init()

    brush.set_radius(10.0)

    assert brush.radius == 10.0
}

test "TerrainBrush: set strength" {
    let brush = TerrainBrush::init()

    brush.set_strength(2.0)

    assert brush.strength == 2.0
}

test "TerrainBrush: set edit mode" {
    let brush = TerrainBrush::init()

    brush.set_edit_mode(TerrainEditMode::LOWER)

    assert brush.edit_mode == TerrainEditMode::LOWER
}

test "TerrainBrush: distance calculation" {
    let brush = TerrainBrush::init()

    let dist = brush.distance_to_center(3, 4, 0, 0)

    assert dist == 5.0
}

test "TerrainBrush: calculate influence" {
    let brush = TerrainBrush::init()
    brush.radius = 10.0

    let influence_close = brush.calculate_influence(2.0)
    let influence_far = brush.calculate_influence(9.0)

    assert influence_close > influence_far
}

test "TexturePainter: init" {
    let painter = TexturePainter::init()

    assert painter.current_texture == 0
    assert painter.brush_size == 5.0
}

test "TexturePainter: select texture" {
    let painter = TexturePainter::init()

    painter.select_texture(3)

    assert painter.current_texture == 3
}

test "TexturePainter: set brush size" {
    let painter = TexturePainter::init()

    painter.set_brush_size(10.0)

    assert painter.brush_size == 10.0
}

test "TexturePainter: set blend mode" {
    let painter = TexturePainter::init()

    painter.set_blend_mode(TextureBlendMode::ADD)

    assert painter.blend_mode == TextureBlendMode::ADD
}

test "ObjectPlacementTool: init" {
    let tool = ObjectPlacementTool::init()

    assert tool.snap_to_grid
    assert tool.grid_size == 1.0
    assert tool.rotation == 0.0
}

test "ObjectPlacementTool: select template" {
    let tool = ObjectPlacementTool::init()

    tool.select_template("Tank")

    assert tool.current_template == "Tank"
}

test "ObjectPlacementTool: rotate object" {
    let tool = ObjectPlacementTool::init()

    tool.rotate_object(45.0)

    assert tool.rotation == 45.0
}

test "ObjectPlacementTool: toggle grid snap" {
    let tool = ObjectPlacementTool::init()

    tool.toggle_grid_snap()

    assert !tool.snap_to_grid
}

test "ObjectPlacementTool: snap to grid" {
    let tool = ObjectPlacementTool::init()
    tool.grid_size = 5.0

    let snapped = tool.snap_to_grid_coord(12.7)

    assert snapped == 10.0
}

test "ObjectPlacementTool: place object" {
    let tool = ObjectPlacementTool::init()
    tool.select_template("Tank")

    let objects = Vec::new()
    let obj = tool.place_object(objects, 10.5, 20.3)

    assert objects.count() == 1
    assert obj.template == "Tank"
}

test "TriggerEditor: init" {
    let editor = TriggerEditor::init()

    assert editor.get_trigger_count() == 0
    assert editor.selected_trigger == -1
}

test "TriggerEditor: create trigger" {
    let editor = TriggerEditor::init()

    let id = editor.create_trigger("Test Trigger")

    assert editor.get_trigger_count() == 1
    assert id == 0
}

test "TriggerEditor: delete trigger" {
    let editor = TriggerEditor::init()

    let id = editor.create_trigger("Test")
    editor.delete_trigger(id)

    assert editor.get_trigger_count() == 0
}

test "TriggerEditor: add condition" {
    let editor = TriggerEditor::init()

    let id = editor.create_trigger("Test")
    editor.add_condition(id, "UnitEntersArea", "area1")

    let trigger = editor.triggers.get(0)
    assert trigger.conditions.count() == 1
}

test "TriggerEditor: add action" {
    let editor = TriggerEditor::init()

    let id = editor.create_trigger("Test")
    editor.add_action(id, "SpawnUnit", "unit1")

    let trigger = editor.triggers.get(0)
    assert trigger.actions.count() == 1
}

test "TriggerEditor: select trigger" {
    let editor = TriggerEditor::init()

    let id = editor.create_trigger("Test")
    editor.select_trigger(id)

    assert editor.selected_trigger == id
}

test "LightingEditor: init" {
    let editor = LightingEditor::init()

    assert editor.get_light_count() == 0
    assert editor.sun_intensity == 1.0
}

test "LightingEditor: add point light" {
    let editor = LightingEditor::init()

    let color = Color::init(1.0, 1.0, 1.0, 1.0)
    let id = editor.add_point_light(10.0, 20.0, 5.0, color, 15.0)

    assert editor.get_light_count() == 1
    assert id == 0
}

test "LightingEditor: add spot light" {
    let editor = LightingEditor::init()

    let color = Color::init(1.0, 1.0, 1.0, 1.0)
    let id = editor.add_spot_light(10.0, 20.0, 5.0, 0.0, -1.0, 0.0, color, 45.0)

    assert editor.get_light_count() == 1
}

test "LightingEditor: remove light" {
    let editor = LightingEditor::init()

    let color = Color::init(1.0, 1.0, 1.0, 1.0)
    let id = editor.add_point_light(10.0, 20.0, 5.0, color, 15.0)
    editor.remove_light(id)

    assert editor.get_light_count() == 0
}

test "LightingEditor: set ambient light" {
    let editor = LightingEditor::init()

    editor.set_ambient_light(0.5, 0.5, 0.5)

    assert editor.ambient_light.r == 0.5
}

test "LightingEditor: set sun direction" {
    let editor = LightingEditor::init()

    editor.set_sun_direction(1.0, -1.0, 0.0)

    assert editor.sun_direction.x == 1.0
}

test "MapValidator: init" {
    let validator = MapValidator::init()

    assert !validator.has_errors()
    assert validator.get_error_count() == 0
}

test "MapValidator: validate empty map" {
    let validator = MapValidator::init()
    let map = EditorMap::init(128, 128)

    let is_valid = validator.validate(map)

    assert !is_valid  // Should fail - no spawn points
    assert validator.has_errors()
}

test "MapValidator: check spawn points" {
    let validator = MapValidator::init()
    let map = EditorMap::init(128, 128)

    // Add spawn points
    map.objects.add(PlacedObject::init("SpawnPoint", 10.0, 10.0, 0.0))
    map.objects.add(PlacedObject::init("SpawnPoint", 100.0, 100.0, 0.0))

    validator.validate(map)

    assert !validator.has_errors()  // Should pass with 2 spawn points
}

test "MapValidator: check terrain size" {
    let validator = MapValidator::init()
    let map = EditorMap::init(32, 32)  // Too small

    validator.validate(map)

    assert validator.has_errors()
}

test "HeightMap: init" {
    let heightmap = HeightMap::init(10, 10)

    assert heightmap.width == 10
    assert heightmap.height == 10
}

test "HeightMap: get and set height" {
    let heightmap = HeightMap::init(10, 10)

    heightmap.set_height(5, 5, 10.0)
    let height = heightmap.get_height(5, 5)

    assert height == 10.0
}

test "HeightMap: get average height" {
    let heightmap = HeightMap::init(10, 10)

    heightmap.set_height(5, 5, 10.0)
    heightmap.set_height(5, 6, 20.0)
    heightmap.set_height(6, 5, 30.0)

    let avg = heightmap.get_average_height_around(5, 5)

    assert avg > 0.0
}

test "TextureMap: init" {
    let tex_map = TextureMap::init(10, 10)

    assert tex_map.width == 10
    assert tex_map.height == 10
}

test "TextureMap: set and get texture weight" {
    let tex_map = TextureMap::init(10, 10)

    tex_map.set_texture(5, 5, 1, 0.8)
    let weight = tex_map.get_texture_weight(5, 5, 1)

    assert weight == 0.8
}

test "MapEditor: init" {
    let editor = MapEditor::init(128, 128)

    assert editor.mode == EditorMode::TERRAIN
    assert !editor.is_playtest_mode
}

test "MapEditor: set mode" {
    let editor = MapEditor::init(128, 128)

    editor.set_mode(EditorMode::TEXTURE)

    assert editor.mode == EditorMode::TEXTURE
}

test "MapEditor: validate map" {
    let editor = MapEditor::init(128, 128)

    // Add minimum required elements
    editor.map.objects.add(PlacedObject::init("SpawnPoint", 10.0, 10.0, 0.0))
    editor.map.objects.add(PlacedObject::init("SpawnPoint", 100.0, 100.0, 0.0))

    let is_valid = editor.validate_map()

    assert is_valid
}

test "MapEditor: enter playtest mode" {
    let editor = MapEditor::init(128, 128)

    editor.set_mode(EditorMode::PLAYTEST)

    assert editor.is_playtest_mode
}

test "MapEditor: exit playtest mode" {
    let editor = MapEditor::init(128, 128)

    editor.set_mode(EditorMode::PLAYTEST)
    editor.set_mode(EditorMode::TERRAIN)

    assert !editor.is_playtest_mode
}
