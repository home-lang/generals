// BIG Archive Reader - Pure Home Implementation
// Reads EA's .big archive format used by C&C Generals Zero Hour
//
// BIG File Format:
// - Magic: "BIGF" or "BIG4" (4 bytes)
// - Archive size: u32 little-endian
// - File count: u32 big-endian
// - Reserved: 4 bytes
// - File entries (at offset 16):
//   - Position: u32 big-endian
//   - Size: u32 big-endian
//   - Name: null-terminated string
//
// Reference: thyme/src/platform/w3dengine/common/win32bigfilesystem.cpp


// BIG archive magic constants
const BIG_MAGIC_BIGF: i32 = 0x46474942  // "BIGF" as little-endian u32
const BIG_MAGIC_BIG4: i32 = 0x34474942  // "BIG4" as little-endian u32
const BIG_PATH_MAX: i32 = 260

// Error types
enum BigError {
    None,
    InvalidMagic,
    InvalidHeader,
    FileNotFound,
    ReadError,
    OutOfMemory,
    PathTooLong,
    ArchiveNotOpen,
}

// Information about a file within the archive
struct ArchivedFileInfo {
    name: string,         // Full path within archive (normalized)
    base_name: string,    // Just the filename (after last /)
    position: i32,        // Offset in the BIG file
    size: i32,            // File size in bytes
}

// Binary reader for parsing archive data
struct BigReader {
    data: Vec<i32>,  // Raw byte array
    position: i32,          // Current read position
}

// A single BIG archive file
struct BigArchive {
    file_path: string,
    archive_size: i32,
    file_count: i32,
    files: HashMap<String, ArchivedFileInfo>,  // Map of normalized path -> info
    raw_data: Vec<i32>,             // Entire archive in memory
    is_open: bool,
    last_error: BigError,
}

// Simple wildcard pattern matching (* and ?)
fn match_pattern(str: string, pattern: string): bool {
    let s = 0
    let p = 0
    let star_idx: i32? = null
    let match_idx = 0

    while (s < str.len()) {
        if (p < pattern.len()) {
            let pc = pattern.char_at(p)
            let sc = str.char_at(s)

            if (pc == "?" or to_lower(pc) == to_lower(sc)) {
                s = s + 1
                p = p + 1
                continue
            }

            if (pc == "*") {
                star_idx = p
                match_idx = s
                p = p + 1
                continue
            }
        }

        if (star_idx != null) {
            p = star_idx + 1
            match_idx = match_idx + 1
            s = match_idx
        } else {
            return false
        }
    }

    // Skip trailing wildcards
    while (p < pattern.len() and pattern.char_at(p) == "*") {
        p = p + 1
    }

    return p == pattern.len()
}

fn to_lower(c: i32): i32 {
    if (c >= 65 and c <= 90) {  // "A" to "Z"
        return c + 32
    }
    return c
}

// Archive file system - manages multiple BIG archives
struct BigFileSystem {
    archives: Vec<BigArchive>,
    search_paths: Vec<string>,
}

// ============================================================================
// C&C Generals specific archive loading
// ============================================================================

// Standard BIG files in C&C Generals Zero Hour
const GENERALS_BIG_FILES: Vec<string> = [
    "INIZH.big",      // Zero Hour INI files
    "INI.big",        // Base game INI files
    "Speech.big",     // Voice audio
    "SpeechZH.big",   // Zero Hour voices
    "Audio.big",      // Sound effects
    "AudioZH.big",    // Zero Hour sounds
    "W3D.big",        // 3D models
    "W3DZH.big",      // Zero Hour models
    "Textures.big",   // Textures
    "TexturesZH.big", // Zero Hour textures
    "Maps.big",       // Single player maps
    "MapsZH.big",     // Zero Hour maps
    "Window.big",     // UI definitions
    "WindowZH.big",   // Zero Hour UI
    "Terrain.big",    // Terrain data
    "TerrainZH.big",  // Zero Hour terrain
    "English.big",    // Localized strings
    "EnglishZH.big",  // Zero Hour strings
]

// Load all standard game archives
fn load_game_archives(game_path: string): BigFileSystem {
    let fs = BigFileSystem::init()

    // Add the game directory as search path
    fs.add_search_path(game_path)

    // Try to load each standard archive
    for big_file in GENERALS_BIG_FILES {
        let full_path = game_path + "/" + big_file
        fs.load_archive(full_path)
    }

    // Also load any other .big files in the directory
    fs.load_directory(game_path)

    return fs
}

// ============================================================================
// TESTS
// ============================================================================

fn test_pattern_matching(): bool {
    assert(match_pattern("test.ini", "*.ini"), "Match *.ini")
    assert(match_pattern("data/ini/test.ini", "*.ini"), "Match nested *.ini")
    assert(!match_pattern("test.tga", "*.ini"), "No match *.ini on .tga")
    assert(match_pattern("test.ini", "test.???"), "Match test.???")
    assert(match_pattern("TEST.INI", "*.ini"), "Case insensitive match")
    assert(match_pattern("a", "*"), "Match single char with *")
    assert(match_pattern("abc", "a*c"), "Match a*c")
    assert(match_pattern("data/ini/gamedata.ini", "data/ini/*.ini"), "Match path pattern")
    return true
}

fn test_path_normalization(): bool {
    let archive = BigArchive::init()

    let p1 = archive.normalize_path("Data\\INI\\GameData.ini")
    assert(p1 == "data/ini/gamedata.ini", "Normalize backslash and case")

    let p2 = archive.normalize_path("already/lowercase/path.txt")
    assert(p2 == "already/lowercase/path.txt", "Already normalized path")

    return true
}

fn test_archived_file_info(): bool {
    let info = ArchivedFileInfo::init("data/ini/gamedata.ini", 1000, 5000)

    assert(info.name == "data/ini/gamedata.ini", "Full name")
    assert(info.base_name == "gamedata.ini", "Base name")
    assert(info.position == 1000, "Position")
    assert(info.size == 5000, "Size")

    return true
}

fn test_big_archive_init(): bool {
    let archive = BigArchive::init()

    assert(archive.file_path == "", "Empty path on init")
    assert(archive.is_open == false, "Not open on init")
    assert(archive.file_count == 0, "Zero file count on init")

    return true
}

fn test_big_file_system_init(): bool {
    let fs = BigFileSystem::init()

    assert(fs.get_archive_count() == 0, "No archives on init")
    assert(fs.get_total_file_count() == 0, "No files on init")

    return true
}

fn test_big_reader(): bool {
    let data = Vec::init()
    // Add test bytes: 0x12 0x34 0x56 0x78
    data.add(0x12)
    data.add(0x34)
    data.add(0x56)
    data.add(0x78)

    let reader = BigReader::init(data)

    // Test little-endian read
    let le = reader.read_u32_le()
    assert(le == 0x78563412, "Little-endian u32")

    // Reset and test big-endian read
    reader.seek(0)
    let be = reader.read_u32_be()
    assert(be == 0x12345678, "Big-endian u32")

    return true
}

fn test_magic_validation(): bool {
    // Test BIGF magic (0x42 0x49 0x47 0x46 = "BIGF")
    let data = Vec::init()
    data.add(0x42)  // B
    data.add(0x49)  // I
    data.add(0x47)  // G
    data.add(0x46)  // F

    let reader = BigReader::init(data)
    let magic = reader.read_u32_le()

    assert(magic == BIG_MAGIC_BIGF, "BIGF magic validated")

    return true
}

fn run_all_tests(): bool {
    assert(test_pattern_matching(), "Test 1: Pattern matching")
    assert(test_path_normalization(), "Test 2: Path normalization")
    assert(test_archived_file_info(), "Test 3: Archived file info")
    assert(test_big_archive_init(), "Test 4: BigArchive init")
    assert(test_big_file_system_init(), "Test 5: BigFileSystem init")
    assert(test_big_reader(), "Test 6: BigReader")
    assert(test_magic_validation(), "Test 7: Magic validation")
    return true
}
