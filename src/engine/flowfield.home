// Flow field pathfinding for C&C Generals Zero Hour
// Efficient pathfinding for large groups of units
// Written in Home language

// Flow field cell
struct FlowCell {
    cost: i32,            // Cost to reach this cell
    best_direction: Vec2, // Direction to move
    is_blocked: bool,
}

// Integration field for calculating flow
struct IntegrationField {
    width: i32,
    height: i32,
    cells: Vec<Vec<i32>>,
    goal_x: i32,
    goal_y: i32,
}

// Flow field
struct FlowField {
    width: i32,
    height: i32,
    cells: Vec<Vec<FlowCell>>,
}

// Flow field manager
struct FlowFieldManager {
    flow_fields: Vec<FlowField>,
    integration_fields: Vec<IntegrationField>,
    map_width: i32,
    map_height: i32,
    cell_size: f64,
}

// Helper structs
struct Vec2 {
    x: f64,
    y: f64,
}

fn sqrt(x: f64): f64 {
    return x ** 0.5
}

// Tests
test "FlowCell: init" {
    let cell = FlowCell::init()

    assert cell.cost == 9999
    assert !cell.is_blocked
}

test "FlowCell: set direction" {
    let cell = FlowCell::init()

    cell.set_direction(1.0, 0.0)
    assert cell.best_direction.x == 1.0
    assert cell.best_direction.y == 0.0
}

test "IntegrationField: init" {
    let field = IntegrationField::init(10, 10)

    assert field.width == 10
    assert field.height == 10
}

test "IntegrationField: set and get cost" {
    let field = IntegrationField::init(10, 10)

    field.set_cost(5, 5, 100)
    assert field.get_cost(5, 5) == 100
}

test "IntegrationField: set goal" {
    let field = IntegrationField::init(10, 10)

    field.set_goal(5, 5)
    assert field.goal_x == 5
    assert field.goal_y == 5
    assert field.get_cost(5, 5) == 0
}

test "IntegrationField: set blocked" {
    let field = IntegrationField::init(10, 10)

    field.set_blocked(3, 3)
    assert field.is_blocked(3, 3)
}

test "IntegrationField: get neighbors" {
    let field = IntegrationField::init(10, 10)

    let neighbors = field.get_neighbors(5, 5)
    assert neighbors.count() == 8  // All 8 directions

    let corner_neighbors = field.get_neighbors(0, 0)
    assert corner_neighbors.count() == 3  // Corner has 3 neighbors
}

test "IntegrationField: calculate from goal" {
    let field = IntegrationField::init(10, 10)

    field.set_goal(5, 5)
    field.calculate_from_goal()

    // Adjacent cells should have cost 1
    assert field.get_cost(4, 5) == 1
    assert field.get_cost(6, 5) == 1
    assert field.get_cost(5, 4) == 1
    assert field.get_cost(5, 6) == 1

    // Corner cell should have cost 1 (diagonal)
    assert field.get_cost(4, 4) == 1
}

test "IntegrationField: blocked cells" {
    let field = IntegrationField::init(10, 10)

    field.set_blocked(5, 5)
    field.set_goal(4, 5)
    field.calculate_from_goal()

    // Blocked cell should remain 255
    assert field.is_blocked(5, 5)
}

test "FlowField: init" {
    let field = FlowField::init(10, 10)

    assert field.width == 10
    assert field.height == 10
}

test "FlowField: get cell" {
    let field = FlowField::init(10, 10)

    let cell = field.get_cell(5, 5)?
    assert cell.cost == 9999

    let invalid = field.get_cell(100, 100)
    assert invalid == null
}

test "FlowField: set blocked" {
    let field = FlowField::init(10, 10)

    field.set_blocked(5, 5, true)

    let cell = field.get_cell(5, 5)?
    assert cell.is_blocked
}

test "FlowField: calculate from integration" {
    let integration = IntegrationField::init(5, 5)
    integration.set_goal(2, 2)
    integration.calculate_from_goal()

    let flow = FlowField::init(5, 5)
    flow.calculate_from_integration(integration)

    let cell = flow.get_cell(2, 2)?
    assert cell.cost == 0

    let neighbor = flow.get_cell(1, 2)?
    assert neighbor.cost == 1
}

test "FlowField: get direction" {
    let integration = IntegrationField::init(5, 5)
    integration.set_goal(2, 2)
    integration.calculate_from_goal()

    let flow = FlowField::init(5, 5)
    flow.calculate_from_integration(integration)

    let direction = flow.get_direction(0, 2)?
    assert direction.x > 0.0  // Should point right
}

test "FlowField: is at goal" {
    let integration = IntegrationField::init(5, 5)
    integration.set_goal(2, 2)
    integration.calculate_from_goal()

    let flow = FlowField::init(5, 5)
    flow.calculate_from_integration(integration)

    assert flow.is_at_goal(2, 2)
    assert !flow.is_at_goal(0, 0)
}

test "FlowFieldManager: init" {
    let manager = FlowFieldManager::init(50, 50, 10.0)

    assert manager.map_width == 50
    assert manager.map_height == 50
    assert manager.cell_size == 10.0
}

test "FlowFieldManager: create flow field" {
    let manager = FlowFieldManager::init(10, 10, 1.0)

    let obstacles = Vec::new()
    obstacles.add((5, 5))

    let field_id = manager.create_flow_field(7, 7, obstacles)

    assert field_id == 0
    assert manager.get_field_count() == 1
}

test "FlowFieldManager: get flow direction" {
    let manager = FlowFieldManager::init(10, 10, 1.0)

    let obstacles = Vec::new()
    let field_id = manager.create_flow_field(5, 5, obstacles)

    let direction = manager.get_flow_direction(field_id, 3, 5)?
    assert direction.x > 0.0  // Should point toward goal
}

test "FlowFieldManager: world to grid" {
    let manager = FlowFieldManager::init(100, 100, 10.0)

    let (gx, gy) = manager.world_to_grid(25.0, 35.0)
    assert gx == 2
    assert gy == 3
}

test "FlowFieldManager: clear field" {
    let manager = FlowFieldManager::init(10, 10, 1.0)

    let obstacles = Vec::new()
    manager.create_flow_field(5, 5, obstacles)

    assert manager.get_field_count() == 1

    manager.clear_field(0)
    assert manager.get_field_count() == 0
}

test "FlowFieldManager: clear all fields" {
    let manager = FlowFieldManager::init(10, 10, 1.0)

    let obstacles = Vec::new()
    manager.create_flow_field(5, 5, obstacles)
    manager.create_flow_field(7, 7, obstacles)

    assert manager.get_field_count() == 2

    manager.clear_all_fields()
    assert manager.get_field_count() == 0
}

test "Vec2: length" {
    let vec = Vec2::init(3.0, 4.0)
    assert vec.length() == 5.0
}
