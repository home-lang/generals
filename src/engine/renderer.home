// Renderer system for C&C Generals Zero Hour
// Manages 3D rendering, models, terrain, particles
// Written in Home language

import world
import object

// Render layer for draw order
enum RenderLayer {
    TERRAIN = 0,
    SHADOWS = 1,
    OBJECTS = 2,
    EFFECTS = 3,
    PARTICLES = 4,
    UI = 5,
}

// Material properties
struct Material {
    diffuse_color: Vec4,
    specular_color: Vec4,
    shininess: f64,
    texture_name: string,
    blend_mode: BlendMode,
}

// Blend modes
enum BlendMode {
    OPAQUE = 0,
    ALPHA = 1,
    ADDITIVE = 2,
    MULTIPLY = 3,
}

// Mesh for rendering
struct Mesh {
    vertex_count: i32,
    index_count: i32,
    material: Material,
    bounds_min: Vec3,
    bounds_max: Vec3,
}

// Model instance
struct ModelInstance {
    mesh: Mesh,
    transform: Mat4,
    visible: bool,
    layer: RenderLayer,
}

// Camera for rendering
struct Camera {
    position: Vec3,
    target: Vec3,
    up: Vec3,
    fov: f64,
    near_plane: f64,
    far_plane: f64,
    aspect_ratio: f64,
}

// Light source
struct Light {
    position: Vec3,
    color: Vec3,
    intensity: f64,
    radius: f64,
    light_type: LightType,
}

enum LightType {
    DIRECTIONAL = 0,
    POINT = 1,
    SPOT = 2,
}

// Render queue entry
struct RenderCommand {
    model: ModelInstance,
    layer: RenderLayer,
    distance_to_camera: f64,
}

// Main renderer
struct Renderer {
    camera: Camera,
    lights: Vec<Light>,
    render_queue: Vec<RenderCommand>,
    terrain_mesh: Mesh?,
    frame_count: i32,
}

// Render stats for debugging
struct RenderStats {
    frame_time: f64,
    draw_calls: i32,
    triangles: i32,
    vertices: i32,
}

// Math helpers
struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

struct Vec4 {
    x: f64,
    y: f64,
    z: f64,
    w: f64,
}

struct Mat4 {
    m: Vec<f64>,  // 16 elements
}

// Helper functions
fn cos(angle: f64): f64 {
    // Simplified cosine
    return 1.0 - (angle * angle) / 2.0
}

fn sin(angle: f64): f64 {
    // Simplified sine
    return angle - (angle * angle * angle) / 6.0
}

fn sqrt(x: f64): f64 {
    return x ** 0.5
}

// Tests
test "Material: init" {
    let material = Material::init("tank_diffuse.tga")

    assert material.texture_name == "tank_diffuse.tga"
    assert material.shininess == 32.0
    assert material.blend_mode == BlendMode::OPAQUE
}

test "Material: set color" {
    let material = Material::init("test.tga")
    material.set_color(1.0, 0.5, 0.0, 1.0)

    assert material.diffuse_color.x == 1.0
    assert material.diffuse_color.y == 0.5
}

test "Mesh: triangle count" {
    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)

    assert mesh.get_triangle_count() == 100
}

test "Camera: init" {
    let pos = Vec3::init(0.0, 100.0, 0.0)
    let target = Vec3::init(0.0, 0.0, 0.0)
    let camera = Camera::init(pos, target)

    assert camera.position.y == 100.0
    assert camera.fov == 60.0
    assert camera.near_plane == 1.0
}

test "Camera: move and look" {
    let pos = Vec3::init(0.0, 100.0, 0.0)
    let target = Vec3::init(0.0, 0.0, 0.0)
    let camera = Camera::init(pos, target)

    camera.move_to(Vec3::init(10.0, 100.0, 10.0))
    assert camera.position.x == 10.0

    camera.look_at(Vec3::init(5.0, 0.0, 5.0))
    assert camera.target.x == 5.0
}

test "Light: init" {
    let pos = Vec3::init(0.0, 50.0, 0.0)
    let color = Vec3::init(1.0, 1.0, 1.0)
    let light = Light::init(pos, color, 1.0)

    assert light.intensity == 1.0
    assert light.light_type == LightType::POINT
}

test "Light: attenuation" {
    let pos = Vec3::init(0.0, 0.0, 0.0)
    let color = Vec3::init(1.0, 1.0, 1.0)
    let light = Light::init(pos, color, 1.0)

    assert light.get_attenuation(0.0) == 1.0
    assert light.get_attenuation(50.0) == 0.5
    assert light.get_attenuation(100.0) == 0.0
    assert light.get_attenuation(150.0) == 0.0
}

test "ModelInstance: init and positioning" {
    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)
    let transform = Mat4::identity()
    let instance = ModelInstance::init(mesh, transform)

    assert instance.visible
    assert instance.layer == RenderLayer::OBJECTS

    instance.set_position(Vec3::init(10.0, 0.0, 10.0))
    instance.set_layer(RenderLayer::EFFECTS)

    assert instance.layer == RenderLayer::EFFECTS
}

test "Renderer: init" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    assert renderer.frame_count == 0
    assert renderer.lights.count() == 0
}

test "Renderer: add lights" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    let light1 = Light::init(Vec3::init(0.0, 50.0, 0.0), Vec3::init(1.0, 1.0, 1.0), 1.0)
    let light2 = Light::init(Vec3::init(100.0, 50.0, 0.0), Vec3::init(1.0, 0.8, 0.6), 0.8)

    renderer.add_light(light1)
    renderer.add_light(light2)

    assert renderer.lights.count() == 2
}

test "Renderer: submit models" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)
    let instance = ModelInstance::init(mesh, Mat4::identity())

    renderer.submit_model(instance)
    assert renderer.render_queue.count() == 1
}

test "Renderer: render frame" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)
    let instance = ModelInstance::init(mesh, Mat4::identity())

    renderer.submit_model(instance)
    renderer.render_frame()

    assert renderer.frame_count == 1
    assert renderer.render_queue.count() == 0  // Cleared after render
}

test "RenderCommand: sorting by layer" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    let material = Material::init("test.tga")
    let mesh1 = Mesh::init(100, 300, material)
    let mesh2 = Mesh::init(100, 300, material)

    let instance1 = ModelInstance::init(mesh1, Mat4::identity())
    instance1.set_layer(RenderLayer::PARTICLES)

    let instance2 = ModelInstance::init(mesh2, Mat4::identity())
    instance2.set_layer(RenderLayer::TERRAIN)

    renderer.submit_model(instance1)
    renderer.submit_model(instance2)

    renderer.sort_render_queue()

    // Terrain should be first (lower layer value)
    let first = renderer.render_queue.get(0)
    assert first.layer == RenderLayer::TERRAIN
}

test "RenderStats: tracking" {
    let stats = RenderStats::init()

    assert stats.draw_calls == 0
    assert stats.triangles == 0

    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)

    stats.add_mesh(mesh)
    assert stats.draw_calls == 1
    assert stats.triangles == 100
    assert stats.vertices == 100

    stats.reset()
    assert stats.draw_calls == 0
}

test "Vec3: operations" {
    let a = Vec3::init(1.0, 2.0, 3.0)
    let b = Vec3::init(4.0, 5.0, 6.0)

    let sum = Vec3::add(a, b)
    assert sum.x == 5.0
    assert sum.y == 7.0

    let diff = Vec3::sub(b, a)
    assert diff.x == 3.0

    let scaled = Vec3::scale(a, 2.0)
    assert scaled.x == 2.0

    let distance = Vec3::distance(a, b)
    assert distance > 0.0
}

test "Vec3: normalize" {
    let v = Vec3::init(3.0, 4.0, 0.0)
    let len = Vec3::length(v)
    assert len == 5.0

    let normalized = Vec3::normalize(v)
    let new_len = Vec3::length(normalized)
    // Should be approximately 1.0
    assert new_len > 0.99 && new_len < 1.01
}

test "Mat4: identity" {
    let mat = Mat4::identity()
    assert mat.m.count() == 16
    assert mat.m.get(0) == 1.0
    assert mat.m.get(5) == 1.0
    assert mat.m.get(1) == 0.0
}

test "Mat4: translation" {
    let pos = Vec3::init(10.0, 20.0, 30.0)
    let mat = Mat4::translation(pos)

    let extracted = mat.get_position()
    assert extracted.x == 10.0
    assert extracted.y == 20.0
    assert extracted.z == 30.0
}
