// Renderer system for C&C Generals Zero Hour
// Manages 3D rendering, models, terrain, particles
// Written in Home language

import world
import object

// Render layer for draw order
enum RenderLayer {
    TERRAIN = 0,
    SHADOWS = 1,
    OBJECTS = 2,
    EFFECTS = 3,
    PARTICLES = 4,
    UI = 5,
}

// Material properties
struct Material {
    diffuse_color: Vec4,
    specular_color: Vec4,
    shininess: Float,
    texture_name: String,
    blend_mode: BlendMode,

    fn init(texture_name: String) -> Material {
        return Material {
            diffuse_color: Vec4::init(1.0, 1.0, 1.0, 1.0),
            specular_color: Vec4::init(1.0, 1.0, 1.0, 1.0),
            shininess: 32.0,
            texture_name: texture_name,
            blend_mode: BlendMode::OPAQUE,
        }
    }

    fn set_color(self, r: Float, g: Float, b: Float, a: Float) {
        self.diffuse_color = Vec4::init(r, g, b, a)
    }
}

// Blend modes
enum BlendMode {
    OPAQUE = 0,
    ALPHA = 1,
    ADDITIVE = 2,
    MULTIPLY = 3,
}

// Mesh for rendering
struct Mesh {
    vertex_count: Int,
    index_count: Int,
    material: Material,
    bounds_min: Vec3,
    bounds_max: Vec3,

    fn init(vertex_count: Int, index_count: Int, material: Material) -> Mesh {
        return Mesh {
            vertex_count: vertex_count,
            index_count: index_count,
            material: material,
            bounds_min: Vec3::init(-1.0, -1.0, -1.0),
            bounds_max: Vec3::init(1.0, 1.0, 1.0),
        }
    }

    fn get_triangle_count(self) -> Int {
        return self.index_count / 3
    }
}

// Model instance
struct ModelInstance {
    mesh: Mesh,
    transform: Mat4,
    visible: Bool,
    layer: RenderLayer,

    fn init(mesh: Mesh, transform: Mat4) -> ModelInstance {
        return ModelInstance {
            mesh: mesh,
            transform: transform,
            visible: true,
            layer: RenderLayer::OBJECTS,
        }
    }

    fn set_position(self, pos: Vec3) {
        self.transform = Mat4::translation(pos)
    }

    fn set_layer(self, layer: RenderLayer) {
        self.layer = layer
    }
}

// Camera for rendering
struct Camera {
    position: Vec3,
    target: Vec3,
    up: Vec3,
    fov: Float,
    near_plane: Float,
    far_plane: Float,
    aspect_ratio: Float,

    fn init(position: Vec3, target: Vec3) -> Camera {
        return Camera {
            position: position,
            target: target,
            up: Vec3::init(0.0, 1.0, 0.0),
            fov: 60.0,
            near_plane: 1.0,
            far_plane: 10000.0,
            aspect_ratio: 16.0 / 9.0,
        }
    }

    fn move_to(self, pos: Vec3) {
        self.position = pos
    }

    fn look_at(self, target: Vec3) {
        self.target = target
    }

    fn zoom(self, delta: Float) {
        let direction = Vec3::sub(self.target, self.position)
        direction = Vec3::normalize(direction)
        self.position = Vec3::add(self.position, Vec3::scale(direction, delta))
    }

    fn rotate(self, yaw: Float, pitch: Float) {
        // Rotate camera around target
        let offset = Vec3::sub(self.position, self.target)
        let distance = Vec3::length(offset)

        // Apply rotation (simplified)
        self.position.x = self.target.x + distance * cos(yaw)
        self.position.z = self.target.z + distance * sin(yaw)
    }
}

// Light source
struct Light {
    position: Vec3,
    color: Vec3,
    intensity: Float,
    radius: Float,
    light_type: LightType,

    fn init(position: Vec3, color: Vec3, intensity: Float) -> Light {
        return Light {
            position: position,
            color: color,
            intensity: intensity,
            radius: 100.0,
            light_type: LightType::POINT,
        }
    }

    fn get_attenuation(self, distance: Float) -> Float {
        if distance >= self.radius {
            return 0.0
        }
        return 1.0 - (distance / self.radius)
    }
}

enum LightType {
    DIRECTIONAL = 0,
    POINT = 1,
    SPOT = 2,
}

// Render queue entry
struct RenderCommand {
    model: ModelInstance,
    layer: RenderLayer,
    distance_to_camera: Float,

    fn init(model: ModelInstance, distance: Float) -> RenderCommand {
        return RenderCommand {
            model: model,
            layer: model.layer,
            distance_to_camera: distance,
        }
    }
}

// Main renderer
struct Renderer {
    camera: Camera,
    lights: Collection<Light>,
    render_queue: Collection<RenderCommand>,
    terrain_mesh: Mesh?,
    frame_count: Int,

    fn init(camera: Camera) -> Renderer {
        return Renderer {
            camera: camera,
            lights: Collection::new(),
            render_queue: Collection::new(),
            terrain_mesh: null,
            frame_count: 0,
        }
    }

    fn add_light(self, light: Light) {
        self.lights.add(light)
    }

    fn set_terrain(self, mesh: Mesh) {
        self.terrain_mesh = mesh
    }

    fn submit_model(self, model: ModelInstance) {
        let distance = Vec3::distance(model.transform.get_position(), self.camera.position)
        let command = RenderCommand::init(model, distance)
        self.render_queue.add(command)
    }

    fn render_frame(self) {
        self.frame_count = self.frame_count + 1

        // Sort render queue by layer then distance
        self.sort_render_queue()

        // Render terrain
        if let Some(terrain) = self.terrain_mesh {
            self.render_terrain(terrain)
        }

        // Render all models
        for command in self.render_queue {
            if command.model.visible {
                self.render_model(command.model)
            }
        }

        // Clear queue for next frame
        self.render_queue.clear()
    }

    fn sort_render_queue(self) {
        // Simple bubble sort by layer then distance
        let count = self.render_queue.count()

        for i in 0..count {
            for j in 0..(count - i - 1) {
                let a = self.render_queue.get(j)
                let b = self.render_queue.get(j + 1)

                if self.should_swap(a, b) {
                    self.render_queue.swap(j, j + 1)
                }
            }
        }
    }

    fn should_swap(self, a: RenderCommand, b: RenderCommand) -> Bool {
        // Sort by layer first
        if a.layer != b.layer {
            return a.layer > b.layer
        }

        // Then by distance (back to front for alpha)
        if a.model.mesh.material.blend_mode != BlendMode::OPAQUE {
            return a.distance_to_camera < b.distance_to_camera
        }

        // Front to back for opaque
        return a.distance_to_camera > b.distance_to_camera
    }

    fn render_terrain(self, mesh: Mesh) {
        // TODO: Render terrain mesh with heightmap textures
    }

    fn render_model(self, model: ModelInstance) {
        // TODO: Render model mesh with lighting
    }

    fn get_visible_object_count(self) -> Int {
        let count = 0
        for command in self.render_queue {
            if command.model.visible {
                count = count + 1
            }
        }
        return count
    }

    fn clear_lights(self) {
        self.lights.clear()
    }
}

// Render stats for debugging
struct RenderStats {
    frame_time: Float,
    draw_calls: Int,
    triangles: Int,
    vertices: Int,

    fn init() -> RenderStats {
        return RenderStats {
            frame_time: 0.0,
            draw_calls: 0,
            triangles: 0,
            vertices: 0,
        }
    }

    fn reset(self) {
        self.draw_calls = 0
        self.triangles = 0
        self.vertices = 0
    }

    fn add_mesh(self, mesh: Mesh) {
        self.draw_calls = self.draw_calls + 1
        self.triangles = self.triangles + mesh.get_triangle_count()
        self.vertices = self.vertices + mesh.vertex_count
    }
}

// Math helpers
struct Vec3 {
    x: Float,
    y: Float,
    z: Float,

    fn init(x: Float, y: Float, z: Float) -> Vec3 {
        return Vec3 { x: x, y: y, z: z }
    }

    fn add(a: Vec3, b: Vec3) -> Vec3 {
        return Vec3::init(a.x + b.x, a.y + b.y, a.z + b.z)
    }

    fn sub(a: Vec3, b: Vec3) -> Vec3 {
        return Vec3::init(a.x - b.x, a.y - b.y, a.z - b.z)
    }

    fn scale(v: Vec3, s: Float) -> Vec3 {
        return Vec3::init(v.x * s, v.y * s, v.z * s)
    }

    fn length(v: Vec3) -> Float {
        return sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
    }

    fn normalize(v: Vec3) -> Vec3 {
        let len = Vec3::length(v)
        if len == 0.0 {
            return v
        }
        return Vec3::scale(v, 1.0 / len)
    }

    fn distance(a: Vec3, b: Vec3) -> Float {
        let diff = Vec3::sub(b, a)
        return Vec3::length(diff)
    }
}

struct Vec4 {
    x: Float,
    y: Float,
    z: Float,
    w: Float,

    fn init(x: Float, y: Float, z: Float, w: Float) -> Vec4 {
        return Vec4 { x: x, y: y, z: z, w: w }
    }
}

struct Mat4 {
    m: Collection<Float>,  // 16 elements

    fn identity() -> Mat4 {
        let mat = Mat4 { m: Collection::new() }
        for i in 0..16 {
            if i % 5 == 0 {
                mat.m.add(1.0)
            } else {
                mat.m.add(0.0)
            }
        }
        return mat
    }

    fn translation(pos: Vec3) -> Mat4 {
        let mat = Mat4::identity()
        mat.m.set(12, pos.x)
        mat.m.set(13, pos.y)
        mat.m.set(14, pos.z)
        return mat
    }

    fn get_position(self) -> Vec3 {
        return Vec3::init(
            self.m.get(12),
            self.m.get(13),
            self.m.get(14)
        )
    }
}

// Helper functions
fn cos(angle: Float) -> Float {
    // Simplified cosine
    return 1.0 - (angle * angle) / 2.0
}

fn sin(angle: Float) -> Float {
    // Simplified sine
    return angle - (angle * angle * angle) / 6.0
}

fn sqrt(x: Float) -> Float {
    return x ** 0.5
}

// Tests
test "Material: init" {
    let material = Material::init("tank_diffuse.tga")

    assert material.texture_name == "tank_diffuse.tga"
    assert material.shininess == 32.0
    assert material.blend_mode == BlendMode::OPAQUE
}

test "Material: set color" {
    let material = Material::init("test.tga")
    material.set_color(1.0, 0.5, 0.0, 1.0)

    assert material.diffuse_color.x == 1.0
    assert material.diffuse_color.y == 0.5
}

test "Mesh: triangle count" {
    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)

    assert mesh.get_triangle_count() == 100
}

test "Camera: init" {
    let pos = Vec3::init(0.0, 100.0, 0.0)
    let target = Vec3::init(0.0, 0.0, 0.0)
    let camera = Camera::init(pos, target)

    assert camera.position.y == 100.0
    assert camera.fov == 60.0
    assert camera.near_plane == 1.0
}

test "Camera: move and look" {
    let pos = Vec3::init(0.0, 100.0, 0.0)
    let target = Vec3::init(0.0, 0.0, 0.0)
    let camera = Camera::init(pos, target)

    camera.move_to(Vec3::init(10.0, 100.0, 10.0))
    assert camera.position.x == 10.0

    camera.look_at(Vec3::init(5.0, 0.0, 5.0))
    assert camera.target.x == 5.0
}

test "Light: init" {
    let pos = Vec3::init(0.0, 50.0, 0.0)
    let color = Vec3::init(1.0, 1.0, 1.0)
    let light = Light::init(pos, color, 1.0)

    assert light.intensity == 1.0
    assert light.light_type == LightType::POINT
}

test "Light: attenuation" {
    let pos = Vec3::init(0.0, 0.0, 0.0)
    let color = Vec3::init(1.0, 1.0, 1.0)
    let light = Light::init(pos, color, 1.0)

    assert light.get_attenuation(0.0) == 1.0
    assert light.get_attenuation(50.0) == 0.5
    assert light.get_attenuation(100.0) == 0.0
    assert light.get_attenuation(150.0) == 0.0
}

test "ModelInstance: init and positioning" {
    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)
    let transform = Mat4::identity()
    let instance = ModelInstance::init(mesh, transform)

    assert instance.visible
    assert instance.layer == RenderLayer::OBJECTS

    instance.set_position(Vec3::init(10.0, 0.0, 10.0))
    instance.set_layer(RenderLayer::EFFECTS)

    assert instance.layer == RenderLayer::EFFECTS
}

test "Renderer: init" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    assert renderer.frame_count == 0
    assert renderer.lights.count() == 0
}

test "Renderer: add lights" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    let light1 = Light::init(Vec3::init(0.0, 50.0, 0.0), Vec3::init(1.0, 1.0, 1.0), 1.0)
    let light2 = Light::init(Vec3::init(100.0, 50.0, 0.0), Vec3::init(1.0, 0.8, 0.6), 0.8)

    renderer.add_light(light1)
    renderer.add_light(light2)

    assert renderer.lights.count() == 2
}

test "Renderer: submit models" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)
    let instance = ModelInstance::init(mesh, Mat4::identity())

    renderer.submit_model(instance)
    assert renderer.render_queue.count() == 1
}

test "Renderer: render frame" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)
    let instance = ModelInstance::init(mesh, Mat4::identity())

    renderer.submit_model(instance)
    renderer.render_frame()

    assert renderer.frame_count == 1
    assert renderer.render_queue.count() == 0  // Cleared after render
}

test "RenderCommand: sorting by layer" {
    let camera = Camera::init(
        Vec3::init(0.0, 100.0, 100.0),
        Vec3::init(0.0, 0.0, 0.0)
    )
    let renderer = Renderer::init(camera)

    let material = Material::init("test.tga")
    let mesh1 = Mesh::init(100, 300, material)
    let mesh2 = Mesh::init(100, 300, material)

    let instance1 = ModelInstance::init(mesh1, Mat4::identity())
    instance1.set_layer(RenderLayer::PARTICLES)

    let instance2 = ModelInstance::init(mesh2, Mat4::identity())
    instance2.set_layer(RenderLayer::TERRAIN)

    renderer.submit_model(instance1)
    renderer.submit_model(instance2)

    renderer.sort_render_queue()

    // Terrain should be first (lower layer value)
    let first = renderer.render_queue.get(0)
    assert first.layer == RenderLayer::TERRAIN
}

test "RenderStats: tracking" {
    let stats = RenderStats::init()

    assert stats.draw_calls == 0
    assert stats.triangles == 0

    let material = Material::init("test.tga")
    let mesh = Mesh::init(100, 300, material)

    stats.add_mesh(mesh)
    assert stats.draw_calls == 1
    assert stats.triangles == 100
    assert stats.vertices == 100

    stats.reset()
    assert stats.draw_calls == 0
}

test "Vec3: operations" {
    let a = Vec3::init(1.0, 2.0, 3.0)
    let b = Vec3::init(4.0, 5.0, 6.0)

    let sum = Vec3::add(a, b)
    assert sum.x == 5.0
    assert sum.y == 7.0

    let diff = Vec3::sub(b, a)
    assert diff.x == 3.0

    let scaled = Vec3::scale(a, 2.0)
    assert scaled.x == 2.0

    let distance = Vec3::distance(a, b)
    assert distance > 0.0
}

test "Vec3: normalize" {
    let v = Vec3::init(3.0, 4.0, 0.0)
    let len = Vec3::length(v)
    assert len == 5.0

    let normalized = Vec3::normalize(v)
    let new_len = Vec3::length(normalized)
    // Should be approximately 1.0
    assert new_len > 0.99 && new_len < 1.01
}

test "Mat4: identity" {
    let mat = Mat4::identity()
    assert mat.m.count() == 16
    assert mat.m.get(0) == 1.0
    assert mat.m.get(5) == 1.0
    assert mat.m.get(1) == 0.0
}

test "Mat4: translation" {
    let pos = Vec3::init(10.0, 20.0, 30.0)
    let mat = Mat4::translation(pos)

    let extracted = mat.get_position()
    assert extracted.x == 10.0
    assert extracted.y == 20.0
    assert extracted.z == 30.0
}
