// ============================================================================
// Damage/Armor System - Complete Implementation
// Based on Thyme's damage calculation architecture
// Pure Home implementation - converted from Zig
// ============================================================================
//
// Comprehensive damage system with:
// - Damage types (small arms, explosive, fire, poison, etc.)
// - Armor types (light, medium, heavy, structure)
// - Damage modifiers (bonuses vs specific armor)
// - Armor piercing
// - Splash damage
// - Damage over time (DOT)
// - Veterancy bonuses

import engine/entity

// ============================================================================
// Phase 1: Damage Types
// ============================================================================

enum DamageType {
    SMALL_ARMS,      // Rifles, machine guns
    GRENADE,         // Grenades, grenade launchers
    ARMOR_PIERCING,  // Tank shells, AP rounds
    EXPLOSIVE,       // Bombs, missiles
    FIRE,            // Flame throwers, molotovs
    LASER,           // Laser weapons
    POISON,          // Anthrax, toxins
    RADIATION,       // Nuclear weapons
    PARTICLE_BEAM,   // Particle cannon
    CRUSH,           // Being run over
    SNIPER,          // Sniper rifles
    FORCE,           // Force effects
    HACK,            // Hacking damage
    WATER,           // Water damage
    STATUS,          // Status effects
    UNRESISTABLE,    // Cannot be reduced
    COUNT,
}

fn get_damage_type_name(damage_type: DamageType): string {
    if (damage_type == DamageType::SMALL_ARMS) { return "Small Arms" }
    if (damage_type == DamageType::GRENADE) { return "Grenade" }
    if (damage_type == DamageType::ARMOR_PIERCING) { return "Armor Piercing" }
    if (damage_type == DamageType::EXPLOSIVE) { return "Explosive" }
    if (damage_type == DamageType::FIRE) { return "Fire" }
    if (damage_type == DamageType::LASER) { return "Laser" }
    if (damage_type == DamageType::POISON) { return "Poison" }
    if (damage_type == DamageType::RADIATION) { return "Radiation" }
    if (damage_type == DamageType::PARTICLE_BEAM) { return "Particle Beam" }
    if (damage_type == DamageType::CRUSH) { return "Crush" }
    if (damage_type == DamageType::SNIPER) { return "Sniper" }
    return "Unknown"
}

// ============================================================================
// Phase 2: Armor Types
// ============================================================================

enum ArmorType {
    NONE,            // No armor
    INFANTRY_LIGHT,  // Light infantry
    INFANTRY_HEAVY,  // Rangers, tank hunters
    VEHICLE_LIGHT,   // Humvees, buggies
    VEHICLE_MEDIUM,  // APCs, light tanks
    VEHICLE_HEAVY,   // Main battle tanks
    AIRCRAFT,        // Planes, helicopters
    STRUCTURE,       // Buildings
    WALL,            // Walls, gates
    COUNT,
}

fn get_armor_type_name(armor_type: ArmorType): string {
    if (armor_type == ArmorType::NONE) { return "No Armor" }
    if (armor_type == ArmorType::INFANTRY_LIGHT) { return "Light Infantry" }
    if (armor_type == ArmorType::INFANTRY_HEAVY) { return "Heavy Infantry" }
    if (armor_type == ArmorType::VEHICLE_LIGHT) { return "Light Vehicle" }
    if (armor_type == ArmorType::VEHICLE_MEDIUM) { return "Medium Vehicle" }
    if (armor_type == ArmorType::VEHICLE_HEAVY) { return "Heavy Vehicle" }
    if (armor_type == ArmorType::AIRCRAFT) { return "Aircraft" }
    if (armor_type == ArmorType::STRUCTURE) { return "Structure" }
    if (armor_type == ArmorType::WALL) { return "Wall" }
    return "Unknown"
}

// ============================================================================
// Phase 3: Damage Modifier Table
// ============================================================================

struct DamageModifierTable {
    modifiers: Vec<Vec<f64>>,
}

// ============================================================================
// Phase 4: Damage Instance
// ============================================================================

struct DamageInfo {
    amount: f64,
    damage_type: DamageType,
    armor_piercing: f64,     // 0.0 to 1.0 (ignores armor)
    splash_radius: f64,      // 0 = no splash
    splash_falloff: f64,     // 0.0 to 1.0
    is_critical: bool,         // Critical hit
    source_entity_id: i32,
    has_source: bool,
    veterancy_bonus: f64,    // From attacker veterancy
}

// ============================================================================
// Phase 5: Armor Instance
// ============================================================================

struct ArmorInfo {
    armor_type: ArmorType,
    armor_value: f64,        // Base armor (damage reduction)
    resistances: Vec<f64>,    // Per-damage-type resistance
}

// ============================================================================
// Phase 6: Damage Calculation
// ============================================================================

struct DamageCalculator {
    modifier_table: DamageModifierTable,
}

// ============================================================================
// Phase 7: Damage Over Time (DOT)
// ============================================================================

struct DamageOverTime {
    damage_per_second: f64,
    damage_type: DamageType,
    duration: f64,           // Total duration in seconds
    elapsed: f64,            // Time elapsed
    tick_rate: f64,          // How often to apply damage
    last_tick: f64,
}

// ============================================================================
// Tests
// ============================================================================

fn test_damage_modifier_table(): bool {
    let table = DamageModifierTable::init()

    let mod = table.get(DamageType::SMALL_ARMS, ArmorType::VEHICLE_HEAVY)
    assert(mod == 0.1, "Small arms vs heavy vehicle")

    let mod2 = table.get(DamageType::ARMOR_PIERCING, ArmorType::VEHICLE_HEAVY)
    assert(mod2 == 1.0, "AP vs heavy vehicle")

    return true
}

fn test_damage_calculator_basic(): bool {
    let calc = DamageCalculator::init()

    let damage = DamageInfo::init(100.0, DamageType::SMALL_ARMS)
    let armor = ArmorInfo::init(ArmorType::INFANTRY_LIGHT, 0.0)

    let final_damage = calc.calculate_damage(damage, armor)
    assert(final_damage == 100.0, "Basic damage")

    return true
}

fn test_damage_calculator_armor_modifier(): bool {
    let calc = DamageCalculator::init()

    let damage = DamageInfo::init(100.0, DamageType::SMALL_ARMS)
    let armor = ArmorInfo::init(ArmorType::VEHICLE_HEAVY, 0.0)

    let final_damage = calc.calculate_damage(damage, armor)
    assert(final_damage == 10.0, "Armor type modifier")  // 100 * 0.1

    return true
}

fn test_damage_calculator_armor_piercing(): bool {
    let calc = DamageCalculator::init()

    let damage = DamageInfo::init(100.0, DamageType::SMALL_ARMS)
    damage.armor_piercing = 0.5  // 50% armor piercing

    let armor = ArmorInfo::init(ArmorType::INFANTRY_LIGHT, 20.0)

    // Base: 100, armor reduction: 20 * (1 - 0.5) = 10
    // Final: 100 - 10 = 90
    let final_damage = calc.calculate_damage(damage, armor)
    assert(final_damage == 90.0, "Armor piercing")

    return true
}

fn test_damage_calculator_splash(): bool {
    let calc = DamageCalculator::init()

    let damage = DamageInfo::init(200.0, DamageType::EXPLOSIVE)
    damage.splash_radius = 10.0
    damage.splash_falloff = 1.0  // Full falloff

    let armor = ArmorInfo::init(ArmorType::INFANTRY_LIGHT, 0.0)

    // At center (distance 0)
    let center_damage = calc.calculate_splash_damage(damage, armor, 0.0)
    assert(center_damage == 300.0, "Center splash damage")  // 200 * 1.5 (explosive vs infantry)

    // At edge (distance 10)
    let edge_damage = calc.calculate_splash_damage(damage, armor, 10.0)
    assert(edge_damage == 0.0, "Edge splash damage")

    return true
}

fn test_damage_over_time(): bool {
    let dot = DamageOverTime::init(10.0, DamageType::POISON, 5.0)

    // First tick at 0.5 seconds
    let dmg1 = dot.update(0.5)
    assert(dmg1 != null, "First tick exists")
    assert(dmg1.amount == 5.0, "First tick amount")  // 10 dps * 0.5s

    // No tick at 0.6 seconds (needs 1.0 total)
    let dmg2 = dot.update(0.1)
    assert(dmg2 == null, "No tick yet")

    // Second tick at 1.0 seconds
    let dmg3 = dot.update(0.4)
    assert(dmg3 != null, "Second tick exists")

    return true
}

fn test_damage_over_time_expiration(): bool {
    let dot = DamageOverTime::init(10.0, DamageType::FIRE, 2.0)

    assert(!dot.is_expired(), "Not expired initially")

    let _ = dot.update(2.5)
    assert(dot.is_expired(), "Expired after duration")

    return true
}

fn test_damage_info_builders(): bool {
    let damage = DamageInfo::init(100.0, DamageType::EXPLOSIVE)
    damage = damage.with_armor_piercing(0.3)
    damage = damage.with_splash(15.0, 0.8)
    damage = damage.with_veterancy(1.25)

    assert(damage.amount == 100.0, "Amount")
    assert(damage.armor_piercing == 0.3, "Armor piercing")
    assert(damage.splash_radius == 15.0, "Splash radius")
    assert(damage.veterancy_bonus == 1.25, "Veterancy bonus")

    return true
}

fn run_all_tests(): bool {
    assert(test_damage_modifier_table(), "Test 1: Damage modifier table")
    assert(test_damage_calculator_basic(), "Test 2: Damage calculator basic")
    assert(test_damage_calculator_armor_modifier(), "Test 3: Armor modifier")
    assert(test_damage_calculator_armor_piercing(), "Test 4: Armor piercing")
    assert(test_damage_calculator_splash(), "Test 5: Splash damage")
    assert(test_damage_over_time(), "Test 6: Damage over time")
    assert(test_damage_over_time_expiration(), "Test 7: DOT expiration")
    assert(test_damage_info_builders(), "Test 8: Damage info builders")
    return true
}
