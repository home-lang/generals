// Tech Tree and Upgrade System
// Implements faction-specific technology trees and unit/building upgrades

enum UpgradeType {
    UNIT_UPGRADE,      // Affects unit capabilities
    BUILDING_UPGRADE,  // Affects building functionality
    GLOBAL_UPGRADE,    // Affects all units/buildings
    GENERAL_UPGRADE,   // Unlocks general powers
}

enum UpgradeCategory {
    ARMOR,
    DAMAGE,
    SPEED,
    RANGE,
    PRODUCTION,
    SPECIAL,
    ECONOMY,
}

struct UpgradeDefinition {
    id: String,
    name: String,
    description: String,
    faction: String,
    upgrade_type: UpgradeType,
    category: UpgradeCategory,

    // Requirements
    cost: Int,
    build_time: Float,
    requires_building: String,
    requires_upgrade: String,  // Prerequisite upgrade
    science_level: Int,

    // Effects
    armor_bonus: Float,
    damage_bonus: Float,
    speed_bonus: Float,
    range_bonus: Float,
    health_bonus: Float,
    production_bonus: Float,
    income_bonus: Float,

    // Affected units
    affects_units: Collection<String>,
    affects_buildings: Collection<String>,

    fn init(id: String, name: String, faction: String) -> UpgradeDefinition {
        let upgrade = UpgradeDefinition {
            id: id,
            name: name,
            description: "",
            faction: faction,
            upgrade_type: UpgradeType::GLOBAL_UPGRADE,
            category: UpgradeCategory::SPECIAL,
            cost: 1000,
            build_time: 30.0,
            requires_building: "",
            requires_upgrade: "",
            science_level: 1,
            armor_bonus: 0.0,
            damage_bonus: 0.0,
            speed_bonus: 0.0,
            range_bonus: 0.0,
            health_bonus: 0.0,
            production_bonus: 0.0,
            income_bonus: 0.0,
            affects_units: Collection::init(),
            affects_buildings: Collection::init(),
        }
        return upgrade
    }
}

// USA Upgrades
fn create_composite_armor() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("composite_armor", "Composite Armor", "USA")
    upgrade.description = "Advanced armor plating for all vehicles"
    upgrade.category = UpgradeCategory::ARMOR
    upgrade.cost = 2000
    upgrade.build_time = 45.0
    upgrade.requires_building = "strategy_center"
    upgrade.armor_bonus = 25.0
    upgrade.affects_units.add("crusader")
    upgrade.affects_units.add("paladin")
    upgrade.affects_units.add("tomahawk")
    upgrade.affects_units.add("humvee")
    return upgrade
}

fn create_tow_missile() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("tow_missile", "TOW Missile", "USA")
    upgrade.description = "Upgrade Humvees with anti-tank missiles"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 1200
    upgrade.build_time = 30.0
    upgrade.requires_building = "strategy_center"
    upgrade.damage_bonus = 50.0
    upgrade.affects_units.add("humvee")
    return upgrade
}

fn create_drone_armor() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("drone_armor", "Drone Armor", "USA")
    upgrade.description = "Heavier armor for drones"
    upgrade.category = UpgradeCategory::ARMOR
    upgrade.cost = 500
    upgrade.build_time = 20.0
    upgrade.requires_building = "strategy_center"
    upgrade.health_bonus = 25.0
    upgrade.affects_units.add("drone")
    return upgrade
}

fn create_advanced_training() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("advanced_training", "Advanced Training", "USA")
    upgrade.description = "Infantry gain veterancy faster"
    upgrade.category = UpgradeCategory::SPECIAL
    upgrade.cost = 1500
    upgrade.build_time = 40.0
    upgrade.requires_building = "barracks"
    upgrade.affects_units.add("ranger")
    upgrade.affects_units.add("missile_defender")
    upgrade.affects_units.add("pathfinder")
    return upgrade
}

fn create_laser_missiles() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("laser_missiles", "Laser Missiles", "USA")
    upgrade.description = "Laser-guided missiles for increased accuracy"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 2500
    upgrade.build_time = 60.0
    upgrade.requires_building = "strategy_center"
    upgrade.science_level = 3
    upgrade.damage_bonus = 25.0
    upgrade.range_bonus = 50.0
    upgrade.affects_units.add("raptor")
    upgrade.affects_units.add("comanche")
    return upgrade
}

fn create_countermeasures() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("countermeasures", "Countermeasures", "USA")
    upgrade.description = "Aircraft gain missile defense"
    upgrade.category = UpgradeCategory::ARMOR
    upgrade.cost = 1000
    upgrade.build_time = 30.0
    upgrade.requires_building = "airfield"
    upgrade.affects_units.add("raptor")
    upgrade.affects_units.add("comanche")
    upgrade.affects_units.add("aurora")
    return upgrade
}

fn create_supply_lines() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("supply_lines", "Supply Lines", "USA")
    upgrade.description = "Supply centers generate additional income"
    upgrade.category = UpgradeCategory::ECONOMY
    upgrade.cost = 800
    upgrade.build_time = 20.0
    upgrade.requires_building = "supply_center"
    upgrade.income_bonus = 10.0
    upgrade.affects_buildings.add("supply_center")
    return upgrade
}

// China Upgrades
fn create_chain_guns() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("chain_guns", "Chain Guns", "China")
    upgrade.description = "Replace machine guns with chain guns"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 1500
    upgrade.build_time = 30.0
    upgrade.requires_building = "war_factory"
    upgrade.damage_bonus = 50.0
    upgrade.affects_units.add("battlemaster")
    upgrade.affects_units.add("overlord")
    return upgrade
}

fn create_black_napalm() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("black_napalm", "Black Napalm", "China")
    upgrade.description = "More powerful napalm weapons"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 2000
    upgrade.build_time = 45.0
    upgrade.requires_building = "nuclear_reactor"
    upgrade.damage_bonus = 25.0
    upgrade.affects_units.add("dragon_tank")
    upgrade.affects_units.add("inferno_cannon")
    upgrade.affects_units.add("mig")
    return upgrade
}

fn create_uranium_shells() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("uranium_shells", "Uranium Shells", "China")
    upgrade.description = "Depleted uranium ammunition"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 2500
    upgrade.build_time = 60.0
    upgrade.requires_building = "nuclear_reactor"
    upgrade.science_level = 3
    upgrade.damage_bonus = 25.0
    upgrade.affects_units.add("battlemaster")
    upgrade.affects_units.add("overlord")
    upgrade.affects_units.add("nuke_cannon")
    return upgrade
}

fn create_nuke_mig() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("nuke_mig", "Nuclear MiG", "China")
    upgrade.description = "MiGs carry tactical nukes"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 2000
    upgrade.build_time = 45.0
    upgrade.requires_building = "nuclear_reactor"
    upgrade.damage_bonus = 100.0
    upgrade.affects_units.add("mig")
    return upgrade
}

fn create_autoloader() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("autoloader", "Autoloader", "China")
    upgrade.description = "Tanks fire faster"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 1000
    upgrade.build_time = 30.0
    upgrade.requires_building = "propaganda_center"
    upgrade.damage_bonus = 20.0  // From faster ROF
    upgrade.affects_units.add("battlemaster")
    upgrade.affects_units.add("gattling_tank")
    return upgrade
}

fn create_subliminal_messaging() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("subliminal_messaging", "Subliminal Messaging", "China")
    upgrade.description = "Propaganda towers heal faster"
    upgrade.category = UpgradeCategory::SPECIAL
    upgrade.cost = 500
    upgrade.build_time = 20.0
    upgrade.requires_building = "propaganda_center"
    upgrade.affects_buildings.add("propaganda_tower")
    return upgrade
}

fn create_hacker_software() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("hacker_software", "Internet Upgrade", "China")
    upgrade.description = "Hackers generate more income"
    upgrade.category = UpgradeCategory::ECONOMY
    upgrade.cost = 1000
    upgrade.build_time = 30.0
    upgrade.requires_building = "internet_center"
    upgrade.income_bonus = 10.0
    upgrade.affects_units.add("hacker")
    return upgrade
}

fn create_satellite_hack() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("satellite_hack", "Satellite Hack", "China")
    upgrade.description = "Hackers reveal enemy positions"
    upgrade.category = UpgradeCategory::SPECIAL
    upgrade.cost = 2000
    upgrade.build_time = 60.0
    upgrade.requires_building = "internet_center"
    upgrade.science_level = 2
    upgrade.affects_units.add("hacker")
    return upgrade
}

// GLA Upgrades
fn create_junk_repair() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("junk_repair", "Junk Repair", "GLA")
    upgrade.description = "Vehicles slowly self-repair"
    upgrade.category = UpgradeCategory::SPECIAL
    upgrade.cost = 1000
    upgrade.build_time = 30.0
    upgrade.requires_building = "palace"
    upgrade.affects_units.add("scorpion")
    upgrade.affects_units.add("marauder")
    upgrade.affects_units.add("toxin_tractor")
    return upgrade
}

fn create_anthrax_beta() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("anthrax_beta", "Anthrax Beta", "GLA")
    upgrade.description = "More potent anthrax weapons"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 2500
    upgrade.build_time = 60.0
    upgrade.requires_building = "palace"
    upgrade.science_level = 3
    upgrade.damage_bonus = 25.0
    upgrade.affects_units.add("toxin_tractor")
    upgrade.affects_units.add("toxin_rebel")
    upgrade.affects_buildings.add("toxin_tunnel")
    return upgrade
}

fn create_anthrax_gamma() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("anthrax_gamma", "Anthrax Gamma", "GLA")
    upgrade.description = "Deadliest anthrax variant"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 2000
    upgrade.build_time = 45.0
    upgrade.requires_building = "palace"
    upgrade.requires_upgrade = "anthrax_beta"
    upgrade.science_level = 5
    upgrade.damage_bonus = 25.0
    upgrade.affects_units.add("toxin_tractor")
    upgrade.affects_units.add("toxin_rebel")
    return upgrade
}

fn create_ap_bullets() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("ap_bullets", "AP Bullets", "GLA")
    upgrade.description = "Armor-piercing ammunition"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 1000
    upgrade.build_time = 30.0
    upgrade.requires_building = "palace"
    upgrade.damage_bonus = 25.0
    upgrade.affects_units.add("rpg_trooper")
    upgrade.affects_units.add("rebel")
    upgrade.affects_units.add("terrorist")
    return upgrade
}

fn create_ap_rockets() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("ap_rockets", "AP Rockets", "GLA")
    upgrade.description = "Armor-piercing rockets"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 2000
    upgrade.build_time = 45.0
    upgrade.requires_building = "black_market"
    upgrade.damage_bonus = 25.0
    upgrade.affects_units.add("rpg_trooper")
    upgrade.affects_units.add("scorpion")
    return upgrade
}

fn create_arm_the_mob() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("arm_the_mob", "Arm the Mob", "GLA")
    upgrade.description = "Angry mobs receive AK-47s"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 800
    upgrade.build_time = 20.0
    upgrade.requires_building = "palace"
    upgrade.damage_bonus = 50.0
    upgrade.affects_units.add("angry_mob")
    return upgrade
}

fn create_camouflage() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("camouflage_upgrade", "Camouflage", "GLA")
    upgrade.description = "Units gain stealth when stationary"
    upgrade.category = UpgradeCategory::SPECIAL
    upgrade.cost = 2000
    upgrade.build_time = 60.0
    upgrade.requires_building = "palace"
    upgrade.science_level = 2
    upgrade.affects_units.add("scorpion")
    upgrade.affects_units.add("marauder")
    upgrade.affects_units.add("quad_cannon")
    return upgrade
}

fn create_buggy_ammo() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("buggy_ammo", "Buggy Ammo", "GLA")
    upgrade.description = "Technical and Quad Cannon get better ammo"
    upgrade.category = UpgradeCategory::DAMAGE
    upgrade.cost = 1200
    upgrade.build_time = 30.0
    upgrade.requires_building = "arms_dealer"
    upgrade.damage_bonus = 25.0
    upgrade.affects_units.add("technical")
    upgrade.affects_units.add("quad_cannon")
    return upgrade
}

fn create_radar_van_scan() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("radar_van_scan", "Radar Scan", "GLA")
    upgrade.description = "Radar Van reveals stealth"
    upgrade.category = UpgradeCategory::SPECIAL
    upgrade.cost = 500
    upgrade.build_time = 20.0
    upgrade.requires_building = "black_market"
    upgrade.affects_units.add("radar_van")
    return upgrade
}

fn create_worker_shoes() -> UpgradeDefinition {
    let upgrade = UpgradeDefinition::init("worker_shoes", "Worker Shoes", "GLA")
    upgrade.description = "Workers move faster"
    upgrade.category = UpgradeCategory::SPEED
    upgrade.cost = 200
    upgrade.build_time = 15.0
    upgrade.requires_building = "supply_stash"
    upgrade.speed_bonus = 25.0
    upgrade.affects_units.add("worker")
    return upgrade
}

struct TechTreeNode {
    upgrade: UpgradeDefinition,
    is_researched: Bool,
    research_progress: Float,
    children: Collection<TechTreeNode>,

    fn init(upgrade: UpgradeDefinition) -> TechTreeNode {
        let node = TechTreeNode {
            upgrade: upgrade,
            is_researched: false,
            research_progress: 0.0,
            children: Collection::init(),
        }
        return node
    }

    fn can_research(self) -> Bool {
        if self.is_researched {
            return false
        }

        // Check if prerequisite is researched
        if self.upgrade.requires_upgrade != "" {
            return false  // Parent would check this
        }

        return true
    }

    fn start_research(self) -> Bool {
        if !self.can_research() {
            return false
        }

        self.research_progress = 0.0
        return true
    }

    fn update_research(self, dt: Float) -> Bool {
        if self.is_researched {
            return true
        }

        self.research_progress = self.research_progress + dt

        if self.research_progress >= self.upgrade.build_time {
            self.is_researched = true
            return true
        }

        return false
    }
}

struct UpgradeRegistry {
    upgrades: Collection<UpgradeDefinition>,

    fn init() -> UpgradeRegistry {
        let registry = UpgradeRegistry {
            upgrades: Collection::init(),
        }

        // USA Upgrades
        registry.upgrades.add(create_composite_armor())
        registry.upgrades.add(create_tow_missile())
        registry.upgrades.add(create_drone_armor())
        registry.upgrades.add(create_advanced_training())
        registry.upgrades.add(create_laser_missiles())
        registry.upgrades.add(create_countermeasures())
        registry.upgrades.add(create_supply_lines())

        // China Upgrades
        registry.upgrades.add(create_chain_guns())
        registry.upgrades.add(create_black_napalm())
        registry.upgrades.add(create_uranium_shells())
        registry.upgrades.add(create_nuke_mig())
        registry.upgrades.add(create_autoloader())
        registry.upgrades.add(create_subliminal_messaging())
        registry.upgrades.add(create_hacker_software())
        registry.upgrades.add(create_satellite_hack())

        // GLA Upgrades
        registry.upgrades.add(create_junk_repair())
        registry.upgrades.add(create_anthrax_beta())
        registry.upgrades.add(create_anthrax_gamma())
        registry.upgrades.add(create_ap_bullets())
        registry.upgrades.add(create_ap_rockets())
        registry.upgrades.add(create_arm_the_mob())
        registry.upgrades.add(create_camouflage())
        registry.upgrades.add(create_buggy_ammo())
        registry.upgrades.add(create_radar_van_scan())
        registry.upgrades.add(create_worker_shoes())

        return registry
    }

    fn get_upgrade(self, id: String) -> UpgradeDefinition? {
        for i in 0..self.upgrades.len() {
            let upgrade = self.upgrades.get(i)
            if upgrade.id == id {
                return upgrade
            }
        }
        return null
    }

    fn get_faction_upgrades(self, faction: String) -> Collection<UpgradeDefinition> {
        let result = Collection::init()

        for i in 0..self.upgrades.len() {
            let upgrade = self.upgrades.get(i)
            if upgrade.faction == faction {
                result.add(upgrade)
            }
        }

        return result
    }

    fn get_upgrades_by_category(self, category: UpgradeCategory) -> Collection<UpgradeDefinition> {
        let result = Collection::init()

        for i in 0..self.upgrades.len() {
            let upgrade = self.upgrades.get(i)
            if upgrade.category == category {
                result.add(upgrade)
            }
        }

        return result
    }
}

struct PlayerUpgrades {
    player_id: Int,
    faction: String,
    researched: Collection<String>,  // Upgrade IDs
    in_progress: String,  // Current upgrade being researched
    progress: Float,

    fn init(player_id: Int, faction: String) -> PlayerUpgrades {
        let upgrades = PlayerUpgrades {
            player_id: player_id,
            faction: faction,
            researched: Collection::init(),
            in_progress: "",
            progress: 0.0,
        }
        return upgrades
    }

    fn has_upgrade(self, upgrade_id: String) -> Bool {
        for i in 0..self.researched.len() {
            let id = self.researched.get(i)
            if id == upgrade_id {
                return true
            }
        }
        return false
    }

    fn start_research(self, upgrade_id: String) -> Bool {
        if self.in_progress != "" {
            return false  // Already researching
        }

        if self.has_upgrade(upgrade_id) {
            return false  // Already have it
        }

        self.in_progress = upgrade_id
        self.progress = 0.0
        return true
    }

    fn update_research(self, dt: Float, registry: UpgradeRegistry) -> Bool {
        if self.in_progress == "" {
            return false
        }

        let upgrade = registry.get_upgrade(self.in_progress)
        if upgrade == null {
            return false
        }

        self.progress = self.progress + dt

        if self.progress >= upgrade.build_time {
            self.researched.add(self.in_progress)
            self.in_progress = ""
            self.progress = 0.0
            return true  // Research complete
        }

        return false
    }

    fn cancel_research(self) {
        self.in_progress = ""
        self.progress = 0.0
    }

    fn get_armor_bonus(self, unit_id: String, registry: UpgradeRegistry) -> Float {
        let total = 0.0

        for i in 0..self.researched.len() {
            let upgrade_id = self.researched.get(i)
            let upgrade = registry.get_upgrade(upgrade_id)

            if upgrade != null {
                // Check if this upgrade affects the unit
                for j in 0..upgrade.affects_units.len() {
                    let affected = upgrade.affects_units.get(j)
                    if affected == unit_id {
                        total = total + upgrade.armor_bonus
                    }
                }
            }
        }

        return total
    }

    fn get_damage_bonus(self, unit_id: String, registry: UpgradeRegistry) -> Float {
        let total = 0.0

        for i in 0..self.researched.len() {
            let upgrade_id = self.researched.get(i)
            let upgrade = registry.get_upgrade(upgrade_id)

            if upgrade != null {
                for j in 0..upgrade.affects_units.len() {
                    let affected = upgrade.affects_units.get(j)
                    if affected == unit_id {
                        total = total + upgrade.damage_bonus
                    }
                }
            }
        }

        return total
    }

    fn get_speed_bonus(self, unit_id: String, registry: UpgradeRegistry) -> Float {
        let total = 0.0

        for i in 0..self.researched.len() {
            let upgrade_id = self.researched.get(i)
            let upgrade = registry.get_upgrade(upgrade_id)

            if upgrade != null {
                for j in 0..upgrade.affects_units.len() {
                    let affected = upgrade.affects_units.get(j)
                    if affected == unit_id {
                        total = total + upgrade.speed_bonus
                    }
                }
            }
        }

        return total
    }
}

struct TechTreeManager {
    registry: UpgradeRegistry,
    player_upgrades: Collection<PlayerUpgrades>,

    fn init() -> TechTreeManager {
        let manager = TechTreeManager {
            registry: UpgradeRegistry::init(),
            player_upgrades: Collection::init(),
        }
        return manager
    }

    fn add_player(self, player_id: Int, faction: String) {
        let upgrades = PlayerUpgrades::init(player_id, faction)
        self.player_upgrades.add(upgrades)
    }

    fn get_player_upgrades(self, player_id: Int) -> PlayerUpgrades? {
        for i in 0..self.player_upgrades.len() {
            let upgrades = self.player_upgrades.get(i)
            if upgrades.player_id == player_id {
                return upgrades
            }
        }
        return null
    }

    fn research_upgrade(self, player_id: Int, upgrade_id: String) -> Bool {
        let player = self.get_player_upgrades(player_id)
        if player == null {
            return false
        }

        return player.start_research(upgrade_id)
    }

    fn update(self, dt: Float) {
        for i in 0..self.player_upgrades.len() {
            let player = self.player_upgrades.get(i)
            player.update_research(dt, self.registry)
        }
    }

    fn get_available_upgrades(self, player_id: Int) -> Collection<UpgradeDefinition> {
        let player = self.get_player_upgrades(player_id)
        if player == null {
            return Collection::init()
        }

        let faction_upgrades = self.registry.get_faction_upgrades(player.faction)
        let available = Collection::init()

        for i in 0..faction_upgrades.len() {
            let upgrade = faction_upgrades.get(i)

            // Check if already researched
            if player.has_upgrade(upgrade.id) {
                continue
            }

            // Check prerequisites
            if upgrade.requires_upgrade != "" {
                if !player.has_upgrade(upgrade.requires_upgrade) {
                    continue
                }
            }

            available.add(upgrade)
        }

        return available
    }
}

// Tests
fn test_upgrade_creation() -> Bool {
    let armor = create_composite_armor()
    assert(armor.id == "composite_armor", "Armor ID")
    assert(armor.faction == "USA", "Armor faction")
    assert(armor.armor_bonus == 25.0, "Armor bonus")
    return true
}

fn test_upgrade_registry() -> Bool {
    let registry = UpgradeRegistry::init()

    assert(registry.upgrades.len() > 25, "Has upgrades")

    let composite = registry.get_upgrade("composite_armor")
    assert(composite != null, "Found composite armor")

    let usa = registry.get_faction_upgrades("USA")
    assert(usa.len() == 7, "USA upgrade count")

    let china = registry.get_faction_upgrades("China")
    assert(china.len() == 8, "China upgrade count")

    let gla = registry.get_faction_upgrades("GLA")
    assert(gla.len() == 10, "GLA upgrade count")

    return true
}

fn test_player_upgrades() -> Bool {
    let player = PlayerUpgrades::init(1, "USA")

    assert(!player.has_upgrade("composite_armor"), "No upgrades initially")
    assert(player.in_progress == "", "Nothing in progress")

    let started = player.start_research("composite_armor")
    assert(started, "Started research")
    assert(player.in_progress == "composite_armor", "In progress set")

    return true
}

fn test_research_progress() -> Bool {
    let registry = UpgradeRegistry::init()
    let player = PlayerUpgrades::init(1, "USA")

    player.start_research("composite_armor")

    // Update for 20 seconds
    player.update_research(20.0, registry)
    assert(!player.has_upgrade("composite_armor"), "Not done yet")

    // Update for remaining time
    player.update_research(30.0, registry)
    assert(player.has_upgrade("composite_armor"), "Research complete")
    assert(player.in_progress == "", "No longer in progress")

    return true
}

fn test_bonus_calculation() -> Bool {
    let registry = UpgradeRegistry::init()
    let player = PlayerUpgrades::init(1, "USA")

    player.researched.add("composite_armor")

    let bonus = player.get_armor_bonus("crusader", registry)
    assert(bonus == 25.0, "Crusader armor bonus")

    let paladin_bonus = player.get_armor_bonus("paladin", registry)
    assert(paladin_bonus == 25.0, "Paladin armor bonus")

    return true
}

fn test_tech_tree_manager() -> Bool {
    let manager = TechTreeManager::init()

    manager.add_player(1, "USA")
    manager.add_player(2, "China")

    let player1 = manager.get_player_upgrades(1)
    assert(player1 != null, "Found player 1")
    assert(player1.faction == "USA", "Player 1 faction")

    let available = manager.get_available_upgrades(1)
    assert(available.len() == 7, "All USA upgrades available")

    return true
}

fn test_prerequisites() -> Bool {
    let registry = UpgradeRegistry::init()
    let gamma = registry.get_upgrade("anthrax_gamma")

    assert(gamma != null, "Found gamma")
    assert(gamma.requires_upgrade == "anthrax_beta", "Requires beta")

    let player = PlayerUpgrades::init(1, "GLA")
    let manager = TechTreeManager::init()
    manager.add_player(1, "GLA")

    // Gamma should not be available without beta
    let available = manager.get_available_upgrades(1)
    let has_gamma = false
    for i in 0..available.len() {
        let upgrade = available.get(i)
        if upgrade.id == "anthrax_gamma" {
            has_gamma = true
        }
    }
    assert(!has_gamma, "Gamma not available without beta")

    return true
}

fn test_category_filtering() -> Bool {
    let registry = UpgradeRegistry::init()

    let armor = registry.get_upgrades_by_category(UpgradeCategory::ARMOR)
    assert(armor.len() > 0, "Has armor upgrades")

    let damage = registry.get_upgrades_by_category(UpgradeCategory::DAMAGE)
    assert(damage.len() > 5, "Has damage upgrades")

    let economy = registry.get_upgrades_by_category(UpgradeCategory::ECONOMY)
    assert(economy.len() > 0, "Has economy upgrades")

    return true
}

fn test_multiple_bonuses() -> Bool {
    let registry = UpgradeRegistry::init()
    let player = PlayerUpgrades::init(1, "China")

    // Add multiple upgrades affecting same unit
    player.researched.add("chain_guns")
    player.researched.add("uranium_shells")

    let total = player.get_damage_bonus("battlemaster", registry)
    assert(total == 75.0, "Multiple bonuses stack (50 + 25)")

    return true
}

fn test_cancel_research() -> Bool {
    let player = PlayerUpgrades::init(1, "USA")

    player.start_research("composite_armor")
    assert(player.in_progress == "composite_armor", "Started")

    player.cancel_research()
    assert(player.in_progress == "", "Cancelled")
    assert(player.progress == 0.0, "Progress reset")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_upgrade_creation(), "Test 1: Upgrade creation")
    assert(test_upgrade_registry(), "Test 2: Upgrade registry")
    assert(test_player_upgrades(), "Test 3: Player upgrades")
    assert(test_research_progress(), "Test 4: Research progress")
    assert(test_bonus_calculation(), "Test 5: Bonus calculation")
    assert(test_tech_tree_manager(), "Test 6: Tech tree manager")
    assert(test_prerequisites(), "Test 7: Prerequisites")
    assert(test_category_filtering(), "Test 8: Category filtering")
    assert(test_multiple_bonuses(), "Test 9: Multiple bonuses")
    assert(test_cancel_research(), "Test 10: Cancel research")
    return true
}
