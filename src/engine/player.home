// Player and Team system for C&C Generals Zero Hour
// Based on Thyme's player.h and team.h
// Written in Home language

// Player relationships
enum Relationship {
    NEUTRAL = 0,
    ENEMY = 1,
    ALLY = 2,
    SELF = 3,
}

// Player difficulty (for AI)
enum PlayerDifficulty {
    EASY = 0,
    MEDIUM = 1,
    HARD = 2,
    BRUTAL = 3,
}

// Player types
enum PlayerType {
    HUMAN = 0,
    COMPUTER = 1,
    OBSERVER = 2,
}

// Faction types
enum FactionType {
    USA = 0,
    CHINA = 1,
    GLA = 2,
}

// Team - Group of players with shared vision/alliance
struct Team {
    team_id: i32,
    name: string,
    players: Vec<i32>,  // Player IDs
    is_defeated: bool,

    fn init(team_id: i32, name: string): Team {
        return Team {
            team_id: team_id,
            name: name,
            players: Vec::new(),
            is_defeated: false,
        }
    }

    fn add_player(&self, player_id: i32) {
        self.players.add(player_id)
    }

    fn remove_player(&self, player_id: i32) {
        let new_players = Vec::new()
        for pid in self.players {
            if pid != player_id {
                new_players.add(pid)
            }
        }
        self.players = new_players
    }

    fn has_player(&self, player_id: i32): bool {
        for pid in self.players {
            if pid == player_id {
                return true
            }
        }
        return false
    }

    fn get_player_count(&self): i32 {
        return self.players.count()
    }

    fn is_empty(&self): bool {
        return self.players.count() == 0
    }
}

// Player - Represents a human or AI player
struct Player {
    player_id: i32,
    player_name: string,
    player_type: PlayerType,
    faction: FactionType,
    team_id: i32,
    difficulty: PlayerDifficulty,

    // Resources
    money: f64,
    power: i32,
    power_consumed: i32,

    // Limits
    max_unit_count: i32,
    current_unit_count: i32,

    // Upgrades completed (bitfield)
    upgrades_completed: i32,

    // Science purchased
    science_purchased: i32,

    // General's powers
    general_points: i32,
    general_points_spent: i32,

    // Skirmish stats
    units_built: i32,
    units_lost: i32,
    units_killed: i32,
    buildings_built: i32,
    buildings_lost: i32,
    buildings_destroyed: i32,

    // State
    is_defeated: bool,
    is_observer: bool,
    has_surrendered: bool,

    // Color
    color: i32,  // RGB color for this player

    fn init(
        player_id: i32,
        player_name: string,
        player_type: PlayerType,
        faction: FactionType,
        team_id: i32
    ): Player {
        return Player {
            player_id: player_id,
            player_name: player_name,
            player_type: player_type,
            faction: faction,
            team_id: team_id,
            difficulty: PlayerDifficulty::MEDIUM,
            money: 0.0,
            power: 0,
            power_consumed: 0,
            max_unit_count: 100,
            current_unit_count: 0,
            upgrades_completed: 0,
            science_purchased: 0,
            general_points: 0,
            general_points_spent: 0,
            units_built: 0,
            units_lost: 0,
            units_killed: 0,
            buildings_built: 0,
            buildings_lost: 0,
            buildings_destroyed: 0,
            is_defeated: false,
            is_observer: false,
            has_surrendered: false,
            color: 0xFFFFFF,
        }
    }

    fn get_name(&self): string {
        return self.player_name
    }

    fn get_faction(&self): FactionType {
        return self.faction
    }

    fn is_human(&self): bool {
        return self.player_type == PlayerType::HUMAN
    }

    fn is_ai(&self): bool {
        return self.player_type == PlayerType::COMPUTER
    }

    fn get_money(&self): f64 {
        return self.money
    }

    fn add_money(&self, amount: f64) {
        self.money = self.money + amount
    }

    fn spend_money(&self, amount: f64): bool {
        if self.money >= amount {
            self.money = self.money - amount
            return true
        }
        return false
    }

    fn can_afford(&self, cost: f64): bool {
        return self.money >= cost
    }

    fn get_power(&self): i32 {
        return self.power
    }

    fn get_power_consumed(&self): i32 {
        return self.power_consumed
    }

    fn get_power_available(&self): i32 {
        return self.power - self.power_consumed
    }

    fn has_power(&self): bool {
        return self.get_power_available() >= 0
    }

    fn add_power_generator(&self, power: i32) {
        self.power = self.power + power
    }

    fn remove_power_generator(&self, power: i32) {
        self.power = self.power - power
        if self.power < 0 {
            self.power = 0
        }
    }

    fn add_power_consumer(&self, power: i32) {
        self.power_consumed = self.power_consumed + power
    }

    fn remove_power_consumer(&self, power: i32) {
        self.power_consumed = self.power_consumed - power
        if self.power_consumed < 0 {
            self.power_consumed = 0
        }
    }

    fn has_upgrade(&self, upgrade_id: i32): bool {
        let bit = 1 << upgrade_id
        return (self.upgrades_completed & bit) != 0
    }

    fn add_upgrade(&self, upgrade_id: i32) {
        let bit = 1 << upgrade_id
        self.upgrades_completed = self.upgrades_completed | bit
    }

    fn has_science(&self, science_id: i32): bool {
        let bit = 1 << science_id
        return (self.science_purchased & bit) != 0
    }

    fn purchase_science(&self, science_id: i32, cost: f64): bool {
        if !self.can_afford(cost) {
            return false
        }

        if self.has_science(science_id) {
            return false  // Already purchased
        }

        if self.spend_money(cost) {
            let bit = 1 << science_id
            self.science_purchased = self.science_purchased | bit
            return true
        }

        return false
    }

    fn can_build_more_units(&self): bool {
        return self.current_unit_count < self.max_unit_count
    }

    fn on_unit_built(&self) {
        self.current_unit_count = self.current_unit_count + 1
        self.units_built = self.units_built + 1
    }

    fn on_unit_destroyed(&self, is_own_unit: bool) {
        if is_own_unit {
            self.current_unit_count = self.current_unit_count - 1
            self.units_lost = self.units_lost + 1
        } else {
            self.units_killed = self.units_killed + 1
        }
    }

    fn on_building_built(&self) {
        self.buildings_built = self.buildings_built + 1
    }

    fn on_building_destroyed(&self, is_own_building: bool) {
        if is_own_building {
            self.buildings_lost = self.buildings_lost + 1
        } else {
            self.buildings_destroyed = self.buildings_destroyed + 1
        }
    }

    fn award_general_points(&self, points: i32) {
        self.general_points = self.general_points + points
    }

    fn spend_general_points(&self, points: i32): bool {
        let available = self.general_points - self.general_points_spent
        if available >= points {
            self.general_points_spent = self.general_points_spent + points
            return true
        }
        return false
    }

    fn get_available_general_points(&self): i32 {
        return self.general_points - self.general_points_spent
    }

    fn set_defeated(&self, defeated: bool) {
        self.is_defeated = defeated
    }

    fn surrender(&self) {
        self.has_surrendered = true
        self.is_defeated = true
    }

    fn get_color(&self): i32 {
        return self.color
    }

    fn set_color(&self, color: i32) {
        self.color = color
    }
}

// PlayerManager - Manages all players in the game
struct PlayerManager {
    players: Vec<Player>,
    teams: Vec<Team>,
    local_player_id: i32,

    fn init(): PlayerManager {
        return PlayerManager {
            players: Vec::new(),
            teams: Vec::new(),
            local_player_id: -1,
        }
    }

    fn add_player(&self, player: Player) {
        self.players.add(player)
    }

    fn get_player(&self, player_id: i32): Player? {
        for player in self.players {
            if player.player_id == player_id {
                return player
            }
        }
        return null
    }

    fn get_player_count(&self): i32 {
        return self.players.count()
    }

    fn add_team(&self, team: Team) {
        self.teams.add(team)
    }

    fn get_team(&self, team_id: i32): Team? {
        for team in self.teams {
            if team.team_id == team_id {
                return team
            }
        }
        return null
    }

    fn get_relationship(&self, player_id_a: i32, player_id_b: i32): Relationship {
        if player_id_a == player_id_b {
            return Relationship::SELF
        }

        let player_a = self.get_player(player_id_a)?
        let player_b = self.get_player(player_id_b)?

        if player_a.team_id == player_b.team_id {
            return Relationship::ALLY
        }

        return Relationship::ENEMY
    }

    fn are_allies(&self, player_id_a: i32, player_id_b: i32): bool {
        let rel = self.get_relationship(player_id_a, player_id_b)
        return rel == Relationship::ALLY || rel == Relationship::SELF
    }

    fn are_enemies(&self, player_id_a: i32, player_id_b: i32): bool {
        return self.get_relationship(player_id_a, player_id_b) == Relationship::ENEMY
    }

    fn set_local_player(&self, player_id: i32) {
        self.local_player_id = player_id
    }

    fn get_local_player(&self): Player? {
        return self.get_player(self.local_player_id)
    }

    fn is_local_player(&self, player_id: i32): bool {
        return player_id == self.local_player_id
    }

    fn get_alive_players(&self): Vec<Player> {
        let alive = Vec::new()
        for player in self.players {
            if !player.is_defeated {
                alive.add(player)
            }
        }
        return alive
    }

    fn get_human_players(&self): Vec<Player> {
        let humans = Vec::new()
        for player in self.players {
            if player.is_human() {
                humans.add(player)
            }
        }
        return humans
    }

    fn get_ai_players(&self): Vec<Player> {
        let ais = Vec::new()
        for player in self.players {
            if player.is_ai() {
                ais.add(player)
            }
        }
        return ais
    }
}

// Tests
test "Player: init and basic properties" {
    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::USA, 0)

    assert player.player_id == 0
    assert player.get_name() == "Player 1"
    assert player.is_human()
    assert !player.is_ai()
    assert player.get_faction() == FactionType::USA
}

test "Player: money management" {
    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::USA, 0)

    player.add_money(5000.0)
    assert player.get_money() == 5000.0

    assert player.can_afford(1000.0)
    assert player.spend_money(1000.0)
    assert player.get_money() == 4000.0

    assert !player.can_afford(5000.0)
    assert !player.spend_money(5000.0)
    assert player.get_money() == 4000.0  // No change
}

test "Player: power management" {
    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::CHINA, 0)

    player.add_power_generator(100)
    assert player.get_power() == 100
    assert player.get_power_available() == 100

    player.add_power_consumer(60)
    assert player.get_power_consumed() == 60
    assert player.get_power_available() == 40
    assert player.has_power()

    player.add_power_consumer(50)
    assert player.get_power_available() == -10
    assert !player.has_power()
}

test "Player: upgrades" {
    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::USA, 0)

    assert !player.has_upgrade(5)
    player.add_upgrade(5)
    assert player.has_upgrade(5)
}

test "Player: science purchase" {
    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::CHINA, 0)
    player.add_money(5000.0)

    assert !player.has_science(10)
    assert player.purchase_science(10, 2000.0)
    assert player.has_science(10)
    assert player.get_money() == 3000.0

    // Can't purchase twice
    assert !player.purchase_science(10, 2000.0)

    // Can't afford
    assert !player.purchase_science(11, 5000.0)
}

test "Player: unit limits" {
    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::GLA, 0)
    player.max_unit_count = 5

    assert player.can_build_more_units()

    for i in 0..5 {
        player.on_unit_built()
    }

    assert !player.can_build_more_units()
}

test "Player: statistics" {
    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::USA, 0)

    player.on_unit_built()
    player.on_unit_built()
    assert player.units_built == 2

    player.on_unit_destroyed(true)
    assert player.units_lost == 1

    player.on_unit_destroyed(false)
    assert player.units_killed == 1
}

test "Player: general points" {
    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::USA, 0)

    player.award_general_points(5)
    assert player.get_available_general_points() == 5

    assert player.spend_general_points(3)
    assert player.get_available_general_points() == 2

    assert !player.spend_general_points(5)
}

test "Team: player management" {
    let team = Team::init(0, "Team 1")

    team.add_player(0)
    team.add_player(1)

    assert team.has_player(0)
    assert team.has_player(1)
    assert !team.has_player(2)
    assert team.get_player_count() == 2

    team.remove_player(0)
    assert !team.has_player(0)
    assert team.get_player_count() == 1
}

test "PlayerManager: relationships" {
    let manager = PlayerManager::init()

    let player1 = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::USA, 0)
    let player2 = Player::init(1, "Player 2", PlayerType::HUMAN, FactionType::CHINA, 0)
    let player3 = Player::init(2, "Player 3", PlayerType::COMPUTER, FactionType::GLA, 1)

    manager.add_player(player1)
    manager.add_player(player2)
    manager.add_player(player3)

    // Same player
    assert manager.get_relationship(0, 0) == Relationship::SELF

    // Same team
    assert manager.get_relationship(0, 1) == Relationship::ALLY
    assert manager.are_allies(0, 1)

    // Different team
    assert manager.get_relationship(0, 2) == Relationship::ENEMY
    assert manager.are_enemies(0, 2)
}

test "PlayerManager: local player" {
    let manager = PlayerManager::init()

    let player = Player::init(0, "Player 1", PlayerType::HUMAN, FactionType::USA, 0)
    manager.add_player(player)

    manager.set_local_player(0)
    assert manager.is_local_player(0)

    let local = manager.get_local_player()?
    assert local.player_id == 0
}

test "PlayerManager: filtering players" {
    let manager = PlayerManager::init()

    let human1 = Player::init(0, "Human 1", PlayerType::HUMAN, FactionType::USA, 0)
    let human2 = Player::init(1, "Human 2", PlayerType::HUMAN, FactionType::CHINA, 0)
    let ai1 = Player::init(2, "AI 1", PlayerType::COMPUTER, FactionType::GLA, 1)

    manager.add_player(human1)
    manager.add_player(human2)
    manager.add_player(ai1)

    let humans = manager.get_human_players()
    assert humans.count() == 2

    let ais = manager.get_ai_players()
    assert ais.count() == 1

    human1.set_defeated(true)
    let alive = manager.get_alive_players()
    assert alive.count() == 2
}
