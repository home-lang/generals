// C&C Generals Zero Hour - Home Port
// Entity Component System (ECS)
//
// Original: GameObject.cpp, Module.cpp (Westwood Studios/EA)
// Redesigned as modern ECS in Home

import basics/allocator
import engine/math
import graphics/mesh

// Entity is just an ID
struct Entity {
    id: u32
    generation: u32  // For detecting stale references
}

// Component type IDs
enum ComponentType {
    Transform = 0
    Renderable = 1
    Velocity = 2
    Health = 3
    Unit = 4
    Building = 5
    Weapon = 6
    Selectable = 7
    Team = 8
}

// Component: Transform (position, rotation, scale)
struct TransformComponent {
    entity: Entity
    transform: Transform
    child_count: usize
}

// Component: Renderable (visual representation)
struct RenderableComponent {
    entity: Entity
    visible: bool
    cast_shadow: bool
    receive_shadow: bool
}

// Component: Velocity (movement)
struct VelocityComponent {
    entity: Entity
    linear: Vec3
    angular: Vec3
    max_speed: f32
}

// Component: Health (damage/destruction)
struct HealthComponent {
    entity: Entity
    current: f32
    maximum: f32
    regeneration_rate: f32
    armor: f32
}

// Component: Unit (RTS unit specific)
struct UnitComponent {
    entity: Entity
    unit_type: string
    move_speed: f32
    turn_speed: f32
    attack_range: f32
    vision_range: f32
    experience: u32
    veterancy_level: u32
}

// Component: Building (structure specific)
struct BuildingComponent {
    entity: Entity
    building_type: string
    construction_progress: f32
    is_constructing: bool
    power_consumption: i32
    power_production: i32
}

// Component: Weapon
struct WeaponComponent {
    entity: Entity
    weapon_name: string
    damage: f32
    range: f32
    fire_rate: f32
    reload_time: f32
    ammo_current: u32
    ammo_max: u32
    last_fire_time: f64
}

// Component: Selectable (can be selected by player)
struct SelectableComponent {
    entity: Entity
    is_selected: bool
    selection_priority: u32
    selection_radius: f32
}

// Component: Team
struct TeamComponent {
    entity: Entity
    team_id: u32
    is_friendly: bool
}

// Component storage (array-based for cache efficiency)
struct ComponentArray<T> {
    components: []T
    entity_to_index: [4096]u32  // Map entity ID to component index
    index_to_entity: [4096]u32  // Map component index to entity ID
    count: usize
    capacity: usize
    allocator: Allocator

    fn init(allocator: Allocator, capacity: usize): ComponentArray<T> {
        return ComponentArray {
            components: allocator.alloc(T, capacity)
            entity_to_index: [4096]u32{ 0xFFFFFFFF }  // Invalid index
            index_to_entity: [4096]u32{ 0 }
            count: 0
            capacity: capacity
            allocator: allocator
        }
    }

    fn add(mut self, entity: Entity, component: T): bool {
        if (self.count >= self.capacity) {
            return false
        }

        if (entity.id >= 4096) {
            return false
        }

        // Add component
        let index = self.count
        self.components[index] = component
        self.entity_to_index[entity.id] = @intCast(u32, index)
        self.index_to_entity[index] = entity.id
        self.count += 1

        return true
    }

    fn remove(mut self, entity: Entity): bool {
        if (entity.id >= 4096) {
            return false
        }

        let index = self.entity_to_index[entity.id]
        if (index == 0xFFFFFFFF) {
            return false  // Entity doesn't have this component
        }

        // Swap with last element
        let last_index = self.count - 1
        if (index < last_index) {
            self.components[index] = self.components[last_index]

            let moved_entity_id = self.index_to_entity[last_index]
            self.entity_to_index[moved_entity_id] = @intCast(u32, index)
            self.index_to_entity[index] = moved_entity_id
        }

        // Clear mappings
        self.entity_to_index[entity.id] = 0xFFFFFFFF
        self.count -= 1

        return true
    }

    fn get(&self, entity: Entity): ?*T {
        if (entity.id >= 4096) {
            return null
        }

        let index = self.entity_to_index[entity.id]
        if (index == 0xFFFFFFFF or index >= self.count) {
            return null
        }

        return &self.components[index]
    }

    fn has(&self, entity: Entity): bool {
        if (entity.id >= 4096) {
            return false
        }

        let index = self.entity_to_index[entity.id]
        return index != 0xFFFFFFFF and index < self.count
    }

    fn deinit(mut self) {
        self.allocator.free(self.components)
    }
}

// ECS World (manages all entities and components)
struct World {
    entity_count: usize
    free_count: usize
    next_entity_id: u32
    max_entities: usize
    transforms: ComponentArray<TransformComponent>
    renderables: ComponentArray<RenderableComponent>
    velocities: ComponentArray<VelocityComponent>
    healths: ComponentArray<HealthComponent>
    units: ComponentArray<UnitComponent>
    buildings: ComponentArray<BuildingComponent>
    weapons: ComponentArray<WeaponComponent>
    selectables: ComponentArray<SelectableComponent>
    teams: ComponentArray<TeamComponent>
    allocator: Allocator
}

// Systems operate on components
struct MovementSystem {
}

struct RenderSystem {
}

// Global ECS world
var g_world: ?World = null

export fn init_ecs(allocator: Allocator) {
    g_world = World.init(allocator)
}

export fn shutdown_ecs() {
    if (g_world) {
        g_world.?.deinit()
        g_world = null
    }
}

export fn create_entity(): Entity {
    if (g_world) {
        return g_world.?.create_entity()
    }
    return Entity { id: 0, generation: 0 }
}

export fn destroy_entity(entity: Entity) {
    if (g_world) {
        g_world.?.destroy_entity(entity)
    }
}

export fn update_movement_system(delta_time: f32) {
    if (g_world) {
        MovementSystem.update(&g_world.?, delta_time)
    }
}

export fn update_render_system() {
    if (g_world) {
        RenderSystem.update(&g_world.?)
    }
}

export fn get_world(): ?*World {
    if (g_world) {
        return &g_world.?
    }
    return null
}
