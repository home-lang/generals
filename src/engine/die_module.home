// Die Module - Death Logic and Effects
// Based on Thyme engine die module architecture
// Handles object death, destruction effects, and spawning

from basics import Collection, Map
from behavior_module import ModuleData, create_module_data, get_property, get_property_int, get_property_float, get_property_bool

// ============================================================================
// Death Types
// ============================================================================

enum DeathType {
    Normal,         // Standard death
    Crushed,        // Run over by vehicle
    Burned,         // Fire damage
    Exploded,       // Explosion
    Poisoned,       // Toxin
    Toppled,        // Building collapse
    Flooded,        // Water
    Lasered,        // Laser weapon
    Detonated,      // Self-destruct
    Sold,           // Building sold
    Captured,       // Building captured
    Sunk,           // Vehicle in water
    SuicideBombed,  // Suicide attack
    RadiationDeath, // Nuclear
}

// Death condition flags
const DEATH_FLAG_NONE: Int = 0
const DEATH_FLAG_LEAVE_CORPSE: Int = 1
const DEATH_FLAG_CREATE_DEBRIS: Int = 2
const DEATH_FLAG_SPAWN_CRATES: Int = 4
const DEATH_FLAG_PLAY_SOUND: Int = 8
const DEATH_FLAG_PLAY_FX: Int = 16
const DEATH_FLAG_TRANSFER_GARRISONED: Int = 32
const DEATH_FLAG_COUNT_AS_KILL: Int = 64

// ============================================================================
// Death Event Data
// ============================================================================

struct DeathEvent {
    victim_id: Int,
    victim_type: String,
    killer_id: Int,
    killer_type: String,
    death_type: DeathType,
    position_x: Float,
    position_y: Float,
    position_z: Float,
    damage_amount: Float,
    damage_type: String,
    frame: Int,
}

fn create_death_event(victim_id: Int, killer_id: Int, death_type: DeathType) -> DeathEvent {
    return DeathEvent {
        victim_id: victim_id,
        victim_type: "",
        killer_id: killer_id,
        killer_type: "",
        death_type: death_type,
        position_x: 0.0,
        position_y: 0.0,
        position_z: 0.0,
        damage_amount: 0.0,
        damage_type: "",
        frame: 0,
    }
}

/// Set death position
fn set_death_position(event: DeathEvent, x: Float, y: Float, z: Float) {
    event.position_x = x
    event.position_y = y
    event.position_z = z
}

// ============================================================================
// Base Die Module
// ============================================================================

struct DieModule {
    // Identity
    module_id: Int,
    tag: String,

    // Owner
    owner_id: Int,

    // Configuration
    data: ModuleData,

    // Death behavior
    death_types: Collection<DeathType>,
    required_status: Collection<String>,
    excluded_status: Collection<String>,
    veteran_levels: Collection<Int>,

    // Effects
    fx_list: String,
    ocl_list: String,
    sound: String,

    // Flags
    flags: Int,
}

/// Create base die module
fn create_die_module(tag: String) -> DieModule {
    return DieModule {
        module_id: 0,
        tag: tag,
        owner_id: 0,
        data: create_module_data("", tag),
        death_types: Collection<DeathType>{},
        required_status: Collection<String>{},
        excluded_status: Collection<String>{},
        veteran_levels: Collection<Int>{},
        fx_list: "",
        ocl_list: "",
        sound: "",
        flags: DEATH_FLAG_NONE,
    }
}

/// Initialize from data
fn init_die_module(module: DieModule, data: ModuleData) {
    module.data = data
    module.tag = data.tag

    if data.properties.has("FX") {
        module.fx_list = get_property(data, "FX")
    }
    if data.properties.has("OCL") {
        module.ocl_list = get_property(data, "OCL")
    }
    if data.properties.has("Sound") {
        module.sound = get_property(data, "Sound")
    }
}

/// Check if module should trigger
fn should_trigger(module: DieModule, event: DeathEvent, object_status: Collection<String>, vet_level: Int) -> Bool {
    // Check death type
    if module.death_types.len() > 0 {
        let found = false
        for dt in module.death_types {
            if dt == event.death_type {
                found = true
                break
            }
        }
        if !found {
            return false
        }
    }

    // Check required status
    for req in module.required_status {
        let has_status = false
        for status in object_status {
            if status == req {
                has_status = true
                break
            }
        }
        if !has_status {
            return false
        }
    }

    // Check excluded status
    for excl in module.excluded_status {
        for status in object_status {
            if status == excl {
                return false
            }
        }
    }

    // Check veteran level
    if module.veteran_levels.len() > 0 {
        let found = false
        for level in module.veteran_levels {
            if level == vet_level {
                found = true
                break
            }
        }
        if !found {
            return false
        }
    }

    return true
}

/// Add death type trigger
fn add_death_type(module: DieModule, death_type: DeathType) {
    module.death_types.add(death_type)
}

/// Add required status
fn add_required_status(module: DieModule, status: String) {
    module.required_status.add(status)
}

/// Add excluded status
fn add_excluded_status(module: DieModule, status: String) {
    module.excluded_status.add(status)
}

// ============================================================================
// Specialized Die Modules
// ============================================================================

// FXList Die - Play effects on death
struct FXListDieModule {
    base: DieModule,
    fx_list_names: Collection<String>,
    orient_to_ground: Bool,
    at_bone: String,
}

fn create_fxlist_die(tag: String) -> FXListDieModule {
    let module = FXListDieModule {
        base: create_die_module(tag),
        fx_list_names: Collection<String>{},
        orient_to_ground: true,
        at_bone: "",
    }
    module.base.flags = module.base.flags | DEATH_FLAG_PLAY_FX
    return module
}

/// Add FX list
fn add_fx_list(module: FXListDieModule, name: String) {
    module.fx_list_names.add(name)
}

// Create Object Die - Spawn objects on death
struct CreateObjectDieModule {
    base: DieModule,
    create_object: String,
    count: Int,
    offset_x: Float,
    offset_y: Float,
    offset_z: Float,
    inherit_team: Bool,
    transfer_health: Bool,
}

fn create_object_die(tag: String) -> CreateObjectDieModule {
    return CreateObjectDieModule {
        base: create_die_module(tag),
        create_object: "",
        count: 1,
        offset_x: 0.0,
        offset_y: 0.0,
        offset_z: 0.0,
        inherit_team: true,
        transfer_health: false,
    }
}

/// Get spawn data
fn get_spawn_data(module: CreateObjectDieModule, event: DeathEvent) -> Collection<(String, Float, Float, Float)> {
    let spawns = Collection<(String, Float, Float, Float)>{}

    for i in 0..module.count {
        let x = event.position_x + module.offset_x
        let y = event.position_y + module.offset_y
        let z = event.position_z + module.offset_z
        spawns.add((module.create_object, x, y, z))
    }

    return spawns
}

// Create Crate Die - Drop crates on death
struct CreateCrateDieModule {
    base: DieModule,
    crate_type: String,
    chance: Float,  // 0.0 to 1.0
    must_be_killed_by_player: Bool,
}

fn create_crate_die(tag: String) -> CreateCrateDieModule {
    let module = CreateCrateDieModule {
        base: create_die_module(tag),
        crate_type: "HealthCrate",
        chance: 0.1,  // 10% default
        must_be_killed_by_player: true,
    }
    module.base.flags = module.base.flags | DEATH_FLAG_SPAWN_CRATES
    return module
}

/// Should spawn crate (random)
fn should_spawn_crate(module: CreateCrateDieModule, event: DeathEvent, random_value: Float) -> Bool {
    if module.must_be_killed_by_player && event.killer_id <= 0 {
        return false
    }
    return random_value < module.chance
}

// Special Power Completion Die - Trigger power on death
struct SpecialPowerCompletionDieModule {
    base: DieModule,
    power_template: String,
    power_radius: Float,
    power_damage: Float,
    power_delay: Float,
}

fn create_special_power_die(tag: String) -> SpecialPowerCompletionDieModule {
    return SpecialPowerCompletionDieModule {
        base: create_die_module(tag),
        power_template: "",
        power_radius: 100.0,
        power_damage: 0.0,
        power_delay: 0.0,
    }
}

// Destroy Die - Clean destruction
struct DestroyDieModule {
    base: DieModule,
    destroy_delay: Float,
    debris_count: Int,
    debris_types: Collection<String>,
}

fn create_destroy_die(tag: String) -> DestroyDieModule {
    let module = DestroyDieModule {
        base: create_die_module(tag),
        destroy_delay: 0.0,
        debris_count: 0,
        debris_types: Collection<String>{},
    }
    module.base.flags = module.base.flags | DEATH_FLAG_CREATE_DEBRIS
    return module
}

/// Add debris type
fn add_debris_type(module: DestroyDieModule, debris: String) {
    module.debris_types.add(debris)
}

// Slow Death Die - Animated death
struct SlowDeathDieModule {
    base: DieModule,
    sink_rate: Float,
    sink_delay: Float,
    destruction_delay: Float,
    fx_at_final: String,
    wait_for_sink: Bool,
    fade_delay: Float,
    fade_time: Float,
}

fn create_slow_death_die(tag: String) -> SlowDeathDieModule {
    return SlowDeathDieModule {
        base: create_die_module(tag),
        sink_rate: 0.0,
        sink_delay: 0.0,
        destruction_delay: 5.0,
        fx_at_final: "",
        wait_for_sink: false,
        fade_delay: 3.0,
        fade_time: 2.0,
    }
}

/// Get total death duration
fn get_death_duration(module: SlowDeathDieModule) -> Float {
    return module.destruction_delay + module.sink_delay
}

// Upgrade Die - Transform on death
struct UpgradeDieModule {
    base: DieModule,
    upgrade_to: String,
    copy_team: Bool,
    copy_experience: Bool,
}

fn create_upgrade_die(tag: String) -> UpgradeDieModule {
    return UpgradeDieModule {
        base: create_die_module(tag),
        upgrade_to: "",
        copy_team: true,
        copy_experience: true,
    }
}

// Rebuild Hole Die - Leave foundation
struct RebuildHoleDieModule {
    base: DieModule,
    hole_lifetime: Float,
    rebuild_cost_multiplier: Float,
}

fn create_rebuild_hole_die(tag: String) -> RebuildHoleDieModule {
    return RebuildHoleDieModule {
        base: create_die_module(tag),
        hole_lifetime: 60.0,
        rebuild_cost_multiplier: 0.5,
    }
}

// ============================================================================
// Die Module Manager
// ============================================================================

struct DieModuleManager {
    modules: Map<Int, DieModule>,
    by_owner: Map<Int, Collection<Int>>,
    next_id: Int,
    pending_deaths: Collection<DeathEvent>,
}

fn create_die_manager() -> DieModuleManager {
    return DieModuleManager {
        modules: Map<Int, DieModule>{},
        by_owner: Map<Int, Collection<Int>>{},
        next_id: 1,
        pending_deaths: Collection<DeathEvent>{},
    }
}

/// Register die module
fn register_die(mgr: DieModuleManager, module: DieModule) -> Int {
    let id = mgr.next_id
    mgr.next_id = mgr.next_id + 1
    module.module_id = id

    mgr.modules.set(id, module)

    // Index by owner
    if !mgr.by_owner.has(module.owner_id) {
        mgr.by_owner.set(module.owner_id, Collection<Int>{})
    }
    mgr.by_owner.get(module.owner_id).add(id)

    return id
}

/// Get modules for owner
fn get_die_modules_for_owner(mgr: DieModuleManager, owner_id: Int) -> Collection<DieModule> {
    let result = Collection<DieModule>{}
    if mgr.by_owner.has(owner_id) {
        for id in mgr.by_owner.get(owner_id) {
            if mgr.modules.has(id) {
                result.add(mgr.modules.get(id))
            }
        }
    }
    return result
}

/// Queue death
fn queue_death(mgr: DieModuleManager, event: DeathEvent) {
    mgr.pending_deaths.add(event)
}

/// Process pending deaths
fn process_deaths(mgr: DieModuleManager) -> Collection<DeathEvent> {
    let processed = mgr.pending_deaths
    mgr.pending_deaths = Collection<DeathEvent>{}
    return processed
}

/// Execute death for object
fn execute_death(mgr: DieModuleManager, event: DeathEvent, object_status: Collection<String>, vet_level: Int) -> Collection<(String, String)> {
    // Returns (action_type, parameter) pairs
    let actions = Collection<(String, String)>{}

    let modules = get_die_modules_for_owner(mgr, event.victim_id)
    for module in modules {
        if should_trigger(module, event, object_status, vet_level) {
            if module.fx_list.len() > 0 {
                actions.add(("fx", module.fx_list))
            }
            if module.ocl_list.len() > 0 {
                actions.add(("ocl", module.ocl_list))
            }
            if module.sound.len() > 0 {
                actions.add(("sound", module.sound))
            }
        }
    }

    return actions
}

// ============================================================================
// Tests
// ============================================================================

fn test_death_event() -> Bool {
    let event = create_death_event(100, 200, DeathType::Exploded)
    set_death_position(event, 50.0, 100.0, 0.0)

    assert(event.victim_id == 100, "Victim should be 100")
    assert(event.killer_id == 200, "Killer should be 200")
    assert(event.death_type == DeathType::Exploded, "Death type should be Exploded")
    assert(event.position_x == 50.0, "X should be 50")

    return true
}

fn test_die_module_trigger() -> Bool {
    let module = create_die_module("TestDie")
    add_death_type(module, DeathType::Normal)
    add_death_type(module, DeathType::Burned)

    let event_normal = create_death_event(1, 2, DeathType::Normal)
    let event_exploded = create_death_event(1, 2, DeathType::Exploded)

    let status = Collection<String>{}
    assert(should_trigger(module, event_normal, status, 0) == true, "Should trigger on Normal")
    assert(should_trigger(module, event_exploded, status, 0) == false, "Should not trigger on Exploded")

    return true
}

fn test_create_object_die() -> Bool {
    let module = create_object_die("SpawnOnDeath")
    module.create_object = "Debris"
    module.count = 3

    let event = create_death_event(100, 200, DeathType::Exploded)
    set_death_position(event, 10.0, 20.0, 0.0)

    let spawns = get_spawn_data(module, event)
    assert(spawns.len() == 3, "Should spawn 3 debris")

    return true
}

fn test_slow_death_die() -> Bool {
    let module = create_slow_death_die("SlowDeath")
    module.destruction_delay = 5.0
    module.sink_delay = 2.0

    let duration = get_death_duration(module)
    assert(duration == 7.0, "Total duration should be 7.0")

    return true
}

fn test_crate_die() -> Bool {
    let module = create_crate_die("CrateDrop")
    module.chance = 0.5
    module.must_be_killed_by_player = true

    let event_with_killer = create_death_event(100, 1, DeathType::Normal)
    let event_no_killer = create_death_event(100, 0, DeathType::Normal)

    assert(should_spawn_crate(module, event_with_killer, 0.3) == true, "Should spawn (0.3 < 0.5)")
    assert(should_spawn_crate(module, event_with_killer, 0.7) == false, "Should not spawn (0.7 > 0.5)")
    assert(should_spawn_crate(module, event_no_killer, 0.3) == false, "Should not spawn without killer")

    return true
}

fn test_die_manager() -> Bool {
    let mgr = create_die_manager()

    let module = create_die_module("DeathFX")
    module.owner_id = 100
    module.fx_list = "DeathExplosion"
    add_death_type(module, DeathType::Normal)
    register_die(mgr, module)

    let event = create_death_event(100, 200, DeathType::Normal)
    queue_death(mgr, event)

    let pending = process_deaths(mgr)
    assert(pending.len() == 1, "Should have 1 pending death")

    let status = Collection<String>{}
    let actions = execute_death(mgr, event, status, 0)
    assert(actions.len() == 1, "Should have 1 action")

    let (action_type, param) = actions.get(0)
    assert(action_type == "fx", "Action should be fx")
    assert(param == "DeathExplosion", "FX should be DeathExplosion")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_death_event(), "Death event test failed")
    assert(test_die_module_trigger(), "Die module trigger test failed")
    assert(test_create_object_die(), "Create object die test failed")
    assert(test_slow_death_die(), "Slow death die test failed")
    assert(test_crate_die(), "Crate die test failed")
    assert(test_die_manager(), "Die manager test failed")
    return true
}
