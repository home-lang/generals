// W3D Loader - Pure Home Implementation
// Load Westwood 3D model format (.w3d files from C&C Generals)
//
// W3D Format Structure:
// - Hierarchical chunk-based binary format
// - Little-endian byte order
// - Each chunk has: type (4 bytes), size (4 bytes), data (variable)

import graphics { Vec3 }

// W3D Chunk Types
enum ChunkType {
    // Top-level chunks
    MESH = 0x00000000,
    HIERARCHY = 0x00000100,
    ANIMATION = 0x00000200,
    COMPRESSED_ANIMATION = 0x00000280,
    MORPH_ANIMATION = 0x000002C0,
    HLOD = 0x00000700,
    BOX = 0x00000740,
    HMODEL = 0x00000300,
    LOD_MODEL = 0x00000400,
    COLLECTION = 0x00000420,

    // Mesh chunks
    VERTICES = 0x00000002,
    VERTEX_NORMALS = 0x00000003,
    MESH_USER_TEXT = 0x0000000C,
    VERTEX_INFLUENCES = 0x0000000E,
    MESH_HEADER3 = 0x0000001F,
    TRIANGLES = 0x00000020,
    VERTEX_SHADE_INDICES = 0x00000022,
    MATERIAL_INFO = 0x00000028,
    SHADERS = 0x00000029,
    VERTEX_MATERIALS = 0x0000002A,
    VERTEX_MATERIAL = 0x0000002B,
    VERTEX_MATERIAL_NAME = 0x0000002C,
    VERTEX_MATERIAL_INFO = 0x0000002D,
    TEXTURES = 0x00000030,
    TEXTURE = 0x00000031,
    TEXTURE_NAME = 0x00000032,
    TEXTURE_INFO = 0x00000033,

    // Hierarchy chunks
    HIERARCHY_HEADER = 0x00000101,
    PIVOTS = 0x00000102,
    PIVOT_FIXUPS = 0x00000103,

    // Animation chunks
    ANIMATION_HEADER = 0x00000201,
    ANIMATION_CHANNEL = 0x00000202,
    BIT_CHANNEL = 0x00000203,

    // Compressed animation chunks
    COMPRESSED_ANIMATION_HEADER = 0x00000281,
    COMPRESSED_ANIMATION_CHANNEL = 0x00000282,
    COMPRESSED_BIT_CHANNEL = 0x00000283,
}

// W3D Chunk Header
struct ChunkHeader {
    chunk_type: i32,  // ChunkType as int
    chunk_size: i32,  // Size of chunk data (not including header)
}

// Vec3 for vertices and normals
struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

// Vec2 for texture coordinates
struct Vec2 {
    x: f64,
    y: f64,
}

// Triangle
struct Triangle {
    vertex_indices: Vec<i32>,  // 3 vertex indices
    normal: Vec3,
    attributes: i32,
}

// Mesh data
struct W3DMesh {
    name: string,
    vertices: Vec<Vec3>,
    normals: Vec<Vec3>,
    tex_coords: Vec<Vec2>,
    triangles: Vec<Triangle>,
    material_name: string,
    texture_name: string,
}

// Bone/Pivot in hierarchy
struct W3DBone {
    name: string,
    parent_index: i32,
    position: Vec3,
    rotation: Vec3,  // Euler angles
}

// Skeleton hierarchy
struct W3DHierarchy {
    name: string,
    bones: Vec<W3DBone>,
}

// Animation keyframe
struct AnimationKeyframe {
    time: f64,
    position: Vec3,
    rotation: Vec3,
    scale: Vec3,
}

// Animation channel (one per bone)
struct AnimationChannel {
    bone_index: i32,
    keyframes: Vec<AnimationKeyframe>,
}

// Complete animation
struct W3DAnimation {
    name: string,
    duration: f64,
    frame_rate: f64,
    channels: Vec<AnimationChannel>,
}

// Complete W3D model
struct W3DModel {
    name: string,
    meshes: Vec<W3DMesh>,
    hierarchy: W3DHierarchy?,
    animations: Vec<W3DAnimation>,
}

// Binary reader for W3D files
struct BinaryReader {
    data: Vec<i32>,  // Byte array
    position: i32,
}

// W3D Loader
struct W3DLoader {
    reader: BinaryReader?,
}

// Tests
fn test_chunk_header(): bool {
    let header = ChunkHeader::init()
    assert(header.chunk_type == 0, "Chunk type initialized")
    assert(header.chunk_size == 0, "Chunk size initialized")
    return true
}

fn test_mesh_creation(): bool {
    let mesh = W3DMesh::init("test_mesh")
    assert(mesh.name == "test_mesh", "Mesh name")
    assert(mesh.vertices.len() == 0, "No vertices initially")

    mesh.add_vertex(Vec3::init(1.0, 2.0, 3.0))
    assert(mesh.vertices.len() == 1, "One vertex added")

    return true
}

fn test_hierarchy_creation(): bool {
    let hierarchy = W3DHierarchy::init("skeleton")
    assert(hierarchy.name == "skeleton", "Hierarchy name")

    let bone = W3DBone::init("root")
    bone.parent_index = -1
    hierarchy.add_bone(bone)

    assert(hierarchy.get_bone_count() == 1, "One bone added")

    return true
}

fn test_animation_creation(): bool {
    let animation = W3DAnimation::init("walk")
    assert(animation.name == "walk", "Animation name")
    assert(animation.frame_rate == 30.0, "Default frame rate")

    let channel = AnimationChannel::init(0)
    channel.add_keyframe(AnimationKeyframe::init(0.0))
    animation.add_channel(channel)

    assert(animation.channels.len() == 1, "One channel added")

    return true
}

fn test_binary_reader(): bool {
    let data = Vec::init()
    data.add(0x12)
    data.add(0x34)
    data.add(0x56)
    data.add(0x78)

    let reader = BinaryReader::init(data)

    let b1 = reader.read_u8()
    assert(b1 == 0x12, "Read first byte")

    reader.set_position(0)
    let u32 = reader.read_u32()
    assert(u32 == 0x78563412, "Read u32 little-endian")

    return true
}

fn test_w3d_model(): bool {
    let model = W3DModel::init("tank")
    assert(model.name == "tank", "Model name")
    assert(model.meshes.len() == 0, "No meshes initially")

    let mesh = W3DMesh::init("turret")
    model.add_mesh(mesh)

    assert(model.meshes.len() == 1, "One mesh added")

    return true
}

fn test_loader_creation(): bool {
    let loader = W3DLoader::init()
    assert(loader.reader == null, "No reader initially")

    return true
}

fn run_all_tests(): bool {
    assert(test_chunk_header(), "Test 1: Chunk header")
    assert(test_mesh_creation(), "Test 2: Mesh creation")
    assert(test_hierarchy_creation(), "Test 3: Hierarchy creation")
    assert(test_animation_creation(), "Test 4: Animation creation")
    assert(test_binary_reader(), "Test 5: Binary reader")
    assert(test_w3d_model(), "Test 6: W3D model")
    assert(test_loader_creation(), "Test 7: Loader creation")
    return true
}
