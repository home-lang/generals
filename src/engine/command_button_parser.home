// Command Button Parser - Parses CommandButton definitions from INI
// Handles CommandButton and CommandSet blocks from Data/INI/CommandButton.ini

import control_bar { CommandButtonType }

// Parsed command button definition
struct CommandButtonDefinition {
    name: string,
    button_type: CommandButtonType,

    // Display
    button_image: string,
    button_border_type: string,
    display_name: string,
    description: string,
    help_text: string,

    // Cursor
    cursor_name: string,
    invalid_cursor_name: string,
    radius_cursor_type: string,

    // Associated object/power
    object: string,
    upgrade: string,
    special_power: string,
    science: string,
    weapon_slot: string,

    // Requirements
    needs_upgrade: string,
    conflicting_upgrade: string,
    required_science: string,
    needs_special_power_science: string,

    // Options
    options: u32, // Bit flags for various options
    text_label: string,
    auto_ability: bool,
    needs_daytime: bool,

    // UI positioning
    unit_specific_sound: string,

    is_valid: bool,
}

// Command set - defines which buttons appear for a unit type
struct CommandSetDefinition {
    name: string,
    slots: [CommandSetSlot; 18],  // 6x3 grid
    slot_count: u32,
    is_valid: bool,
}

struct CommandSetSlot {
    slot_number: u32,
    command_button: string,
    is_valid: bool,
}

// Command button options flags
const OPTION_OK_FOR_MULTI_SELECT: u32 = 1
const OPTION_CHECK_LIKE: u32 = 2
const OPTION_NEED_TARGET_ENEMY_OBJECT: u32 = 4
const OPTION_NEED_TARGET_NEUTRAL_OBJECT: u32 = 8
const OPTION_NEED_TARGET_ALLY_OBJECT: u32 = 16
const OPTION_CONTEXTMODE_COMMAND: u32 = 32
const OPTION_OPTION_ONE: u32 = 64
const OPTION_OPTION_TWO: u32 = 128
const OPTION_OPTION_THREE: u32 = 256
const OPTION_NEED_UPGRADE: u32 = 512
const OPTION_NOT_QUEUEABLE: u32 = 1024
const OPTION_IGNORES_UNDERPOWERED: u32 = 2048
const OPTION_NEED_SPECIAL_POWER_SCIENCE: u32 = 4096
const OPTION_SCRIPT_ONLY: u32 = 8192
const OPTION_USES_MINE_CLEARING_WEAPON_SLOT: u32 = 16384
const OPTION_SINGLE_USE_COMMAND: u32 = 32768

const MAX_COMMAND_BUTTONS: u32 = 512
const MAX_COMMAND_SETS: u32 = 256

struct CommandButtonParser {
    buttons: [CommandButtonDefinition; MAX_COMMAND_BUTTONS],
    button_count: u32,
    button_name_to_index: HashMap<string, u32>,

    command_sets: [CommandSetDefinition; MAX_COMMAND_SETS],
    set_count: u32,
    set_name_to_index: HashMap<string, u32>,

    // Parse state
    current_button: u32,
    current_set: u32,
    current_slot: u32,
    in_button_block: bool,
    in_set_block: bool,

    // Errors
    parse_errors: [string; 64],
    error_count: u32,
}

impl CommandButtonParser {
    fn new(): Self {
        let parser = CommandButtonParser {
            buttons: [CommandButtonDefinition::default(); MAX_COMMAND_BUTTONS],
            button_count: 0,
            button_name_to_index: HashMap::new(),
            command_sets: [CommandSetDefinition::default(); MAX_COMMAND_SETS],
            set_count: 0,
            set_name_to_index: HashMap::new(),
            current_button: 0,
            current_set: 0,
            current_slot: 0,
            in_button_block: false,
            in_set_block: false,
            parse_errors: [string::default(); 64],
            error_count: 0,
        }
        parser
    }

    fn parse_file(&mut self, file_path: string): bool {
        let content = std::fs::read_to_string(file_path)
        if (content.is_empty()) {
            self.add_error("Failed to read file: " + file_path)
            return false
        }

        let lines = content.split('\n')
        let line_num: u32 = 0

        for line in lines {
            line_num += 1
            let trimmed = line.trim()

            if (trimmed.is_empty() || trimmed.starts_with(";") || trimmed.starts_with("//")) {
                continue
            }

            if (!self.parse_line(trimmed, line_num)) {
                return false
            }
        }

        true
    }

    fn parse_line(&mut self, line: string, line_num: u32): bool {
        // Block starts
        if (line.starts_with("CommandButton ")) {
            return self.begin_button_block(line)
        }

        if (line.starts_with("CommandSet ")) {
            return self.begin_set_block(line)
        }

        // Block end
        if (line == "End") {
            return self.end_current_block()
        }

        // Property parsing
        if (self.in_button_block) {
            return self.parse_button_property(line)
        }

        if (self.in_set_block) {
            return self.parse_set_property(line)
        }

        true
    }

    fn begin_button_block(&mut self, line: string): bool {
        if (self.button_count >= MAX_COMMAND_BUTTONS) {
            return true // Skip, too many
        }

        let parts = line.split(" ")
        if (parts.len() < 2) {
            return true
        }

        let button_name = parts[1].trim()

        self.current_button = self.button_count
        self.buttons[self.current_button] = CommandButtonDefinition::default()
        self.buttons[self.current_button].name = button_name.to_string()
        self.buttons[self.current_button].is_valid = true

        self.button_name_to_index.insert(button_name.to_string(), self.current_button)
        self.button_count += 1
        self.in_button_block = true

        true
    }

    fn begin_set_block(&mut self, line: string): bool {
        if (self.set_count >= MAX_COMMAND_SETS) {
            return true
        }

        let parts = line.split(" ")
        if (parts.len() < 2) {
            return true
        }

        let set_name = parts[1].trim()

        self.current_set = self.set_count
        self.command_sets[self.current_set] = CommandSetDefinition::default()
        self.command_sets[self.current_set].name = set_name.to_string()
        self.command_sets[self.current_set].is_valid = true

        self.set_name_to_index.insert(set_name.to_string(), self.current_set)
        self.set_count += 1
        self.in_set_block = true

        true
    }

    fn end_current_block(&mut self): bool {
        if (self.in_button_block) {
            self.in_button_block = false
        } else if (self.in_set_block) {
            self.in_set_block = false
        }
        true
    }

    fn parse_button_property(&mut self, line: string): bool {
        let parts = self.split_property(line)
        let key = parts.0
        let value = parts.1
        let button = &mut self.buttons[self.current_button]

        match key.as_str() {
            "Command" => button.button_type = self.parse_command_type(value),
            "ButtonImage" => button.button_image = value,
            "ButtonBorderType" => button.button_border_type = value,
            "TextLabel" => button.text_label = value,
            "DescriptLabel" => button.description = value,
            "HelpTextLabel" => button.help_text = value,
            "CursorName" => button.cursor_name = value,
            "InvalidCursorName" => button.invalid_cursor_name = value,
            "RadiusCursorType" => button.radius_cursor_type = value,
            "Object" => button.object = value,
            "Upgrade" => button.upgrade = value,
            "SpecialPower" => button.special_power = value,
            "Science" => button.science = value,
            "WeaponSlot" => button.weapon_slot = value,
            "NeededUpgrade" => button.needs_upgrade = value,
            "ConflictingUpgrade" => button.conflicting_upgrade = value,
            "RequiredScience" => button.required_science = value,
            "NeedsSpecialPowerScience" => button.needs_special_power_science = value,
            "Options" => button.options = self.parse_options(value),
            "AutoAbility" => button.auto_ability = self.parse_bool(value),
            "NeedsDaytime" => button.needs_daytime = self.parse_bool(value),
            "UnitSpecificSound" => button.unit_specific_sound = value,
            _ => {},
        }

        true
    }

    fn parse_set_property(&mut self, line: string): bool {
        // Format: "1 = Command_DozerConstruct"
        let parts = line.split("=")
        if (parts.len() < 2) {
            return true
        }

        let slot_str = parts[0].trim()
        let command_name = parts[1].trim()

        let slot_num = slot_str.parse::<u32>().unwrap_or(0)
        if (slot_num > 0 && slot_num <= 18) {
            let set = &mut self.command_sets[self.current_set]
            if (set.slot_count < 18) {
                let idx = set.slot_count as usize
                set.slots[idx].slot_number = slot_num
                set.slots[idx].command_button = command_name.to_string()
                set.slots[idx].is_valid = true
                set.slot_count += 1
            }
        }

        true
    }

    fn parse_command_type(&self, value: string): CommandButtonType {
        match value.to_uppercase().as_str() {
            "DOZER_CONSTRUCT" => CommandButtonType::DozerConstruct,
            "DOZER_CONSTRUCT_CANCEL" => CommandButtonType::DozerConstructCancel,
            "UNIT_BUILD" => CommandButtonType::UnitBuild,
            "CANCEL_UNIT_BUILD" => CommandButtonType::UnitBuildCancel,
            "UPGRADE" => CommandButtonType::Upgrade,
            "CANCEL_UPGRADE" => CommandButtonType::UpgradeCancel,
            "SPECIAL_POWER" => CommandButtonType::SpecialPower,
            "SPECIAL_POWER_FROM_SELF" => CommandButtonType::SpecialPowerFromSelf,
            "SPECIAL_POWER_FROM_COMMAND_CENTER" => CommandButtonType::SpecialPowerFromCommandCenter,
            "OBJECT_UPGRADE" => CommandButtonType::ObjectUpgrade,
            "PLAYER_UPGRADE" => CommandButtonType::PlayerUpgrade,
            "EXIT_CONTAINER" => CommandButtonType::ExitContainer,
            "EVACUATE" => CommandButtonType::Evacuate,
            "EVACUATE_CONTAINER" => CommandButtonType::EvacuateContainer,
            "EXECUTE_RAILED_TRANSPORT" => CommandButtonType::ExecuteRailedTransport,
            "COMBAT_DROP" => CommandButtonType::CombatDrop,
            "GUARD" => CommandButtonType::Guard,
            "GUARD_WITHOUT_PURSUIT" | "GUARD_FLYOVER" => CommandButtonType::GuardFlyover,
            "ATTACK_MOVE" => CommandButtonType::AttackMove,
            "STOP" => CommandButtonType::Stop,
            "SCATTER" => CommandButtonType::Scatter,
            "SET_RALLY_POINT" => CommandButtonType::SetRallyPoint,
            "SELL" => CommandButtonType::Sell,
            "CANCEL_CONSTRUCTION" => CommandButtonType::CancelConstruction,
            "TOGGLE_POWER" => CommandButtonType::TogglePower,
            "TOGGLE_WEAPON" => CommandButtonType::ToggleWeapon,
            "CONVERT_TO_CAR_BOMB" => CommandButtonType::ConvertToCarBomb,
            "CONVERT_TO_MOB_SPEAKER" => CommandButtonType::ConvertToMobSpeaker,
            "HIJACK_VEHICLE" => CommandButtonType::Hijack,
            "HACK_INTERNET" => CommandButtonType::HackInternet,
            "SABOTAGE" => CommandButtonType::Sabotage,
            "SNEAK_ATTACK" => CommandButtonType::SneakAttack,
            "TOGGLE_STEALTH" => CommandButtonType::ToggleStealthMode,
            "CHEER" => CommandButtonType::CheerAttack,
            "DEFECTOR" => CommandButtonType::Defect,
            "CAPTURE_BUILDING" => CommandButtonType::CaptureBuilding,
            "DISARM_MINE_DEFECT" => CommandButtonType::DisarmMineDefect,
            "BOOBY_TRAP" => CommandButtonType::Booby_Trap,
            "REMOVE_BOOBY_TRAP" => CommandButtonType::RemoveBoobyTrap,
            "FIRE_WEAPON" => CommandButtonType::FireWeapon,
            "SWITCH_WEAPON" => CommandButtonType::SwitchWeapon,
            "DOCK" => CommandButtonType::Dock,
            "SELECT_ALL" | "SELECT_ALL_UNITS_OF_TYPE" => CommandButtonType::SelectAll,
            "FORMATION_MOVE" => CommandButtonType::FormationMove,
            "SPECIAL_MOVE" => CommandButtonType::SpecialMove,
            "EMPTY_ALL_CONTAINERS_AT_ONCE" => CommandButtonType::EmptyAllContainersAtOnce,
            "FORCE_ATTACK" => CommandButtonType::ForceAttack,
            _ => CommandButtonType::None,
        }
    }

    fn parse_options(&self, value: string): u32 {
        let mut options: u32 = 0
        let parts = value.split(" ")

        for part in parts {
            match part.to_uppercase().as_str() {
                "OK_FOR_MULTI_SELECT" => options |= OPTION_OK_FOR_MULTI_SELECT,
                "CHECK_LIKE" => options |= OPTION_CHECK_LIKE,
                "NEED_TARGET_ENEMY_OBJECT" => options |= OPTION_NEED_TARGET_ENEMY_OBJECT,
                "NEED_TARGET_NEUTRAL_OBJECT" => options |= OPTION_NEED_TARGET_NEUTRAL_OBJECT,
                "NEED_TARGET_ALLY_OBJECT" => options |= OPTION_NEED_TARGET_ALLY_OBJECT,
                "CONTEXTMODE_COMMAND" => options |= OPTION_CONTEXTMODE_COMMAND,
                "OPTION_ONE" => options |= OPTION_OPTION_ONE,
                "OPTION_TWO" => options |= OPTION_OPTION_TWO,
                "OPTION_THREE" => options |= OPTION_OPTION_THREE,
                "NEED_UPGRADE" => options |= OPTION_NEED_UPGRADE,
                "NOT_QUEUEABLE" => options |= OPTION_NOT_QUEUEABLE,
                "IGNORES_UNDERPOWERED" => options |= OPTION_IGNORES_UNDERPOWERED,
                "NEED_SPECIAL_POWER_SCIENCE" => options |= OPTION_NEED_SPECIAL_POWER_SCIENCE,
                "SCRIPT_ONLY" => options |= OPTION_SCRIPT_ONLY,
                "USES_MINE_CLEARING_WEAPON_SET" => options |= OPTION_USES_MINE_CLEARING_WEAPON_SLOT,
                "SINGLE_USE_COMMAND" => options |= OPTION_SINGLE_USE_COMMAND,
                _ => {},
            }
        }

        options
    }

    fn split_property(&self, line: string): (string, string) {
        let eq_pos = line.find("=")
        if (eq_pos.is_some()) {
            let idx = eq_pos.unwrap()
            return (line[0..idx].trim().to_string(), line[idx+1..].trim().to_string())
        }

        let space_pos = line.find(" ")
        if (space_pos.is_some()) {
            let idx = space_pos.unwrap()
            return (line[0..idx].trim().to_string(), line[idx+1..].trim().to_string())
        }

        (line, "".to_string())
    }

    fn parse_bool(&self, value: string): bool {
        let v = value.to_uppercase()
        v == "YES" || v == "TRUE" || v == "1"
    }

    fn add_error(&mut self, msg: string) {
        if (self.error_count < 64) {
            self.parse_errors[self.error_count as usize] = msg
            self.error_count += 1
        }
    }

    // Public API
    fn get_button(&self, name: string): Option<&CommandButtonDefinition> {
        if let Some(idx) = self.button_name_to_index.get(&name) {
            return Some(&self.buttons[*idx as usize])
        }
        None
    }

    fn get_command_set(&self, name: string): Option<&CommandSetDefinition> {
        if let Some(idx) = self.set_name_to_index.get(&name) {
            return Some(&self.command_sets[*idx as usize])
        }
        None
    }

    fn get_buttons_for_set(&self, set_name: string): Vec<(&CommandButtonDefinition, u32)> {
        let mut result = Vec::new()

        if let Some(set) = self.get_command_set(set_name) {
            for i in 0..set.slot_count {
                let slot = &set.slots[i as usize]
                if (slot.is_valid) {
                    if let Some(button) = self.get_button(slot.command_button.clone()) {
                        result.push((button, slot.slot_number))
                    }
                }
            }
        }

        result
    }

    fn get_button_count(&self): u32 {
        self.button_count
    }

    fn get_set_count(&self): u32 {
        self.set_count
    }
}

impl Default for CommandButtonDefinition {
    fn default(): Self {
        CommandButtonDefinition {
            name: "".to_string(),
            button_type: CommandButtonType::None,
            button_image: "".to_string(),
            button_border_type: "".to_string(),
            display_name: "".to_string(),
            description: "".to_string(),
            help_text: "".to_string(),
            cursor_name: "".to_string(),
            invalid_cursor_name: "".to_string(),
            radius_cursor_type: "".to_string(),
            object: "".to_string(),
            upgrade: "".to_string(),
            special_power: "".to_string(),
            science: "".to_string(),
            weapon_slot: "".to_string(),
            needs_upgrade: "".to_string(),
            conflicting_upgrade: "".to_string(),
            required_science: "".to_string(),
            needs_special_power_science: "".to_string(),
            options: 0,
            text_label: "".to_string(),
            auto_ability: false,
            needs_daytime: false,
            unit_specific_sound: "".to_string(),
            is_valid: false,
        }
    }
}

impl Default for CommandSetDefinition {
    fn default(): Self {
        CommandSetDefinition {
            name: "".to_string(),
            slots: [CommandSetSlot::default(); 18],
            slot_count: 0,
            is_valid: false,
        }
    }
}

impl Default for CommandSetSlot {
    fn default(): Self {
        CommandSetSlot {
            slot_number: 0,
            command_button: "".to_string(),
            is_valid: false,
        }
    }
}
