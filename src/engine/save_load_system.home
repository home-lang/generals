// Save/Load System - Game state persistence
// Implements authentic C&C Generals Zero Hour save game functionality

// ============================================================================
// SAVE FILE FORMAT
// ============================================================================

const SAVE_SIGNATURE: [u8; 4] = [0x47, 0x53, 0x41, 0x56]  // "GSAV"
const SAVE_VERSION: u32 = 7  // Zero Hour save version

enum SaveType {
    QUICK_SAVE,
    MANUAL_SAVE,
    AUTO_SAVE,
    CAMPAIGN_SAVE,
    SKIRMISH_SAVE,
    MULTIPLAYER_SAVE
}

struct SaveHeader {
    signature: [u8; 4],
    version: u32,
    timestamp: u64,
    save_type: SaveType,

    // Save metadata
    save_name: [u8; 64],
    map_name: [u8; 128],
    mission_name: [u8; 64],  // For campaign saves

    // Screenshot thumbnail (compressed)
    thumbnail_width: u16,
    thumbnail_height: u16,
    thumbnail_data: [u8; 32768],  // 128x96 compressed

    // Game time
    game_time_frames: u32,
    real_time_seconds: u32,

    // Difficulty
    difficulty: u8,

    // Checksum for integrity
    data_checksum: u32,
    data_size: u32
}

struct PlayerSaveData {
    player_id: u8,
    name: [u8; 32],
    faction: u8,
    color: u8,
    general: u8,
    team: u8,
    is_ai: bool,
    ai_difficulty: u8,

    // Resources
    money: i32,
    power_produced: i32,
    power_consumed: i32,

    // Stats
    units_built: i32,
    units_lost: i32,
    units_killed: i32,
    buildings_built: i32,
    buildings_lost: i32,
    buildings_destroyed: i32,

    // General powers
    general_points: i32,
    unlocked_powers: [bool; 32],
    power_cooldowns: [f32; 32],

    // Superweapons
    superweapon_progress: [f32; 4],

    // Tech/Upgrades
    completed_upgrades: [bool; 64],
    research_progress: [f32; 64],

    // Rank/Experience
    rank: i32,
    experience: i32
}

struct UnitSaveData {
    object_id: u32,
    owner_id: u8,
    unit_type: u32,

    // Position/Rotation
    position_x: f32,
    position_y: f32,
    position_z: f32,
    rotation: f32,

    // State
    health: f32,
    max_health: f32,
    experience: i32,
    veterancy: u8,

    // Behavior
    current_order: u8,
    target_x: f32,
    target_y: f32,
    target_object_id: u32,
    stance: u8,

    // Modifiers
    buffs: [u8; 16],
    debuffs: [u8; 16],

    // Passengers (for transports)
    passenger_count: u8,
    passenger_ids: [u32; 8],

    // Ammunition
    ammo_count: i32,

    // Control group
    control_group: i8
}

struct BuildingSaveData {
    object_id: u32,
    owner_id: u8,
    building_type: u32,

    // Position
    position_x: f32,
    position_y: f32,
    position_z: f32,
    rotation: f32,

    // State
    health: f32,
    max_health: f32,
    is_powered: bool,
    is_selling: bool,
    sell_progress: f32,

    // Construction
    is_under_construction: bool,
    construction_progress: f32,

    // Production
    production_queue: [u32; 9],
    production_progress: f32,
    rally_point_x: f32,
    rally_point_y: f32,

    // Upgrades
    applied_upgrades: [bool; 8],

    // Garrisoned units
    garrison_count: u8,
    garrison_ids: [u32; 10]
}

struct ProjectileSaveData {
    projectile_id: u32,
    weapon_type: u32,
    owner_id: u8,

    position_x: f32,
    position_y: f32,
    position_z: f32,
    velocity_x: f32,
    velocity_y: f32,
    velocity_z: f32,

    target_x: f32,
    target_y: f32,
    target_z: f32,
    target_object_id: u32,

    damage: f32,
    lifetime: f32
}

struct TerrainModification {
    position_x: f32,
    position_y: f32,
    radius: f32,
    modification_type: u8,  // Crater, scorch, etc.
    intensity: f32
}

struct GameSaveData {
    header: SaveHeader,

    // Players
    player_count: u8,
    players: [PlayerSaveData; 8],

    // Units (variable count)
    unit_count: u32,
    units: [UnitSaveData; 4096],

    // Buildings (variable count)
    building_count: u32,
    buildings: [BuildingSaveData; 1024],

    // Projectiles (variable count)
    projectile_count: u32,
    projectiles: [ProjectileSaveData; 512],

    // Terrain modifications
    terrain_mod_count: u32,
    terrain_mods: [TerrainModification; 1024],

    // Random seed state for determinism
    random_state: u64,

    // Camera position
    camera_x: f32,
    camera_y: f32,
    camera_z: f32,
    camera_pitch: f32,
    camera_yaw: f32,
    camera_zoom: f32,

    // Fog of war state (per player)
    fog_data: [[u8; 65536]; 8],

    // Script triggers state (for campaign)
    triggered_events: [bool; 256],
    script_variables: [i32; 128]
}

// ============================================================================
// SAVE SYSTEM MANAGER
// ============================================================================

struct SaveManager {
    current_save_slot: i32,
    quick_save_slot: i32,
    auto_save_enabled: bool,
    auto_save_interval: f32,
    auto_save_timer: f32,
    max_auto_saves: i32,

    // Save slots
    save_slots: [SaveHeader; 100],
    save_slot_count: i32,

    // Save directory
    save_directory: [u8; 256],

    // Operation state
    is_saving: bool,
    is_loading: bool,
    save_progress: f32,
    load_progress: f32,
    last_error: [u8; 128]
}

fn create_save_manager(): SaveManager {
    return SaveManager {
        current_save_slot: -1,
        quick_save_slot: 0,
        auto_save_enabled: true,
        auto_save_interval: 300.0,  // 5 minutes
        auto_save_timer: 0.0,
        max_auto_saves: 3,
        save_slots: [],
        save_slot_count: 0,
        save_directory: "Saves/",
        is_saving: false,
        is_loading: false,
        save_progress: 0.0,
        load_progress: 0.0,
        last_error: ""
    }
}

fn initialize_save_system(manager: mut SaveManager) {
    // Create save directory if needed
    // Scan for existing saves
    scan_save_files(manager)
}

fn scan_save_files(manager: mut SaveManager) {
    // Would scan save directory for .sav files
    // Parse headers to populate save_slots
    manager.save_slot_count = 0
}

fn quick_save(manager: mut SaveManager, game_state: GameSaveData): bool {
    let mut save_data: GameSaveData = game_state
    save_data.header.save_type = SaveType::QUICK_SAVE
    save_data.header.save_name = "QuickSave"

    let filename: [u8; 256] = get_quicksave_filename(manager.quick_save_slot)
    let success: bool = save_game(manager, save_data, filename)

    if success {
        manager.quick_save_slot = (manager.quick_save_slot + 1) % 3
    }

    return success
}

fn quick_load(manager: mut SaveManager): GameSaveData {
    let slot: i32 = (manager.quick_save_slot + 2) % 3  // Most recent quick save
    let filename: [u8; 256] = get_quicksave_filename(slot)
    return load_game(manager, filename)
}

fn auto_save(manager: mut SaveManager, game_state: GameSaveData): bool {
    if not manager.auto_save_enabled {
        return false
    }

    let mut save_data: GameSaveData = game_state
    save_data.header.save_type = SaveType::AUTO_SAVE
    save_data.header.save_name = "AutoSave"

    // Rotate auto saves
    let auto_slot: i32 = cast(i32, save_data.header.timestamp % cast(u64, manager.max_auto_saves))
    let filename: [u8; 256] = get_autosave_filename(auto_slot)

    return save_game(manager, save_data, filename)
}

fn manual_save(manager: mut SaveManager, game_state: GameSaveData, save_name: [u8; 64]): bool {
    let mut save_data: GameSaveData = game_state
    save_data.header.save_type = SaveType::MANUAL_SAVE
    save_data.header.save_name = save_name

    let filename: [u8; 256] = generate_save_filename(save_name)
    return save_game(manager, save_data, filename)
}

fn update_auto_save(manager: mut SaveManager, game_state: GameSaveData, delta_time: f32) {
    if not manager.auto_save_enabled {
        return
    }

    manager.auto_save_timer = manager.auto_save_timer + delta_time

    if manager.auto_save_timer >= manager.auto_save_interval {
        manager.auto_save_timer = 0.0
        auto_save(manager, game_state)
    }
}

// ============================================================================
// SAVE/LOAD OPERATIONS
// ============================================================================

fn save_game(manager: mut SaveManager, data: GameSaveData, filename: [u8; 256]): bool {
    manager.is_saving = true
    manager.save_progress = 0.0

    // Calculate checksum
    let checksum: u32 = calculate_save_checksum(data)

    // Serialize game state
    let mut serialized: [u8; 16777216] = []
    let size: u32 = serialize_game_data(data, serialized)

    manager.save_progress = 0.5

    // Compress data
    let mut compressed: [u8; 16777216] = []
    let compressed_size: u32 = compress_save_data(serialized, size, compressed)

    manager.save_progress = 0.8

    // Write header + compressed data to file
    let success: bool = write_save_file(filename, data.header, compressed, compressed_size)

    manager.save_progress = 1.0
    manager.is_saving = false

    if success {
        // Refresh save list
        scan_save_files(manager)
    } else {
        manager.last_error = "Failed to write save file"
    }

    return success
}

fn load_game(manager: mut SaveManager, filename: [u8; 256]): GameSaveData {
    manager.is_loading = true
    manager.load_progress = 0.0

    let mut data: GameSaveData = create_empty_save_data()

    // Read file
    let mut file_data: [u8; 16777216] = []
    let file_size: u32 = read_save_file(filename, file_data)

    if file_size == 0 {
        manager.last_error = "Failed to read save file"
        manager.is_loading = false
        return data
    }

    manager.load_progress = 0.3

    // Parse header
    data.header = parse_save_header(file_data)

    // Verify signature
    if data.header.signature[0] != SAVE_SIGNATURE[0] or
       data.header.signature[1] != SAVE_SIGNATURE[1] or
       data.header.signature[2] != SAVE_SIGNATURE[2] or
       data.header.signature[3] != SAVE_SIGNATURE[3] {
        manager.last_error = "Invalid save file signature"
        manager.is_loading = false
        return data
    }

    // Check version compatibility
    if data.header.version > SAVE_VERSION {
        manager.last_error = "Save file version too new"
        manager.is_loading = false
        return data
    }

    manager.load_progress = 0.5

    // Decompress data
    let mut decompressed: [u8; 16777216] = []
    let decompressed_size: u32 = decompress_save_data(file_data, data.header.data_size, decompressed)

    manager.load_progress = 0.7

    // Deserialize game state
    deserialize_game_data(decompressed, decompressed_size, data)

    manager.load_progress = 0.9

    // Verify checksum
    let calculated_checksum: u32 = calculate_save_checksum(data)
    if calculated_checksum != data.header.data_checksum {
        manager.last_error = "Save file corrupted"
        // Continue anyway for now
    }

    manager.load_progress = 1.0
    manager.is_loading = false

    return data
}

fn delete_save(manager: mut SaveManager, filename: [u8; 256]): bool {
    // Would delete file from disk
    // Refresh save list
    scan_save_files(manager)
    return true
}

// ============================================================================
// SERIALIZATION
// ============================================================================

fn serialize_game_data(data: GameSaveData, output: mut [u8; 16777216]): u32 {
    let mut offset: u32 = 0

    // Serialize header
    offset = serialize_header(data.header, output, offset)

    // Serialize players
    write_u8(output, offset, data.player_count)
    offset = offset + 1

    for i in 0..cast(i32, data.player_count) {
        offset = serialize_player(data.players[i], output, offset)
    }

    // Serialize units
    write_u32_le(output, offset, data.unit_count)
    offset = offset + 4

    for i in 0..cast(i32, data.unit_count) {
        offset = serialize_unit(data.units[i], output, offset)
    }

    // Serialize buildings
    write_u32_le(output, offset, data.building_count)
    offset = offset + 4

    for i in 0..cast(i32, data.building_count) {
        offset = serialize_building(data.buildings[i], output, offset)
    }

    // Serialize projectiles
    write_u32_le(output, offset, data.projectile_count)
    offset = offset + 4

    for i in 0..cast(i32, data.projectile_count) {
        offset = serialize_projectile(data.projectiles[i], output, offset)
    }

    // Serialize terrain modifications
    write_u32_le(output, offset, data.terrain_mod_count)
    offset = offset + 4

    for i in 0..cast(i32, data.terrain_mod_count) {
        offset = serialize_terrain_mod(data.terrain_mods[i], output, offset)
    }

    // Serialize misc state
    write_u64_le(output, offset, data.random_state)
    offset = offset + 8

    write_f32_le(output, offset, data.camera_x)
    offset = offset + 4
    write_f32_le(output, offset, data.camera_y)
    offset = offset + 4
    write_f32_le(output, offset, data.camera_z)
    offset = offset + 4
    write_f32_le(output, offset, data.camera_pitch)
    offset = offset + 4
    write_f32_le(output, offset, data.camera_yaw)
    offset = offset + 4
    write_f32_le(output, offset, data.camera_zoom)
    offset = offset + 4

    return offset
}

fn serialize_header(header: SaveHeader, output: mut [u8; 16777216], offset: u32): u32 {
    let mut pos: u32 = offset

    // Signature
    output[pos] = header.signature[0]
    output[pos + 1] = header.signature[1]
    output[pos + 2] = header.signature[2]
    output[pos + 3] = header.signature[3]
    pos = pos + 4

    write_u32_le(output, pos, header.version)
    pos = pos + 4

    write_u64_le(output, pos, header.timestamp)
    pos = pos + 8

    // Save type
    output[pos] = cast(u8, header.save_type)
    pos = pos + 1

    // Save name (64 bytes)
    for i in 0..64 {
        output[pos + cast(u32, i)] = header.save_name[i]
    }
    pos = pos + 64

    // Map name (128 bytes)
    for i in 0..128 {
        output[pos + cast(u32, i)] = header.map_name[i]
    }
    pos = pos + 128

    return pos
}

fn serialize_player(player: PlayerSaveData, output: mut [u8; 16777216], offset: u32): u32 {
    let mut pos: u32 = offset

    output[pos] = player.player_id
    pos = pos + 1

    for i in 0..32 {
        output[pos + cast(u32, i)] = player.name[i]
    }
    pos = pos + 32

    output[pos] = player.faction
    output[pos + 1] = player.color
    output[pos + 2] = player.general
    output[pos + 3] = player.team
    output[pos + 4] = cast(u8, player.is_ai)
    output[pos + 5] = player.ai_difficulty
    pos = pos + 6

    write_i32_le(output, pos, player.money)
    pos = pos + 4

    write_i32_le(output, pos, player.power_produced)
    pos = pos + 4

    write_i32_le(output, pos, player.power_consumed)
    pos = pos + 4

    // Stats
    write_i32_le(output, pos, player.units_built)
    pos = pos + 4
    write_i32_le(output, pos, player.units_lost)
    pos = pos + 4
    write_i32_le(output, pos, player.units_killed)
    pos = pos + 4
    write_i32_le(output, pos, player.buildings_built)
    pos = pos + 4
    write_i32_le(output, pos, player.buildings_lost)
    pos = pos + 4
    write_i32_le(output, pos, player.buildings_destroyed)
    pos = pos + 4

    write_i32_le(output, pos, player.general_points)
    pos = pos + 4

    return pos
}

fn serialize_unit(unit: UnitSaveData, output: mut [u8; 16777216], offset: u32): u32 {
    let mut pos: u32 = offset

    write_u32_le(output, pos, unit.object_id)
    pos = pos + 4

    output[pos] = unit.owner_id
    pos = pos + 1

    write_u32_le(output, pos, unit.unit_type)
    pos = pos + 4

    write_f32_le(output, pos, unit.position_x)
    pos = pos + 4
    write_f32_le(output, pos, unit.position_y)
    pos = pos + 4
    write_f32_le(output, pos, unit.position_z)
    pos = pos + 4
    write_f32_le(output, pos, unit.rotation)
    pos = pos + 4

    write_f32_le(output, pos, unit.health)
    pos = pos + 4
    write_f32_le(output, pos, unit.max_health)
    pos = pos + 4

    write_i32_le(output, pos, unit.experience)
    pos = pos + 4

    output[pos] = unit.veterancy
    pos = pos + 1

    return pos
}

fn serialize_building(building: BuildingSaveData, output: mut [u8; 16777216], offset: u32): u32 {
    let mut pos: u32 = offset

    write_u32_le(output, pos, building.object_id)
    pos = pos + 4

    output[pos] = building.owner_id
    pos = pos + 1

    write_u32_le(output, pos, building.building_type)
    pos = pos + 4

    write_f32_le(output, pos, building.position_x)
    pos = pos + 4
    write_f32_le(output, pos, building.position_y)
    pos = pos + 4
    write_f32_le(output, pos, building.position_z)
    pos = pos + 4

    write_f32_le(output, pos, building.health)
    pos = pos + 4

    output[pos] = cast(u8, building.is_powered)
    output[pos + 1] = cast(u8, building.is_under_construction)
    pos = pos + 2

    write_f32_le(output, pos, building.construction_progress)
    pos = pos + 4

    return pos
}

fn serialize_projectile(proj: ProjectileSaveData, output: mut [u8; 16777216], offset: u32): u32 {
    let mut pos: u32 = offset

    write_u32_le(output, pos, proj.projectile_id)
    pos = pos + 4

    write_f32_le(output, pos, proj.position_x)
    pos = pos + 4
    write_f32_le(output, pos, proj.position_y)
    pos = pos + 4
    write_f32_le(output, pos, proj.position_z)
    pos = pos + 4

    write_f32_le(output, pos, proj.velocity_x)
    pos = pos + 4
    write_f32_le(output, pos, proj.velocity_y)
    pos = pos + 4
    write_f32_le(output, pos, proj.velocity_z)
    pos = pos + 4

    return pos
}

fn serialize_terrain_mod(mod_data: TerrainModification, output: mut [u8; 16777216], offset: u32): u32 {
    let mut pos: u32 = offset

    write_f32_le(output, pos, mod_data.position_x)
    pos = pos + 4
    write_f32_le(output, pos, mod_data.position_y)
    pos = pos + 4
    write_f32_le(output, pos, mod_data.radius)
    pos = pos + 4

    output[pos] = mod_data.modification_type
    pos = pos + 1

    write_f32_le(output, pos, mod_data.intensity)
    pos = pos + 4

    return pos
}

fn deserialize_game_data(input: [u8; 16777216], size: u32, data: mut GameSaveData) {
    // Would reverse the serialization process
    // Parse header, players, units, buildings, etc.
}

// ============================================================================
// COMPRESSION
// ============================================================================

fn compress_save_data(input: [u8; 16777216], size: u32, output: mut [u8; 16777216]): u32 {
    // Would use zlib compression (authentic to original)
    // For now, just copy
    for i in 0..cast(i32, size) {
        output[i] = input[i]
    }
    return size
}

fn decompress_save_data(input: [u8; 16777216], size: u32, output: mut [u8; 16777216]): u32 {
    // Would decompress zlib data
    for i in 0..cast(i32, size) {
        output[i] = input[i]
    }
    return size
}

// ============================================================================
// FILE I/O HELPERS
// ============================================================================

fn get_quicksave_filename(slot: i32): [u8; 256] {
    return "QuickSave" + str(slot) + ".sav"
}

fn get_autosave_filename(slot: i32): [u8; 256] {
    return "AutoSave" + str(slot) + ".sav"
}

fn generate_save_filename(name: [u8; 64]): [u8; 256] {
    // Sanitize name and add extension
    return name + ".sav"
}

fn write_save_file(filename: [u8; 256], header: SaveHeader, data: [u8; 16777216], size: u32): bool {
    // Would write to disk
    return true
}

fn read_save_file(filename: [u8; 256], output: mut [u8; 16777216]): u32 {
    // Would read from disk
    return 0
}

fn parse_save_header(data: [u8; 16777216]): SaveHeader {
    let header: SaveHeader = SaveHeader {
        signature: [data[0], data[1], data[2], data[3]],
        version: read_u32_le(data, 4),
        timestamp: read_u64_le(data, 8),
        save_type: SaveType::MANUAL_SAVE,
        save_name: "",
        map_name: "",
        mission_name: "",
        thumbnail_width: 0,
        thumbnail_height: 0,
        thumbnail_data: [],
        game_time_frames: 0,
        real_time_seconds: 0,
        difficulty: 0,
        data_checksum: 0,
        data_size: 0
    }
    return header
}

fn create_empty_save_data(): GameSaveData {
    return GameSaveData {
        header: SaveHeader {
            signature: SAVE_SIGNATURE,
            version: SAVE_VERSION,
            timestamp: 0,
            save_type: SaveType::MANUAL_SAVE,
            save_name: "",
            map_name: "",
            mission_name: "",
            thumbnail_width: 0,
            thumbnail_height: 0,
            thumbnail_data: [],
            game_time_frames: 0,
            real_time_seconds: 0,
            difficulty: 0,
            data_checksum: 0,
            data_size: 0
        },
        player_count: 0,
        players: [],
        unit_count: 0,
        units: [],
        building_count: 0,
        buildings: [],
        projectile_count: 0,
        projectiles: [],
        terrain_mod_count: 0,
        terrain_mods: [],
        random_state: 0,
        camera_x: 0.0,
        camera_y: 0.0,
        camera_z: 0.0,
        camera_pitch: 0.0,
        camera_yaw: 0.0,
        camera_zoom: 0.0,
        fog_data: [],
        triggered_events: [],
        script_variables: []
    }
}

fn calculate_save_checksum(data: GameSaveData): u32 {
    // Would calculate CRC32 or similar
    return 0
}

// ============================================================================
// BINARY HELPERS
// ============================================================================

fn write_u8(output: mut [u8; 16777216], offset: u32, value: u8) {
    output[offset] = value
}

fn write_u32_le(output: mut [u8; 16777216], offset: u32, value: u32) {
    output[offset] = cast(u8, value & 0xFF)
    output[offset + 1] = cast(u8, (value >> 8) & 0xFF)
    output[offset + 2] = cast(u8, (value >> 16) & 0xFF)
    output[offset + 3] = cast(u8, (value >> 24) & 0xFF)
}

fn write_i32_le(output: mut [u8; 16777216], offset: u32, value: i32) {
    write_u32_le(output, offset, cast(u32, value))
}

fn write_u64_le(output: mut [u8; 16777216], offset: u32, value: u64) {
    write_u32_le(output, offset, cast(u32, value & 0xFFFFFFFF))
    write_u32_le(output, offset + 4, cast(u32, (value >> 32) & 0xFFFFFFFF))
}

fn write_f32_le(output: mut [u8; 16777216], offset: u32, value: f32) {
    // Would reinterpret float bits as u32
    write_u32_le(output, offset, 0)
}

fn read_u32_le(data: [u8; 16777216], offset: i32): u32 {
    return cast(u32, data[offset]) |
           (cast(u32, data[offset + 1]) << 8) |
           (cast(u32, data[offset + 2]) << 16) |
           (cast(u32, data[offset + 3]) << 24)
}

fn read_u64_le(data: [u8; 16777216], offset: i32): u64 {
    return cast(u64, read_u32_le(data, offset)) |
           (cast(u64, read_u32_le(data, offset + 4)) << 32)
}

// ============================================================================
// SAVE MENU UI
// ============================================================================

struct SaveLoadUI {
    is_save_mode: bool,
    selected_slot: i32,
    save_slots_visible: [bool; 20],

    // Input field for save name
    save_name_input: [u8; 64],
    input_cursor: i32,

    // Scrolling
    scroll_offset: i32,
    visible_slots: i32,

    // Confirmation dialog
    show_overwrite_confirm: bool,
    show_delete_confirm: bool
}

fn create_save_load_ui(): SaveLoadUI {
    return SaveLoadUI {
        is_save_mode: true,
        selected_slot: -1,
        save_slots_visible: [true; 20],
        save_name_input: "",
        input_cursor: 0,
        scroll_offset: 0,
        visible_slots: 10,
        show_overwrite_confirm: false,
        show_delete_confirm: false
    }
}

fn render_save_load_menu(ui: SaveLoadUI, manager: SaveManager) {
    // Draw background
    // Draw title ("Save Game" or "Load Game")

    // Draw save slots
    for i in 0..ui.visible_slots {
        let slot_idx: i32 = i + ui.scroll_offset
        if slot_idx < manager.save_slot_count {
            let header: SaveHeader = manager.save_slots[slot_idx]
            // Draw thumbnail
            // Draw save name
            // Draw map name
            // Draw date/time
            // Draw game duration
        } else {
            // Draw empty slot
        }
    }

    // Draw scroll bar if needed

    // Draw buttons (Save/Load, Delete, Cancel)

    // Draw save name input if in save mode
    if ui.is_save_mode {
        // Draw text input field
    }
}

// ============================================================================
// TEST FUNCTIONS
// ============================================================================

fn test_save_load_system() {
    print("Testing Save/Load System...")

    // Create save manager
    let mut manager: SaveManager = create_save_manager()
    print("Save manager created")

    // Create test game state
    let mut game_data: GameSaveData = create_empty_save_data()
    game_data.header.map_name = "Tournament City"
    game_data.header.timestamp = 1700000000
    game_data.player_count = 2

    // Add test player data
    game_data.players[0] = PlayerSaveData {
        player_id: 0,
        name: "Player1",
        faction: 0,
        color: 1,
        general: 0,
        team: 0,
        is_ai: false,
        ai_difficulty: 0,
        money: 15000,
        power_produced: 10,
        power_consumed: 5,
        units_built: 25,
        units_lost: 5,
        units_killed: 12,
        buildings_built: 8,
        buildings_lost: 1,
        buildings_destroyed: 3,
        general_points: 3,
        unlocked_powers: [],
        power_cooldowns: [],
        superweapon_progress: [],
        completed_upgrades: [],
        research_progress: [],
        rank: 1,
        experience: 500
    }
    print("Test player data created")

    // Test quick save
    quick_save(manager, game_data)
    print("Quick save created")

    // Test manual save
    manual_save(manager, game_data, "TestSave")
    print("Manual save created")

    // Test auto save
    manager.auto_save_enabled = true
    auto_save(manager, game_data)
    print("Auto save created")

    // Test serialization size
    let mut output: [u8; 16777216] = []
    let size: u32 = serialize_game_data(game_data, output)
    print("Serialized size: " + str(size) + " bytes")

    // Test UI
    let ui: SaveLoadUI = create_save_load_ui()
    print("Save/Load UI created")

    print("Save/Load System tests complete!")
}
