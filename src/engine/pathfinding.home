// AI & Pathfinding System
// Pure Home implementation - converted from Zig
// Based on Thyme's pathfinding implementation

// ============================================================================
// Cell Types
// ============================================================================

enum CellType {
    CLEAR,      // Walkable terrain
    WATER,      // Water (boats only)
    CLIFF,      // Cliff / impassable
    RUBBLE,     // Damaged terrain
    OBSTACLE,   // Building / static obstacle
    BLOCKED,    // Blocked by unit
    RESERVED,   // Reserved for building placement
}

// ============================================================================
// Cell Flags
// ============================================================================

struct CellFlags {
    has_unit: Bool,
    unit_goal: Bool,
    unit_moving: Bool,
    bridge: Bool,
    wall: Bool,

    fn init() -> CellFlags {
        let flags = CellFlags {
            has_unit: false,
            unit_goal: false,
            unit_moving: false,
            bridge: false,
            wall: false,
        }
        return flags
    }

    fn is_empty(self) -> Bool {
        return !self.has_unit && !self.unit_goal && !self.unit_moving
    }
}

// ============================================================================
// Pathfinding Cell
// ============================================================================

struct PathfindCell {
    cell_type: CellType,
    flags: CellFlags,
    cost: Int,
    zone: Int,

    fn init() -> PathfindCell {
        let cell = PathfindCell {
            cell_type: CellType::CLEAR,
            flags: CellFlags::init(),
            cost: 1,
            zone: 0,
        }
        return cell
    }

    fn is_passable(self) -> Bool {
        if self.cell_type == CellType::CLEAR { return true }
        if self.cell_type == CellType::RUBBLE { return true }
        return false
    }

    fn get_move_cost(self) -> Int {
        if self.cell_type == CellType::CLEAR { return 1 }
        if self.cell_type == CellType::RUBBLE { return 2 }
        return 9999  // Impassable
    }
}

// ============================================================================
// Pathfinding Grid
// ============================================================================

struct PathfindGrid {
    cells: Collection<PathfindCell>,
    width: Int,
    height: Int,
    cell_size: Float,

    fn init(width: Int, height: Int, cell_size: Float) -> PathfindGrid {
        let grid = PathfindGrid {
            cells: Collection::init(),
            width: width,
            height: height,
            cell_size: cell_size,
        }

        // Initialize all cells as CLEAR
        let total_cells = width * height
        for i in 0..total_cells {
            grid.cells.add(PathfindCell::init())
        }

        return grid
    }

    fn world_to_grid(self, world_x: Float, world_y: Float) -> Vector2 {
        let grid_x = world_x / self.cell_size
        let grid_y = world_y / self.cell_size
        return Vector2::init(grid_x, grid_y)
    }

    fn grid_to_world(self, grid_x: Int, grid_y: Int) -> Vector2 {
        let world_x = grid_x * self.cell_size + self.cell_size / 2.0
        let world_y = grid_y * self.cell_size + self.cell_size / 2.0
        return Vector2::init(world_x, world_y)
    }

    fn get_cell(self, x: Int, y: Int) -> PathfindCell? {
        if x < 0 || y < 0 { return null }
        if x >= self.width || y >= self.height { return null }

        let index = y * self.width + x
        return self.cells.get(index)
    }

    fn set_cell_type(self, x: Int, y: Int, cell_type: CellType) {
        let cell = self.get_cell(x, y)
        if cell != null {
            cell.cell_type = cell_type
        }
    }

    fn is_passable(self, x: Int, y: Int) -> Bool {
        let cell = self.get_cell(x, y)
        if cell == null { return false }
        return cell.is_passable()
    }
}

// ============================================================================
// Path Node
// ============================================================================

struct PathNode {
    x: Int,
    y: Int,
    world_x: Float,
    world_y: Float,

    fn init(x: Int, y: Int, world_x: Float, world_y: Float) -> PathNode {
        let node = PathNode {
            x: x,
            y: y,
            world_x: world_x,
            world_y: world_y,
        }
        return node
    }

    fn distance_to(self, other: PathNode) -> Float {
        let dx = self.world_x - other.world_x
        let dy = self.world_y - other.world_y
        return sqrt(dx * dx + dy * dy)
    }

    fn to_vec2(self) -> Vector2 {
        return Vector2::init(self.world_x, self.world_y)
    }
}

// ============================================================================
// Path
// ============================================================================

struct Path {
    nodes: Collection<PathNode>,
    waypoints: Collection<Vector2>,
    current_index: Int,
    total_length: Float,
    is_blocked: Bool,

    fn init() -> Path {
        let path = Path {
            nodes: Collection::init(),
            waypoints: Collection::init(),
            current_index: 0,
            total_length: 0.0,
            is_blocked: false,
        }
        return path
    }

    fn add_node(self, x: Int, y: Int, world_x: Float, world_y: Float) {
        let node = PathNode::init(x, y, world_x, world_y)

        // Calculate cumulative path length
        if self.nodes.len() > 0 {
            let last = self.nodes.get(self.nodes.len() - 1)
            self.total_length = self.total_length + node.distance_to(last)
        }

        self.nodes.add(node)
        self.waypoints.add(Vector2::init(world_x, world_y))
    }

    fn add(self, point: Vector2) {
        self.waypoints.add(point)
    }

    fn is_empty(self) -> Bool {
        return self.waypoints.len() == 0
    }

    fn get_next(self) -> Vector2? {
        if self.current_index < self.waypoints.len() {
            return self.waypoints.get(self.current_index)
        }
        return null
    }

    fn remove_first(self) {
        if self.current_index < self.waypoints.len() {
            self.current_index = self.current_index + 1
        }
    }

    fn get_next_waypoint(self) -> PathNode? {
        if self.current_index >= self.nodes.len() {
            return null
        }
        return self.nodes.get(self.current_index)
    }

    fn advance_waypoint(self) {
        if self.current_index < self.nodes.len() {
            self.current_index = self.current_index + 1
        }
    }

    fn is_complete(self) -> Bool {
        return self.current_index >= self.nodes.len()
    }

    fn reset(self) {
        self.current_index = 0
    }
}

// ============================================================================
// A* Node
// ============================================================================

struct AStarNode {
    x: Int,
    y: Int,
    g_cost: Int,  // Cost from start
    h_cost: Int,  // Heuristic cost to goal
    f_cost: Int,  // Total cost (g + h)
    parent_x: Int,
    parent_y: Int,
    has_parent: Bool,

    fn init(x: Int, y: Int, g_cost: Int, h_cost: Int) -> AStarNode {
        let node = AStarNode {
            x: x,
            y: y,
            g_cost: g_cost,
            h_cost: h_cost,
            f_cost: g_cost + h_cost,
            parent_x: 0,
            parent_y: 0,
            has_parent: false,
        }
        return node
    }

    fn set_parent(self, px: Int, py: Int) {
        self.parent_x = px
        self.parent_y = py
        self.has_parent = true
    }
}

// ============================================================================
// Pathfinder (A* Algorithm)
// ============================================================================

struct Pathfinder {
    grid: PathfindGrid,
    grid_size: Float,
    open_list: Collection<AStarNode>,
    closed_list: Collection<AStarNode>,

    fn init(grid_size: Float) -> Pathfinder {
        let pathfinder = Pathfinder {
            grid: PathfindGrid::init(100, 100, grid_size),
            grid_size: grid_size,
            open_list: Collection::init(),
            closed_list: Collection::init(),
        }
        return pathfinder
    }

    fn init_with_grid(grid: PathfindGrid) -> Pathfinder {
        let pathfinder = Pathfinder {
            grid: grid,
            grid_size: grid.cell_size,
            open_list: Collection::init(),
            closed_list: Collection::init(),
        }
        return pathfinder
    }

    fn heuristic(self, x1: Int, y1: Int, x2: Int, y2: Int) -> Int {
        // Manhattan distance
        let dx = abs(x2 - x1)
        let dy = abs(y2 - y1)
        return dx + dy
    }

    fn find_path(self, start_x: Float, start_y: Float, goal_x: Float, goal_y: Float) -> Path {
        let path = Path::init()

        // Convert to grid coordinates
        let start_grid = self.grid.world_to_grid(start_x, start_y)
        let goal_grid = self.grid.world_to_grid(goal_x, goal_y)

        let start_gx = start_grid.x
        let start_gy = start_grid.y
        let goal_gx = goal_grid.x
        let goal_gy = goal_grid.y

        // Check if goal is passable
        if !self.grid.is_passable(goal_gx, goal_gy) {
            return path
        }

        // Initialize
        self.open_list.clear()
        self.closed_list.clear()

        // Add start node
        let start_node = AStarNode::init(start_gx, start_gy, 0, self.heuristic(start_gx, start_gy, goal_gx, goal_gy))
        self.open_list.add(start_node)

        let max_iterations = 10000
        let iterations = 0

        while self.open_list.len() > 0 && iterations < max_iterations {
            iterations = iterations + 1

            // Find node with lowest f_cost
            let current_index = 0
            let lowest_f = self.open_list.get(0).f_cost

            for i in 1..self.open_list.len() {
                let node = self.open_list.get(i)
                if node.f_cost < lowest_f {
                    lowest_f = node.f_cost
                    current_index = i
                }
            }

            let current = self.open_list.remove_at(current_index)

            // Goal reached?
            if current.x == goal_gx && current.y == goal_gy {
                // Reconstruct path
                path = self.reconstruct_path(current)
                return path
            }

            // Add to closed list
            self.closed_list.add(current)

            // Check neighbors
            let neighbors = Collection::init()
            neighbors.add(Vector2::init(current.x - 1, current.y))      // Left
            neighbors.add(Vector2::init(current.x + 1, current.y))      // Right
            neighbors.add(Vector2::init(current.x, current.y - 1))      // Up
            neighbors.add(Vector2::init(current.x, current.y + 1))      // Down

            for i in 0..neighbors.len() {
                let neighbor_pos = neighbors.get(i)
                let nx = neighbor_pos.x
                let ny = neighbor_pos.y

                // Skip if not passable
                if !self.grid.is_passable(nx, ny) { continue }

                // Skip if in closed list
                let in_closed = false
                for j in 0..self.closed_list.len() {
                    let closed_node = self.closed_list.get(j)
                    if closed_node.x == nx && closed_node.y == ny {
                        in_closed = true
                        break
                    }
                }
                if in_closed { continue }

                // Calculate costs
                let cell = self.grid.get_cell(nx, ny)
                let move_cost = 1
                if cell != null {
                    move_cost = cell.get_move_cost()
                }

                let g_cost = current.g_cost + move_cost
                let h_cost = self.heuristic(nx, ny, goal_gx, goal_gy)

                // Check if in open list
                let in_open = false
                for j in 0..self.open_list.len() {
                    let open_node = self.open_list.get(j)
                    if open_node.x == nx && open_node.y == ny {
                        in_open = true
                        // Update if better path
                        if g_cost < open_node.g_cost {
                            open_node.g_cost = g_cost
                            open_node.f_cost = g_cost + h_cost
                            open_node.set_parent(current.x, current.y)
                        }
                        break
                    }
                }

                if !in_open {
                    let neighbor = AStarNode::init(nx, ny, g_cost, h_cost)
                    neighbor.set_parent(current.x, current.y)
                    self.open_list.add(neighbor)
                }
            }
        }

        // No path found
        return path
    }

    fn reconstruct_path(self, goal_node: AStarNode) -> Path {
        let path = Path::init()
        let nodes = Collection::init()

        // Trace back from goal to start
        let current = goal_node
        nodes.add(current)

        while current.has_parent {
            let found = false

            // Find parent in closed list
            for i in 0..self.closed_list.len() {
                let node = self.closed_list.get(i)
                if node.x == current.parent_x && node.y == current.parent_y {
                    nodes.add(node)
                    current = node
                    found = true
                    break
                }
            }

            if !found { break }
        }

        // Reverse nodes to get path from start to goal
        for i in (nodes.len() - 1)..0 {
            let node = nodes.get(i)
            let world_pos = self.grid.grid_to_world(node.x, node.y)
            path.add_node(node.x, node.y, world_pos.x, world_pos.y)
        }

        return path
    }

    fn is_line_of_sight_clear(self, x1: Int, y1: Int, x2: Int, y2: Int) -> Bool {
        // Bresenham's line algorithm
        let dx = abs(x2 - x1)
        let dy = abs(y2 - y1)
        let sx = if x1 < x2 { 1 } else { -1 }
        let sy = if y1 < y2 { 1 } else { -1 }
        let err = dx - dy

        let x = x1
        let y = y1

        let max_steps = 1000
        let steps = 0

        while steps < max_steps {
            if !self.grid.is_passable(x, y) {
                return false
            }

            if x == x2 && y == y2 {
                return true
            }

            let e2 = err * 2
            if e2 > -dy {
                err = err - dy
                x = x + sx
            }
            if e2 < dx {
                err = err + dx
                y = y + sy
            }

            steps = steps + 1
        }

        return false
    }
}

// ============================================================================
// Tests
// ============================================================================

fn test_cell_flags() -> Bool {
    let flags = CellFlags::init()
    assert(flags.is_empty(), "Flags empty")

    flags.has_unit = true
    assert(!flags.is_empty(), "Flags not empty")

    return true
}

fn test_pathfind_cell() -> Bool {
    let cell = PathfindCell::init()
    assert(cell.is_passable(), "Clear cell passable")
    assert(cell.get_move_cost() == 1, "Clear cell cost")

    cell.cell_type = CellType::RUBBLE
    assert(cell.is_passable(), "Rubble passable")
    assert(cell.get_move_cost() == 2, "Rubble cost higher")

    cell.cell_type = CellType::OBSTACLE
    assert(!cell.is_passable(), "Obstacle not passable")

    return true
}

fn test_pathfind_grid() -> Bool {
    let grid = PathfindGrid::init(10, 10, 10.0)
    assert(grid.width == 10, "Grid width")
    assert(grid.height == 10, "Grid height")

    let cell = grid.get_cell(5, 5)
    assert(cell != null, "Cell exists")
    assert(cell.is_passable(), "Cell passable")

    grid.set_cell_type(5, 5, CellType::OBSTACLE)
    let cell2 = grid.get_cell(5, 5)
    assert(!cell2.is_passable(), "Cell blocked")

    return true
}

fn test_path() -> Bool {
    let path = Path::init()
    assert(path.is_empty(), "Path empty")

    path.add_node(0, 0, 0.0, 0.0)
    path.add_node(1, 1, 10.0, 10.0)

    assert(!path.is_empty(), "Path not empty")
    assert(path.nodes.len() == 2, "Two nodes")

    return true
}

fn test_astar_node() -> Bool {
    let node = AStarNode::init(5, 5, 10, 20)
    assert(node.f_cost == 30, "F cost")
    assert(!node.has_parent, "No parent")

    node.set_parent(4, 4)
    assert(node.has_parent, "Has parent")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_cell_flags(), "Test 1: Cell flags")
    assert(test_pathfind_cell(), "Test 2: Pathfind cell")
    assert(test_pathfind_grid(), "Test 3: Pathfind grid")
    assert(test_path(), "Test 4: Path")
    assert(test_astar_node(), "Test 5: A* node")
    return true
}
