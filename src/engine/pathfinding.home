// AI & Pathfinding System
// Pure Home implementation - converted from Zig
// Based on Thyme's pathfinding implementation

import engine/entity

// ============================================================================
// Cell Types
// ============================================================================

enum CellType {
    CLEAR,      // Walkable terrain
    WATER,      // Water (boats only)
    CLIFF,      // Cliff / impassable
    RUBBLE,     // Damaged terrain
    OBSTACLE,   // Building / static obstacle
    BLOCKED,    // Blocked by unit
    RESERVED,   // Reserved for building placement
}

// ============================================================================
// Cell Flags
// ============================================================================

struct CellFlags {
    has_unit: bool,
    unit_goal: bool,
    unit_moving: bool,
    bridge: bool,
    wall: bool,
}

// ============================================================================
// Pathfinding Cell
// ============================================================================

struct PathfindCell {
    cell_type: CellType,
    flags: CellFlags,
    cost: i32,
    zone: i32,
}

// ============================================================================
// Pathfinding Grid
// ============================================================================

struct PathfindGrid {
    cells: Vec<PathfindCell>,
    width: i32,
    height: i32,
    cell_size: f64,
}

// ============================================================================
// Path Node
// ============================================================================

struct PathNode {
    x: i32,
    y: i32,
    world_x: f64,
    world_y: f64,
}

// ============================================================================
// Path
// ============================================================================

struct Path {
    nodes: Vec<PathNode>,
    waypoints: Vec<Vector2>,
    current_index: i32,
    total_length: f64,
    is_blocked: bool,
}

// ============================================================================
// A* Node
// ============================================================================

struct AStarNode {
    x: i32,
    y: i32,
    g_cost: i32,  // Cost from start
    h_cost: i32,  // Heuristic cost to goal
    f_cost: i32,  // Total cost (g + h)
    parent_x: i32,
    parent_y: i32,
    has_parent: bool,
}

// ============================================================================
// Pathfinder (A* Algorithm)
// ============================================================================

struct Pathfinder {
    grid: PathfindGrid,
    grid_size: f64,
    open_list: Vec<AStarNode>,
    closed_list: Vec<AStarNode>,
}

// ============================================================================
// Tests
// ============================================================================

fn test_cell_flags(): bool {
    let flags = CellFlags::init()
    assert(flags.is_empty(), "Flags empty")

    flags.has_unit = true
    assert(!flags.is_empty(), "Flags not empty")

    return true
}

fn test_pathfind_cell(): bool {
    let cell = PathfindCell::init()
    assert(cell.is_passable(), "Clear cell passable")
    assert(cell.get_move_cost() == 1, "Clear cell cost")

    cell.cell_type = CellType::RUBBLE
    assert(cell.is_passable(), "Rubble passable")
    assert(cell.get_move_cost() == 2, "Rubble cost higher")

    cell.cell_type = CellType::OBSTACLE
    assert(!cell.is_passable(), "Obstacle not passable")

    return true
}

fn test_pathfind_grid(): bool {
    let grid = PathfindGrid::init(10, 10, 10.0)
    assert(grid.width == 10, "Grid width")
    assert(grid.height == 10, "Grid height")

    let cell = grid.get_cell(5, 5)
    assert(cell != null, "Cell exists")
    assert(cell.is_passable(), "Cell passable")

    grid.set_cell_type(5, 5, CellType::OBSTACLE)
    let cell2 = grid.get_cell(5, 5)
    assert(!cell2.is_passable(), "Cell blocked")

    return true
}

fn test_path(): bool {
    let path = Path::init()
    assert(path.is_empty(), "Path empty")

    path.add_node(0, 0, 0.0, 0.0)
    path.add_node(1, 1, 10.0, 10.0)

    assert(!path.is_empty(), "Path not empty")
    assert(path.nodes.len() == 2, "Two nodes")

    return true
}

fn test_astar_node(): bool {
    let node = AStarNode::init(5, 5, 10, 20)
    assert(node.f_cost == 30, "F cost")
    assert(!node.has_parent, "No parent")

    node.set_parent(4, 4)
    assert(node.has_parent, "Has parent")

    return true
}

fn run_all_tests(): bool {
    assert(test_cell_flags(), "Test 1: Cell flags")
    assert(test_pathfind_cell(), "Test 2: Pathfind cell")
    assert(test_pathfind_grid(), "Test 3: Pathfind grid")
    assert(test_path(), "Test 4: Path")
    assert(test_astar_node(), "Test 5: A* node")
    return true
}
