// Mod Support for C&C Generals Zero Hour
// Mod loading, asset overrides, script API, custom maps, conflict resolution
// Written in Home language

// Mod types
enum ModType {
    TOTAL_CONVERSION = 0,
    GAMEPLAY = 1,
    VISUAL = 2,
    AUDIO = 3,
    MAP_PACK = 4,
    SCRIPT = 5,
}

// Mod load priority
enum ModPriority {
    LOW = 0,
    NORMAL = 1,
    HIGH = 2,
    CRITICAL = 3,
}

// Asset override types
enum AssetType {
    TEXTURE = 0,
    MODEL = 1,
    AUDIO = 2,
    SCRIPT = 3,
    CONFIG = 4,
    MAP = 5,
}

// Mod manifest
struct ModManifest {
    id: string,
    name: string,
    version: string,
    author: string,
    description: string,
    mod_type: ModType,
    priority: ModPriority,
    dependencies: Vec<string>,
    conflicts: Vec<string>,
    asset_overrides: Vec<AssetOverride>,
}

// Asset override
struct AssetOverride {
    asset_type: AssetType,
    original_path: string,
    override_path: string,
}

// Loaded mod
struct LoadedMod {
    manifest: ModManifest,
    base_path: string,
    is_enabled: bool,
    load_order: i32,
}

// Mod conflict
struct ModConflict {
    mod_a_id: string,
    mod_b_id: string,
    conflict_type: ConflictType,
    description: string,
}

// Conflict resolution
enum ConflictType {
    ASSET_OVERRIDE = 0,
    INCOMPATIBLE = 1,
    DEPENDENCY_MISSING = 2,
}

enum ConflictResolution {
    DISABLE_MOD_A = 0,
    DISABLE_MOD_B = 1,
    MERGE = 2,
    USE_PRIORITY = 3,
}

// Mod loader
struct ModLoader {
    loaded_mods: Vec<LoadedMod>,
    conflicts: Vec<ModConflict>,
    asset_registry: AssetRegistry,
}

// Asset registry
struct AssetRegistry {
    overrides: Vec<RegisteredOverride>,
}

// Registered override
struct RegisteredOverride {
    mod_id: string,
    override: AssetOverride,
}

// Script API
struct ScriptAPI {
    registered_functions: Vec<ScriptFunction>,
}

// Script function
struct ScriptFunction {
    name: string,
    description: string,
}

// Custom map support
struct CustomMapManager {
    maps: Vec<CustomMap>,
}

// Custom map
struct CustomMap {
    name: string,
    author: string,
    description: string,
    file_path: string,
    player_count: i32,
    is_validated: bool,
}

// Mod manager
struct ModManager {
    loader: ModLoader,
    script_api: ScriptAPI,
    map_manager: CustomMapManager,
}

// Tests
test "ModManifest: init" {
    let manifest = ModManifest::init("test_mod", "Test Mod", "1.0.0")

    assert manifest.id == "test_mod"
    assert manifest.name == "Test Mod"
    assert manifest.version == "1.0.0"
}

test "ModManifest: set author" {
    let manifest = ModManifest::init("test", "Test", "1.0")

    manifest.set_author("John Doe")

    assert manifest.author == "John Doe"
}

test "ModManifest: add dependency" {
    let manifest = ModManifest::init("test", "Test", "1.0")

    manifest.add_dependency("base_mod")

    assert manifest.get_dependency_count() == 1
    assert manifest.has_dependency("base_mod")
}

test "ModManifest: add conflict" {
    let manifest = ModManifest::init("test", "Test", "1.0")

    manifest.add_conflict("incompatible_mod")

    assert manifest.conflicts_with("incompatible_mod")
}

test "ModManifest: add asset override" {
    let manifest = ModManifest::init("test", "Test", "1.0")
    let override = AssetOverride::init(AssetType::TEXTURE, "original.png", "override.png")

    manifest.add_asset_override(override)

    assert manifest.asset_overrides.count() == 1
}

test "ModManifest: set priority" {
    let manifest = ModManifest::init("test", "Test", "1.0")

    manifest.set_priority(ModPriority::HIGH)

    assert manifest.priority == ModPriority::HIGH
}

test "AssetOverride: init" {
    let override = AssetOverride::init(AssetType::MODEL, "tank.w3d", "new_tank.w3d")

    assert override.asset_type == AssetType::MODEL
    assert override.original_path == "tank.w3d"
    assert override.override_path == "new_tank.w3d"
}

test "LoadedMod: init" {
    let manifest = ModManifest::init("test", "Test", "1.0")
    let mod = LoadedMod::init(manifest, "/mods/test")

    assert mod.base_path == "/mods/test"
    assert mod.is_enabled
}

test "LoadedMod: enable and disable" {
    let manifest = ModManifest::init("test", "Test", "1.0")
    let mod = LoadedMod::init(manifest, "/mods/test")

    mod.disable()
    assert !mod.is_enabled

    mod.enable()
    assert mod.is_enabled
}

test "LoadedMod: set load order" {
    let manifest = ModManifest::init("test", "Test", "1.0")
    let mod = LoadedMod::init(manifest, "/mods/test")

    mod.set_load_order(5)

    assert mod.load_order == 5
}

test "LoadedMod: get asset path" {
    let manifest = ModManifest::init("test", "Test", "1.0")
    let mod = LoadedMod::init(manifest, "/mods/test")

    let path = mod.get_asset_path("textures/tank.png")

    assert path == "/mods/test/textures/tank.png"
}

test "ModConflict: init" {
    let conflict = ModConflict::init("mod_a", "mod_b", ConflictType::INCOMPATIBLE)

    assert conflict.mod_a_id == "mod_a"
    assert conflict.mod_b_id == "mod_b"
    assert conflict.conflict_type == ConflictType::INCOMPATIBLE
}

test "ModLoader: init" {
    let loader = ModLoader::init()

    assert loader.get_loaded_mod_count() == 0
    assert !loader.has_conflicts()
}

test "ModLoader: load mod" {
    let loader = ModLoader::init()
    let manifest = ModManifest::init("test_mod", "Test", "1.0")

    let success = loader.load_mod(manifest, "/mods/test")

    assert success
    assert loader.get_loaded_mod_count() == 1
}

test "ModLoader: is mod loaded" {
    let loader = ModLoader::init()
    let manifest = ModManifest::init("test_mod", "Test", "1.0")

    loader.load_mod(manifest, "/mods/test")

    assert loader.is_mod_loaded("test_mod")
    assert !loader.is_mod_loaded("other_mod")
}

test "ModLoader: unload mod" {
    let loader = ModLoader::init()
    let manifest = ModManifest::init("test_mod", "Test", "1.0")

    loader.load_mod(manifest, "/mods/test")
    let success = loader.unload_mod("test_mod")

    assert success
    assert loader.get_loaded_mod_count() == 0
}

test "ModLoader: dependency check" {
    let loader = ModLoader::init()

    let base_manifest = ModManifest::init("base", "Base", "1.0")
    loader.load_mod(base_manifest, "/mods/base")

    let dependent_manifest = ModManifest::init("dependent", "Dependent", "1.0")
    dependent_manifest.add_dependency("base")

    let success = loader.load_mod(dependent_manifest, "/mods/dependent")

    assert success
}

test "ModLoader: missing dependency" {
    let loader = ModLoader::init()

    let manifest = ModManifest::init("dependent", "Dependent", "1.0")
    manifest.add_dependency("missing_mod")

    let success = loader.load_mod(manifest, "/mods/dependent")

    assert !success
    assert loader.has_conflicts()
}

test "ModLoader: conflict detection" {
    let loader = ModLoader::init()

    let mod_a = ModManifest::init("mod_a", "Mod A", "1.0")
    loader.load_mod(mod_a, "/mods/a")

    let mod_b = ModManifest::init("mod_b", "Mod B", "1.0")
    mod_b.add_conflict("mod_a")

    let success = loader.load_mod(mod_b, "/mods/b")

    assert !success
    assert loader.has_conflicts()
}

test "AssetRegistry: init" {
    let registry = AssetRegistry::init()

    assert registry.get_override_count() == 0
}

test "AssetRegistry: register override" {
    let registry = AssetRegistry::init()
    let override = AssetOverride::init(AssetType::TEXTURE, "old.png", "new.png")

    registry.register_override("test_mod", override)

    assert registry.get_override_count() == 1
}

test "AssetRegistry: resolve path" {
    let registry = AssetRegistry::init()
    let override = AssetOverride::init(AssetType::TEXTURE, "old.png", "new.png")

    registry.register_override("test_mod", override)

    let resolved = registry.resolve_path("old.png")

    assert resolved == "new.png"
}

test "AssetRegistry: unregister mod" {
    let registry = AssetRegistry::init()
    let override = AssetOverride::init(AssetType::TEXTURE, "old.png", "new.png")

    registry.register_override("test_mod", override)
    registry.unregister_mod("test_mod")

    assert registry.get_override_count() == 0
}

test "ScriptAPI: init" {
    let api = ScriptAPI::init()

    assert api.get_function_count() == 0
}

test "ScriptAPI: register function" {
    let api = ScriptAPI::init()

    api.register_function("spawn_unit", "Spawns a unit at location")

    assert api.get_function_count() == 1
    assert api.has_function("spawn_unit")
}

test "CustomMap: init" {
    let map = CustomMap::init("Desert Storm", "/maps/desert.map")

    assert map.name == "Desert Storm"
    assert map.file_path == "/maps/desert.map"
    assert !map.is_validated
}

test "CustomMap: set author" {
    let map = CustomMap::init("Test Map", "/maps/test.map")

    map.set_author("MapMaker123")

    assert map.author == "MapMaker123"
}

test "CustomMap: mark validated" {
    let map = CustomMap::init("Test Map", "/maps/test.map")

    map.mark_validated()

    assert map.is_validated
}

test "CustomMapManager: init" {
    let manager = CustomMapManager::init()

    assert manager.get_map_count() == 0
}

test "CustomMapManager: register map" {
    let manager = CustomMapManager::init()
    let map = CustomMap::init("Test Map", "/maps/test.map")

    manager.register_map(map)

    assert manager.get_map_count() == 1
}

test "CustomMapManager: get map" {
    let manager = CustomMapManager::init()
    let map = CustomMap::init("Test Map", "/maps/test.map")

    manager.register_map(map)

    let found = manager.get_map("Test Map")

    assert found != null
}

test "CustomMapManager: get maps by author" {
    let manager = CustomMapManager::init()

    let map1 = CustomMap::init("Map 1", "/maps/1.map")
    map1.set_author("Author1")

    let map2 = CustomMap::init("Map 2", "/maps/2.map")
    map2.set_author("Author1")

    manager.register_map(map1)
    manager.register_map(map2)

    let maps = manager.get_maps_by_author("Author1")

    assert maps.count() == 2
}

test "ModManager: init" {
    let manager = ModManager::init()

    assert manager.get_loaded_mod_count() == 0
}

test "ModManager: load mod" {
    let manager = ModManager::init()
    let manifest = ModManifest::init("test", "Test", "1.0")

    let success = manager.load_mod(manifest, "/mods/test")

    assert success
    assert manager.get_loaded_mod_count() == 1
}

test "ModManager: resolve asset" {
    let manager = ModManager::init()
    let manifest = ModManifest::init("test", "Test", "1.0")

    let override = AssetOverride::init(AssetType::TEXTURE, "tank.png", "new_tank.png")
    manifest.add_asset_override(override)

    manager.load_mod(manifest, "/mods/test")

    let resolved = manager.resolve_asset("tank.png")

    assert resolved == "new_tank.png"
}

test "ModManager: register script function" {
    let manager = ModManager::init()

    manager.register_script_function("test_func", "Test function")

    assert manager.script_api.has_function("test_func")
}

test "ModManager: register custom map" {
    let manager = ModManager::init()
    let map = CustomMap::init("Test", "/maps/test.map")

    manager.register_custom_map(map)

    assert manager.get_custom_map_count() == 1
}
