// Memory Pool Factory - Pool Creation and Configuration
// Based on Thyme engine memory pool factory architecture
// Provides centralized pool creation with presets and sizing

from memory_pool import MemoryPool, PoolManager, create_pool_manager, register_pool
from memory_pool import pool_alloc, pool_free, pool_usage, pool_stats, pool_reset

// ============================================================================
// Pool Preset Configurations
// ============================================================================

enum PoolPreset {
    // Size-based presets
    Tiny,       // 16 bytes, 2048 blocks
    Small,      // 32 bytes, 1024 blocks
    Medium,     // 64 bytes, 512 blocks
    Large,      // 128 bytes, 256 blocks
    Huge,       // 256 bytes, 128 blocks
    Massive,    // 512 bytes, 64 blocks

    // Usage-based presets
    Entity,     // Game entities
    Particle,   // Particle effects
    Projectile, // Projectiles
    PathNode,   // Pathfinding nodes
    Command,    // Game commands
    Message,    // Network messages
    Sound,      // Sound instances
    Effect,     // Visual effects
    AIState,    // AI states
    Widget,     // UI widgets
}

struct PoolConfig {
    name: string,
    block_size: i32,
    initial_blocks: i32,
    max_blocks: i32,
    allow_growth: bool,
    alignment: i32,
}

/// Create default config
fn default_config(): PoolConfig {
    return PoolConfig {
        name: "",
        block_size: 64,
        initial_blocks: 256,
        max_blocks: 4096,
        allow_growth: true,
        alignment: 8,
    }
}

/// Get configuration for preset
fn get_preset_config(preset: PoolPreset): PoolConfig {
    let config = default_config()

    if preset == PoolPreset::Tiny {
        config.name = "Tiny"
        config.block_size = 16
        config.initial_blocks = 2048
        config.max_blocks = 8192
    } else if preset == PoolPreset::Small {
        config.name = "Small"
        config.block_size = 32
        config.initial_blocks = 1024
        config.max_blocks = 4096
    } else if preset == PoolPreset::Medium {
        config.name = "Medium"
        config.block_size = 64
        config.initial_blocks = 512
        config.max_blocks = 2048
    } else if preset == PoolPreset::Large {
        config.name = "Large"
        config.block_size = 128
        config.initial_blocks = 256
        config.max_blocks = 1024
    } else if preset == PoolPreset::Huge {
        config.name = "Huge"
        config.block_size = 256
        config.initial_blocks = 128
        config.max_blocks = 512
    } else if preset == PoolPreset::Massive {
        config.name = "Massive"
        config.block_size = 512
        config.initial_blocks = 64
        config.max_blocks = 256
    } else if preset == PoolPreset::Entity {
        config.name = "Entity"
        config.block_size = 256
        config.initial_blocks = 512
        config.max_blocks = 2048
    } else if preset == PoolPreset::Particle {
        config.name = "Particle"
        config.block_size = 64
        config.initial_blocks = 2048
        config.max_blocks = 16384
    } else if preset == PoolPreset::Projectile {
        config.name = "Projectile"
        config.block_size = 128
        config.initial_blocks = 256
        config.max_blocks = 1024
    } else if preset == PoolPreset::PathNode {
        config.name = "PathNode"
        config.block_size = 32
        config.initial_blocks = 2048
        config.max_blocks = 8192
    } else if preset == PoolPreset::Command {
        config.name = "Command"
        config.block_size = 64
        config.initial_blocks = 256
        config.max_blocks = 1024
    } else if preset == PoolPreset::Message {
        config.name = "Message"
        config.block_size = 128
        config.initial_blocks = 512
        config.max_blocks = 2048
    } else if preset == PoolPreset::Sound {
        config.name = "Sound"
        config.block_size = 48
        config.initial_blocks = 128
        config.max_blocks = 512
    } else if preset == PoolPreset::Effect {
        config.name = "Effect"
        config.block_size = 96
        config.initial_blocks = 256
        config.max_blocks = 1024
    } else if preset == PoolPreset::AIState {
        config.name = "AIState"
        config.block_size = 80
        config.initial_blocks = 256
        config.max_blocks = 1024
    } else if preset == PoolPreset::Widget {
        config.name = "Widget"
        config.block_size = 192
        config.initial_blocks = 128
        config.max_blocks = 512
    }

    return config
}

// ============================================================================
// Pool Factory
// ============================================================================

struct PoolFactory {
    manager: PoolManager,
    configs: HashMap<String, PoolConfig>,
    created_pools: Vec<string>,
    stats_enabled: bool,
}

/// Create pool factory
fn create_factory(): PoolFactory {
    return PoolFactory {
        manager: create_pool_manager(),
        configs: HashMap<String, PoolConfig>{},
        created_pools: Vec<string>{},
        stats_enabled: true,
    }
}

/// Create pool from preset
fn create_from_preset(factory: PoolFactory, preset: PoolPreset): MemoryPool {
    let config = get_preset_config(preset)
    return create_from_config(factory, config)
}

/// Create pool from config
fn create_from_config(factory: PoolFactory, config: PoolConfig): MemoryPool {
    // Store config
    factory.configs.set(config.name, config)

    // Create and register pool
    let pool = register_pool(factory.manager, config.name, config.block_size, config.initial_blocks)
    pool.allow_growth = config.allow_growth

    factory.created_pools.add(config.name)

    return pool
}

/// Create pool with custom settings
fn create_custom(factory: PoolFactory, name: string, block_size: i32, initial_blocks: i32): MemoryPool {
    let config = default_config()
    config.name = name
    config.block_size = block_size
    config.initial_blocks = initial_blocks

    return create_from_config(factory, config)
}

/// Create all standard game pools
fn create_standard_pools(factory: PoolFactory) {
    create_from_preset(factory, PoolPreset::Entity)
    create_from_preset(factory, PoolPreset::Particle)
    create_from_preset(factory, PoolPreset::Projectile)
    create_from_preset(factory, PoolPreset::PathNode)
    create_from_preset(factory, PoolPreset::Command)
    create_from_preset(factory, PoolPreset::Message)
    create_from_preset(factory, PoolPreset::Sound)
    create_from_preset(factory, PoolPreset::Effect)
    create_from_preset(factory, PoolPreset::AIState)
    create_from_preset(factory, PoolPreset::Widget)
}

/// Get pool by name
fn get_pool(factory: PoolFactory, name: string): MemoryPool {
    return factory.manager.pools.get(name)
}

/// Check if pool exists
fn has_pool(factory: PoolFactory, name: string): bool {
    return factory.manager.pools.has(name)
}

/// Get pool config
fn get_config(factory: PoolFactory, name: string): PoolConfig {
    if factory.configs.has(name) {
        return factory.configs.get(name)
    }
    return default_config()
}

// ============================================================================
// Factory Statistics
// ============================================================================

struct PoolStatistics {
    name: string,
    block_size: i32,
    usage: i32,
    capacity: i32,
    peak: i32,
    chunks: i32,
    efficiency: f64,
}

/// Get statistics for a pool
fn get_pool_statistics(factory: PoolFactory, name: string): PoolStatistics {
    let stats = PoolStatistics {
        name: name,
        block_size: 0,
        usage: 0,
        capacity: 0,
        peak: 0,
        chunks: 0,
        efficiency: 0.0,
    }

    if !has_pool(factory, name) {
        return stats
    }

    let pool = get_pool(factory, name)
    let (usage, capacity, peak, chunks) = pool_stats(pool)

    stats.block_size = pool.block_size
    stats.usage = usage
    stats.capacity = capacity
    stats.peak = peak
    stats.chunks = chunks

    if capacity > 0 {
        stats.efficiency = (usage as Float) / (capacity as Float) * 100.0
    }

    return stats
}

/// Get statistics for all pools
fn get_all_statistics(factory: PoolFactory): Vec<PoolStatistics> {
    let all_stats = Vec<PoolStatistics>{}

    for name in factory.created_pools {
        all_stats.add(get_pool_statistics(factory, name))
    }

    return all_stats
}

/// Get total memory usage
fn get_total_memory(factory: PoolFactory): i32 {
    let total = 0

    for name in factory.created_pools {
        let stats = get_pool_statistics(factory, name)
        total = total + stats.usage * stats.block_size
    }

    return total
}

/// Get total capacity in bytes
fn get_total_capacity(factory: PoolFactory): i32 {
    let total = 0

    for name in factory.created_pools {
        let stats = get_pool_statistics(factory, name)
        total = total + stats.capacity * stats.block_size
    }

    return total
}

// ============================================================================
// Pool Sizing Helpers
// ============================================================================

/// Calculate optimal block size (aligned to 8)
fn align_size(size: i32): i32 {
    return ((size + 7) / 8) * 8
}

/// Calculate blocks needed for given memory budget
fn blocks_for_budget(block_size: i32, memory_bytes: i32): i32 {
    if block_size <= 0 {
        return 0
    }
    return memory_bytes / block_size
}

/// Estimate memory for config
fn estimate_memory(config: PoolConfig): i32 {
    return config.initial_blocks * config.block_size
}

/// Create optimized config for type
fn config_for_type(name: string, type_size: i32, expected_count: i32): PoolConfig {
    let config = default_config()
    config.name = name
    config.block_size = align_size(type_size)

    // Start with expected count, allow 2x growth
    config.initial_blocks = expected_count
    config.max_blocks = expected_count * 2

    // Use chunks of 64 blocks minimum
    if config.initial_blocks < 64 {
        config.initial_blocks = 64
    }

    return config
}

// ============================================================================
// Pool Defragmentation (Conceptual)
// ============================================================================

/// Compact pool by moving used blocks
fn compact_pool(factory: PoolFactory, name: string): i32 {
    // In a real implementation, this would:
    // 1. Create a new chunk
    // 2. Copy all used blocks to new chunk
    // 3. Update all handles
    // 4. Free old chunks

    // For now, return number of freed chunks (stub)
    return 0
}

/// Reset unused pools
fn reset_unused_pools(factory: PoolFactory, threshold: f64) {
    for name in factory.created_pools {
        let stats = get_pool_statistics(factory, name)
        if stats.efficiency < threshold {
            let pool = get_pool(factory, name)
            pool_reset(pool)
        }
    }
}

// ============================================================================
// Debug Helpers
// ============================================================================

/// Format statistics as string
fn format_stats(stats: PoolStatistics): string {
    return stats.name + ": " +
           int_to_string(stats.usage) + "/" +
           int_to_string(stats.capacity) + " (" +
           float_to_string(stats.efficiency) + "%)"
}

/// Format memory size
fn format_memory(bytes: i32): string {
    if bytes >= 1048576 {
        return float_to_string((bytes as Float) / 1048576.0) + " MB"
    } else if bytes >= 1024 {
        return float_to_string((bytes as Float) / 1024.0) + " KB"
    }
    return int_to_string(bytes) + " B"
}

fn int_to_string(n: i32): string {
    if n == 0 {
        return "0"
    }

    let result = ""
    let num = n
    let negative = false

    if num < 0 {
        negative = true
        num = -num
    }

    while num > 0 {
        let digit = num % 10
        result = String::char_from_code(48 + digit) + result
        num = num / 10
    }

    if negative {
        result = "-" + result
    }

    return result
}

fn float_to_string(f: f64): string {
    let int_part = f as Int
    let frac_part = ((f - (int_part as Float)) * 100.0) as Int
    if frac_part < 0 {
        frac_part = -frac_part
    }

    let frac_str = int_to_string(frac_part)
    if frac_part < 10 {
        frac_str = "0" + frac_str
    }

    return int_to_string(int_part) + "." + frac_str
}

// ============================================================================
// Global Factory Instance
// ============================================================================

let GLOBAL_FACTORY: PoolFactory = create_factory()

/// Get global factory
fn global_factory(): PoolFactory {
    return GLOBAL_FACTORY
}

/// Initialize global pools
fn init_global_pools() {
    create_standard_pools(GLOBAL_FACTORY)
}

// ============================================================================
// Tests
// ============================================================================

fn test_preset_config(): bool {
    let tiny = get_preset_config(PoolPreset::Tiny)
    assert(tiny.block_size == 16, "Tiny should be 16 bytes")
    assert(tiny.initial_blocks == 2048, "Tiny should have 2048 blocks")

    let entity = get_preset_config(PoolPreset::Entity)
    assert(entity.block_size == 256, "Entity should be 256 bytes")

    return true
}

fn test_factory_create(): bool {
    let factory = create_factory()

    let pool = create_from_preset(factory, PoolPreset::Small)
    assert(pool.block_size == 32, "Small pool should be 32 bytes")

    let custom = create_custom(factory, "custom", 100, 50)
    assert(custom.block_size >= 100, "Custom should be at least 100 bytes")

    return true
}

fn test_factory_stats(): bool {
    let factory = create_factory()
    create_standard_pools(factory)

    let all_stats = get_all_statistics(factory)
    assert(all_stats.len() == 10, "Should have 10 standard pools")

    let entity_stats = get_pool_statistics(factory, "Entity")
    assert(entity_stats.name == "Entity", "Should get Entity stats")
    assert(entity_stats.block_size == 256, "Entity block size should be 256")

    return true
}

fn test_sizing(): bool {
    assert(align_size(1) == 8, "1 should align to 8")
    assert(align_size(8) == 8, "8 should stay 8")
    assert(align_size(9) == 16, "9 should align to 16")
    assert(align_size(17) == 24, "17 should align to 24")

    assert(blocks_for_budget(64, 1024) == 16, "1KB / 64B = 16 blocks")

    return true
}

fn test_config_for_type(): bool {
    let config = config_for_type("TestType", 100, 500)
    assert(config.name == "TestType", "Name should match")
    assert(config.block_size == 104, "Should align 100 to 104")
    assert(config.initial_blocks == 500, "Should have 500 initial")
    assert(config.max_blocks == 1000, "Should have 1000 max")

    return true
}

fn run_all_tests(): bool {
    assert(test_preset_config(), "Preset config test failed")
    assert(test_factory_create(), "Factory create test failed")
    assert(test_factory_stats(), "Factory stats test failed")
    assert(test_sizing(), "Sizing test failed")
    assert(test_config_for_type(), "Config for type test failed")
    return true
}
