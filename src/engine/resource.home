// ============================================================================
// Resource System for Generals RTS
// Manages supply collection and player economy
// ============================================================================

import engine/entity

// ============================================================================
// Resource Types
// ============================================================================

/// Resource types in C&C Generals
enum ResourceType {
    SUPPLIES,  // Main resource in Generals
    POWER,     // Generated by power plants
}

// ============================================================================
// Vec2 Helper
// ============================================================================

struct Vec2 {
    x: f64,
    y: f64,
}

fn vec2_init(x: f64, y: f64): Vec2 {
    let v = Vec2 {}
    v.x = x
    v.y = y
    return v
}

// ============================================================================
// Resource Node (Supply Pile)
// ============================================================================

/// Resource node - supply pile on the map
struct ResourceNode {
    id: i32,
    position: Vec2,
    resource_type: ResourceType,
    amount: f64,
    max_amount: f64,
    active: bool,
}

fn create_resource_node(id: i32, x: f64, y: f64, amount: f64): ResourceNode {
    let node = ResourceNode {}
    node.id = id
    node.position = vec2_init(x, y)
    node.resource_type = ResourceType::SUPPLIES
    node.amount = amount
    node.max_amount = amount
    node.active = true
    return node
}

fn collect_from_node(node: ResourceNode, amount: f64): f64 {
    let collected = amount
    if collected > node.amount {
        collected = node.amount
    }

    node.amount = node.amount - collected
    if node.amount <= 0.0 {
        node.active = false
    }

    return collected
}

fn is_node_empty(node: ResourceNode): bool {
    return node.amount <= 0.0
}

// ============================================================================
// Player Resources
// ============================================================================

/// Player resources
struct PlayerResources {
    supplies: f64,
    power: f64,
    supply_limit: f64,
}

fn create_player_resources(): PlayerResources {
    let resources = PlayerResources {}
    resources.supplies = 0.0
    resources.power = 0.0
    resources.supply_limit = 100.0  // Starting supply limit
    return resources
}

fn add_supplies(resources: PlayerResources, amount: f64) {
    resources.supplies = resources.supplies + amount
    if resources.supplies > resources.supply_limit {
        resources.supplies = resources.supply_limit
    }
}

fn can_afford(resources: PlayerResources, cost: f64): bool {
    return resources.supplies >= cost
}

fn spend_resources(resources: PlayerResources, cost: f64): bool {
    if can_afford(resources, cost) {
        resources.supplies = resources.supplies - cost
        return true
    }
    return false
}

// ============================================================================
// Resource Collector (Worker Unit)
// ============================================================================

/// Resource collection component for worker units
struct ResourceCollector {
    collection_rate: f64,      // Resources per second
    carrying_capacity: f64,
    current_cargo: f64,
    target_node_id: i32,         // -1 if none
    return_to_depot_id: i32,     // -1 if none
    is_collecting: bool,
    is_returning: bool,
}

fn create_collector(collection_rate: f64, carrying_capacity: f64): ResourceCollector {
    let collector = ResourceCollector {}
    collector.collection_rate = collection_rate
    collector.carrying_capacity = carrying_capacity
    collector.current_cargo = 0.0
    collector.target_node_id = -1
    collector.return_to_depot_id = -1
    collector.is_collecting = false
    collector.is_returning = false
    return collector
}

fn is_collector_full(collector: ResourceCollector): bool {
    return collector.current_cargo >= collector.carrying_capacity
}

fn is_collector_empty(collector: ResourceCollector): bool {
    return collector.current_cargo <= 0.0
}

fn collect_resource(collector: ResourceCollector, dt: f64, node: ResourceNode) {
    let amount = collector.collection_rate * dt
    let collected = collect_from_node(node, amount)

    collector.current_cargo = collector.current_cargo + collected
    if collector.current_cargo > collector.carrying_capacity {
        collector.current_cargo = collector.carrying_capacity
    }
}

fn deposit_resources(collector: ResourceCollector, player_resources: PlayerResources) {
    add_supplies(player_resources, collector.current_cargo)
    collector.current_cargo = 0.0
}

// ============================================================================
// Resource Manager
// ============================================================================

/// Resource Manager - manages all resource nodes and collection
struct ResourceManager {
    resource_nodes: Vec<ResourceNode>,
    next_node_id: i32,
}

fn create_resource_manager(): ResourceManager {
    let manager = ResourceManager {}
    manager.resource_nodes = Vec<ResourceNode> {}
    manager.next_node_id = 1
    return manager
}

/// Create a new resource node (supply pile)
fn create_node(manager: ResourceManager, x: f64, y: f64, amount: f64): i32 {
    let id = manager.next_node_id
    manager.next_node_id = manager.next_node_id + 1

    let node = create_resource_node(id, x, y, amount)
    manager.resource_nodes.add(node)

    return id
}

/// Get resource node by ID
struct NodeResult {
    found: bool,
    node: ResourceNode,
}

fn get_node(manager: ResourceManager, id: i32): NodeResult {
    let result = NodeResult {}
    result.found = false

    for i in 0..manager.resource_nodes.len() {
        let node = manager.resource_nodes.get(i)
        if node.id == id && node.active {
            result.found = true
            result.node = node
            return result
        }
    }

    return result
}

/// Find nearest resource node to position
fn find_nearest_node(manager: ResourceManager, position: Vec2, max_distance: f64): i32 {
    let nearest_id = -1
    let nearest_dist_sq = max_distance * max_distance

    for i in 0..manager.resource_nodes.len() {
        let node = manager.resource_nodes.get(i)
        if !node.active || is_node_empty(node) {
            continue
        }

        let dx = node.position.x - position.x
        let dy = node.position.y - position.y
        let dist_sq = dx * dx + dy * dy

        if dist_sq < nearest_dist_sq {
            nearest_dist_sq = dist_sq
            nearest_id = node.id
        }
    }

    return nearest_id
}

/// Get all active resource nodes
fn get_active_nodes(manager: ResourceManager): Vec<ResourceNode> {
    let active = Vec<ResourceNode> {}

    for i in 0..manager.resource_nodes.len() {
        let node = manager.resource_nodes.get(i)
        if node.active {
            active.add(node)
        }
    }

    return active
}

/// Update resource nodes (cleanup)
fn update_resource_manager(manager: ResourceManager) {
    // Cleanup can be done here if needed
    // For now, nodes just become inactive when depleted
}

// ============================================================================
// Tests
// ============================================================================

fn test_node_creation(): bool {
    let node = create_resource_node(1, 100.0, 200.0, 1000.0)

    assert(node.id == 1, "ID should be 1")
    assert(node.amount == 1000.0, "Amount should be 1000")
    assert(node.active, "Node should be active")

    return true
}

fn test_node_collection(): bool {
    let node = create_resource_node(1, 100.0, 200.0, 1000.0)

    let collected = collect_from_node(node, 100.0)
    assert(collected == 100.0, "Should collect 100")
    assert(node.amount == 900.0, "Amount should be 900")
    assert(node.active, "Node should still be active")

    return true
}

fn test_node_depletion(): bool {
    let node = create_resource_node(1, 100.0, 200.0, 50.0)

    // Try to collect more than available
    let collected = collect_from_node(node, 100.0)
    assert(collected == 50.0, "Should collect only 50")
    assert(node.amount == 0.0, "Amount should be 0")
    assert(!node.active, "Node should be inactive")
    assert(is_node_empty(node), "Node should be empty")

    return true
}

fn test_player_resources(): bool {
    let resources = create_player_resources()

    assert(resources.supplies == 0.0, "Should start at 0")

    add_supplies(resources, 500.0)
    assert(resources.supplies == 500.0, "Should have 500")

    assert(can_afford(resources, 300.0), "Should afford 300")
    assert(spend_resources(resources, 300.0), "Should spend 300")
    assert(resources.supplies == 200.0, "Should have 200 left")

    assert(!can_afford(resources, 300.0), "Should not afford 300")
    assert(!spend_resources(resources, 300.0), "Should not spend 300")

    return true
}

fn test_supply_limit(): bool {
    let resources = create_player_resources()

    // Add more than limit
    add_supplies(resources, 150.0)
    assert(resources.supplies == 100.0, "Should be capped at limit")

    return true
}

fn test_collector_creation(): bool {
    let collector = create_collector(10.0, 100.0)

    assert(collector.collection_rate == 10.0, "Rate should be 10")
    assert(collector.carrying_capacity == 100.0, "Capacity should be 100")
    assert(collector.current_cargo == 0.0, "Cargo should be 0")
    assert(is_collector_empty(collector), "Should be empty")
    assert(!is_collector_full(collector), "Should not be full")

    return true
}

fn test_collector_collection(): bool {
    let collector = create_collector(10.0, 100.0)
    let node = create_resource_node(1, 0.0, 0.0, 1000.0)
    let resources = create_player_resources()

    // Collect for 5 seconds
    collect_resource(collector, 5.0, node)
    assert(collector.current_cargo == 50.0, "Cargo should be 50")
    assert(node.amount == 950.0, "Node should have 950 left")

    // Deposit
    deposit_resources(collector, resources)
    assert(collector.current_cargo == 0.0, "Cargo should be 0 after deposit")
    assert(resources.supplies == 50.0, "Resources should be 50")

    return true
}

fn test_collector_capacity(): bool {
    let collector = create_collector(10.0, 100.0)
    let node = create_resource_node(1, 0.0, 0.0, 1000.0)

    // Collect for 15 seconds (should hit capacity)
    collect_resource(collector, 15.0, node)
    assert(collector.current_cargo == 100.0, "Should be at capacity")
    assert(is_collector_full(collector), "Should be full")

    return true
}

fn test_manager_creation(): bool {
    let manager = create_resource_manager()

    assert(manager.resource_nodes.len() == 0, "Should have no nodes")
    assert(manager.next_node_id == 1, "Next ID should be 1")

    return true
}

fn test_manager_create_node(): bool {
    let manager = create_resource_manager()

    let id = create_node(manager, 100.0, 200.0, 1000.0)
    assert(id == 1, "First ID should be 1")
    assert(manager.resource_nodes.len() == 1, "Should have 1 node")

    return true
}

fn test_manager_get_node(): bool {
    let manager = create_resource_manager()

    let id = create_node(manager, 100.0, 200.0, 1000.0)

    let result = get_node(manager, id)
    assert(result.found, "Should find node")
    assert(result.node.id == id, "Should be correct node")

    return true
}

fn test_manager_find_nearest(): bool {
    let manager = create_resource_manager()

    create_node(manager, 100.0, 100.0, 1000.0)
    create_node(manager, 500.0, 500.0, 1000.0)

    let pos = vec2_init(150.0, 150.0)
    let nearest = find_nearest_node(manager, pos, 1000.0)

    assert(nearest == 1, "Nearest should be node 1")

    return true
}

fn run_all_tests(): bool {
    assert(test_node_creation(), "Node creation test failed")
    assert(test_node_collection(), "Node collection test failed")
    assert(test_node_depletion(), "Node depletion test failed")
    assert(test_player_resources(), "Player resources test failed")
    assert(test_supply_limit(), "Supply limit test failed")
    assert(test_collector_creation(), "Collector creation test failed")
    assert(test_collector_collection(), "Collector collection test failed")
    assert(test_collector_capacity(), "Collector capacity test failed")
    assert(test_manager_creation(), "Manager creation test failed")
    assert(test_manager_create_node(), "Manager create node test failed")
    assert(test_manager_get_node(), "Manager get node test failed")
    assert(test_manager_find_nearest(), "Manager find nearest test failed")
    return true
}
