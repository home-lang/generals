// C&C Generals Zero Hour - Home Port
// Physics & Collision System
//
// Original: CollisionDetection.cpp, PhysicsUpdate.cpp (Westwood Studios/EA)
// Ported to Home with modern collision detection

import basics/allocator
import engine/math
import graphics/mesh

// Collision shapes
enum CollisionShape {
    Sphere
    Box
    Capsule
    Mesh
}

// Sphere collider
struct SphereCollider {
    center: Vec3
    radius: f32
}

// Box collider (Axis-Aligned Bounding Box)
struct BoxCollider {
    min: Vec3
    max: Vec3
}

// Capsule collider (for units)
struct CapsuleCollider {
    start: Vec3
    end: Vec3
    radius: f32
}

// Ray for raycasting
struct Ray {
    origin: Vec3
    direction: Vec3
}

// Ray hit information
struct RayHit {
    hit: bool
    distance: f32
    point: Vec3
    normal: Vec3
}

// Collision detection functions

fn sphere_sphere_collision(a: SphereCollider, b: SphereCollider): bool {
    let dist_sq = vec3_distance_squared(a.center, b.center)
    let radius_sum = a.radius + b.radius
    return dist_sq <= (radius_sum * radius_sum)
}

fn box_box_collision(a: BoxCollider, b: BoxCollider): bool {
    // AABB vs AABB collision
    if (a.max.x < b.min.x or a.min.x > b.max.x) {
        return false
    }
    if (a.max.y < b.min.y or a.min.y > b.max.y) {
        return false
    }
    if (a.max.z < b.min.z or a.min.z > b.max.z) {
        return false
    }
    return true
}

fn sphere_box_collision(sphere: SphereCollider, box: BoxCollider): bool {
    // Find closest point on box to sphere center
    let closest = Vec3 {
        x: clamp(sphere.center.x, box.min.x, box.max.x)
        y: clamp(sphere.center.y, box.min.y, box.max.y)
        z: clamp(sphere.center.z, box.min.z, box.max.z)
    }

    let dist_sq = vec3_distance_squared(closest, sphere.center)
    return dist_sq <= (sphere.radius * sphere.radius)
}

fn ray_sphere_intersection(ray: Ray, sphere: SphereCollider): RayHit {
    let oc = vec3_sub(ray.origin, sphere.center)
    let a = ray.direction.dot(ray.direction)
    let b = 2.0 * oc.dot(ray.direction)
    let c = oc.dot(oc) - sphere.radius * sphere.radius
    let discriminant = b * b - 4.0 * a * c

    if (discriminant < 0.0) {
        return RayHit {
            hit: false
            distance: 0.0
            point: Vec3.init(0.0, 0.0, 0.0)
            normal: Vec3.init(0.0, 1.0, 0.0)
        }
    }

    let t = (-b - @sqrt(discriminant)) / (2.0 * a)
    if (t < 0.0) {
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    let hit_point = ray.point_at(t)
    let normal = vec3_sub(hit_point, sphere.center).normalize()

    return RayHit {
        hit: true
        distance: t
        point: hit_point
        normal: normal
    }
}

fn ray_box_intersection(ray: Ray, box: BoxCollider): RayHit {
    // Slab method for ray-AABB intersection
    let inv_dir = Vec3 {
        x: 1.0 / ray.direction.x
        y: 1.0 / ray.direction.y
        z: 1.0 / ray.direction.z
    }

    let t1 = (box.min.x - ray.origin.x) * inv_dir.x
    let t2 = (box.max.x - ray.origin.x) * inv_dir.x
    let t3 = (box.min.y - ray.origin.y) * inv_dir.y
    let t4 = (box.max.y - ray.origin.y) * inv_dir.y
    let t5 = (box.min.z - ray.origin.z) * inv_dir.z
    let t6 = (box.max.z - ray.origin.z) * inv_dir.z

    let tmin = max_f32(max_f32(min_f32(t1, t2), min_f32(t3, t4)), min_f32(t5, t6))
    let tmax = min_f32(min_f32(max_f32(t1, t2), max_f32(t3, t4)), max_f32(t5, t6))

    // Ray doesn't intersect AABB
    if (tmax < 0.0 or tmin > tmax) {
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    let t = if tmin < 0.0 { tmax } else { tmin }
    let hit_point = ray.point_at(t)

    // Calculate normal (simplified)
    let normal = Vec3.init(0.0, 1.0, 0.0)  // TODO: Calculate actual normal

    return RayHit {
        hit: true
        distance: t
        point: hit_point
        normal: normal
    }
}

fn ray_plane_intersection(ray: Ray, plane_point: Vec3, plane_normal: Vec3): RayHit {
    let denom = ray.direction.dot(plane_normal)

    if (@abs(denom) < EPSILON) {
        // Ray is parallel to plane
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    let t = vec3_sub(plane_point, ray.origin).dot(plane_normal) / denom

    if (t < 0.0) {
        // Intersection behind ray origin
        return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
    }

    let hit_point = ray.point_at(t)

    return RayHit {
        hit: true
        distance: t
        point: hit_point
        normal: plane_normal
    }
}

// Spatial partitioning - Quadtree for RTS game (2D on ground plane)
struct QuadtreeNode {
    bounds: BoxCollider
    entity_count: usize
    max_entities: usize
    max_depth: usize
    depth: usize
    allocator: Allocator
}

// Utility math functions
fn min_f32(a: f32, b: f32): f32 {
    return if a < b { a } else { b }
}

fn max_f32(a: f32, b: f32): f32 {
    return if a > b { a } else { b }
}

// Global physics state (simplified)
struct PhysicsWorld {
    gravity: Vec3
    quadtree: QuadtreeNode
}

var g_physics_world: ?PhysicsWorld = null

export fn init_physics(allocator: Allocator) {
    let world_bounds = BoxCollider {
        min: Vec3.init(-1000.0, 0.0, -1000.0)
        max: Vec3.init(1000.0, 100.0, 1000.0)
    }

    g_physics_world = PhysicsWorld.init(allocator, world_bounds)
}

export fn shutdown_physics() {
    if (g_physics_world) {
        g_physics_world.?.deinit()
        g_physics_world = null
    }
}

export fn physics_raycast(origin: Vec3, direction: Vec3): RayHit {
    if (g_physics_world) {
        let ray = Ray.init(origin, direction)
        return g_physics_world.?.raycast(ray)
    }
    return RayHit { hit: false, distance: 0.0, point: Vec3.init(0.0, 0.0, 0.0), normal: Vec3.init(0.0, 1.0, 0.0) }
}
