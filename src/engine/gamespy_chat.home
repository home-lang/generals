// GameSpy Chat - Chat system for online multiplayer
// Handles channels, messages, user presence, and chat moderation

// ============================================================================
// Configuration
// ============================================================================

struct GameSpyChatConfig {
    server_address: string = "chat.gamespy.com",
    server_port: u16 = 6667,                  // IRC-like protocol
    reconnect_delay: f32 = 5.0,
    heartbeat_interval: f32 = 30.0,
    max_channels: i32 = 10,
    max_users_per_channel: i32 = 256,
    max_message_length: i32 = 512,
    message_rate_limit: f32 = 0.5,            // Min seconds between messages
    nick_max_length: i32 = 32,
    channel_name_max: i32 = 64,
    enable_profanity_filter: bool = true,
    auto_join_lobby: bool = true,
    lobby_channel: string = "#GPG_Generals",
}

// ============================================================================
// Chat States
// ============================================================================

enum ChatConnectionState {
    Disconnected,
    Connecting,
    Authenticating,
    Connected,
    Reconnecting,
    Error,
}

enum ChannelType {
    Lobby,                                    // Main game lobby
    Game,                                     // In-game chat
    Private,                                  // Private messages
    Clan,                                     // Clan/guild chat
    Tournament,                               // Tournament channels
}

enum UserStatus {
    Online,
    Away,
    InGame,
    Idle,
    DoNotDisturb,
    Offline,
}

// ============================================================================
// Chat User
// ============================================================================

struct ChatUser {
    user_id: u64,
    nickname: string,
    profile_id: u64,
    status: UserStatus,
    status_message: string,
    is_operator: bool,
    is_voice: bool,
    is_muted: bool,
    is_banned: bool,
    is_friend: bool,
    is_ignored: bool,
    join_time: f32,
    last_message_time: f32,
    game_info: string,                        // Current game if in-game
}

fn create_chat_user(user_id: u64, nickname: string): ChatUser {
    return ChatUser {
        user_id: user_id,
        nickname: nickname,
        profile_id: 0,
        status: UserStatus.Online,
        status_message: "",
        is_operator: false,
        is_voice: false,
        is_muted: false,
        is_banned: false,
        is_friend: false,
        is_ignored: false,
        join_time: 0.0,
        last_message_time: 0.0,
        game_info: "",
    };
}

// ============================================================================
// Chat Channel
// ============================================================================

struct ChatChannel {
    channel_id: u64,
    name: string,
    topic: string,
    channel_type: ChannelType,
    password: string,
    is_password_protected: bool,
    user_limit: i32,
    users: [u64; 256],                        // User IDs
    user_count: i32,
    operators: [u64; 16],
    operator_count: i32,
    is_moderated: bool,
    is_invite_only: bool,
    created_time: f32,
    last_activity: f32,
}

fn create_chat_channel(channel_id: u64, name: string, channel_type: ChannelType): ChatChannel {
    return ChatChannel {
        channel_id: channel_id,
        name: name,
        topic: "",
        channel_type: channel_type,
        password: "",
        is_password_protected: false,
        user_limit: 256,
        users: [0; 256],
        user_count: 0,
        operators: [0; 16],
        operator_count: 0,
        is_moderated: false,
        is_invite_only: false,
        created_time: 0.0,
        last_activity: 0.0,
    };
}

fn channel_add_user(channel: &mut ChatChannel, user_id: u64): bool {
    if (channel.user_count >= channel.user_limit) {
        return false;
    }

    // Check if already in channel
    for i in 0..channel.user_count {
        if (channel.users[i] == user_id) {
            return false;
        }
    }

    channel.users[channel.user_count] = user_id;
    channel.user_count += 1;
    return true;
}

fn channel_remove_user(channel: &mut ChatChannel, user_id: u64): bool {
    for i in 0..channel.user_count {
        if (channel.users[i] == user_id) {
            // Shift remaining users
            for j in i..(channel.user_count - 1) {
                channel.users[j] = channel.users[j + 1];
            }
            channel.user_count -= 1;
            return true;
        }
    }
    return false;
}

fn channel_has_user(channel: &ChatChannel, user_id: u64): bool {
    for i in 0..channel.user_count {
        if (channel.users[i] == user_id) {
            return true;
        }
    }
    return false;
}

fn channel_is_operator(channel: &ChatChannel, user_id: u64): bool {
    for i in 0..channel.operator_count {
        if (channel.operators[i] == user_id) {
            return true;
        }
    }
    return false;
}

// ============================================================================
// Chat Message
// ============================================================================

enum MessageType {
    Public,                                   // Channel message
    Private,                                  // Direct message
    Action,                                   // /me action
    Notice,                                   // System notice
    Server,                                   // Server message
    Error,                                    // Error message
    Join,                                     // User joined
    Part,                                     // User left
    Kick,                                     // User kicked
    Ban,                                      // User banned
    TopicChange,                              // Topic changed
    ModeChange,                               // Mode changed
}

struct ChatMessage {
    message_id: u64,
    message_type: MessageType,
    sender_id: u64,
    sender_name: string,
    channel_id: u64,
    channel_name: string,
    content: string,
    timestamp: f32,
    is_highlighted: bool,                     // Contains user's nick
    is_filtered: bool,                        // Profanity filtered
}

fn create_chat_message(message_id: u64, sender_id: u64, sender_name: string, content: string): ChatMessage {
    return ChatMessage {
        message_id: message_id,
        message_type: MessageType.Public,
        sender_id: sender_id,
        sender_name: sender_name,
        channel_id: 0,
        channel_name: "",
        content: content,
        timestamp: 0.0,
        is_highlighted: false,
        is_filtered: false,
    };
}

// ============================================================================
// Chat Command
// ============================================================================

enum ChatCommand {
    Join,                                     // /join #channel
    Part,                                     // /part #channel
    Msg,                                      // /msg user message
    Nick,                                     // /nick newnick
    Away,                                     // /away message
    Back,                                     // /back
    Kick,                                     // /kick user reason
    Ban,                                      // /ban user
    Unban,                                    // /unban user
    Op,                                       // /op user
    Deop,                                     // /deop user
    Topic,                                    // /topic new topic
    Mode,                                     // /mode +/-flags
    Invite,                                   // /invite user
    Ignore,                                   // /ignore user
    Unignore,                                 // /unignore user
    Who,                                      // /who #channel
    Whois,                                    // /whois user
    List,                                     // /list
    Quit,                                     // /quit message
}

struct ParsedCommand {
    command: ChatCommand,
    target: string,
    args: string,
    is_valid: bool,
}

fn parse_chat_command(input: string): ParsedCommand {
    let mut result = ParsedCommand {
        command: ChatCommand.Msg,
        target: "",
        args: "",
        is_valid: false,
    };

    if (input.len() == 0 || input.char_at(0) != "/") {
        return result;
    }

    // Find command end (space or end of string)
    let mut cmd_end: i32 = 1;
    while (cmd_end < input.len() as i32 && input.char_at(cmd_end as i32) != " ") {
        cmd_end += 1;
    }

    let cmd_str = input.substring(1, cmd_end);

    // Parse command
    if (cmd_str == "join" || cmd_str == "j") {
        result.command = ChatCommand.Join;
        result.is_valid = true;
    } else if (cmd_str == "part" || cmd_str == "leave") {
        result.command = ChatCommand.Part;
        result.is_valid = true;
    } else if (cmd_str == "msg" || cmd_str == "pm" || cmd_str == "w") {
        result.command = ChatCommand.Msg;
        result.is_valid = true;
    } else if (cmd_str == "nick") {
        result.command = ChatCommand.Nick;
        result.is_valid = true;
    } else if (cmd_str == "away") {
        result.command = ChatCommand.Away;
        result.is_valid = true;
    } else if (cmd_str == "back") {
        result.command = ChatCommand.Back;
        result.is_valid = true;
    } else if (cmd_str == "kick") {
        result.command = ChatCommand.Kick;
        result.is_valid = true;
    } else if (cmd_str == "ban") {
        result.command = ChatCommand.Ban;
        result.is_valid = true;
    } else if (cmd_str == "unban") {
        result.command = ChatCommand.Unban;
        result.is_valid = true;
    } else if (cmd_str == "op") {
        result.command = ChatCommand.Op;
        result.is_valid = true;
    } else if (cmd_str == "deop") {
        result.command = ChatCommand.Deop;
        result.is_valid = true;
    } else if (cmd_str == "topic") {
        result.command = ChatCommand.Topic;
        result.is_valid = true;
    } else if (cmd_str == "invite") {
        result.command = ChatCommand.Invite;
        result.is_valid = true;
    } else if (cmd_str == "ignore") {
        result.command = ChatCommand.Ignore;
        result.is_valid = true;
    } else if (cmd_str == "unignore") {
        result.command = ChatCommand.Unignore;
        result.is_valid = true;
    } else if (cmd_str == "who") {
        result.command = ChatCommand.Who;
        result.is_valid = true;
    } else if (cmd_str == "whois") {
        result.command = ChatCommand.Whois;
        result.is_valid = true;
    } else if (cmd_str == "list") {
        result.command = ChatCommand.List;
        result.is_valid = true;
    } else if (cmd_str == "quit" || cmd_str == "q") {
        result.command = ChatCommand.Quit;
        result.is_valid = true;
    } else if (cmd_str == "me") {
        result.command = ChatCommand.Msg;  // Action
        result.is_valid = true;
    }

    // Parse target and args
    if (cmd_end < input.len() as i32) {
        let remaining = input.substring(cmd_end + 1, input.len() as i32);
        // First word is target, rest is args
        let mut target_end: i32 = 0;
        while (target_end < remaining.len() as i32 && remaining.char_at(target_end as i32) != " ") {
            target_end += 1;
        }
        result.target = remaining.substring(0, target_end);
        if (target_end < remaining.len() as i32) {
            result.args = remaining.substring(target_end + 1, remaining.len() as i32);
        }
    }

    return result;
}

// ============================================================================
// GameSpy Chat Manager
// ============================================================================

struct GameSpyChatManager {
    config: GameSpyChatConfig,
    state: ChatConnectionState,

    // Local user
    local_user_id: u64,
    local_nickname: string,
    local_profile_id: u64,
    auth_token: string,

    // Users
    users: HashMap<u64, ChatUser>,
    users_by_nick: HashMap<string, u64>,

    // Channels
    channels: HashMap<u64, ChatChannel>,
    channels_by_name: HashMap<string, u64>,
    joined_channels: [u64; 10],
    joined_channel_count: i32,
    active_channel_id: u64,

    // Messages
    message_history: [ChatMessage; 1000],
    message_count: i32,
    next_message_id: u64,

    // Friends and ignore lists
    friends: [u64; 100],
    friend_count: i32,
    ignored: [u64; 100],
    ignored_count: i32,

    // Rate limiting
    last_message_time: f32,
    current_time: f32,

    // Connection
    next_user_id: u64,
    next_channel_id: u64,
    reconnect_timer: f32,
    heartbeat_timer: f32,

    // Callbacks
    on_connected: fn() = null,
    on_disconnected: fn(string) = null,
    on_message_received: fn(&ChatMessage) = null,
    on_user_joined: fn(u64, u64) = null,      // channel_id, user_id
    on_user_left: fn(u64, u64) = null,
    on_channel_list: fn(&[ChatChannel]) = null,
    on_error: fn(string) = null,
}

fn create_gamespy_chat_manager(config: GameSpyChatConfig): GameSpyChatManager {
    return GameSpyChatManager {
        config: config,
        state: ChatConnectionState.Disconnected,
        local_user_id: 0,
        local_nickname: "",
        local_profile_id: 0,
        auth_token: "",
        users: HashMap<u64, ChatUser>.new(),
        users_by_nick: HashMap<string, u64>.new(),
        channels: HashMap<u64, ChatChannel>.new(),
        channels_by_name: HashMap<string, u64>.new(),
        joined_channels: [0; 10],
        joined_channel_count: 0,
        active_channel_id: 0,
        message_history: [create_chat_message(0, 0, "", ""); 1000],
        message_count: 0,
        next_message_id: 1,
        friends: [0; 100],
        friend_count: 0,
        ignored: [0; 100],
        ignored_count: 0,
        last_message_time: 0.0,
        current_time: 0.0,
        next_user_id: 1,
        next_channel_id: 1,
        reconnect_timer: 0.0,
        heartbeat_timer: 0.0,
    };
}

// ============================================================================
// Connection Management
// ============================================================================

fn connect(manager: &mut GameSpyChatManager, nickname: string, profile_id: u64, auth_token: string): bool {
    if (manager.state != ChatConnectionState.Disconnected) {
        return false;
    }

    manager.local_nickname = nickname;
    manager.local_profile_id = profile_id;
    manager.auth_token = auth_token;
    manager.state = ChatConnectionState.Connecting;

    // Create local user
    manager.local_user_id = manager.next_user_id;
    manager.next_user_id += 1;

    let local_user = create_chat_user(manager.local_user_id, nickname);
    manager.users.insert(manager.local_user_id, local_user);
    manager.users_by_nick.insert(nickname, manager.local_user_id);

    // Simulate connection success
    manager.state = ChatConnectionState.Connected;

    // Auto-join lobby if configured
    if (manager.config.auto_join_lobby) {
        join_channel(manager, manager.config.lobby_channel, "");
    }

    if (manager.on_connected != null) {
        manager.on_connected();
    }

    return true;
}

fn disconnect(manager: &mut GameSpyChatManager, reason: string) {
    if (manager.state == ChatConnectionState.Disconnected) {
        return;
    }

    // Leave all channels
    while (manager.joined_channel_count > 0) {
        leave_channel(manager, manager.joined_channels[0]);
    }

    manager.state = ChatConnectionState.Disconnected;

    if (manager.on_disconnected != null) {
        manager.on_disconnected(reason);
    }
}

fn reconnect(manager: &mut GameSpyChatManager) {
    if (manager.state != ChatConnectionState.Disconnected) {
        disconnect(manager, "Reconnecting");
    }

    manager.state = ChatConnectionState.Reconnecting;
    manager.reconnect_timer = manager.config.reconnect_delay;
}

// ============================================================================
// Channel Operations
// ============================================================================

fn join_channel(manager: &mut GameSpyChatManager, channel_name: string, password: string): bool {
    if (manager.state != ChatConnectionState.Connected) {
        return false;
    }

    if (manager.joined_channel_count >= manager.config.max_channels) {
        return false;
    }

    // Check if already joined
    let existing_id = manager.channels_by_name.get(channel_name);
    if (existing_id != null) {
        for i in 0..manager.joined_channel_count {
            if (manager.joined_channels[i] == *existing_id) {
                return false;  // Already in channel
            }
        }
    }

    // Create or get channel
    let channel_id = if existing_id != null {
        *existing_id
    } else {
        let new_id = manager.next_channel_id;
        manager.next_channel_id += 1;

        let channel_type = if channel_name.starts_with("#GPG_") {
            ChannelType.Lobby
        } else if (channel_name.starts_with("#game_")) {
            ChannelType.Game
        } else {
            ChannelType.Private
        };

        let mut channel = create_chat_channel(new_id, channel_name, channel_type);
        channel.created_time = manager.current_time;

        manager.channels.insert(new_id, channel);
        manager.channels_by_name.insert(channel_name, new_id);

        new_id
    };

    // Add user to channel
    let channel = manager.channels.get_mut(channel_id);
    if (channel != null) {
        if (channel.is_password_protected && channel.password != password) {
            if (manager.on_error != null) {
                manager.on_error("Incorrect channel password");
            }
            return false;
        }

        channel_add_user(channel, manager.local_user_id);
        channel.last_activity = manager.current_time;
    }

    // Track joined channel
    manager.joined_channels[manager.joined_channel_count] = channel_id;
    manager.joined_channel_count += 1;

    // Set as active if first channel
    if (manager.joined_channel_count == 1) {
        manager.active_channel_id = channel_id;
    }

    // Add system message
    add_system_message(manager, channel_id, MessageType.Join, manager.local_nickname + " has joined the channel");

    return true;
}

fn leave_channel(manager: &mut GameSpyChatManager, channel_id: u64): bool {
    // Find and remove from joined list
    let mut found_idx: i32 = -1;
    for i in 0..manager.joined_channel_count {
        if (manager.joined_channels[i] == channel_id) {
            found_idx = i;
            break;
        }
    }

    if (found_idx < 0) {
        return false;
    }

    // Remove user from channel
    let channel = manager.channels.get_mut(channel_id);
    if (channel != null) {
        channel_remove_user(channel, manager.local_user_id);
        add_system_message(manager, channel_id, MessageType.Part, manager.local_nickname + " has left the channel");
    }

    // Remove from joined list
    for i in found_idx..(manager.joined_channel_count - 1) {
        manager.joined_channels[i] = manager.joined_channels[i + 1];
    }
    manager.joined_channel_count -= 1;

    // Update active channel
    if (manager.active_channel_id == channel_id) {
        if (manager.joined_channel_count > 0) {
            manager.active_channel_id = manager.joined_channels[0];
        } else {
            manager.active_channel_id = 0;
        }
    }

    return true;
}

fn set_active_channel(manager: &mut GameSpyChatManager, channel_id: u64) {
    for i in 0..manager.joined_channel_count {
        if (manager.joined_channels[i] == channel_id) {
            manager.active_channel_id = channel_id;
            return;
        }
    }
}

fn set_channel_topic(manager: &mut GameSpyChatManager, channel_id: u64, topic: string): bool {
    let channel = manager.channels.get_mut(channel_id);
    if (channel == null) {
        return false;
    }

    // Check if user is operator
    if (!channel_is_operator(channel, manager.local_user_id)) {
        if (manager.on_error != null) {
            manager.on_error("You are not a channel operator");
        }
        return false;
    }

    channel.topic = topic;
    add_system_message(manager, channel_id, MessageType.TopicChange, "Topic changed to: " + topic);

    return true;
}

// ============================================================================
// Message Operations
// ============================================================================

fn send_message(manager: &mut GameSpyChatManager, content: string): bool {
    return send_channel_message(manager, manager.active_channel_id, content);
}

fn send_channel_message(manager: &mut GameSpyChatManager, channel_id: u64, content: string): bool {
    if (manager.state != ChatConnectionState.Connected) {
        return false;
    }

    // Rate limiting
    if (manager.current_time - manager.last_message_time < manager.config.message_rate_limit) {
        if (manager.on_error != null) {
            manager.on_error("You are sending messages too quickly");
        }
        return false;
    }

    // Check message length
    if (content.len() > manager.config.max_message_length as i32) {
        if (manager.on_error != null) {
            manager.on_error("Message too long");
        }
        return false;
    }

    // Check if in channel
    let mut in_channel = false;
    for i in 0..manager.joined_channel_count {
        if (manager.joined_channels[i] == channel_id) {
            in_channel = true;
            break;
        }
    }

    if (!in_channel) {
        return false;
    }

    // Check if muted
    let channel = manager.channels.get(channel_id);
    if (channel != null && channel.is_moderated) {
        let user = manager.users.get(manager.local_user_id);
        if (user != null && !user.is_voice && !channel_is_operator(channel, manager.local_user_id)) {
            if (manager.on_error != null) {
                manager.on_error("Channel is moderated");
            }
            return false;
        }
    }

    // Apply profanity filter
    let filtered_content = if manager.config.enable_profanity_filter {
        filter_profanity(content)
    } else {
        content
    };

    // Create message
    let mut message = create_chat_message(manager.next_message_id, manager.local_user_id, manager.local_nickname, filtered_content);
    message.message_type = MessageType.Public;
    message.channel_id = channel_id;
    if (channel != null) {
        message.channel_name = channel.name;
    }
    message.timestamp = manager.current_time;
    message.is_filtered = filtered_content != content;

    manager.next_message_id += 1;
    manager.last_message_time = manager.current_time;

    // Add to history
    add_message_to_history(manager, message);

    // Update channel activity
    let channel_mut = manager.channels.get_mut(channel_id);
    if (channel_mut != null) {
        channel_mut.last_activity = manager.current_time;
    }

    return true;
}

fn send_private_message(manager: &mut GameSpyChatManager, target_nickname: string, content: string): bool {
    if (manager.state != ChatConnectionState.Connected) {
        return false;
    }

    let target_id = manager.users_by_nick.get(target_nickname);
    if (target_id == null) {
        if (manager.on_error != null) {
            manager.on_error("User not found: " + target_nickname);
        }
        return false;
    }

    // Check if ignored
    for i in 0..manager.ignored_count {
        if (manager.ignored[i] == *target_id) {
            if (manager.on_error != null) {
                manager.on_error("You have ignored this user");
            }
            return false;
        }
    }

    let filtered_content = if manager.config.enable_profanity_filter {
        filter_profanity(content)
    } else {
        content
    };

    let mut message = create_chat_message(manager.next_message_id, manager.local_user_id, manager.local_nickname, filtered_content);
    message.message_type = MessageType.Private;
    message.channel_name = target_nickname;
    message.timestamp = manager.current_time;

    manager.next_message_id += 1;
    manager.last_message_time = manager.current_time;

    add_message_to_history(manager, message);

    return true;
}

fn add_system_message(manager: &mut GameSpyChatManager, channel_id: u64, msg_type: MessageType, content: string) {
    let mut message = create_chat_message(manager.next_message_id, 0, "System", content);
    message.message_type = msg_type;
    message.channel_id = channel_id;
    message.timestamp = manager.current_time;

    manager.next_message_id += 1;
    add_message_to_history(manager, message);
}

fn add_message_to_history(manager: &mut GameSpyChatManager, message: ChatMessage) {
    if (manager.message_count >= 1000) {
        // Shift messages
        for i in 0..999 {
            manager.message_history[i] = manager.message_history[i + 1];
        }
        manager.message_count = 999;
    }

    manager.message_history[manager.message_count] = message;
    manager.message_count += 1;

    if (manager.on_message_received != null) {
        manager.on_message_received(&manager.message_history[manager.message_count - 1]);
    }
}

// ============================================================================
// User Operations
// ============================================================================

fn set_status(manager: &mut GameSpyChatManager, status: UserStatus, message: string) {
    let user = manager.users.get_mut(manager.local_user_id);
    if (user != null) {
        user.status = status;
        user.status_message = message;
    }
}

fn add_friend(manager: &mut GameSpyChatManager, user_id: u64): bool {
    if (manager.friend_count >= 100) {
        return false;
    }

    // Check if already friend
    for i in 0..manager.friend_count {
        if (manager.friends[i] == user_id) {
            return false;
        }
    }

    manager.friends[manager.friend_count] = user_id;
    manager.friend_count += 1;

    let user = manager.users.get_mut(user_id);
    if (user != null) {
        user.is_friend = true;
    }

    return true;
}

fn remove_friend(manager: &mut GameSpyChatManager, user_id: u64): bool {
    for i in 0..manager.friend_count {
        if (manager.friends[i] == user_id) {
            for j in i..(manager.friend_count - 1) {
                manager.friends[j] = manager.friends[j + 1];
            }
            manager.friend_count -= 1;

            let user = manager.users.get_mut(user_id);
            if (user != null) {
                user.is_friend = false;
            }

            return true;
        }
    }
    return false;
}

fn ignore_user(manager: &mut GameSpyChatManager, user_id: u64): bool {
    if (manager.ignored_count >= 100) {
        return false;
    }

    for i in 0..manager.ignored_count {
        if (manager.ignored[i] == user_id) {
            return false;
        }
    }

    manager.ignored[manager.ignored_count] = user_id;
    manager.ignored_count += 1;

    let user = manager.users.get_mut(user_id);
    if (user != null) {
        user.is_ignored = true;
    }

    return true;
}

fn unignore_user(manager: &mut GameSpyChatManager, user_id: u64): bool {
    for i in 0..manager.ignored_count {
        if (manager.ignored[i] == user_id) {
            for j in i..(manager.ignored_count - 1) {
                manager.ignored[j] = manager.ignored[j + 1];
            }
            manager.ignored_count -= 1;

            let user = manager.users.get_mut(user_id);
            if (user != null) {
                user.is_ignored = false;
            }

            return true;
        }
    }
    return false;
}

// ============================================================================
// Moderation
// ============================================================================

fn kick_user(manager: &mut GameSpyChatManager, channel_id: u64, user_id: u64, reason: string): bool {
    let channel = manager.channels.get_mut(channel_id);
    if (channel == null) {
        return false;
    }

    if (!channel_is_operator(channel, manager.local_user_id)) {
        if (manager.on_error != null) {
            manager.on_error("You are not a channel operator");
        }
        return false;
    }

    let user = manager.users.get(user_id);
    let user_name = if user != null { user.nickname } else { "Unknown" };

    channel_remove_user(channel, user_id);
    add_system_message(manager, channel_id, MessageType.Kick, user_name + " was kicked: " + reason);

    return true;
}

fn ban_user(manager: &mut GameSpyChatManager, channel_id: u64, user_id: u64): bool {
    let channel = manager.channels.get_mut(channel_id);
    if (channel == null) {
        return false;
    }

    if (!channel_is_operator(channel, manager.local_user_id)) {
        return false;
    }

    let user = manager.users.get_mut(user_id);
    if (user != null) {
        user.is_banned = true;
    }

    channel_remove_user(channel, user_id);

    let user_name = if user != null { user.nickname } else { "Unknown" };
    add_system_message(manager, channel_id, MessageType.Ban, user_name + " was banned");

    return true;
}

fn grant_operator(manager: &mut GameSpyChatManager, channel_id: u64, user_id: u64): bool {
    let channel = manager.channels.get_mut(channel_id);
    if (channel == null) {
        return false;
    }

    if (!channel_is_operator(channel, manager.local_user_id)) {
        return false;
    }

    if (channel.operator_count >= 16) {
        return false;
    }

    channel.operators[channel.operator_count] = user_id;
    channel.operator_count += 1;

    let user = manager.users.get_mut(user_id);
    if (user != null) {
        user.is_operator = true;
    }

    return true;
}

// ============================================================================
// Profanity Filter
// ============================================================================

fn filter_profanity(content: string): string {
    // Simple profanity filter - replace bad words with asterisks
    // In real implementation, would have a proper word list
    let bad_words = ["badword1", "badword2"];  // Placeholder

    let mut filtered = content;
    for word in bad_words {
        // Simple replacement (real impl would use regex)
        filtered = filtered.replace(word, "***");
    }

    return filtered;
}

// ============================================================================
// Update Loop
// ============================================================================

fn update_chat(manager: &mut GameSpyChatManager, delta_time: f32) {
    manager.current_time += delta_time;

    match manager.state {
        ChatConnectionState.Reconnecting => {
            manager.reconnect_timer -= delta_time;
            if (manager.reconnect_timer <= 0.0) {
                // Attempt reconnect
                manager.state = ChatConnectionState.Disconnected;
                connect(manager, manager.local_nickname, manager.local_profile_id, manager.auth_token);
            }
        },
        ChatConnectionState.Connected => {
            // Heartbeat
            manager.heartbeat_timer += delta_time;
            if (manager.heartbeat_timer >= manager.config.heartbeat_interval) {
                manager.heartbeat_timer = 0.0;
                // Send heartbeat packet
            }

            // Update user idle times
            for entry in manager.users.iter_mut() {
                let user = entry.value;
                if (user.user_id == manager.local_user_id) {
                    continue;
                }

                // Auto-set idle status
                let idle_time = manager.current_time - user.last_message_time;
                if (idle_time > 300.0 && user.status == UserStatus.Online) {
                    user.status = UserStatus.Idle;
                }
            }
        },
        _ => {},
    }
}

// ============================================================================
// Tests
// ============================================================================

fn test_gamespy_chat() {
    print("Testing GameSpy Chat...");

    // Create manager
    let config = GameSpyChatConfig {};
    let mut manager = create_gamespy_chat_manager(config);
    print("  Created chat manager");

    // Connect
    connect(&mut manager, "TestPlayer", 12345, "auth_token_123");
    print("  Connected as TestPlayer");

    // Join channel
    join_channel(&mut manager, "#GPG_Generals", "");
    print("  Joined lobby channel");

    // Send message
    send_message(&mut manager, "Hello, world!");
    print("  Sent message");

    // Check message history
    print("  Message count: " + manager.message_count as string);

    // Parse command
    let cmd = parse_chat_command("/join #test");
    print("  Parsed command: valid=" + cmd.is_valid as string + " target=" + cmd.target);

    // Set status
    set_status(&mut manager, UserStatus.Away, "BRB");
    print("  Set status to Away");

    // Update
    update_chat(&mut manager, 0.016);

    // Disconnect
    disconnect(&mut manager, "Test complete");
    print("  Disconnected");

    print("GameSpy Chat tests complete!");
}
