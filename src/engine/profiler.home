// C&C Generals Zero Hour - Home Port
// Performance Profiling System
//
// Original: PerfTimer.h/PerfGather (EA Games)
// Ported to Home with EA's hierarchical profiling system
//
// EA's profiling architecture:
// - High-precision timing using CPU cycle counter (RDTSC)
// - Hierarchical profiling (parent timers subtract child timer time)
// - Gross time vs Net time tracking
// - Call count statistics
// - Frame-by-frame data collection
// - Export to CSV for analysis
//
// Usage:
// ```
// const PROF_UPDATE_LOGIC = ProfileScope.init("UpdateLogic")
//
// fn update_game_logic(delta_time: f32) {
//     let _prof = PROF_UPDATE_LOGIC.start()  // Auto-stops on scope exit
//     // ... game logic ...
// }
// ```

import basics/allocator
import basics/string
import basics/time

const MAX_PROFILE_SCOPES: u32 = 512
const MAX_PROFILE_HISTORY_FRAMES: u32 = 300  // 5 seconds at 60 FPS

// High-precision timer using monotonic clock
struct PrecisionTimer {
    start_time_ns: i64
}

// Profile scope data (one per named profiling region)
struct ProfileScope {
    name: string
    start_time_ns: i64
    gross_time_ns: i64  // Total time including child scopes
    net_time_ns: i64    // Time excluding child scopes
    call_count: u32
    history_index: u32
    history_count: u32
    parent_scope_id: i32  // -1 if no parent
}

// RAII scope guard for automatic profiler stop
struct AutoProfileScope {
}

// Frame statistics
struct FrameStats {
    frame_number: u32
    frame_time_ms: f32
    fps: f32
    logic_time_ms: f32
    render_time_ms: f32
    audio_time_ms: f32
    entity_count: u32
    draw_calls: u32
    triangles: u32
    memory_used_mb: f32
    memory_peak_mb: f32
}

// Global profiler manager
struct Profiler {
    scope_count: u32
    scope_stack_depth: u32
    frame_number: u32
    frame_timer: PrecisionTimer
    frame_stats_index: u32
    frame_stats_count: u32
    show_profiler: bool
    show_graph: bool
    allocator: Allocator
}

// Global profiler instance
var g_profiler: ?Profiler = null

export fn init_profiler(allocator: Allocator) {
    g_profiler = Profiler.init(allocator)
    println("Profiler: Initialized")
}

export fn shutdown_profiler() {
    g_profiler = null
    println("Profiler: Shutdown")
}

fn get_profiler(): *Profiler {
    // TODO: Return reference to global profiler
    // For now, this is a placeholder
    return &g_profiler.?
}

export fn profiler_end_frame() {
    if (!g_profiler) {
        return
    }

    g_profiler.?.end_frame()
}

export fn profiler_print_stats() {
    if (!g_profiler) {
        return
    }

    g_profiler.?.print_stats()
}

export fn profiler_reset() {
    if (!g_profiler) {
        return
    }

    g_profiler.?.reset()
}

export fn profiler_toggle_display() {
    if (!g_profiler) {
        return
    }

    g_profiler.?.show_profiler = !g_profiler.?.show_profiler
}

export fn profiler_export_csv(filepath: string): bool {
    if (!g_profiler) {
        return false
    }

    return g_profiler.?.export_to_csv(filepath)
}

// Platform-specific high-precision timer
fn get_time_nanoseconds(): i64 {
    // TODO: Use platform-specific monotonic clock
    // On Windows: QueryPerformanceCounter
    // On macOS/Linux: clock_gettime(CLOCK_MONOTONIC)
    // On x86: __rdtsc() (CPU cycle counter)

    // Placeholder - return current time in nanoseconds
    return 0
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
