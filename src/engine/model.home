// Model and mesh system for C&C Generals Zero Hour
// Loads and manages 3D models from W3D files
// Written in Home language

import renderer

// Model definition from W3D
struct Model {
    name: string,
    meshes: Vec<renderer::Mesh>,
    animations: Vec<Animation>,
    skeleton: Skeleton?,
    bounds_min: Vec3,
    bounds_max: Vec3,
}

// Animation data
struct Animation {
    name: string,
    duration: f64,
    frame_count: i32,
    fps: f64,
    is_looping: bool,
}

// Skeleton for animated models
struct Skeleton {
    bones: Vec<Bone>,
    root_bone_index: i32,
}

// Bone in skeleton
struct Bone {
    name: string,
    parent_index: i32,
    position: Vec3,
    rotation: Quat,
    scale: Vec3,
}

// Quaternion for rotations
struct Quat {
    x: f64,
    y: f64,
    z: f64,
    w: f64,
}

// Animation state for playing
struct AnimationState {
    animation: Animation,
    current_time: f64,
    is_playing: bool,
    playback_speed: f64,
}

// Model library - manages all loaded models
struct ModelLibrary {
    models: Vec<Model>,
    model_names: Vec<string>,
}

// LOD (Level of Detail) system
struct LODModel {
    lod_levels: Vec<Model>,
    lod_distances: Vec<f64>,
}

// Vec3 helpers
struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

// Helper functions
fn min(a: i32, b: i32): i32 {
    if (a < b) { return a } else { return b }
}

fn min_float(a: f64, b: f64): f64 {
    if (a < b) { return a } else { return b }
}

fn max_float(a: f64, b: f64): f64 {
    if (a > b) { return a } else { return b }
}

// Tests
test "Model: init and add meshes" {
    let model = Model::init("avCrusader")

    assert model.name == "avCrusader"
    assert model.get_mesh_count() == 0

    let material = renderer::Material::init("crusader_diffuse.tga")
    let mesh = renderer::Mesh::init(500, 1500, material)

    model.add_mesh(mesh)
    assert model.get_mesh_count() == 1
}

test "Model: bounds update" {
    let model = Model::init("test")

    let material = renderer::Material::init("test.tga")
    let mesh1 = renderer::Mesh::init(100, 300, material)
    mesh1.bounds_min = Vec3::init(-10.0, -5.0, -10.0)
    mesh1.bounds_max = Vec3::init(10.0, 5.0, 10.0)

    model.add_mesh(mesh1)
    assert model.bounds_min.x == -10.0
    assert model.bounds_max.x == 10.0

    let mesh2 = renderer::Mesh::init(100, 300, material)
    mesh2.bounds_min = Vec3::init(-20.0, -5.0, -10.0)
    mesh2.bounds_max = Vec3::init(5.0, 10.0, 10.0)

    model.add_mesh(mesh2)
    assert model.bounds_min.x == -20.0
    assert model.bounds_max.y == 10.0
}

test "Animation: init and frame calculation" {
    let anim = Animation::init("idle", 30, 30.0)

    assert anim.name == "idle"
    assert anim.frame_count == 30
    assert anim.duration == 1.0

    assert anim.get_frame_at_time(0.0) == 0
    assert anim.get_frame_at_time(0.5) == 15
}

test "Animation: looping" {
    let anim = Animation::init("run", 24, 24.0)
    anim.is_looping = true

    // At 1.5 seconds, should loop back
    let frame = anim.get_frame_at_time(1.5)
    assert frame == 12
}

test "Skeleton: add and get bones" {
    let skeleton = Skeleton::init()

    let root = Bone::init("root", -1)
    let child = Bone::init("spine", 0)

    let root_index = skeleton.add_bone(root)
    let child_index = skeleton.add_bone(child)

    assert root_index == 0
    assert child_index == 1

    let retrieved = skeleton.get_bone(0)?
    assert retrieved.name == "root"
    assert !retrieved.has_parent()

    let child_bone = skeleton.get_bone(1)?
    assert child_bone.has_parent()
}

test "Skeleton: find bone by name" {
    let skeleton = Skeleton::init()

    skeleton.add_bone(Bone::init("root", -1))
    skeleton.add_bone(Bone::init("spine", 0))
    skeleton.add_bone(Bone::init("head", 1))

    let found = skeleton.get_bone_by_name("head")?
    assert found.name == "head"
    assert found.parent_index == 1
}

test "Bone: init" {
    let bone = Bone::init("test_bone", 5)

    assert bone.name == "test_bone"
    assert bone.parent_index == 5
    assert bone.has_parent()
    assert bone.scale.x == 1.0
}

test "Quat: identity" {
    let q = Quat::identity()

    assert q.x == 0.0
    assert q.y == 0.0
    assert q.z == 0.0
    assert q.w == 1.0
}

test "AnimationState: playback" {
    let anim = Animation::init("walk", 30, 30.0)
    let state = AnimationState::init(anim)

    assert !state.is_playing
    assert state.current_time == 0.0

    state.play()
    assert state.is_playing

    state.update(0.5)
    assert state.current_time == 0.5
    assert state.get_progress() == 0.5

    state.pause()
    assert !state.is_playing

    state.update(0.5)
    assert state.current_time == 0.5  // Should not advance when paused
}

test "AnimationState: looping" {
    let anim = Animation::init("idle", 30, 30.0)
    anim.is_looping = true

    let state = AnimationState::init(anim)
    state.play()

    state.update(1.5)
    assert state.current_time < 1.0  // Should have looped
}

test "AnimationState: non-looping stops" {
    let anim = Animation::init("die", 20, 20.0)
    anim.is_looping = false

    let state = AnimationState::init(anim)
    state.play()

    state.update(2.0)
    assert !state.is_playing  // Should auto-stop
    assert state.current_time == anim.duration
}

test "AnimationState: playback speed" {
    let anim = Animation::init("run", 30, 30.0)
    let state = AnimationState::init(anim)

    state.playback_speed = 2.0
    state.play()

    state.update(0.5)
    assert state.current_time == 1.0  // 2x speed
}

test "ModelLibrary: load and find models" {
    let library = ModelLibrary::init()

    assert library.get_model_count() == 0

    let index1 = library.load_model("avCrusader")
    let index2 = library.load_model("avHumvee")

    assert library.get_model_count() == 2

    let model = library.get_model(index1)?
    assert model.name == "avCrusader"

    let found = library.find_model("avHumvee")?
    assert found.name == "avHumvee"
}

test "LODModel: add levels" {
    let lod_model = LODModel::init()

    let high = Model::init("tank_high")
    let medium = Model::init("tank_medium")
    let low = Model::init("tank_low")

    lod_model.add_lod(high, 100.0)
    lod_model.add_lod(medium, 300.0)
    lod_model.add_lod(low, 1000.0)

    assert lod_model.get_lod_count() == 3
}

test "LODModel: distance selection" {
    let lod_model = LODModel::init()

    let high = Model::init("tank_high")
    let medium = Model::init("tank_medium")
    let low = Model::init("tank_low")

    lod_model.add_lod(high, 100.0)
    lod_model.add_lod(medium, 300.0)
    lod_model.add_lod(low, 1000.0)

    let close = lod_model.get_lod_for_distance(50.0)?
    assert close.name == "tank_high"

    let mid = lod_model.get_lod_for_distance(200.0)?
    assert mid.name == "tank_medium"

    let far = lod_model.get_lod_for_distance(800.0)?
    assert far.name == "tank_low"

    let very_far = lod_model.get_lod_for_distance(5000.0)?
    assert very_far.name == "tank_low"  // Use lowest detail
}

test "Vec3: min and max" {
    let a = Vec3::init(1.0, 5.0, 3.0)
    let b = Vec3::init(3.0, 2.0, 4.0)

    let min_vec = Vec3::min(a, b)
    assert min_vec.x == 1.0
    assert min_vec.y == 2.0
    assert min_vec.z == 3.0

    let max_vec = Vec3::max(a, b)
    assert max_vec.x == 3.0
    assert max_vec.y == 5.0
    assert max_vec.z == 4.0
}
