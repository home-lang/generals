// Model and mesh system for C&C Generals Zero Hour
// Loads and manages 3D models from W3D files
// Written in Home language

import renderer

// Model definition from W3D
struct Model {
    name: string,
    meshes: Vec<renderer::Mesh>,
    animations: Vec<Animation>,
    skeleton: Skeleton?,
    bounds_min: Vec3,
    bounds_max: Vec3,

    fn init(name: string): Model {
        return Model {
            name: name,
            meshes: Vec::new(),
            animations: Vec::new(),
            skeleton: null,
            bounds_min: Vec3::init(0.0, 0.0, 0.0),
            bounds_max: Vec3::init(0.0, 0.0, 0.0),
        }
    }

    fn add_mesh(&self, mesh: renderer::Mesh) {
        self.meshes.add(mesh)
        self.update_bounds(mesh)
    }

    fn update_bounds(&self, mesh: renderer::Mesh) {
        if self.meshes.count() == 1 {
            self.bounds_min = mesh.bounds_min
            self.bounds_max = mesh.bounds_max
        } else {
            self.bounds_min = Vec3::min(self.bounds_min, mesh.bounds_min)
            self.bounds_max = Vec3::max(self.bounds_max, mesh.bounds_max)
        }
    }

    fn get_mesh_count(&self): i32 {
        return self.meshes.count()
    }

    fn get_animation(&self, name: string): Animation? {
        for anim in self.animations {
            if anim.name == name {
                return anim
            }
        }
        return null
    }
}

// Animation data
struct Animation {
    name: string,
    duration: f64,
    frame_count: i32,
    fps: f64,
    is_looping: bool,

    fn init(name: string, frame_count: i32, fps: f64): Animation {
        return Animation {
            name: name,
            duration: frame_count as Float / fps,
            frame_count: frame_count,
            fps: fps,
            is_looping: true,
        }
    }

    fn get_frame_at_time(&self, time: f64): i32 {
        let frame_time = time * self.fps

        if self.is_looping {
            let frame = (frame_time as Int) % self.frame_count
            return frame
        } else {
            let frame = min(frame_time as Int, self.frame_count - 1)
            return frame
        }
    }
}

// Skeleton for animated models
struct Skeleton {
    bones: Vec<Bone>,
    root_bone_index: i32,

    fn init(): Skeleton {
        return Skeleton {
            bones: Vec::new(),
            root_bone_index: 0,
        }
    }

    fn add_bone(&self, bone: Bone): i32 {
        let index = self.bones.count()
        self.bones.add(bone)
        return index
    }

    fn get_bone(&self, index: i32): Bone? {
        if index >= 0 && index < self.bones.count() {
            return self.bones.get(index)
        }
        return null
    }

    fn get_bone_by_name(&self, name: string): Bone? {
        for bone in self.bones {
            if bone.name == name {
                return bone
            }
        }
        return null
    }
}

// Bone in skeleton
struct Bone {
    name: string,
    parent_index: i32,
    position: Vec3,
    rotation: Quat,
    scale: Vec3,

    fn init(name: string, parent_index: i32): Bone {
        return Bone {
            name: name,
            parent_index: parent_index,
            position: Vec3::init(0.0, 0.0, 0.0),
            rotation: Quat::identity(),
            scale: Vec3::init(1.0, 1.0, 1.0),
        }
    }

    fn has_parent(&self): bool {
        return self.parent_index >= 0
    }
}

// Quaternion for rotations
struct Quat {
    x: f64,
    y: f64,
    z: f64,
    w: f64,

    fn init(x: f64, y: f64, z: f64, w: f64): Quat {
        return Quat { x: x, y: y, z: z, w: w }
    }

    fn identity(): Quat {
        return Quat::init(0.0, 0.0, 0.0, 1.0)
    }
}

// Animation state for playing
struct AnimationState {
    animation: Animation,
    current_time: f64,
    is_playing: bool,
    playback_speed: f64,

    fn init(animation: Animation): AnimationState {
        return AnimationState {
            animation: animation,
            current_time: 0.0,
            is_playing: false,
            playback_speed: 1.0,
        }
    }

    fn play(&self) {
        self.is_playing = true
    }

    fn pause(&self) {
        self.is_playing = false
    }

    fn stop(&self) {
        self.is_playing = false
        self.current_time = 0.0
    }

    fn update(&self, delta_time: f64) {
        if !self.is_playing {
            return
        }

        self.current_time = self.current_time + (delta_time * self.playback_speed)

        if self.animation.is_looping {
            if self.current_time >= self.animation.duration {
                self.current_time = self.current_time - self.animation.duration
            }
        } else {
            if self.current_time >= self.animation.duration {
                self.current_time = self.animation.duration
                self.is_playing = false
            }
        }
    }

    fn get_current_frame(&self): i32 {
        return self.animation.get_frame_at_time(self.current_time)
    }

    fn get_progress(&self): f64 {
        return self.current_time / self.animation.duration
    }
}

// Model library - manages all loaded models
struct ModelLibrary {
    models: Vec<Model>,
    model_names: Vec<string>,

    fn init(): ModelLibrary {
        return ModelLibrary {
            models: Vec::new(),
            model_names: Vec::new(),
        }
    }

    fn load_model(&self, name: string): i32 {
        // TODO: Actually load W3D file
        let model = Model::init(name)
        let index = self.models.count()
        self.models.add(model)
        self.model_names.add(name)
        return index
    }

    fn get_model(&self, index: i32): Model? {
        if index >= 0 && index < self.models.count() {
            return self.models.get(index)
        }
        return null
    }

    fn find_model(&self, name: string): Model? {
        for i in 0..self.model_names.count() {
            if self.model_names.get(i) == name {
                return self.models.get(i)
            }
        }
        return null
    }

    fn get_model_count(&self): i32 {
        return self.models.count()
    }
}

// LOD (Level of Detail) system
struct LODModel {
    lod_levels: Vec<Model>,
    lod_distances: Vec<f64>,

    fn init(): LODModel {
        return LODModel {
            lod_levels: Vec::new(),
            lod_distances: Vec::new(),
        }
    }

    fn add_lod(&self, model: Model, distance: f64) {
        self.lod_levels.add(model)
        self.lod_distances.add(distance)
    }

    fn get_lod_for_distance(&self, distance: f64): Model? {
        for i in 0..self.lod_distances.count() {
            if distance <= self.lod_distances.get(i) {
                return self.lod_levels.get(i)
            }
        }

        // Return lowest detail if beyond all distances
        if self.lod_levels.count() > 0 {
            return self.lod_levels.get(self.lod_levels.count() - 1)
        }

        return null
    }

    fn get_lod_count(&self): i32 {
        return self.lod_levels.count()
    }
}

// Vec3 helpers
struct Vec3 {
    x: f64,
    y: f64,
    z: f64,

    fn init(x: f64, y: f64, z: f64): Vec3 {
        return Vec3 { x: x, y: y, z: z }
    }

    fn min(a: Vec3, b: Vec3): Vec3 {
        return Vec3::init(
            min_float(a.x, b.x),
            min_float(a.y, b.y),
            min_float(a.z, b.z)
        )
    }

    fn max(a: Vec3, b: Vec3): Vec3 {
        return Vec3::init(
            max_float(a.x, b.x),
            max_float(a.y, b.y),
            max_float(a.z, b.z)
        )
    }
}

// Helper functions
fn min(a: i32, b: i32): i32 {
    if a < b { return a } else { return b }
}

fn min_float(a: f64, b: f64): f64 {
    if a < b { return a } else { return b }
}

fn max_float(a: f64, b: f64): f64 {
    if a > b { return a } else { return b }
}

// Tests
test "Model: init and add meshes" {
    let model = Model::init("avCrusader")

    assert model.name == "avCrusader"
    assert model.get_mesh_count() == 0

    let material = renderer::Material::init("crusader_diffuse.tga")
    let mesh = renderer::Mesh::init(500, 1500, material)

    model.add_mesh(mesh)
    assert model.get_mesh_count() == 1
}

test "Model: bounds update" {
    let model = Model::init("test")

    let material = renderer::Material::init("test.tga")
    let mesh1 = renderer::Mesh::init(100, 300, material)
    mesh1.bounds_min = Vec3::init(-10.0, -5.0, -10.0)
    mesh1.bounds_max = Vec3::init(10.0, 5.0, 10.0)

    model.add_mesh(mesh1)
    assert model.bounds_min.x == -10.0
    assert model.bounds_max.x == 10.0

    let mesh2 = renderer::Mesh::init(100, 300, material)
    mesh2.bounds_min = Vec3::init(-20.0, -5.0, -10.0)
    mesh2.bounds_max = Vec3::init(5.0, 10.0, 10.0)

    model.add_mesh(mesh2)
    assert model.bounds_min.x == -20.0
    assert model.bounds_max.y == 10.0
}

test "Animation: init and frame calculation" {
    let anim = Animation::init("idle", 30, 30.0)

    assert anim.name == "idle"
    assert anim.frame_count == 30
    assert anim.duration == 1.0

    assert anim.get_frame_at_time(0.0) == 0
    assert anim.get_frame_at_time(0.5) == 15
}

test "Animation: looping" {
    let anim = Animation::init("run", 24, 24.0)
    anim.is_looping = true

    // At 1.5 seconds, should loop back
    let frame = anim.get_frame_at_time(1.5)
    assert frame == 12
}

test "Skeleton: add and get bones" {
    let skeleton = Skeleton::init()

    let root = Bone::init("root", -1)
    let child = Bone::init("spine", 0)

    let root_index = skeleton.add_bone(root)
    let child_index = skeleton.add_bone(child)

    assert root_index == 0
    assert child_index == 1

    let retrieved = skeleton.get_bone(0)?
    assert retrieved.name == "root"
    assert !retrieved.has_parent()

    let child_bone = skeleton.get_bone(1)?
    assert child_bone.has_parent()
}

test "Skeleton: find bone by name" {
    let skeleton = Skeleton::init()

    skeleton.add_bone(Bone::init("root", -1))
    skeleton.add_bone(Bone::init("spine", 0))
    skeleton.add_bone(Bone::init("head", 1))

    let found = skeleton.get_bone_by_name("head")?
    assert found.name == "head"
    assert found.parent_index == 1
}

test "Bone: init" {
    let bone = Bone::init("test_bone", 5)

    assert bone.name == "test_bone"
    assert bone.parent_index == 5
    assert bone.has_parent()
    assert bone.scale.x == 1.0
}

test "Quat: identity" {
    let q = Quat::identity()

    assert q.x == 0.0
    assert q.y == 0.0
    assert q.z == 0.0
    assert q.w == 1.0
}

test "AnimationState: playback" {
    let anim = Animation::init("walk", 30, 30.0)
    let state = AnimationState::init(anim)

    assert !state.is_playing
    assert state.current_time == 0.0

    state.play()
    assert state.is_playing

    state.update(0.5)
    assert state.current_time == 0.5
    assert state.get_progress() == 0.5

    state.pause()
    assert !state.is_playing

    state.update(0.5)
    assert state.current_time == 0.5  // Should not advance when paused
}

test "AnimationState: looping" {
    let anim = Animation::init("idle", 30, 30.0)
    anim.is_looping = true

    let state = AnimationState::init(anim)
    state.play()

    state.update(1.5)
    assert state.current_time < 1.0  // Should have looped
}

test "AnimationState: non-looping stops" {
    let anim = Animation::init("die", 20, 20.0)
    anim.is_looping = false

    let state = AnimationState::init(anim)
    state.play()

    state.update(2.0)
    assert !state.is_playing  // Should auto-stop
    assert state.current_time == anim.duration
}

test "AnimationState: playback speed" {
    let anim = Animation::init("run", 30, 30.0)
    let state = AnimationState::init(anim)

    state.playback_speed = 2.0
    state.play()

    state.update(0.5)
    assert state.current_time == 1.0  // 2x speed
}

test "ModelLibrary: load and find models" {
    let library = ModelLibrary::init()

    assert library.get_model_count() == 0

    let index1 = library.load_model("avCrusader")
    let index2 = library.load_model("avHumvee")

    assert library.get_model_count() == 2

    let model = library.get_model(index1)?
    assert model.name == "avCrusader"

    let found = library.find_model("avHumvee")?
    assert found.name == "avHumvee"
}

test "LODModel: add levels" {
    let lod_model = LODModel::init()

    let high = Model::init("tank_high")
    let medium = Model::init("tank_medium")
    let low = Model::init("tank_low")

    lod_model.add_lod(high, 100.0)
    lod_model.add_lod(medium, 300.0)
    lod_model.add_lod(low, 1000.0)

    assert lod_model.get_lod_count() == 3
}

test "LODModel: distance selection" {
    let lod_model = LODModel::init()

    let high = Model::init("tank_high")
    let medium = Model::init("tank_medium")
    let low = Model::init("tank_low")

    lod_model.add_lod(high, 100.0)
    lod_model.add_lod(medium, 300.0)
    lod_model.add_lod(low, 1000.0)

    let close = lod_model.get_lod_for_distance(50.0)?
    assert close.name == "tank_high"

    let mid = lod_model.get_lod_for_distance(200.0)?
    assert mid.name == "tank_medium"

    let far = lod_model.get_lod_for_distance(800.0)?
    assert far.name == "tank_low"

    let very_far = lod_model.get_lod_for_distance(5000.0)?
    assert very_far.name == "tank_low"  // Use lowest detail
}

test "Vec3: min and max" {
    let a = Vec3::init(1.0, 5.0, 3.0)
    let b = Vec3::init(3.0, 2.0, 4.0)

    let min_vec = Vec3::min(a, b)
    assert min_vec.x == 1.0
    assert min_vec.y == 2.0
    assert min_vec.z == 3.0

    let max_vec = Vec3::max(a, b)
    assert max_vec.x == 3.0
    assert max_vec.y == 5.0
    assert max_vec.z == 4.0
}
