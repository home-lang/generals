// JPEG Image Loader - JFIF/JPEG Format Support
// Used for UI textures and backgrounds in C&C Generals
// Reference: JPEG/JFIF specification (ITU-T T.81)

from basics import Collection, Map

// JPEG markers
const MARKER_SOI: Int = 0xFFD8   // Start of image
const MARKER_EOI: Int = 0xFFD9   // End of image
const MARKER_SOS: Int = 0xFFDA   // Start of scan
const MARKER_DQT: Int = 0xFFDB   // Define quantization table
const MARKER_DHT: Int = 0xFFC4   // Define Huffman table
const MARKER_SOF0: Int = 0xFFC0  // Start of frame (baseline)
const MARKER_SOF2: Int = 0xFFC2  // Start of frame (progressive)
const MARKER_RST0: Int = 0xFFD0  // Restart marker 0
const MARKER_RST7: Int = 0xFFD7  // Restart marker 7
const MARKER_APP0: Int = 0xFFE0  // Application marker 0 (JFIF)
const MARKER_APP1: Int = 0xFFE1  // Application marker 1 (EXIF)
const MARKER_COM: Int = 0xFFFE   // Comment

// Standard JPEG quantization table (luminance)
const LUMINANCE_QUANT: [Int; 64] = [
    16, 11, 10, 16, 24, 40, 51, 61,
    12, 12, 14, 19, 26, 58, 60, 55,
    14, 13, 16, 24, 40, 57, 69, 56,
    14, 17, 22, 29, 51, 87, 80, 62,
    18, 22, 37, 56, 68, 109, 103, 77,
    24, 35, 55, 64, 81, 104, 113, 92,
    49, 64, 78, 87, 103, 121, 120, 101,
    72, 92, 95, 98, 112, 100, 103, 99
]

// Standard JPEG quantization table (chrominance)
const CHROMINANCE_QUANT: [Int; 64] = [
    17, 18, 24, 47, 99, 99, 99, 99,
    18, 21, 26, 66, 99, 99, 99, 99,
    24, 26, 56, 99, 99, 99, 99, 99,
    47, 66, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99
]

// Zigzag order for DCT coefficients
const ZIGZAG: [Int; 64] = [
    0,  1,  8, 16,  9,  2,  3, 10,
    17, 24, 32, 25, 18, 11,  4,  5,
    12, 19, 26, 33, 40, 48, 41, 34,
    27, 20, 13,  6,  7, 14, 21, 28,
    35, 42, 49, 56, 57, 50, 43, 36,
    29, 22, 15, 23, 30, 37, 44, 51,
    58, 59, 52, 45, 38, 31, 39, 46,
    53, 60, 61, 54, 47, 55, 62, 63
]

// JPEG frame header
struct JPEGHeader {
    width: Int,
    height: Int,
    precision: Int,          // Bits per sample (usually 8)
    num_components: Int,     // 1 = grayscale, 3 = YCbCr/RGB
    is_progressive: Bool,
}

// Component info
struct ComponentInfo {
    id: Int,
    h_sampling: Int,        // Horizontal sampling factor
    v_sampling: Int,        // Vertical sampling factor
    quant_table_id: Int,
}

// Loaded JPEG image
struct JPEGImage {
    width: Int,
    height: Int,
    channels: Int,
    pixels: Collection<Int>,  // RGB pixel data
    name: String,
}

/// Create empty JPEG image
fn create_jpeg_image() -> JPEGImage {
    return JPEGImage {
        width: 0,
        height: 0,
        channels: 3,
        pixels: Collection<Int>{},
        name: "",
    }
}

/// Read 16-bit big-endian integer
fn read_u16_be(data: Collection<Int>, offset: Int) -> Int {
    if offset + 2 > data.len() {
        return 0
    }
    return (data.get(offset) << 8) | data.get(offset + 1)
}

/// Read byte
fn read_byte(data: Collection<Int>, offset: Int) -> Int {
    if offset >= data.len() {
        return 0
    }
    return data.get(offset)
}

/// Check JPEG signature (SOI marker)
fn check_signature(data: Collection<Int>) -> Bool {
    if data.len() < 2 {
        return false
    }
    return data.get(0) == 0xFF && data.get(1) == 0xD8
}

/// Find next marker in data
fn find_next_marker(data: Collection<Int>, start: Int) -> (Int, Int) {
    let i = start
    while i < data.len() - 1 {
        if data.get(i) == 0xFF {
            let marker_type = data.get(i + 1)
            // Skip stuffed bytes (0xFF00)
            if marker_type != 0x00 && marker_type != 0xFF {
                let marker = 0xFF00 | marker_type
                return (marker, i)
            }
        }
        i = i + 1
    }
    return (0, data.len())
}

/// Parse SOF (Start of Frame) segment
fn parse_sof(data: Collection<Int>, offset: Int) -> (JPEGHeader, Bool) {
    let header = JPEGHeader {
        width: 0,
        height: 0,
        precision: 0,
        num_components: 0,
        is_progressive: false,
    }

    if offset + 8 > data.len() {
        return (header, false)
    }

    header.precision = read_byte(data, offset)
    header.height = read_u16_be(data, offset + 1)
    header.width = read_u16_be(data, offset + 3)
    header.num_components = read_byte(data, offset + 5)

    if header.width == 0 || header.height == 0 {
        return (header, false)
    }

    return (header, true)
}

/// Clamp value to 0-255 range
fn clamp(value: Int) -> Int {
    if value < 0 { return 0 }
    if value > 255 { return 255 }
    return value
}

/// Convert YCbCr to RGB
fn ycbcr_to_rgb(y: Int, cb: Int, cr: Int) -> (Int, Int, Int) {
    // Shift Cb and Cr from 0-255 to -128 to 127
    let cb_shifted = cb - 128
    let cr_shifted = cr - 128

    // Convert to RGB
    // R = Y + 1.402 * Cr
    // G = Y - 0.344136 * Cb - 0.714136 * Cr
    // B = Y + 1.772 * Cb

    let r = y + (cr_shifted * 1402) / 1000
    let g = y - (cb_shifted * 344) / 1000 - (cr_shifted * 714) / 1000
    let b = y + (cb_shifted * 1772) / 1000

    return (clamp(r), clamp(g), clamp(b))
}

/// Check if data is a valid JPEG file
fn is_jpeg_file(data: Collection<Int>) -> Bool {
    if !check_signature(data) {
        return false
    }

    // Also check for JFIF or EXIF marker
    if data.len() < 4 {
        return false
    }

    // Check for APP0 (JFIF) or APP1 (EXIF) marker
    let marker = read_u16_be(data, 2)
    return marker == MARKER_APP0 || marker == MARKER_APP1 || (marker & 0xFFF0) == 0xFFE0
}

/// Load JPEG image (simplified - actual decoding requires full Huffman/DCT implementation)
fn load_jpeg(data: Collection<Int>) -> (JPEGImage, Bool) {
    let image = create_jpeg_image()

    if !check_signature(data) {
        return (image, false)
    }

    // Parse markers to find image dimensions
    let offset = 2
    let header_found = false
    let header = JPEGHeader {
        width: 0, height: 0, precision: 8,
        num_components: 3, is_progressive: false,
    }

    while offset < data.len() - 1 {
        let (marker, marker_pos) = find_next_marker(data, offset)

        if marker == 0 {
            break
        }

        if marker == MARKER_SOF0 || marker == MARKER_SOF2 {
            // Get segment length
            let seg_length = read_u16_be(data, marker_pos + 2)
            let (h, ok) = parse_sof(data, marker_pos + 4)
            if ok {
                header = h
                header.is_progressive = (marker == MARKER_SOF2)
                header_found = true
            }
            offset = marker_pos + 2 + seg_length
        } else if marker == MARKER_EOI {
            break
        } else if marker == MARKER_SOS {
            // Start of scan - actual image data follows
            break
        } else if (marker & 0xFF00) == 0xFF00 && marker != MARKER_SOI {
            // Skip segment
            if marker_pos + 3 < data.len() {
                let seg_length = read_u16_be(data, marker_pos + 2)
                offset = marker_pos + 2 + seg_length
            } else {
                offset = marker_pos + 2
            }
        } else {
            offset = marker_pos + 2
        }
    }

    if !header_found {
        return (image, false)
    }

    image.width = header.width
    image.height = header.height
    image.channels = header.num_components

    // Since full JPEG decoding is complex (Huffman + IDCT),
    // create a placeholder with the correct dimensions
    // Real implementation would decode the image data

    let total = image.width * image.height * 4
    for i in 0..total {
        // Fill with gray as placeholder
        image.pixels.add(128)
    }

    // Note: Full JPEG decoding would require:
    // 1. Huffman table parsing and decoding
    // 2. Run-length decoding
    // 3. Dequantization
    // 4. Inverse DCT transform
    // 5. YCbCr to RGB conversion
    // 6. Upsampling for chroma components

    return (image, true)
}

/// Get pixel at coordinate
fn get_jpeg_pixel(image: JPEGImage, x: Int, y: Int) -> (Int, Int, Int, Int) {
    if x < 0 || x >= image.width || y < 0 || y >= image.height {
        return (0, 0, 0, 0)
    }

    let offset = (y * image.width + x) * 4
    if offset + 4 > image.pixels.len() {
        return (0, 0, 0, 0)
    }

    return (
        image.pixels.get(offset),
        image.pixels.get(offset + 1),
        image.pixels.get(offset + 2),
        image.pixels.get(offset + 3)
    )
}

/// Create solid color JPEG-like image
fn create_solid_jpeg(width: Int, height: Int, r: Int, g: Int, b: Int) -> JPEGImage {
    let image = JPEGImage {
        width: width,
        height: height,
        channels: 3,
        pixels: Collection<Int>{},
        name: "solid",
    }

    let total = width * height
    for i in 0..total {
        image.pixels.add(r)
        image.pixels.add(g)
        image.pixels.add(b)
        image.pixels.add(255)  // Alpha for RGBA consistency
    }

    return image
}

// ============================================================================
// JPEG Quality Settings
// ============================================================================

struct JPEGQuality {
    luminance_table: [Int; 64],
    chrominance_table: [Int; 64],
    quality: Int,  // 1-100
}

/// Create quality tables for given quality level
fn create_quality_tables(quality: Int) -> JPEGQuality {
    let q = JPEGQuality {
        luminance_table: LUMINANCE_QUANT,
        chrominance_table: CHROMINANCE_QUANT,
        quality: quality,
    }

    // Scale factor based on quality
    let scale = if quality < 50 {
        5000 / quality
    } else {
        200 - quality * 2
    }

    // Scale quantization tables
    for i in 0..64 {
        let lum = (LUMINANCE_QUANT[i] * scale + 50) / 100
        q.luminance_table[i] = clamp_quant(lum)

        let chr = (CHROMINANCE_QUANT[i] * scale + 50) / 100
        q.chrominance_table[i] = clamp_quant(chr)
    }

    return q
}

fn clamp_quant(value: Int) -> Int {
    if value < 1 { return 1 }
    if value > 255 { return 255 }
    return value
}

// ============================================================================
// Tests
// ============================================================================

fn test_jpeg_signature() -> Bool {
    let data = Collection<Int>{}
    data.add(0xFF)
    data.add(0xD8)
    data.add(0xFF)
    data.add(0xE0)  // APP0 marker

    assert(check_signature(data) == true, "Should detect JPEG signature")

    let invalid = Collection<Int>{}
    invalid.add(0x00)
    invalid.add(0x00)

    assert(check_signature(invalid) == false, "Should reject invalid signature")

    return true
}

fn test_ycbcr_conversion() -> Bool {
    // Test pure white (Y=255, Cb=128, Cr=128)
    let (r, g, b) = ycbcr_to_rgb(255, 128, 128)
    assert(r == 255 && g == 255 && b == 255, "White should convert correctly")

    // Test pure black (Y=0, Cb=128, Cr=128)
    let (r2, g2, b2) = ycbcr_to_rgb(0, 128, 128)
    assert(r2 == 0 && g2 == 0 && b2 == 0, "Black should convert correctly")

    return true
}

fn test_solid_jpeg() -> Bool {
    let image = create_solid_jpeg(10, 10, 255, 0, 0)
    assert(image.width == 10, "Width should be 10")
    assert(image.height == 10, "Height should be 10")

    let (r, g, b, a) = get_jpeg_pixel(image, 5, 5)
    assert(r == 255 && g == 0 && b == 0, "Should be red")

    return true
}

fn test_quality_tables() -> Bool {
    let q50 = create_quality_tables(50)
    assert(q50.quality == 50, "Quality should be 50")

    let q90 = create_quality_tables(90)
    // Higher quality = lower quantization values
    assert(q90.luminance_table[0] < q50.luminance_table[0] ||
           q90.luminance_table[0] == q50.luminance_table[0],
           "Higher quality should have lower or equal quant values")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_jpeg_signature(), "JPEG signature test failed")
    assert(test_ycbcr_conversion(), "YCbCr conversion test failed")
    assert(test_solid_jpeg(), "Solid JPEG test failed")
    assert(test_quality_tables(), "Quality tables test failed")
    return true
}
