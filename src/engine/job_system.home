// C&C Generals Zero Hour - Home Port
// Job System for Multi-Threading
//
// Original: EA used platform-specific threading (EA's system was single-threaded for logic)
// Enhanced with modern job system for parallel processing
//
// Modern enhancements:
// - Work-stealing job queue
// - Worker thread pool
// - Parallel-for operations
// - Task dependencies
//
// C&C Generals was primarily single-threaded for game logic (determinism for multiplayer),
// but used threads for:
// - Asset loading
// - Audio processing
// - Network I/O
// - Particle updates
//
// This port adds optional multi-threading for:
// - Pathfinding (can run multiple A* searches in parallel)
// - Particle system updates
// - AI behavior tree evaluation
// - Physics/collision detection
// - Asset streaming
//
// Usage:
// ```
// // Initialize with N worker threads
// init_job_system(4)
//
// // Submit jobs
// let job1 = submit_job(|| {
//     update_particles()
// })
//
// let job2 = submit_job(|| {
//     update_pathfinding()
// })
//
// // Wait for completion
// wait_for_job(job1)
// wait_for_job(job2)
// ```

import basics/allocator
import basics/string

const MAX_JOBS: u32 = 4096
const MAX_WORKER_THREADS: u32 = 16

// Job priority
enum JobPriority {
    Low      // Background tasks
    Normal   // General work
    High     // Time-sensitive (pathfinding, AI)
    Critical // Must complete this frame (asset loading)
}

// Job status
enum JobStatus {
    Pending    // Waiting in queue
    Running    // Currently executing
    Completed  // Finished successfully
    Failed     // Error occurred
}

// Job function type
type JobFunction = fn(): void

// Job descriptor
struct Job {
    id: u32
    priority: JobPriority
    status: JobStatus
    work_fn: JobFunction
    dependency_count: u32
    error_message: string
}

// Job queue (lock-free ring buffer)
struct JobQueue {
    head: u32  // Next job to dequeue
    tail: u32  // Next slot to enqueue
    count: u32
}

// Worker thread
struct WorkerThread {
    thread_id: u32
    is_running: bool
    current_job_id: u32
}

// Job system manager
struct JobSystem {
    job_count: u32
    next_job_id: u32
    queue_critical: JobQueue
    queue_high: JobQueue
    queue_normal: JobQueue
    queue_low: JobQueue
    worker_count: u32
    allocator: Allocator
}

struct JobSystemStats {
    total_jobs: u32
    pending_jobs: u32
    running_jobs: u32
    completed_jobs: u32
    failed_jobs: u32
    active_workers: u32
}

// Global job system
var g_job_system: ?JobSystem = null

export fn init_job_system(allocator: Allocator, num_threads: u32) {
    g_job_system = JobSystem.init(allocator, num_threads)
    g_job_system.?.start_workers()

    println("JobSystem: Initialized with {num_threads} threads")
}

export fn shutdown_job_system() {
    if (!g_job_system) {
        return
    }

    g_job_system.?.stop_workers()
    g_job_system = null

    println("JobSystem: Shutdown")
}

export fn submit_job(work: JobFunction): u32 {
    if (!g_job_system) {
        return 0
    }

    return g_job_system.?.submit_job(work, JobPriority.Normal)
}

export fn submit_job_priority(work: JobFunction, priority: JobPriority): u32 {
    if (!g_job_system) {
        return 0
    }

    return g_job_system.?.submit_job(work, priority)
}

export fn wait_for_job(job_id: u32) {
    if (!g_job_system) {
        return
    }

    g_job_system.?.wait_for_job(job_id)
}

export fn wait_for_all_jobs() {
    if (!g_job_system) {
        return
    }

    g_job_system.?.wait_for_all()
}

// Platform-specific sleep functions
fn sleep_microseconds(us: u32) {
    // TODO: Platform-specific microsleep
}

fn default_job_function() {
    // Empty default job
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
