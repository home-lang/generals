// C&C Generals Zero Hour - Home Port
// Job System for Multi-Threading
//
// Original: EA used platform-specific threading (EA's system was single-threaded for logic)
// Enhanced with modern job system for parallel processing
//
// Modern enhancements:
// - Work-stealing job queue
// - Worker thread pool
// - Parallel-for operations
// - Task dependencies
//
// C&C Generals was primarily single-threaded for game logic (determinism for multiplayer),
// but used threads for:
// - Asset loading
// - Audio processing
// - Network I/O
// - Particle updates
//
// This port adds optional multi-threading for:
// - Pathfinding (can run multiple A* searches in parallel)
// - Particle system updates
// - AI behavior tree evaluation
// - Physics/collision detection
// - Asset streaming
//
// Usage:
// ```
// // Initialize with N worker threads
// init_job_system(4)
//
// // Submit jobs
// let job1 = submit_job(|| {
//     update_particles()
// })
//
// let job2 = submit_job(|| {
//     update_pathfinding()
// })
//
// // Wait for completion
// wait_for_job(job1)
// wait_for_job(job2)
// ```

import basics/allocator
import basics/string

const MAX_JOBS: u32 = 4096
const MAX_WORKER_THREADS: u32 = 16

// Job priority
enum JobPriority {
    Low      // Background tasks
    Normal   // General work
    High     // Time-sensitive (pathfinding, AI)
    Critical // Must complete this frame (asset loading)
}

// Job status
enum JobStatus {
    Pending    // Waiting in queue
    Running    // Currently executing
    Completed  // Finished successfully
    Failed     // Error occurred
}

// Job function type
type JobFunction = fn(): void

// Job descriptor
struct Job {
    id: u32
    priority: JobPriority
    status: JobStatus

    // Job function to execute
    work_fn: JobFunction

    // Dependencies (this job waits for these jobs)
    dependencies: []u32
    dependency_count: u32

    // Results
    error_message: string

    fn init(id: u32, work: JobFunction): Job {
        return Job {
            id: id
            priority: JobPriority.Normal
            status: JobStatus.Pending
            work_fn: work
            dependencies: []
            dependency_count: 0
            error_message: ""
        }
    }

    fn can_run(self, job_system: *JobSystem): bool {
        // Check if all dependencies are completed
        for dep_id in self.dependencies {
            let dep_job = job_system.get_job(dep_id)
            if dep_job {
                if dep_job.?.status != JobStatus.Completed {
                    return false
                }
            }
        }
        return true
    }

    fn execute(mut self) {
        self.status = JobStatus.Running

        // Execute work function
        // TODO: Error handling
        self.work_fn()

        self.status = JobStatus.Completed
    }
}

// Job queue (lock-free ring buffer)
struct JobQueue {
    jobs: [MAX_JOBS]?Job
    head: u32  // Next job to dequeue
    tail: u32  // Next slot to enqueue

    count: u32

    fn init(): JobQueue {
        return JobQueue {
            jobs: [null; MAX_JOBS]
            head: 0
            tail: 0
            count: 0
        }
    }

    fn enqueue(mut self, job: Job): bool {
        if self.count >= MAX_JOBS {
            return false  // Queue full
        }

        self.jobs[self.tail] = job
        self.tail = (self.tail + 1) % MAX_JOBS
        self.count += 1

        return true
    }

    fn dequeue(mut self): ?Job {
        if self.count == 0 {
            return null  // Queue empty
        }

        let job = self.jobs[self.head]
        self.jobs[self.head] = null
        self.head = (self.head + 1) % MAX_JOBS
        self.count -= 1

        return job
    }

    fn is_empty(self): bool {
        return self.count == 0
    }

    fn is_full(self): bool {
        return self.count >= MAX_JOBS
    }
}

// Worker thread
struct WorkerThread {
    thread_id: u32
    is_running: bool

    // Jobs currently being processed
    current_job_id: u32

    fn init(thread_id: u32): WorkerThread {
        return WorkerThread {
            thread_id: thread_id
            is_running: false
            current_job_id: 0
        }
    }

    fn run(mut self, job_system: *JobSystem) {
        self.is_running = true

        loop {
            if !self.is_running {
                break
            }

            // Try to get a job from the queue
            let job = job_system.pop_job()

            if job {
                self.current_job_id = job.?.id
                job.?.execute()
                self.current_job_id = 0
            } else {
                // No jobs available - sleep briefly
                sleep_microseconds(100)
            }
        }
    }

    fn stop(mut self) {
        self.is_running = false
    }
}

// Job system manager
struct JobSystem {
    jobs: [MAX_JOBS]Job
    job_count: u32
    next_job_id: u32

    // Job queues by priority
    queue_critical: JobQueue
    queue_high: JobQueue
    queue_normal: JobQueue
    queue_low: JobQueue

    // Worker threads
    workers: [MAX_WORKER_THREADS]WorkerThread
    worker_count: u32

    allocator: Allocator

    fn init(allocator: Allocator, num_threads: u32): JobSystem {
        let thread_count = if num_threads > MAX_WORKER_THREADS {
            MAX_WORKER_THREADS
        } else {
            num_threads
        }

        return JobSystem {
            jobs: [Job.init(0, default_job_function); MAX_JOBS]
            job_count: 0
            next_job_id: 1
            queue_critical: JobQueue.init()
            queue_high: JobQueue.init()
            queue_normal: JobQueue.init()
            queue_low: JobQueue.init()
            workers: [WorkerThread.init(0); MAX_WORKER_THREADS]
            worker_count: thread_count
            allocator: allocator
        }
    }

    fn start_workers(mut self) {
        for i in 0..self.worker_count {
            self.workers[i] = WorkerThread.init(i)

            // TODO: Spawn actual OS thread
            // platform_spawn_thread(worker_thread_main, &self.workers[i])
        }

        println("JobSystem: Started {self.worker_count} worker threads")
    }

    fn stop_workers(mut self) {
        for i in 0..self.worker_count {
            self.workers[i].stop()
        }

        // TODO: Join threads
        println("JobSystem: Stopped worker threads")
    }

    fn submit_job(mut self, work: JobFunction, priority: JobPriority): u32 {
        if self.job_count >= MAX_JOBS {
            println("JobSystem: Cannot submit job - max limit reached!")
            return 0
        }

        let job_id = self.next_job_id
        self.next_job_id += 1

        let mut job = Job.init(job_id, work)
        job.priority = priority

        // Add to appropriate queue
        let queued = match priority {
            JobPriority.Critical => self.queue_critical.enqueue(job)
            JobPriority.High => self.queue_high.enqueue(job)
            JobPriority.Normal => self.queue_normal.enqueue(job)
            JobPriority.Low => self.queue_low.enqueue(job)
        }

        if !queued {
            println("JobSystem: Failed to queue job {job_id}")
            return 0
        }

        self.jobs[self.job_count] = job
        self.job_count += 1

        return job_id
    }

    fn pop_job(mut self): ?*Job {
        // Try queues in priority order
        if !self.queue_critical.is_empty() {
            let job = self.queue_critical.dequeue()
            if job {
                return self.get_job(job.?.id)
            }
        }

        if !self.queue_high.is_empty() {
            let job = self.queue_high.dequeue()
            if job {
                return self.get_job(job.?.id)
            }
        }

        if !self.queue_normal.is_empty() {
            let job = self.queue_normal.dequeue()
            if job {
                return self.get_job(job.?.id)
            }
        }

        if !self.queue_low.is_empty() {
            let job = self.queue_low.dequeue()
            if job {
                return self.get_job(job.?.id)
            }
        }

        return null
    }

    fn get_job(mut self, job_id: u32): ?*Job {
        for i in 0..self.job_count {
            if self.jobs[i].id == job_id {
                return &self.jobs[i]
            }
        }
        return null
    }

    fn wait_for_job(mut self, job_id: u32) {
        loop {
            let job = self.get_job(job_id)
            if job {
                if job.?.status == JobStatus.Completed or job.?.status == JobStatus.Failed {
                    break
                }
            } else {
                break  // Job not found
            }

            // Sleep briefly
            sleep_microseconds(10)
        }
    }

    fn wait_for_all(mut self) {
        loop {
            let mut all_done = true

            for i in 0..self.job_count {
                let status = self.jobs[i].status
                if status == JobStatus.Pending or status == JobStatus.Running {
                    all_done = false
                    break
                }
            }

            if all_done {
                break
            }

            sleep_microseconds(100)
        }
    }

    fn get_stats(self): JobSystemStats {
        let mut stats = JobSystemStats {
            total_jobs: self.job_count
            pending_jobs: 0
            running_jobs: 0
            completed_jobs: 0
            failed_jobs: 0
            active_workers: 0
        }

        for i in 0..self.job_count {
            match self.jobs[i].status {
                JobStatus.Pending => stats.pending_jobs += 1
                JobStatus.Running => stats.running_jobs += 1
                JobStatus.Completed => stats.completed_jobs += 1
                JobStatus.Failed => stats.failed_jobs += 1
            }
        }

        for i in 0..self.worker_count {
            if self.workers[i].is_running {
                stats.active_workers += 1
            }
        }

        return stats
    }
}

struct JobSystemStats {
    total_jobs: u32
    pending_jobs: u32
    running_jobs: u32
    completed_jobs: u32
    failed_jobs: u32
    active_workers: u32
}

// Global job system
var g_job_system: ?JobSystem = null

export fn init_job_system(allocator: Allocator, num_threads: u32) {
    g_job_system = JobSystem.init(allocator, num_threads)
    g_job_system.?.start_workers()

    println("JobSystem: Initialized with {num_threads} threads")
}

export fn shutdown_job_system() {
    if !g_job_system {
        return
    }

    g_job_system.?.stop_workers()
    g_job_system = null

    println("JobSystem: Shutdown")
}

export fn submit_job(work: JobFunction): u32 {
    if !g_job_system {
        return 0
    }

    return g_job_system.?.submit_job(work, JobPriority.Normal)
}

export fn submit_job_priority(work: JobFunction, priority: JobPriority): u32 {
    if !g_job_system {
        return 0
    }

    return g_job_system.?.submit_job(work, priority)
}

export fn wait_for_job(job_id: u32) {
    if !g_job_system {
        return
    }

    g_job_system.?.wait_for_job(job_id)
}

export fn wait_for_all_jobs() {
    if !g_job_system {
        return
    }

    g_job_system.?.wait_for_all()
}

// Platform-specific sleep functions
fn sleep_microseconds(us: u32) {
    // TODO: Platform-specific microsleep
}

fn default_job_function() {
    // Empty default job
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
