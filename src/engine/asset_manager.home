// Unified Asset Manager
// Central system for loading and managing all game assets
// Coordinates between various loaders (BIG, W3D, DDS, TGA, INI, etc.)


// Import loaders
from big_archive import BIGArchive, load_big_archive
from w3d_loader import W3DModel, load_w3d_model
from dds_loader import DDSTexture, load_dds
from tga_loader import TGAImage, load_tga
from ini_parser import INIFile, parse_ini_file
from csf_parser import CSFFile, load_csf_file
from wnd_parser import WNDFile, parse_wnd_file
from cursor_loader import AnimatedCursor, CursorManager, load_ani_cursor, load_cur_cursor
from bink_video import BinkVideo, VideoManager
from splash_screen import SplashScreen, SplashManager, load_splash_screen
from str_parser import StringTable, StringManager, parse_str_file
from asset_paths import AssetConfig, AssetPaths, Language

// ============================================================================
// Asset Types
// ============================================================================

enum AssetType {
    Unknown,
    Archive,      // .big files
    Model,        // .w3d files
    TextureTGA,   // .tga files
    TextureDDS,   // .dds files
    Config,       // .ini files
    Localization, // .csf files
    UI,           // .wnd files
    Cursor,       // .ani/.cur files
    Video,        // .bik files
    Splash,       // .bmp files
    Strings,      // .str files
    Audio,        // .wav files
    Map,          // map files
}

// Detect asset type from file extension
fn detect_asset_type(filename: string): AssetType {
    let lower = filename.to_lowercase()

    if (lower.ends_with(".big")) {
        return AssetType::Archive
    } else if (lower.ends_with(".w3d")) {
        return AssetType::Model
    } else if (lower.ends_with(".tga")) {
        return AssetType::TextureTGA
    } else if (lower.ends_with(".dds")) {
        return AssetType::TextureDDS
    } else if (lower.ends_with(".ini")) {
        return AssetType::Config
    } else if (lower.ends_with(".csf")) {
        return AssetType::Localization
    } else if (lower.ends_with(".wnd")) {
        return AssetType::UI
    } else if (lower.ends_with(".ani") || lower.ends_with(".cur")) {
        return AssetType::Cursor
    } else if (lower.ends_with(".bik")) {
        return AssetType::Video
    } else if (lower.ends_with(".bmp")) {
        return AssetType::Splash
    } else if (lower.ends_with(".str")) {
        return AssetType::Strings
    } else if (lower.ends_with(".wav")) {
        return AssetType::Audio
    }

    return AssetType::Unknown
}

// ============================================================================
// Asset Cache
// ============================================================================

struct AssetCache<T> {
    items: HashMap<String, T>,
    max_size: i32,
    access_order: Vec<string>,  // LRU tracking

    fn init(max_size: i32): AssetCache<T> {
        return AssetCache<T> {
            items: HashMap<String, T>{},
            max_size: max_size,
            access_order: Vec<string>{},
        }
    }

    fn get(&self, key: string): T {
        if (self.items.has(key)) {
            // Move to end for LRU
            self.touch(key)
            return self.items.get(key)
        }
        // Return default - caller should check has() first
        return self.items.get(key)
    }

    fn has(&self, key: string): bool {
        return self.items.has(key)
    }

    fn set(&self, key: string, value: T) {
        // Evict if at capacity
        if (self.items.len() >= self.max_size && !self.items.has(key)) {
            self.evict_oldest()
        }

        self.items.set(key, value)
        self.touch(key)
    }

    fn touch(&self, key: string) {
        // Remove from current position
        let new_order = Vec<string>{}
        for k in self.access_order {
            if (k != key) {
                new_order.add(k)
            }
        }
        new_order.add(key)
        self.access_order = new_order
    }

    fn evict_oldest(&self) {
        if (self.access_order.len() > 0) {
            let oldest = self.access_order.get(0)
            self.items.remove(oldest)
            self.access_order.remove_at(0)
        }
    }

    fn clear(&self) {
        self.items.clear()
        self.access_order.clear()
    }

    fn count(&self): i32 {
        return self.items.len()
    }
}

// ============================================================================
// Asset Manager
// ============================================================================

struct AssetManager {
    config: AssetConfig,
    cursor_manager: CursorManager,
    video_manager: VideoManager,
    splash_manager: SplashManager,
    string_manager: StringManager,
    model_cache: HashMap<String, W3DModel>,
    texture_tga_cache: HashMap<String, TGAImage>,
    texture_dds_cache: HashMap<String, DDSTexture>,
    ini_cache: HashMap<String, INIFile>,
    csf_cache: HashMap<String, CSFFile>,
    wnd_cache: HashMap<String, WNDFile>,
    archives: Vec<BIGArchive>,
    models_loaded: i32,
    textures_loaded: i32,
    configs_loaded: i32,
}

// Get language name as string
fn get_language_name(lang: Language): string {
    match lang {
        Language::English => "English",
        Language::German => "German",
        Language::French => "French",
        Language::Spanish => "Spanish",
        Language::Italian => "Italian",
        Language::Korean => "Korean",
        Language::Chinese => "Chinese",
        Language::Polish => "Polish",
        Language::Brazilian => "Brazilian",
        Language::Russian => "Russian",
        Language::Ukrainian => "Ukrainian",
        Language::Arabic => "Arabic",
        Language::Swedish => "Swedish",
    }
}

// ============================================================================
// Asset Loading Helpers
// ============================================================================

// Load all core INI files
fn load_core_configs(manager: AssetManager, read_file: fn(String): string): i32 {
    let loaded = 0

    let core_files = [
        "GameData.ini",
        "GameLOD.ini",
        "AudioSettings.ini",
        "Armor.ini",
        "Locomotor.ini",
        "Object.ini",
        "Weapon.ini",
    ]

    for filename in core_files {
        let path = manager.config.paths.ini + "/" + filename
        let content = read_file(path)
        if (content.len() > 0) {
            if (manager.load_ini(filename, content)) {
                loaded = loaded + 1
            }
        }
    }

    return loaded
}

// Load localization for current language
fn load_localization(manager: AssetManager, read_file: fn(String): Vec<i32>): bool {
    let csf_path = manager.config.get_csf_path()
    let data = read_file(csf_path)

    if (data.len() > 0) {
        return manager.load_csf("generals.csf", data)
    }

    return false
}

// Load all game cursors
fn load_game_cursors(manager: AssetManager, read_file: fn(String): Vec<i32>): i32 {
    let loaded = 0

    let cursor_files = [
        "SCCDefault.ani",
        "SCCSelect.ani",
        "SCCMove.ani",
        "SCCAttack.ani",
    ]

    for filename in cursor_files {
        let path = manager.config.paths.cursors + "/" + filename
        let data = read_file(path)
        if (data.len() > 0) {
            if (manager.load_cursor(filename, data)) {
                loaded = loaded + 1
            }
        }
    }

    return loaded
}

// ============================================================================
// Tests
// ============================================================================

fn test_asset_type_detection(): bool {
    assert(detect_asset_type("model.w3d") == AssetType::Model, "Should detect W3D")
    assert(detect_asset_type("texture.tga") == AssetType::TextureTGA, "Should detect TGA")
    assert(detect_asset_type("texture.dds") == AssetType::TextureDDS, "Should detect DDS")
    assert(detect_asset_type("config.ini") == AssetType::Config, "Should detect INI")
    assert(detect_asset_type("strings.csf") == AssetType::Localization, "Should detect CSF")
    assert(detect_asset_type("menu.wnd") == AssetType::UI, "Should detect WND")
    assert(detect_asset_type("cursor.ani") == AssetType::Cursor, "Should detect ANI")
    assert(detect_asset_type("intro.bik") == AssetType::Video, "Should detect BIK")
    assert(detect_asset_type("splash.bmp") == AssetType::Splash, "Should detect BMP")
    return true
}

fn test_asset_manager_init(): bool {
    let manager = AssetManager::init()
    assert(manager.models_loaded == 0, "Should start with 0 models")
    assert(manager.textures_loaded == 0, "Should start with 0 textures")
    return true
}

fn test_language_name(): bool {
    assert(get_language_name(Language::English) == "English", "English name")
    assert(get_language_name(Language::German) == "German", "German name")
    return true
}

fn run_all_tests(): bool {
    assert(test_asset_type_detection(), "Asset type detection test failed")
    assert(test_asset_manager_init(), "Asset manager init test failed")
    assert(test_language_name(), "Language name test failed")
    return true
}
