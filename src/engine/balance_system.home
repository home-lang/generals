// Balance and Tuning System for C&C Generals Zero Hour
// Dynamic balance adjustments, faction tuning, matchmaking, gameplay parameters
// Written in Home language

// Balance categories
enum BalanceCategory {
    UNIT_COMBAT = 0,
    UNIT_COST = 1,
    BUILDING_STATS = 2,
    RESOURCE_ECONOMY = 3,
    ABILITY_POWER = 4,
    FACTION_BONUS = 5,
}

// Balance patch
struct BalancePatch {
    version: String,
    category: BalanceCategory,
    target_id: String,
    parameter: String,
    old_value: Float,
    new_value: Float,
    reason: String,

    fn init(version: String, category: BalanceCategory, target_id: String) -> BalancePatch {
        return BalancePatch {
            version: version,
            category: category,
            target_id: target_id,
            parameter: "",
            old_value: 0.0,
            new_value: 0.0,
            reason: "",
        }
    }

    fn set_adjustment(self, param: String, old_val: Float, new_val: Float) {
        self.parameter = param
        self.old_value = old_val
        self.new_value = new_val
    }

    fn set_reason(self, reason: String) {
        self.reason = reason
    }

    fn get_change_percent(self) -> Float {
        if self.old_value == 0.0 {
            return 0.0
        }
        return ((self.new_value - self.old_value) / self.old_value) * 100.0
    }

    fn is_buff(self) -> Bool {
        return self.new_value > self.old_value
    }

    fn is_nerf(self) -> Bool {
        return self.new_value < self.old_value
    }
}

// Faction balance
struct FactionBalance {
    faction_name: String,
    win_rate: Float,
    play_rate: Float,
    strength_rating: Float,

    // Bonuses
    damage_modifier: Float,
    health_modifier: Float,
    cost_modifier: Float,
    speed_modifier: Float,

    fn init(faction_name: String) -> FactionBalance {
        return FactionBalance {
            faction_name: faction_name,
            win_rate: 50.0,
            play_rate: 33.3,
            strength_rating: 1.0,
            damage_modifier: 1.0,
            health_modifier: 1.0,
            cost_modifier: 1.0,
            speed_modifier: 1.0,
        }
    }

    fn update_stats(self, win_rate: Float, play_rate: Float) {
        self.win_rate = win_rate
        self.play_rate = play_rate
        self.calculate_strength()
    }

    fn calculate_strength(self) {
        // Strength based on win rate (50% = 1.0 strength)
        self.strength_rating = self.win_rate / 50.0
    }

    fn apply_balance_adjustment(self, category: BalanceCategory, modifier: Float) {
        match category {
            BalanceCategory::UNIT_COMBAT => self.damage_modifier = modifier,
            BalanceCategory::BUILDING_STATS => self.health_modifier = modifier,
            BalanceCategory::UNIT_COST => self.cost_modifier = modifier,
            _ => {},
        }
    }

    fn needs_buff(self) -> Bool {
        return self.win_rate < 45.0
    }

    fn needs_nerf(self) -> Bool {
        return self.win_rate > 55.0
    }

    fn get_balance_status(self) -> String {
        if self.needs_buff() {
            return "Underpowered"
        } else if self.needs_nerf() {
            return "Overpowered"
        }
        return "Balanced"
    }
}

// Match result for statistics
struct MatchResult {
    winner_faction: String,
    loser_faction: String,
    match_duration: Float,
    winner_score: Int,
    loser_score: Int,

    fn init(winner: String, loser: String, duration: Float) -> MatchResult {
        return MatchResult {
            winner_faction: winner,
            loser_faction: loser,
            match_duration: duration,
            winner_score: 0,
            loser_score: 0,
        }
    }
}

// Balance analyzer
struct BalanceAnalyzer {
    faction_stats: Collection<FactionBalance>,
    match_history: Collection<MatchResult>,
    patches: Collection<BalancePatch>,
    analysis_window: Int,

    fn init() -> BalanceAnalyzer {
        let analyzer = BalanceAnalyzer {
            faction_stats: Collection::new(),
            match_history: Collection::new(),
            patches: Collection::new(),
            analysis_window: 1000,
        }

        // Initialize faction stats
        analyzer.faction_stats.add(FactionBalance::init("USA"))
        analyzer.faction_stats.add(FactionBalance::init("China"))
        analyzer.faction_stats.add(FactionBalance::init("GLA"))

        return analyzer
    }

    fn record_match(self, result: MatchResult) {
        self.match_history.add(result)

        // Keep only recent matches
        if self.match_history.count() > self.analysis_window {
            self.match_history.remove_at(0)
        }

        self.update_faction_stats()
    }

    fn update_faction_stats(self) {
        for i in 0..self.faction_stats.count() {
            let faction = self.faction_stats.get(i)

            let wins = 0
            let total = 0

            for j in 0..self.match_history.count() {
                let match = self.match_history.get(j)

                if match.winner_faction == faction.faction_name {
                    wins = wins + 1
                    total = total + 1
                } else if match.loser_faction == faction.faction_name {
                    total = total + 1
                }
            }

            if total > 0 {
                let win_rate = (wins as Float / total as Float) * 100.0
                let play_rate = (total as Float / self.match_history.count() as Float) * 100.0
                faction.update_stats(win_rate, play_rate)
            }
        }
    }

    fn get_faction_balance(self, faction_name: String) -> FactionBalance? {
        for i in 0..self.faction_stats.count() {
            let faction = self.faction_stats.get(i)
            if faction.faction_name == faction_name {
                return faction
            }
        }
        return null
    }

    fn apply_patch(self, patch: BalancePatch) {
        self.patches.add(patch)
    }

    fn get_balance_recommendations(self) -> Collection<BalancePatch> {
        let recommendations = Collection::new()

        for i in 0..self.faction_stats.count() {
            let faction = self.faction_stats.get(i)

            if faction.needs_buff() {
                let patch = BalancePatch::init("auto", BalanceCategory::UNIT_COMBAT, faction.faction_name)
                patch.set_adjustment("damage_modifier", 1.0, 1.05)
                patch.set_reason("Win rate below 45%")
                recommendations.add(patch)
            } else if faction.needs_nerf() {
                let patch = BalancePatch::init("auto", BalanceCategory::UNIT_COMBAT, faction.faction_name)
                patch.set_adjustment("damage_modifier", 1.0, 0.95)
                patch.set_reason("Win rate above 55%")
                recommendations.add(patch)
            }
        }

        return recommendations
    }

    fn get_patch_count(self) -> Int {
        return self.patches.count()
    }

    fn get_match_count(self) -> Int {
        return self.match_history.count()
    }
}

// Matchmaking ELO system
struct PlayerRating {
    player_id: Int,
    rating: Float,
    matches_played: Int,
    wins: Int,
    losses: Int,

    fn init(player_id: Int) -> PlayerRating {
        return PlayerRating {
            player_id: player_id,
            rating: 1500.0,
            matches_played: 0,
            wins: 0,
            losses: 0,
        }
    }

    fn update_rating(self, opponent_rating: Float, won: Bool, k_factor: Float) {
        let expected = self.calculate_expected_score(opponent_rating)
        let actual = if won { 1.0 } else { 0.0 }

        self.rating = self.rating + k_factor * (actual - expected)
        self.matches_played = self.matches_played + 1

        if won {
            self.wins = self.wins + 1
        } else {
            self.losses = self.losses + 1
        }
    }

    fn calculate_expected_score(self, opponent_rating: Float) -> Float {
        let diff = opponent_rating - self.rating
        return 1.0 / (1.0 + pow(10.0, diff / 400.0))
    }

    fn get_win_rate(self) -> Float {
        if self.matches_played == 0 {
            return 0.0
        }
        return (self.wins as Float / self.matches_played as Float) * 100.0
    }

    fn get_tier(self) -> String {
        if self.rating >= 2200.0 {
            return "Master"
        } else if self.rating >= 1900.0 {
            return "Diamond"
        } else if self.rating >= 1600.0 {
            return "Platinum"
        } else if self.rating >= 1300.0 {
            return "Gold"
        } else if self.rating >= 1000.0 {
            return "Silver"
        }
        return "Bronze"
    }
}

// Matchmaking system
struct MatchmakingSystem {
    player_pool: Collection<PlayerRating>,
    k_factor: Float,
    rating_range: Float,

    fn init() -> MatchmakingSystem {
        return MatchmakingSystem {
            player_pool: Collection::new(),
            k_factor: 32.0,
            rating_range: 200.0,
        }
    }

    fn add_player(self, player: PlayerRating) {
        self.player_pool.add(player)
    }

    fn find_match(self, player_id: Int) -> Int? {
        let player = self.get_player(player_id)
        if player == null {
            return null
        }

        let p = player?
        let best_match_id = -1
        let smallest_diff = 99999.0

        for i in 0..self.player_pool.count() {
            let candidate = self.player_pool.get(i)

            if candidate.player_id == player_id {
                continue
            }

            let diff = abs(candidate.rating - p.rating)

            if diff <= self.rating_range && diff < smallest_diff {
                smallest_diff = diff
                best_match_id = candidate.player_id
            }
        }

        if best_match_id != -1 {
            return best_match_id
        }

        return null
    }

    fn record_match_result(self, player1_id: Int, player2_id: Int, player1_won: Bool) {
        let p1 = self.get_player(player1_id)
        let p2 = self.get_player(player2_id)

        if p1 == null || p2 == null {
            return
        }

        let player1 = p1?
        let player2 = p2?

        player1.update_rating(player2.rating, player1_won, self.k_factor)
        player2.update_rating(player1.rating, !player1_won, self.k_factor)
    }

    fn get_player(self, player_id: Int) -> PlayerRating? {
        for i in 0..self.player_pool.count() {
            let player = self.player_pool.get(i)
            if player.player_id == player_id {
                return player
            }
        }
        return null
    }

    fn get_leaderboard(self) -> Collection<PlayerRating> {
        // Simple bubble sort by rating
        let sorted = Collection::new()

        for i in 0..self.player_pool.count() {
            sorted.add(self.player_pool.get(i))
        }

        let n = sorted.count()
        for i in 0..n {
            for j in 0..(n - i - 1) {
                let p1 = sorted.get(j)
                let p2 = sorted.get(j + 1)

                if p1.rating < p2.rating {
                    sorted.set(j, p2)
                    sorted.set(j + 1, p1)
                }
            }
        }

        return sorted
    }

    fn get_player_count(self) -> Int {
        return self.player_pool.count()
    }
}

// Gameplay parameters
struct GameplayParameters {
    // Economy
    starting_credits: Int,
    supply_value: Int,
    supply_respawn_time: Float,

    // Combat
    global_damage_multiplier: Float,
    veteran_bonus_multiplier: Float,

    // Building
    build_speed_multiplier: Float,
    power_loss_penalty: Float,

    // Special powers
    superweapon_cooldown_multiplier: Float,

    fn init() -> GameplayParameters {
        return GameplayParameters {
            starting_credits: 10000,
            supply_value: 2000,
            supply_respawn_time: 60.0,
            global_damage_multiplier: 1.0,
            veteran_bonus_multiplier: 1.25,
            build_speed_multiplier: 1.0,
            power_loss_penalty: 0.5,
            superweapon_cooldown_multiplier: 1.0,
        }
    }

    fn apply_preset(self, preset_name: String) {
        match preset_name {
            "quick_match" => {
                self.starting_credits = 15000
                self.build_speed_multiplier = 1.5
                self.superweapon_cooldown_multiplier = 0.7
            },
            "competitive" => {
                self.starting_credits = 10000
                self.build_speed_multiplier = 1.0
                self.superweapon_cooldown_multiplier = 1.2
            },
            "hardcore" => {
                self.starting_credits = 5000
                self.global_damage_multiplier = 1.5
                self.build_speed_multiplier = 0.8
            },
            _ => {},
        }
    }
}

// Game mode balance
struct GameModeBalance {
    mode_name: String,
    parameters: GameplayParameters,
    faction_modifiers: Collection<FactionBalance>,

    fn init(mode_name: String) -> GameModeBalance {
        return GameModeBalance {
            mode_name: mode_name,
            parameters: GameplayParameters::init(),
            faction_modifiers: Collection::new(),
        }
    }

    fn add_faction_modifier(self, faction: FactionBalance) {
        self.faction_modifiers.add(faction)
    }
}

// Balance manager
struct BalanceManager {
    analyzer: BalanceAnalyzer,
    matchmaking: MatchmakingSystem,
    global_parameters: GameplayParameters,
    game_modes: Collection<GameModeBalance>,

    fn init() -> BalanceManager {
        return BalanceManager {
            analyzer: BalanceAnalyzer::init(),
            matchmaking: MatchmakingSystem::init(),
            global_parameters: GameplayParameters::init(),
            game_modes: Collection::new(),
        }
    }

    fn record_match(self, winner_faction: String, loser_faction: String, duration: Float) {
        let result = MatchResult::init(winner_faction, loser_faction, duration)
        self.analyzer.record_match(result)
    }

    fn get_balance_recommendations(self) -> Collection<BalancePatch> {
        return self.analyzer.get_balance_recommendations()
    }

    fn apply_balance_patch(self, patch: BalancePatch) {
        self.analyzer.apply_patch(patch)
    }
}

// Helper functions
fn pow(base: Float, exp: Float) -> Float {
    if exp == 0.0 {
        return 1.0
    }
    let result = base
    let count = exp as Int
    for i in 1..count {
        result = result * base
    }
    return result
}

fn abs(x: Float) -> Float {
    if x < 0.0 {
        return -x
    }
    return x
}

// Tests
test "BalancePatch: init" {
    let patch = BalancePatch::init("1.0.0", BalanceCategory::UNIT_COMBAT, "usa_ranger")

    assert patch.version == "1.0.0"
    assert patch.category == BalanceCategory::UNIT_COMBAT
    assert patch.target_id == "usa_ranger"
}

test "BalancePatch: set adjustment" {
    let patch = BalancePatch::init("1.0", BalanceCategory::UNIT_COST, "test")

    patch.set_adjustment("cost", 500.0, 450.0)

    assert patch.parameter == "cost"
    assert patch.old_value == 500.0
    assert patch.new_value == 450.0
}

test "BalancePatch: get change percent" {
    let patch = BalancePatch::init("1.0", BalanceCategory::UNIT_COMBAT, "test")

    patch.set_adjustment("damage", 100.0, 110.0)

    assert patch.get_change_percent() == 10.0
}

test "BalancePatch: is buff" {
    let patch = BalancePatch::init("1.0", BalanceCategory::UNIT_COMBAT, "test")

    patch.set_adjustment("damage", 100.0, 110.0)

    assert patch.is_buff()
    assert !patch.is_nerf()
}

test "FactionBalance: init" {
    let faction = FactionBalance::init("USA")

    assert faction.faction_name == "USA"
    assert faction.win_rate == 50.0
    assert faction.strength_rating == 1.0
}

test "FactionBalance: update stats" {
    let faction = FactionBalance::init("China")

    faction.update_stats(45.0, 30.0)

    assert faction.win_rate == 45.0
    assert faction.play_rate == 30.0
}

test "FactionBalance: needs buff" {
    let faction = FactionBalance::init("GLA")

    faction.update_stats(40.0, 25.0)

    assert faction.needs_buff()
    assert !faction.needs_nerf()
}

test "FactionBalance: needs nerf" {
    let faction = FactionBalance::init("USA")

    faction.update_stats(60.0, 35.0)

    assert faction.needs_nerf()
    assert !faction.needs_buff()
}

test "FactionBalance: get balance status" {
    let faction = FactionBalance::init("China")

    faction.update_stats(50.0, 33.0)

    assert faction.get_balance_status() == "Balanced"
}

test "MatchResult: init" {
    let result = MatchResult::init("USA", "China", 1200.0)

    assert result.winner_faction == "USA"
    assert result.loser_faction == "China"
    assert result.match_duration == 1200.0
}

test "BalanceAnalyzer: init" {
    let analyzer = BalanceAnalyzer::init()

    assert analyzer.faction_stats.count() == 3
    assert analyzer.get_match_count() == 0
}

test "BalanceAnalyzer: record match" {
    let analyzer = BalanceAnalyzer::init()

    let result = MatchResult::init("USA", "China", 900.0)
    analyzer.record_match(result)

    assert analyzer.get_match_count() == 1
}

test "BalanceAnalyzer: update faction stats" {
    let analyzer = BalanceAnalyzer::init()

    for i in 0..10 {
        let result = MatchResult::init("USA", "China", 900.0)
        analyzer.record_match(result)
    }

    let usa = analyzer.get_faction_balance("USA")
    if let Some(faction) = usa {
        assert faction.win_rate > 0.0
    }
}

test "BalanceAnalyzer: apply patch" {
    let analyzer = BalanceAnalyzer::init()

    let patch = BalancePatch::init("1.0", BalanceCategory::UNIT_COMBAT, "usa_ranger")
    analyzer.apply_patch(patch)

    assert analyzer.get_patch_count() == 1
}

test "BalanceAnalyzer: get balance recommendations" {
    let analyzer = BalanceAnalyzer::init()

    // Record matches to create imbalance
    for i in 0..50 {
        let result = MatchResult::init("USA", "China", 900.0)
        analyzer.record_match(result)
    }

    let recommendations = analyzer.get_balance_recommendations()

    assert recommendations.count() > 0
}

test "PlayerRating: init" {
    let player = PlayerRating::init(1)

    assert player.player_id == 1
    assert player.rating == 1500.0
    assert player.matches_played == 0
}

test "PlayerRating: update rating win" {
    let player = PlayerRating::init(1)

    player.update_rating(1500.0, true, 32.0)

    assert player.rating > 1500.0
    assert player.matches_played == 1
    assert player.wins == 1
}

test "PlayerRating: update rating loss" {
    let player = PlayerRating::init(1)

    player.update_rating(1500.0, false, 32.0)

    assert player.rating < 1500.0
    assert player.losses == 1
}

test "PlayerRating: get win rate" {
    let player = PlayerRating::init(1)

    player.update_rating(1500.0, true, 32.0)
    player.update_rating(1500.0, true, 32.0)
    player.update_rating(1500.0, false, 32.0)

    let win_rate = player.get_win_rate()

    assert win_rate > 65.0 && win_rate < 70.0
}

test "PlayerRating: get tier" {
    let player = PlayerRating::init(1)
    player.rating = 1700.0

    let tier = player.get_tier()

    assert tier == "Platinum"
}

test "MatchmakingSystem: init" {
    let mm = MatchmakingSystem::init()

    assert mm.get_player_count() == 0
    assert mm.k_factor == 32.0
}

test "MatchmakingSystem: add player" {
    let mm = MatchmakingSystem::init()

    let player = PlayerRating::init(1)
    mm.add_player(player)

    assert mm.get_player_count() == 1
}

test "MatchmakingSystem: find match" {
    let mm = MatchmakingSystem::init()

    let p1 = PlayerRating::init(1)
    p1.rating = 1500.0

    let p2 = PlayerRating::init(2)
    p2.rating = 1550.0

    mm.add_player(p1)
    mm.add_player(p2)

    let match_id = mm.find_match(1)

    assert match_id != null
}

test "MatchmakingSystem: record match result" {
    let mm = MatchmakingSystem::init()

    let p1 = PlayerRating::init(1)
    let p2 = PlayerRating::init(2)

    mm.add_player(p1)
    mm.add_player(p2)

    let p1_rating = p1.rating

    mm.record_match_result(1, 2, true)

    let updated_p1 = mm.get_player(1)
    if let Some(player) = updated_p1 {
        assert player.rating > p1_rating
    }
}

test "GameplayParameters: init" {
    let params = GameplayParameters::init()

    assert params.starting_credits == 10000
    assert params.global_damage_multiplier == 1.0
}

test "GameplayParameters: apply preset" {
    let params = GameplayParameters::init()

    params.apply_preset("quick_match")

    assert params.starting_credits == 15000
    assert params.build_speed_multiplier == 1.5
}

test "GameModeBalance: init" {
    let mode = GameModeBalance::init("Ranked")

    assert mode.mode_name == "Ranked"
}

test "BalanceManager: init" {
    let manager = BalanceManager::init()

    assert manager.global_parameters.starting_credits == 10000
}

test "BalanceManager: record match" {
    let manager = BalanceManager::init()

    manager.record_match("USA", "China", 900.0)

    assert manager.analyzer.get_match_count() == 1
}

test "BalanceManager: get recommendations" {
    let manager = BalanceManager::init()

    // Create imbalance
    for i in 0..100 {
        manager.record_match("USA", "China", 900.0)
    }

    let recommendations = manager.get_balance_recommendations()

    assert recommendations.count() > 0
}
