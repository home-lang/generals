// C&C Generals Zero Hour - Home Port
// Frame Rate Limiter
//
// Original: FrameRateLimit.h (EA Games)
// Ported to Home with EA's FPS limiting system
//
// EA's frame rate control:
// - Configurable FPS cap (30, 60, 120, 144, 240, uncapped)
// - High-precision waiting using performance counter
// - Separate logic and render FPS
// - Logic runs at fixed 30 FPS (LOGICFRAMES_PER_SECOND)
// - Render can run at higher FPS
//
// Usage:
// ```
// let limiter = FrameRateLimiter.init()
// limiter.set_target_fps(60)
//
// loop {
//     limiter.wait()  // Sleep until next frame
//     update_game()
//     render_game()
// }
// ```

import basics/time

const LOGICFRAMES_PER_SECOND: u32 = 30  // EA's fixed logic rate

// Common FPS presets matching EA's system
const FPS_PRESET_30: u32 = 30
const FPS_PRESET_60: u32 = 60
const FPS_PRESET_120: u32 = 120
const FPS_PRESET_144: u32 = 144
const FPS_PRESET_240: u32 = 240
const FPS_PRESET_UNCAPPED: u32 = 1000000

// Frame rate limiter
struct FrameRateLimiter {
    target_fps: u32
    target_frame_time_ns: i64
    last_frame_time_ns: i64
    frame_start_time_ns: i64
    actual_fps: f32
    frame_time_ms: f32
    fps_history_index: u32
    fps_history_count: u32
}

// FPS presets enum
enum FPSPreset {
    FPS30
    FPS60
    FPS120
    FPS144
    FPS240
    Uncapped
}

// Logic timestep manager (EA's fixed timestep system)
struct LogicTimestep {
    logic_hz: u32           // Fixed logic rate (30 Hz)
    logic_dt: f32           // Fixed logic delta time (1/30 = 0.0333s)
    accumulator: f32        // Accumulated time for logic updates
    max_accumulator: f32    // Prevent spiral of death
}

// FPS preset cycling (EA's system for changing FPS in-game)
struct FPSPresetCycler {
    current_index: u32
}

// Global frame limiter
var g_frame_limiter: ?FrameRateLimiter = null
var g_logic_timestep: ?LogicTimestep = null

export fn init_frame_limiter() {
    g_frame_limiter = FrameRateLimiter.init()
    g_logic_timestep = LogicTimestep.init()

    println("FrameLimiter: Initialized (target: 60 FPS)")
}

export fn shutdown_frame_limiter() {
    g_frame_limiter = null
    g_logic_timestep = null

    println("FrameLimiter: Shutdown")
}

export fn set_target_fps(fps: u32) {
    if (!g_frame_limiter) {
        return
    }

    g_frame_limiter.?.set_target_fps(fps)
}

export fn begin_frame() {
    if (!g_frame_limiter) {
        return
    }

    g_frame_limiter.?.begin_frame()
}

export fn wait_for_next_frame() {
    if (!g_frame_limiter) {
        return
    }

    g_frame_limiter.?.wait()
}

export fn get_current_fps(): f32 {
    if (!g_frame_limiter) {
        return 0.0
    }

    return g_frame_limiter.?.get_fps()
}

export fn get_frame_time(): f32 {
    if (!g_frame_limiter) {
        return 0.0
    }

    return g_frame_limiter.?.get_frame_time_ms()
}

export fn get_logic_updates(delta_time: f32): u32 {
    if (!g_logic_timestep) {
        return 1  // Fallback: one logic update per frame
    }

    return g_logic_timestep.?.update(delta_time)
}

export fn get_logic_alpha(): f32 {
    if (!g_logic_timestep) {
        return 1.0
    }

    return g_logic_timestep.?.get_alpha()
}

export fn get_fixed_logic_dt(): f32 {
    if (!g_logic_timestep) {
        return 0.0333
    }

    return g_logic_timestep.?.get_fixed_dt()
}

// Platform-specific timing functions
fn get_time_nanoseconds(): i64 {
    // TODO: Use platform-specific monotonic clock
    // On Windows: QueryPerformanceCounter
    // On macOS/Linux: clock_gettime(CLOCK_MONOTONIC)
    return 0
}

fn sleep_milliseconds(ms: u32) {
    // TODO: Platform-specific sleep
    // On Windows: Sleep(ms)
    // On POSIX: usleep(ms * 1000)
}
