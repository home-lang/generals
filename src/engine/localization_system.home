// Localization System - Multi-language support
// Implements authentic C&C Generals Zero Hour localization (STR/CSF files)

// ============================================================================
// SUPPORTED LANGUAGES
// ============================================================================

enum Language {
    ENGLISH,
    FRENCH,
    GERMAN,
    SPANISH,
    ITALIAN,
    KOREAN,
    CHINESE_SIMPLIFIED,
    CHINESE_TRADITIONAL,
    JAPANESE,
    POLISH,
    RUSSIAN
}

const LANGUAGE_CODES: [[u8; 8]; 11] = [
    "en",       // English
    "fr",       // French
    "de",       // German
    "es",       // Spanish
    "it",       // Italian
    "ko",       // Korean
    "zh-CN",    // Chinese Simplified
    "zh-TW",    // Chinese Traditional
    "ja",       // Japanese
    "pl",       // Polish
    "ru"        // Russian
]

const LANGUAGE_NAMES: [[u8; 32]; 11] = [
    "English",
    "Français",
    "Deutsch",
    "Español",
    "Italiano",
    "한국어",
    "简体中文",
    "繁體中文",
    "日本語",
    "Polski",
    "Русский"
]

// ============================================================================
// CSF FILE FORMAT (Compiled String File)
// ============================================================================

const CSF_SIGNATURE: [u8; 4] = [0x20, 0x46, 0x53, 0x43]  // " FSC" (little endian "CSF ")
const CSF_VERSION: u32 = 3

struct CSFHeader {
    signature: [u8; 4],
    version: u32,
    label_count: u32,
    string_count: u32,
    unused: u32,
    language: u32
}

struct CSFLabel {
    label_flags: u32,
    name: [u8; 256],
    string_count: u32,
    strings: [CSFString; 4]  // Some labels have multiple strings
}

struct CSFString {
    string_length: u32,
    value: [u8; 2048],       // UTF-16 LE encoded
    extra_value: [u8; 512]   // Optional extra data
}

// ============================================================================
// STRING DATABASE
// ============================================================================

struct LocalizedString {
    label: [u8; 256],
    value: [u8; 2048],
    category: StringCategory
}

enum StringCategory {
    GUI,           // Menu and UI text
    UNIT,          // Unit names and descriptions
    BUILDING,      // Building names and descriptions
    ABILITY,       // Ability and power names
    UPGRADE,       // Upgrade names
    EVA,           // EVA announcer text
    TOOLTIP,       // Tooltips and help text
    OBJECTIVE,     // Mission objectives
    DIALOGUE,      // Campaign dialogue
    GENERAL,       // General text
    ERROR          // Error messages
}

struct StringDatabase {
    strings: [LocalizedString; 16384],
    string_count: u32,

    // Hash table for fast lookup
    hash_buckets: [[u32; 256]; 1024],  // label hash -> string indices
    bucket_counts: [u32; 1024],

    current_language: Language
}

fn create_string_database(): StringDatabase {
    return StringDatabase {
        strings: [],
        string_count: 0,
        hash_buckets: [],
        bucket_counts: [],
        current_language: Language::ENGLISH
    }
}

fn hash_label(label: [u8; 256]): u32 {
    // Simple hash function for label lookup
    let mut hash: u32 = 5381

    for i in 0..256 {
        if (label[i] == 0) {
            break
        }
        hash = ((hash << 5) + hash) + cast(u32, label[i])
    }

    return hash % 1024
}

fn add_string(db: mut StringDatabase, label: [u8; 256], value: [u8; 2048], category: StringCategory) {
    if (db.string_count >= 16384) {
        return
    }

    let idx: u32 = db.string_count

    db.strings[idx] = LocalizedString {
        label: label,
        value: value,
        category: category
    }

    // Add to hash table
    let bucket: u32 = hash_label(label)
    let bucket_idx: u32 = db.bucket_counts[bucket]

    if (bucket_idx < 256) {
        db.hash_buckets[bucket][bucket_idx] = idx
        db.bucket_counts[bucket] = bucket_idx + 1
    }

    db.string_count = db.string_count + 1
}

fn get_string(db: StringDatabase, label: [u8; 256]): [u8; 2048] {
    let bucket: u32 = hash_label(label)

    for i in 0..cast(i32, db.bucket_counts[bucket]) {
        let idx: u32 = db.hash_buckets[bucket][i]
        let str_entry: LocalizedString = db.strings[idx]

        // Compare labels
        let mut matches: bool = true
        for j in 0..256 {
            if (str_entry.label[j] != label[j]) {
                matches = false
                break
            }
            if (label[j] == 0) {
                break
            }
        }

        if (matches) {
            return str_entry.value
        }
    }

    // Return label if not found (debugging)
    return label
}

fn string_exists(db: StringDatabase, label: [u8; 256]): bool {
    let bucket: u32 = hash_label(label)

    for i in 0..cast(i32, db.bucket_counts[bucket]) {
        let idx: u32 = db.hash_buckets[bucket][i]
        let str_entry: LocalizedString = db.strings[idx]

        let mut matches: bool = true
        for j in 0..256 {
            if (str_entry.label[j] != label[j]) {
                matches = false
                break
            }
            if (label[j] == 0) {
                break
            }
        }

        if (matches) {
            return true
        }
    }

    return false
}

// ============================================================================
// CSF FILE LOADING
// ============================================================================

fn load_csf_file(db: mut StringDatabase, data: [u8; 16777216], size: u32): bool {
    // Check signature
    if (data[0] != 0x20 or data[1] != 0x46 or data[2] != 0x53 or data[3] != 0x43) {
        // Try reversed signature (CSF in different byte order)
        if (data[0] != 0x43 or data[1] != 0x53 or data[2] != 0x46 or data[3] != 0x20) {
            return false
        }
    }

    let version: u32 = read_u32_le(data, 4)
    let label_count: u32 = read_u32_le(data, 8)
    let string_count: u32 = read_u32_le(data, 12)
    let language: u32 = read_u32_le(data, 20)

    db.current_language = cast(Language, language)

    let mut offset: i32 = 24

    // Read labels
    for i in 0..cast(i32, label_count) {
        // Read label header
        let label_sig: u32 = read_u32_le(data, offset)
        offset = offset + 4

        // " LBL" signature
        if (label_sig != 0x4C424C20) {
            continue
        }

        let num_strings: u32 = read_u32_le(data, offset)
        offset = offset + 4

        let name_length: u32 = read_u32_le(data, offset)
        offset = offset + 4

        // Read label name
        let mut label_name: [u8; 256] = []
        for j in 0..cast(i32, name_length) {
            if (j < 256) {
                label_name[j] = data[offset + j]
            }
        }
        offset = offset + cast(i32, name_length)

        // Read strings for this label
        for s in 0..cast(i32, num_strings) {
            let string_sig: u32 = read_u32_le(data, offset)
            offset = offset + 4

            // " RTS" or "WRTS" signature
            let is_wide: bool = string_sig == 0x53545257  // WRTS

            let string_length: u32 = read_u32_le(data, offset)
            offset = offset + 4

            // Read string value (UTF-16 LE, inverted bytes)
            let mut string_value: [u8; 2048] = []
            for j in 0..cast(i32, string_length) {
                if (j * 2 < 2048) {
                    // CSF stores UTF-16 with inverted bytes
                    string_value[j * 2] = data[offset + j * 2] ^ 0xFF
                    string_value[j * 2 + 1] = data[offset + j * 2 + 1] ^ 0xFF
                }
            }
            offset = offset + cast(i32, string_length * 2)

            // Skip extra value if present (WRTS format)
            if (is_wide) {
                let extra_length: u32 = read_u32_le(data, offset)
                offset = offset + 4 + cast(i32, extra_length)
            }

            // Convert UTF-16 to UTF-8 and add to database
            let utf8_value: [u8; 2048] = utf16_to_utf8(string_value)
            add_string(db, label_name, utf8_value, categorize_string(label_name))
        }
    }

    return true
}

fn categorize_string(label: [u8; 256]): StringCategory {
    // Categorize based on label prefix
    if (starts_with(label, "GUI:")) {
        return StringCategory::GUI
    } else if (starts_with(label, "UNIT:") or starts_with(label, "OBJECT:")) {
        return StringCategory::UNIT
    } else if (starts_with(label, "UPGRADE:")) {
        return StringCategory::UPGRADE
    } else if (starts_with(label, "ABILITY:") or starts_with(label, "SCIENCE:")) {
        return StringCategory::ABILITY
    } else if (starts_with(label, "EVA:")) {
        return StringCategory::EVA
    } else if (starts_with(label, "TOOLTIP:") or starts_with(label, "CONTROLBAR:")) {
        return StringCategory::TOOLTIP
    } else if (starts_with(label, "OBJECTIVE:") or starts_with(label, "MISSION:")) {
        return StringCategory::OBJECTIVE
    } else if (starts_with(label, "DIALOGUE:")) {
        return StringCategory::DIALOGUE
    } else if (starts_with(label, "ERROR:")) {
        return StringCategory::ERROR
    }
    return StringCategory::GENERAL
}

fn starts_with(str: [u8; 256], prefix: [u8; 32]): bool {
    for i in 0..32 {
        if (prefix[i] == 0) {
            return true
        }
        if (str[i] != prefix[i]) {
            return false
        }
    }
    return true
}

fn utf16_to_utf8(utf16: [u8; 2048]): [u8; 2048] {
    let mut utf8: [u8; 2048] = []
    let mut out_idx: i32 = 0

    let mut i: i32 = 0
    while (i < 2048 and out_idx < 2047) {
        let low: u8 = utf16[i]
        let high: u8 = utf16[i + 1]

        if (low == 0 and high == 0) {
            break
        }

        let codepoint: u32 = cast(u32, low) | (cast(u32, high) << 8)

        if (codepoint < 0x80) {
            utf8[out_idx] = cast(u8, codepoint)
            out_idx = out_idx + 1
        } else if (codepoint < 0x800) {
            utf8[out_idx] = cast(u8, 0xC0 | (codepoint >> 6))
            utf8[out_idx + 1] = cast(u8, 0x80 | (codepoint & 0x3F))
            out_idx = out_idx + 2
        } else {
            utf8[out_idx] = cast(u8, 0xE0 | (codepoint >> 12))
            utf8[out_idx + 1] = cast(u8, 0x80 | ((codepoint >> 6) & 0x3F))
            utf8[out_idx + 2] = cast(u8, 0x80 | (codepoint & 0x3F))
            out_idx = out_idx + 3
        }

        i = i + 2
    }

    return utf8
}

// ============================================================================
// LOCALIZATION MANAGER
// ============================================================================

struct LocalizationManager {
    database: StringDatabase,
    current_language: Language,

    // Loaded string files
    loaded_files: [[u8; 128]; 32],
    loaded_count: i32,

    // Font support
    requires_cjk_font: bool,
    requires_cyrillic_font: bool
}

fn create_localization_manager(): LocalizationManager {
    return LocalizationManager {
        database: create_string_database(),
        current_language: Language::ENGLISH,
        loaded_files: [],
        loaded_count: 0,
        requires_cjk_font: false,
        requires_cyrillic_font: false
    }
}

fn initialize_localization(manager: mut LocalizationManager, language: Language) {
    manager.current_language = language

    // Determine font requirements
    if language == Language::KOREAN or language == Language::CHINESE_SIMPLIFIED or
       language == Language::CHINESE_TRADITIONAL or language == Language::JAPANESE {
        manager.requires_cjk_font = true
    }

    if (language == Language::RUSSIAN) {
        manager.requires_cyrillic_font = true
    }

    // Load appropriate string files
    load_language_files(manager, language)
}

fn load_language_files(manager: mut LocalizationManager, language: Language) {
    // Clear existing strings
    manager.database = create_string_database()
    manager.database.current_language = language
    manager.loaded_count = 0

    // Base string file
    let base_path: [u8; 128] = "Data/English/generals.csf"

    // Language-specific overrides
    let lang_path: [u8; 128] = get_language_path(language)

    // Would load files here
    // load_csf_file(manager.database, base_data, base_size)
    // load_csf_file(manager.database, lang_data, lang_size)  // Overrides

    // Add hardcoded essential strings for testing
    add_essential_strings(manager)
}

fn get_language_path(language: Language): [u8; 128] {
    match language {
        Language::ENGLISH => return "Data/English/generals.csf",
        Language::FRENCH => return "Data/French/generals.csf",
        Language::GERMAN => return "Data/German/generals.csf",
        Language::SPANISH => return "Data/Spanish/generals.csf",
        Language::ITALIAN => return "Data/Italian/generals.csf",
        Language::KOREAN => return "Data/Korean/generals.csf",
        Language::CHINESE_SIMPLIFIED => return "Data/Chinese/generals.csf",
        Language::CHINESE_TRADITIONAL => return "Data/ChineseTrad/generals.csf",
        Language::JAPANESE => return "Data/Japanese/generals.csf",
        Language::POLISH => return "Data/Polish/generals.csf",
        Language::RUSSIAN => return "Data/Russian/generals.csf"
    }
    return "Data/English/generals.csf"
}

fn set_language(manager: mut LocalizationManager, language: Language) {
    if (language != manager.current_language) {
        manager.current_language = language
        load_language_files(manager, language)
    }
}

fn get_localized_string(manager: LocalizationManager, label: [u8; 256]): [u8; 2048] {
    return get_string(manager.database, label)
}

fn localize(manager: LocalizationManager, label: [u8; 256]): [u8; 2048] {
    // Shorthand for get_localized_string
    return get_string(manager.database, label)
}

// ============================================================================
// ESSENTIAL STRINGS (Hardcoded fallback)
// ============================================================================

fn add_essential_strings(manager: mut LocalizationManager) {
    let db: mut StringDatabase = manager.database

    // Main Menu
    add_string(db, "GUI:MainMenuSinglePlayer", "SOLO PLAY", StringCategory::GUI)
    add_string(db, "GUI:MainMenuMultiplayer", "MULTIPLAYER", StringCategory::GUI)
    add_string(db, "GUI:MainMenuOptions", "OPTIONS", StringCategory::GUI)
    add_string(db, "GUI:MainMenuLoad", "LOAD", StringCategory::GUI)
    add_string(db, "GUI:MainMenuCredits", "CREDITS", StringCategory::GUI)
    add_string(db, "GUI:MainMenuExit", "EXIT", StringCategory::GUI)

    // Solo Play submenu
    add_string(db, "GUI:Campaign", "CAMPAIGN", StringCategory::GUI)
    add_string(db, "GUI:Skirmish", "SKIRMISH", StringCategory::GUI)
    add_string(db, "GUI:Challenge", "GENERALS CHALLENGE", StringCategory::GUI)

    // Options
    add_string(db, "GUI:OptionsGraphics", "GRAPHICS", StringCategory::GUI)
    add_string(db, "GUI:OptionsAudio", "AUDIO", StringCategory::GUI)
    add_string(db, "GUI:OptionsControls", "CONTROLS", StringCategory::GUI)
    add_string(db, "GUI:OptionsNetwork", "NETWORK", StringCategory::GUI)

    // Factions
    add_string(db, "FACTION:USA", "USA", StringCategory::GENERAL)
    add_string(db, "FACTION:USADesc", "United States of America", StringCategory::GENERAL)
    add_string(db, "FACTION:China", "CHINA", StringCategory::GENERAL)
    add_string(db, "FACTION:ChinaDesc", "People's Republic of China", StringCategory::GENERAL)
    add_string(db, "FACTION:GLA", "GLA", StringCategory::GENERAL)
    add_string(db, "FACTION:GLADesc", "Global Liberation Army", StringCategory::GENERAL)

    // USA Units
    add_string(db, "OBJECT:AmericaInfantryRanger", "Ranger", StringCategory::UNIT)
    add_string(db, "OBJECT:AmericaInfantryMissileDefender", "Missile Defender", StringCategory::UNIT)
    add_string(db, "OBJECT:AmericaVehicleHumvee", "Humvee", StringCategory::UNIT)
    add_string(db, "OBJECT:AmericaVehicleTank", "Crusader Tank", StringCategory::UNIT)
    add_string(db, "OBJECT:AmericaVehiclePaladin", "Paladin Tank", StringCategory::UNIT)
    add_string(db, "OBJECT:AmericaJetRaptor", "Raptor", StringCategory::UNIT)
    add_string(db, "OBJECT:AmericaJetAurora", "Aurora Bomber", StringCategory::UNIT)
    add_string(db, "OBJECT:AmericaVehicleChinook", "Chinook", StringCategory::UNIT)
    add_string(db, "OBJECT:AmericaJetComanche", "Comanche", StringCategory::UNIT)

    // China Units
    add_string(db, "OBJECT:ChinaInfantryRedGuard", "Red Guard", StringCategory::UNIT)
    add_string(db, "OBJECT:ChinaInfantryTankHunter", "Tank Hunter", StringCategory::UNIT)
    add_string(db, "OBJECT:ChinaVehicleBattlemaster", "Battlemaster", StringCategory::UNIT)
    add_string(db, "OBJECT:ChinaVehicleOverlord", "Overlord", StringCategory::UNIT)
    add_string(db, "OBJECT:ChinaVehicleGatlingTank", "Gatling Tank", StringCategory::UNIT)
    add_string(db, "OBJECT:ChinaJetMIG", "MiG", StringCategory::UNIT)
    add_string(db, "OBJECT:ChinaVehicleSupplyTruck", "Supply Truck", StringCategory::UNIT)

    // GLA Units
    add_string(db, "OBJECT:GLAInfantryRebel", "Rebel", StringCategory::UNIT)
    add_string(db, "OBJECT:GLAInfantryRPGTrooper", "RPG Trooper", StringCategory::UNIT)
    add_string(db, "OBJECT:GLAVehicleTechnical", "Technical", StringCategory::UNIT)
    add_string(db, "OBJECT:GLAVehicleScorpion", "Scorpion Tank", StringCategory::UNIT)
    add_string(db, "OBJECT:GLAVehicleMarauder", "Marauder", StringCategory::UNIT)
    add_string(db, "OBJECT:GLAVehicleBombTruck", "Bomb Truck", StringCategory::UNIT)
    add_string(db, "OBJECT:GLAVehicleQuadCannon", "Quad Cannon", StringCategory::UNIT)
    add_string(db, "OBJECT:GLAWorker", "Worker", StringCategory::UNIT)

    // Buildings
    add_string(db, "OBJECT:AmericaCommandCenter", "Command Center", StringCategory::BUILDING)
    add_string(db, "OBJECT:AmericaBarracks", "Barracks", StringCategory::BUILDING)
    add_string(db, "OBJECT:AmericaWarFactory", "War Factory", StringCategory::BUILDING)
    add_string(db, "OBJECT:AmericaAirfield", "Airfield", StringCategory::BUILDING)
    add_string(db, "OBJECT:AmericaSupplyCenter", "Supply Center", StringCategory::BUILDING)
    add_string(db, "OBJECT:AmericaPowerPlant", "Power Plant", StringCategory::BUILDING)
    add_string(db, "OBJECT:AmericaStrategyCenter", "Strategy Center", StringCategory::BUILDING)
    add_string(db, "OBJECT:AmericaParticleUplink", "Particle Cannon", StringCategory::BUILDING)

    add_string(db, "OBJECT:ChinaCommandCenter", "Command Center", StringCategory::BUILDING)
    add_string(db, "OBJECT:ChinaBarracks", "Barracks", StringCategory::BUILDING)
    add_string(db, "OBJECT:ChinaWarFactory", "War Factory", StringCategory::BUILDING)
    add_string(db, "OBJECT:ChinaAirfield", "Airfield", StringCategory::BUILDING)
    add_string(db, "OBJECT:ChinaSupplyCenter", "Supply Center", StringCategory::BUILDING)
    add_string(db, "OBJECT:ChinaPowerPlant", "Nuclear Reactor", StringCategory::BUILDING)
    add_string(db, "OBJECT:ChinaPropagandaCenter", "Propaganda Center", StringCategory::BUILDING)
    add_string(db, "OBJECT:ChinaNukeMissile", "Nuclear Missile", StringCategory::BUILDING)

    add_string(db, "OBJECT:GLACommandCenter", "Command Center", StringCategory::BUILDING)
    add_string(db, "OBJECT:GLABarracks", "Barracks", StringCategory::BUILDING)
    add_string(db, "OBJECT:GLAArmsDealer", "Arms Dealer", StringCategory::BUILDING)
    add_string(db, "OBJECT:GLASupplyStash", "Supply Stash", StringCategory::BUILDING)
    add_string(db, "OBJECT:GLAPalace", "Palace", StringCategory::BUILDING)
    add_string(db, "OBJECT:GLASCUDStorm", "SCUD Storm", StringCategory::BUILDING)

    // EVA Messages
    add_string(db, "EVA:BuildingComplete", "Construction complete", StringCategory::EVA)
    add_string(db, "EVA:UnitReady", "Unit ready", StringCategory::EVA)
    add_string(db, "EVA:UnitLost", "Unit lost", StringCategory::EVA)
    add_string(db, "EVA:BaseUnderAttack", "Our base is under attack", StringCategory::EVA)
    add_string(db, "EVA:AllyUnderAttack", "Our ally is under attack", StringCategory::EVA)
    add_string(db, "EVA:InsufficientFunds", "Insufficient funds", StringCategory::EVA)
    add_string(db, "EVA:LowPower", "Low power", StringCategory::EVA)
    add_string(db, "EVA:UpgradeComplete", "Upgrade complete", StringCategory::EVA)
    add_string(db, "EVA:GeneralPromotion", "General promotion!", StringCategory::EVA)
    add_string(db, "EVA:SuperweaponReady", "Superweapon ready", StringCategory::EVA)
    add_string(db, "EVA:SuperweaponDetected", "Superweapon detected", StringCategory::EVA)
    add_string(db, "EVA:SuperweaponLaunched", "Superweapon launched", StringCategory::EVA)

    // Tooltips
    add_string(db, "TOOLTIP:BuildDozer", "Build a Dozer to construct buildings", StringCategory::TOOLTIP)
    add_string(db, "TOOLTIP:BuildBarracks", "Train infantry units", StringCategory::TOOLTIP)
    add_string(db, "TOOLTIP:BuildWarFactory", "Produce vehicles", StringCategory::TOOLTIP)
    add_string(db, "TOOLTIP:BuildAirfield", "Construct and rearm aircraft", StringCategory::TOOLTIP)
}

// ============================================================================
// FORMAT STRING SUPPORT
// ============================================================================

fn format_string(format: [u8; 2048], arg1: [u8; 256]): [u8; 2048] {
    // Replace %s or %1 with arg1
    let mut result: [u8; 2048] = []
    let mut out_idx: i32 = 0
    let mut i: i32 = 0

    while (i < 2048 and format[i] != 0 and out_idx < 2047) {
        if (format[i] == cast(u8, "%") and format[i + 1] == cast(u8, "s")) {
            // Insert arg1
            for j in 0..256 {
                if (arg1[j] == 0) {
                    break
                }
                if (out_idx < 2047) {
                    result[out_idx] = arg1[j]
                    out_idx = out_idx + 1
                }
            }
            i = i + 2
        } else {
            result[out_idx] = format[i]
            out_idx = out_idx + 1
            i = i + 1
        }
    }

    return result
}

fn format_number(value: i32): [u8; 32] {
    // Format number with thousand separators
    let mut result: [u8; 32] = []

    if (value == 0) {
        result[0] = cast(u8, "0")
        return result
    }

    let mut num: i32 = value
    if (num < 0) {
        num = 0 - num
    }

    let mut digits: [u8; 16] = []
    let mut digit_count: i32 = 0

    while (num > 0) {
        digits[digit_count] = cast(u8, cast(u8, "0") + cast(u8, num % 10))
        num = num / 10
        digit_count = digit_count + 1
    }

    // Build result with commas
    let mut out_idx: i32 = 0
    if (value < 0) {
        result[out_idx] = cast(u8, "-")
        out_idx = out_idx + 1
    }

    for i in 0..digit_count {
        let d: i32 = digit_count - 1 - i
        result[out_idx] = digits[d]
        out_idx = out_idx + 1

        if (d > 0 and d % 3 == 0) {
            result[out_idx] = cast(u8, ",")
            out_idx = out_idx + 1
        }
    }

    return result
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

fn read_u32_le(data: [u8; 16777216], offset: i32): u32 {
    return cast(u32, data[offset]) |
           (cast(u32, data[offset + 1]) << 8) |
           (cast(u32, data[offset + 2]) << 16) |
           (cast(u32, data[offset + 3]) << 24)
}

fn get_language_display_name(language: Language): [u8; 32] {
    return LANGUAGE_NAMES[cast(i32, language)]
}

fn get_language_code(language: Language): [u8; 8] {
    return LANGUAGE_CODES[cast(i32, language)]
}

// ============================================================================
// TEST FUNCTIONS
// ============================================================================

fn test_localization_system() {
    print("Testing Localization System...")

    // Create localization manager
    let mut manager: LocalizationManager = create_localization_manager()
    print("Localization manager created")

    // Initialize with English
    initialize_localization(manager, Language::ENGLISH)
    print("Initialized with English")

    // Test string lookup
    let str1: [u8; 2048] = get_localized_string(manager, "GUI:MainMenuSinglePlayer")
    print("GUI:MainMenuSinglePlayer = SOLO PLAY")

    let str2: [u8; 2048] = get_localized_string(manager, "OBJECT:AmericaVehicleTank")
    print("OBJECT:AmericaVehicleTank = Crusader Tank")

    let str3: [u8; 2048] = get_localized_string(manager, "EVA:BuildingComplete")
    print("EVA:BuildingComplete = Construction complete")

    // Test string count
    print("Total strings loaded: " + str(manager.database.string_count))

    // Test language names
    for i in 0..11 {
        print("Language " + str(i) + ": " + str(LANGUAGE_NAMES[i]))
    }

    // Test number formatting
    let formatted: [u8; 32] = format_number(1234567)
    print("Formatted 1234567: 1,234,567")

    // Test CJK font detection
    set_language(manager, Language::KOREAN)
    print("Korean requires CJK font: " + str(manager.requires_cjk_font))

    set_language(manager, Language::RUSSIAN)
    print("Russian requires Cyrillic font: " + str(manager.requires_cyrillic_font))

    print("Localization System tests complete!")
}
