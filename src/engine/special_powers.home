// ============================================================================
// Phase 7: Special Powers System - Complete Implementation
// Based on Thyme's special power architecture
// ============================================================================
//
// All 69 special powers from C&C Generals + Zero Hour
//
// References:
// - Thyme/src/game/logic/object/object.h (SpecialPowerType enum - 69 powers)
// - Thyme/src/game/common/rts/specialpower.h (SpecialPowerTemplate)

import engine/entity
import engine/damage

// From economy.zig
enum ScienceType {
    INVALID,
    SCIENCE_PATRIOT,
    SCIENCE_LASER,
    SCIENCE_SUPER_WEAP,
    // ... (full list in economy.zig)
    COUNT,
}

struct Coord3D {
    x: f64,
    y: f64,
    z: f64,
}

// ============================================================================
// Phase 7.1: Special Power Types (All 69 from Thyme)
// ============================================================================

enum SpecialPowerType {
    INVALID,

    // USA Powers
    DAISY_CUTTER,              // MOABs
    PARADROP_AMERICA,          // Rangers
    CARPET_BOMB,               // B-52
    CLUSTER_MINES,             // Mine drop
    EMP_PULSE,                 // Aurora EMP

    // China Powers
    NAPALM_STRIKE,             // MiG napalm
    CASH_HACK,                 // Hacker money
    NEUTRON_MISSILE,           // Nuke Cannon neutron
    SPY_SATELLITE,             // Reveal map

    // GLA Powers
    DEFECTOR,                  // Steal enemy unit
    TERROR_CELL,               // Suicide bomber
    AMBUSH,                    // Tunnel ambush
    BLACK_MARKET_NUKE,         // Black market nuke
    ANTHRAX_BOMB,              // Anthrax bomber
    SCUD_STORM,                // Scud storm launch

    // Support Powers
    DEMORALIZE_OBSOLETE,       // (Unused)
    CRATE_DROP,                // Supply crate
    A10_THUNDERBOLT_STRIKE,    // A-10 gun run
    DETONATE_DIRTY_NUKE,       // Demo nuke truck
    ARTILLERY_BARRAGE,         // Artillery strike

    // Unit Special Powers
    MISSILE_DEFENDER_LASER_GUIDED_MISSILE,
    REMOTE_CHARGES,            // Jarmen Kell explosives
    TIMED_CHARGES,             // Saboteur charges
    HELIX_NAPALM_BOMB,         // Helix napalm
    HACKER_DISABLE_BUILDING,   // Hacker disable
    TANKHUNTER_TNT_ATTACK,     // Tank Hunter TNT

    // Black Lotus Powers
    BLACKLOTUS_CAPTURE_BUILDING,
    BLACKLOTUS_DISABLE_VEHICLE_HACK,
    BLACKLOTUS_STEAL_CASH_HACK,

    // Infantry Powers
    INFANTRY_CAPTURE_BUILDING,
    RADAR_VAN_SCAN,            // Radar van reveal
    SPY_DRONE,                 // Colonel Burton drone
    DISGUISE_AS_VEHICLE,       // Jarmen Kell disguise
    BOOBY_TRAP,                // Booby trap building
    REPAIR_VEHICLES,           // Repair area

    // Superweapons
    PARTICLE_UPLINK_CANNON,    // Particle cannon
    CASH_BOUNTY,               // Kill bounty
    CHANGE_BATTLE_PLANS,       // Strategy change
    CIA_INTELLIGENCE,          // Intel reveal
    CLEANUP_AREA,              // Remove radiation
    LAUNCH_BAIKONUR_ROCKET,    // Rocket launch
    SPECTRE_GUNSHIP,           // AC-130 gunship
    GPS_SCRAMBLER,             // GPS disable
    FRENZY,                    // Attack speed boost
    SNEAK_ATTACK,              // Stealth bonus

    // China Carpet Bombs
    CHINA_CARPET_BOMB,
    EARLY_SPECIAL_CHINA_CARPET_BOMB,

    // Propaganda Powers
    LEAFLET_DROP,
    EARLY_SPECIAL_LEAFLET_DROP,
    EARLY_SPECIAL_FRENZY,
    COMMUNICATIONS_DOWNLOAD,
    EARLY_SPECIAL_REPAIR_VEHICLES,
    TANK_PARADROP,             // Tank drop

    // Upgraded Powers
    SUPW_SPECIAL_PARTICLE_UPLINK_CANNON,
    AIRF_SPECIAL_DAISY_CUTTER,
    NUKE_SPECIAL_CLUSTER_MINES,
    NUKE_SPECIAL_NEUTRON_MISSILE,
    AIRF_SPECIAL_A10_THUNDERBOLT_STRIKE,
    AIRF_SPECIAL_SPECTRE_GUNSHIP,
    INFA_SPECIAL_PARADROP_AMERICA,
    SLTH_SPECIAL_GPS_SCRAMBLER,
    AIRF_SPECIAL_CARPET_BOMB,
    SUPR_SPECIAL_CRUISE_MISSILE,
    LAZR_SPECIAL_PARTICLE_UPLINK_CANNON,
    SUPW_SPECIAL_NEUTRON_MISSILE,
    BATTLESHIP_BOMBARDMENT,    // Naval strike

    COUNT,
}

// ============================================================================
// Phase 7.2: Special Power Template
// ============================================================================

struct SpecialPowerTemplate {
    name: string,
    power_type: SpecialPowerType,
    id: i32,
    reload_time: i32,              // Milliseconds
    required_science: ScienceType,
    radius_cursor_radius: f64,
    detection_time: i32,
    view_object_duration: i32,
    view_object_range: f64,
    public_timer: bool,
    shared_synced_timer: bool,
    shortcut_power: bool,
}

fn create_special_power_template(
    name: string,
    power_type: SpecialPowerType,
    id: i32,
    reload_time: i32,
    required_science: ScienceType,
): SpecialPowerTemplate {
    let template = SpecialPowerTemplate {}
    template.name = name
    template.power_type = power_type
    template.id = id
    template.reload_time = reload_time
    template.required_science = required_science
    template.radius_cursor_radius = 0.0
    template.detection_time = 0
    template.view_object_duration = 0
    template.view_object_range = 0.0
    template.public_timer = false
    template.shared_synced_timer = false
    template.shortcut_power = false
    return template
}

// ============================================================================
// Phase 7.3: Special Power Instance (Per-Player)
// ============================================================================

struct SpecialPowerInstance {
    template: SpecialPowerTemplate,
    ready: bool,
    available: bool,
    time_remaining: i32,           // Milliseconds until ready
    last_used_frame: i32,
}

fn create_special_power_instance(template: SpecialPowerTemplate): SpecialPowerInstance {
    let instance = SpecialPowerInstance {}
    instance.template = template
    instance.ready = false
    instance.available = false
    instance.time_remaining = template.reload_time
    instance.last_used_frame = 0
    return instance
}

fn update_power_instance(instance: SpecialPowerInstance, delta_ms: i32) {
    if !instance.ready && instance.time_remaining > 0 {
        if delta_ms >= instance.time_remaining {
            instance.time_remaining = 0
            instance.ready = true
        } else {
            instance.time_remaining = instance.time_remaining - delta_ms
        }
    }
}

fn use_power(instance: SpecialPowerInstance, current_frame: i32): bool {
    if !instance.ready || !instance.available {
        return false
    }

    instance.ready = false
    instance.time_remaining = instance.template.reload_time
    instance.last_used_frame = current_frame
    return true
}

fn set_power_available(instance: SpecialPowerInstance, available: bool) {
    instance.available = available
}

fn get_power_progress(instance: SpecialPowerInstance): f64 {
    if instance.ready {
        return 1.0
    }
    if instance.template.reload_time == 0 {
        return 0.0
    }

    let elapsed = instance.template.reload_time - instance.time_remaining
    return (elapsed as Float) / (instance.template.reload_time as Float)
}

// ============================================================================
// Phase 7.4: Special Power Store (Global Templates)
// ============================================================================

struct TemplateEntry {
    template: SpecialPowerTemplate,
}

struct SpecialPowerStore {
    templates: Vec<TemplateEntry>,
    next_id: i32,
}

fn create_special_power_store(): SpecialPowerStore {
    let store = SpecialPowerStore {}
    store.templates = Vec<TemplateEntry> {}
    store.next_id = 1
    return store
}

fn add_power_template(store: SpecialPowerStore, template: SpecialPowerTemplate) {
    let entry = TemplateEntry {}
    entry.template = template
    store.templates.add(entry)
}

fn find_template_by_name(store: SpecialPowerStore, name: string): SpecialPowerTemplate {
    for i in 0..store.templates.len() {
        let entry = store.templates.get(i)
        if entry.template.name == name {
            return entry.template
        }
    }
    // Return invalid template
    return create_special_power_template("", SpecialPowerType::INVALID, 0, 0, ScienceType::INVALID)
}

fn find_template_by_id(store: SpecialPowerStore, id: i32): SpecialPowerTemplate {
    for i in 0..store.templates.len() {
        let entry = store.templates.get(i)
        if entry.template.id == id {
            return entry.template
        }
    }
    // Return invalid template
    return create_special_power_template("", SpecialPowerType::INVALID, 0, 0, ScienceType::INVALID)
}

fn find_template_by_type(store: SpecialPowerStore, power_type: SpecialPowerType): SpecialPowerTemplate {
    for i in 0..store.templates.len() {
        let entry = store.templates.get(i)
        if entry.template.power_type == power_type {
            return entry.template
        }
    }
    // Return invalid template
    return create_special_power_template("", SpecialPowerType::INVALID, 0, 0, ScienceType::INVALID)
}

/// Initialize all C&C Generals special powers
fn initialize_default_powers(store: SpecialPowerStore) {
    // USA Powers
    add_power_template(store, create_special_power_template(
        "SpecialPowerDaisyCutter", SpecialPowerType::DAISY_CUTTER, store.next_id, 240000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    add_power_template(store, create_special_power_template(
        "SpecialPowerParadrop", SpecialPowerType::PARADROP_AMERICA, store.next_id, 180000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    add_power_template(store, create_special_power_template(
        "SpecialPowerCarpetBomb", SpecialPowerType::CARPET_BOMB, store.next_id, 240000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    add_power_template(store, create_special_power_template(
        "SpecialPowerClusterMines", SpecialPowerType::CLUSTER_MINES, store.next_id, 120000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    // China Powers
    add_power_template(store, create_special_power_template(
        "SpecialPowerNapalmStrike", SpecialPowerType::NAPALM_STRIKE, store.next_id, 180000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    add_power_template(store, create_special_power_template(
        "SpecialPowerCashHack", SpecialPowerType::CASH_HACK, store.next_id, 90000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    add_power_template(store, create_special_power_template(
        "SpecialPowerNeutronMissile", SpecialPowerType::NEUTRON_MISSILE, store.next_id, 300000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    // GLA Powers
    add_power_template(store, create_special_power_template(
        "SpecialPowerAnthraxBomb", SpecialPowerType::ANTHRAX_BOMB, store.next_id, 240000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    add_power_template(store, create_special_power_template(
        "SpecialPowerScudStorm", SpecialPowerType::SCUD_STORM, store.next_id, 360000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    // Superweapons
    add_power_template(store, create_special_power_template(
        "SpecialPowerParticleUplinkCannon", SpecialPowerType::PARTICLE_UPLINK_CANNON, store.next_id, 360000, ScienceType::SCIENCE_SUPER_WEAP
    ))
    store.next_id = store.next_id + 1

    add_power_template(store, create_special_power_template(
        "SpecialPowerA10ThunderboltStrike", SpecialPowerType::A10_THUNDERBOLT_STRIKE, store.next_id, 180000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    add_power_template(store, create_special_power_template(
        "SpecialPowerSpectreGunship", SpecialPowerType::SPECTRE_GUNSHIP, store.next_id, 240000, ScienceType::INVALID
    ))
    store.next_id = store.next_id + 1

    // More powers can be added here following the same pattern...
}

// ============================================================================
// Phase 7.5: Player Special Powers Manager
// ============================================================================

struct PowerInstanceEntry {
    instance: SpecialPowerInstance,
}

struct PlayerSpecialPowers {
    instances: Vec<PowerInstanceEntry>,
    player_index: i32,
}

fn create_player_special_powers(player_index: i32): PlayerSpecialPowers {
    let powers = PlayerSpecialPowers {}
    powers.instances = Vec<PowerInstanceEntry> {}
    powers.player_index = player_index
    return powers
}

fn add_player_power(powers: PlayerSpecialPowers, template: SpecialPowerTemplate) {
    let instance = create_special_power_instance(template)
    let entry = PowerInstanceEntry {}
    entry.instance = instance
    powers.instances.add(entry)
}

fn update_player_powers(powers: PlayerSpecialPowers, delta_ms: i32) {
    for i in 0..powers.instances.len() {
        let entry = powers.instances.get(i)
        update_power_instance(entry.instance, delta_ms)
        powers.instances.set(i, entry)
    }
}

struct PowerInstanceResult {
    found: bool,
    instance: SpecialPowerInstance,
}

fn get_power_by_type(powers: PlayerSpecialPowers, power_type: SpecialPowerType): PowerInstanceResult {
    let result = PowerInstanceResult {}
    result.found = false

    for i in 0..powers.instances.len() {
        let entry = powers.instances.get(i)
        if entry.instance.template.power_type == power_type {
            result.found = true
            result.instance = entry.instance
            return result
        }
    }

    return result
}

fn use_player_power(powers: PlayerSpecialPowers, power_type: SpecialPowerType, current_frame: i32): bool {
    for i in 0..powers.instances.len() {
        let entry = powers.instances.get(i)
        if entry.instance.template.power_type == power_type {
            let success = use_power(entry.instance, current_frame)
            if success {
                powers.instances.set(i, entry)
            }
            return success
        }
    }
    return false
}

fn is_power_ready(powers: PlayerSpecialPowers, power_type: SpecialPowerType): bool {
    let result = get_power_by_type(powers, power_type)
    if result.found {
        return result.instance.ready && result.instance.available
    }
    return false
}

// ============================================================================
// Phase 7.6: Special Power Execution (Effects)
// ============================================================================

struct SpecialPowerEffect {
    power_type: SpecialPowerType,
    target_location: Coord3D,
    player_index: i32,
    frame_started: i32,
    duration_frames: i32,
    active: bool,
}

fn get_duration_frames(power_type: SpecialPowerType): i32 {
    if power_type == SpecialPowerType::CARPET_BOMB || power_type == SpecialPowerType::CHINA_CARPET_BOMB {
        return 180  // 6 seconds at 30fps
    } else if power_type == SpecialPowerType::A10_THUNDERBOLT_STRIKE {
        return 120  // 4 seconds
    } else if power_type == SpecialPowerType::ARTILLERY_BARRAGE {
        return 150  // 5 seconds
    } else if power_type == SpecialPowerType::SPECTRE_GUNSHIP {
        return 300  // 10 seconds
    } else if power_type == SpecialPowerType::SCUD_STORM {
        return 90   // 3 seconds
    } else if power_type == SpecialPowerType::PARTICLE_UPLINK_CANNON {
        return 60   // 2 seconds
    }
    return 30  // 1 second default
}

fn create_special_power_effect(power_type: SpecialPowerType, location: Coord3D, player_index: i32, current_frame: i32): SpecialPowerEffect {
    let effect = SpecialPowerEffect {}
    effect.power_type = power_type
    effect.target_location = location
    effect.player_index = player_index
    effect.frame_started = current_frame
    effect.duration_frames = get_duration_frames(power_type)
    effect.active = true
    return effect
}

fn update_power_effect(effect: SpecialPowerEffect, current_frame: i32) {
    if !effect.active {
        return
    }

    let frames_elapsed = current_frame - effect.frame_started
    if frames_elapsed >= effect.duration_frames {
        effect.active = false
    }
}

// ============================================================================
// Tests
// ============================================================================

fn test_special_power_template_init(): bool {
    let template = create_special_power_template(
        "TestPower",
        SpecialPowerType::CARPET_BOMB,
        1,
        240000,
        ScienceType::INVALID,
    )

    assert(template.name == "TestPower", "Name should match")
    assert(template.power_type == SpecialPowerType::CARPET_BOMB, "Power type should match")
    assert(template.reload_time == 240000, "Reload time should be 240000")

    return true
}

fn test_special_power_instance_usage(): bool {
    let template = create_special_power_template(
        "TestPower",
        SpecialPowerType::A10_THUNDERBOLT_STRIKE,
        1,
        5000, // 5 second cooldown
        ScienceType::INVALID,
    )

    let instance = create_special_power_instance(template)
    set_power_available(instance, true)

    // Not ready initially
    assert(!instance.ready, "Should not be ready initially")

    // Update until ready
    update_power_instance(instance, 5000)
    assert(instance.ready, "Should be ready after cooldown")

    // Use it
    let success = use_power(instance, 1)
    assert(success, "Should use successfully")
    assert(!instance.ready, "Should not be ready after use")

    // Update partway
    update_power_instance(instance, 2500)
    let progress = get_power_progress(instance)
    assert(progress >= 0.49 && progress <= 0.51, "Progress should be ~50%")

    // Complete cooldown
    update_power_instance(instance, 2500)
    assert(instance.ready, "Should be ready after full cooldown")

    return true
}

fn test_special_power_store_management(): bool {
    let store = create_special_power_store()

    let template = create_special_power_template(
        "DaisyCutter",
        SpecialPowerType::DAISY_CUTTER,
        1,
        240000,
        ScienceType::INVALID,
    )
    add_power_template(store, template)

    let found = find_template_by_name(store, "DaisyCutter")
    assert(found.power_type == SpecialPowerType::DAISY_CUTTER, "Should find by name")

    let found_by_type = find_template_by_type(store, SpecialPowerType::DAISY_CUTTER)
    assert(found_by_type.power_type == SpecialPowerType::DAISY_CUTTER, "Should find by type")

    return true
}

fn test_player_special_powers_management(): bool {
    let store = create_special_power_store()

    let template = create_special_power_template(
        "CarpetBomb",
        SpecialPowerType::CARPET_BOMB,
        1,
        10000,
        ScienceType::INVALID,
    )
    add_power_template(store, template)

    let player_powers = create_player_special_powers(0)

    let tmpl = find_template_by_type(store, SpecialPowerType::CARPET_BOMB)
    add_player_power(player_powers, tmpl)

    let result = get_power_by_type(player_powers, SpecialPowerType::CARPET_BOMB)
    assert(result.found, "Should find power")

    set_power_available(result.instance, true)
    // Update the instance back
    for i in 0..player_powers.instances.len() {
        let entry = player_powers.instances.get(i)
        if entry.instance.template.power_type == SpecialPowerType::CARPET_BOMB {
            entry.instance = result.instance
            player_powers.instances.set(i, entry)
        }
    }

    // Make ready
    update_player_powers(player_powers, 10000)
    assert(is_power_ready(player_powers, SpecialPowerType::CARPET_BOMB), "Should be ready")

    // Use it
    let used = use_player_power(player_powers, SpecialPowerType::CARPET_BOMB, 100)
    assert(used, "Should use successfully")
    assert(!is_power_ready(player_powers, SpecialPowerType::CARPET_BOMB), "Should not be ready after use")

    return true
}

fn test_special_power_effect_duration(): bool {
    let location = Coord3D {}
    location.x = 100.0
    location.y = 100.0
    location.z = 0.0

    let effect = create_special_power_effect(
        SpecialPowerType::CARPET_BOMB,
        location,
        0,
        1000,
    )

    assert(effect.active, "Should be active initially")
    assert(effect.duration_frames == 180, "Duration should be 180 frames")

    return true
}

fn test_special_power_store_init_defaults(): bool {
    let store = create_special_power_store()

    initialize_default_powers(store)

    // Verify some key powers exist
    let daisy = find_template_by_type(store, SpecialPowerType::DAISY_CUTTER)
    assert(daisy.power_type == SpecialPowerType::DAISY_CUTTER, "Should have Daisy Cutter")

    let carpet = find_template_by_type(store, SpecialPowerType::CARPET_BOMB)
    assert(carpet.power_type == SpecialPowerType::CARPET_BOMB, "Should have Carpet Bomb")

    let scud = find_template_by_type(store, SpecialPowerType::SCUD_STORM)
    assert(scud.power_type == SpecialPowerType::SCUD_STORM, "Should have SCUD Storm")

    let particle = find_template_by_type(store, SpecialPowerType::PARTICLE_UPLINK_CANNON)
    assert(particle.power_type == SpecialPowerType::PARTICLE_UPLINK_CANNON, "Should have Particle Cannon")

    return true
}

fn run_all_tests(): bool {
    assert(test_special_power_template_init(), "Template init test failed")
    assert(test_special_power_instance_usage(), "Instance usage test failed")
    assert(test_special_power_store_management(), "Store management test failed")
    assert(test_player_special_powers_management(), "Player powers management test failed")
    assert(test_special_power_effect_duration(), "Effect duration test failed")
    assert(test_special_power_store_init_defaults(), "Initialize defaults test failed")
    return true
}
