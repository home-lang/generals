// Network system for C&C Generals Zero Hour
// Multiplayer, lobbies, game synchronization
// Written in Home language

import player
import object

// Network message types
enum MessageType {
    // Connection
    CONNECT_REQUEST = 0,
    CONNECT_ACCEPT = 1,
    CONNECT_REJECT = 2,
    DISCONNECT = 3,

    // Lobby
    LOBBY_CREATE = 10,
    LOBBY_JOIN = 11,
    LOBBY_LEAVE = 12,
    LOBBY_UPDATE = 13,
    LOBBY_START_GAME = 14,

    // Game sync
    GAME_STATE = 20,
    PLAYER_COMMAND = 21,
    OBJECT_UPDATE = 22,
    FRAME_SYNC = 23,

    // Chat
    CHAT_MESSAGE = 30,
}

// Player connection status
enum ConnectionStatus {
    DISCONNECTED = 0,
    CONNECTING = 1,
    CONNECTED = 2,
    SYNCING = 3,
    IN_GAME = 4,
}

// Network player
struct NetworkPlayer {
    player_id: i32,
    name: string,
    connection_status: ConnectionStatus,
    ping_ms: i32,
    last_frame_ack: i32,
    is_host: bool,

    fn init(player_id: i32, name: string): NetworkPlayer {
        return NetworkPlayer {
            player_id: player_id,
            name: name,
            connection_status: ConnectionStatus::DISCONNECTED,
            ping_ms: 0,
            last_frame_ack: 0,
            is_host: false,
        }
    }

    fn is_connected(&self): bool {
        return self.connection_status == ConnectionStatus::CONNECTED ||
               self.connection_status == ConnectionStatus::IN_GAME
    }

    fn is_synced(&self): bool {
        return self.connection_status == ConnectionStatus::IN_GAME
    }

    fn update_ping(&self, ping_ms: i32) {
        self.ping_ms = ping_ms
    }
}

// Network message
struct NetworkMessage {
    message_type: MessageType,
    sender_id: i32,
    frame_number: i32,
    data: string,
    timestamp: f64,

    fn init(message_type: MessageType, sender_id: i32): NetworkMessage {
        return NetworkMessage {
            message_type: message_type,
            sender_id: sender_id,
            frame_number: 0,
            data: "",
            timestamp: 0.0,
        }
    }

    fn set_data(&self, data: string) {
        self.data = data
    }

    fn get_size(&self): i32 {
        return self.data.length() + 20  // Header + data
    }
}

// Player command for game sync
struct PlayerCommand {
    player_id: i32,
    frame_number: i32,
    command_type: CommandType,
    object_ids: Vec<i32>,
    target_position: Vec3?,
    target_object_id: i32,

    fn init(player_id: i32, frame_number: i32, command_type: CommandType): PlayerCommand {
        return PlayerCommand {
            player_id: player_id,
            frame_number: frame_number,
            command_type: command_type,
            object_ids: Vec::new(),
            target_position: null,
            target_object_id: -1,
        }
    }

    fn add_object(&self, object_id: i32) {
        self.object_ids.add(object_id)
    }

    fn set_target_position(&self, pos: Vec3) {
        self.target_position = pos
    }
}

enum CommandType {
    MOVE = 0,
    ATTACK = 1,
    ATTACK_MOVE = 2,
    STOP = 3,
    BUILD = 4,
    PRODUCE_UNIT = 5,
    CANCEL_PRODUCTION = 6,
    USE_ABILITY = 7,
}

// Game lobby
struct GameLobby {
    lobby_id: i32,
    name: string,
    host_id: i32,
    players: Vec<NetworkPlayer>,
    max_players: i32,
    map_name: string,
    is_started: bool,
    is_locked: bool,

    fn init(lobby_id: i32, name: string, host_id: i32): GameLobby {
        return GameLobby {
            lobby_id: lobby_id,
            name: name,
            host_id: host_id,
            players: Vec::new(),
            max_players: 8,
            map_name: "",
            is_started: false,
            is_locked: false,
        }
    }

    fn add_player(&self, player: NetworkPlayer): bool {
        if self.is_full() || self.is_locked {
            return false
        }

        self.players.add(player)
        return true
    }

    fn remove_player(&self, player_id: i32): bool {
        for i in 0..self.players.count() {
            let player = self.players.get(i)
            if player.player_id == player_id {
                self.players.remove(i)
                return true
            }
        }
        return false
    }

    fn get_player(&self, player_id: i32): NetworkPlayer? {
        for player in self.players {
            if player.player_id == player_id {
                return player
            }
        }
        return null
    }

    fn get_player_count(&self): i32 {
        return self.players.count()
    }

    fn is_full(&self): bool {
        return self.players.count() >= self.max_players
    }

    fn set_map(&self, map_name: string) {
        self.map_name = map_name
    }

    fn start_game(&self) {
        if self.players.count() < 2 {
            return
        }

        self.is_started = true
        self.is_locked = true
    }

    fn is_host(&self, player_id: i32): bool {
        return player_id == self.host_id
    }
}

// Chat message
struct ChatMessage {
    sender_id: i32,
    sender_name: string,
    message: string,
    timestamp: f64,
    is_team_only: bool,

    fn init(sender_id: i32, sender_name: string, message: string): ChatMessage {
        return ChatMessage {
            sender_id: sender_id,
            sender_name: sender_name,
            message: message,
            timestamp: 0.0,
            is_team_only: false,
        }
    }

    fn make_team_only(&self) {
        self.is_team_only = true
    }
}

// Network game state
struct NetworkGameState {
    current_frame: i32,
    frame_buffer: Vec<Vec<PlayerCommand>>,
    waiting_for_frames: Vec<i32>,
    is_paused: bool,

    fn init(): NetworkGameState {
        return NetworkGameState {
            current_frame: 0,
            frame_buffer: Vec::new(),
            waiting_for_frames: Vec::new(),
            is_paused: false,
        }
    }

    fn queue_command(&self, command: PlayerCommand) {
        // Ensure buffer has enough frames
        while self.frame_buffer.count() <= command.frame_number {
            self.frame_buffer.add(Vec::new())
        }

        let frame_commands = self.frame_buffer.get(command.frame_number)
        frame_commands.add(command)
    }

    fn get_commands_for_frame(&self, frame: i32): Vec<PlayerCommand>? {
        if frame < self.frame_buffer.count() {
            return self.frame_buffer.get(frame)
        }
        return null
    }

    fn can_advance_frame(&self): bool {
        if self.is_paused {
            return false
        }

        // Check if all players have sent commands for next frame
        return self.waiting_for_frames.count() == 0
    }

    fn advance_frame(&self) {
        self.current_frame = self.current_frame + 1
    }

    fn wait_for_player(&self, player_id: i32) {
        if !self.waiting_for_frames.contains(player_id) {
            self.waiting_for_frames.add(player_id)
        }
    }

    fn player_ready(&self, player_id: i32) {
        for i in 0..self.waiting_for_frames.count() {
            if self.waiting_for_frames.get(i) == player_id {
                self.waiting_for_frames.remove(i)
                return
            }
        }
    }
}

// Network manager
struct NetworkManager {
    local_player_id: i32,
    players: Vec<NetworkPlayer>,
    lobbies: Vec<GameLobby>,
    current_lobby: GameLobby?,
    game_state: NetworkGameState,
    pending_messages: Vec<NetworkMessage>,
    chat_history: Vec<ChatMessage>,
    bytes_sent: i32,
    bytes_received: i32,
    is_hosting: bool,

    fn init(local_player_id: i32): NetworkManager {
        return NetworkManager {
            local_player_id: local_player_id,
            players: Vec::new(),
            lobbies: Vec::new(),
            current_lobby: null,
            game_state: NetworkGameState::init(),
            pending_messages: Vec::new(),
            chat_history: Vec::new(),
            bytes_sent: 0,
            bytes_received: 0,
            is_hosting: false,
        }
    }

    fn create_lobby(&self, name: string): i32 {
        let lobby = GameLobby::init(self.lobbies.count(), name, self.local_player_id)
        self.lobbies.add(lobby)
        self.current_lobby = lobby
        self.is_hosting = true

        let local_player = NetworkPlayer::init(self.local_player_id, "Host")
        local_player.is_host = true
        local_player.connection_status = ConnectionStatus::CONNECTED
        lobby.add_player(local_player)

        return lobby.lobby_id
    }

    fn join_lobby(&self, lobby_id: i32, player_name: string): bool {
        for lobby in self.lobbies {
            if lobby.lobby_id == lobby_id {
                let player = NetworkPlayer::init(self.local_player_id, player_name)
                if lobby.add_player(player) {
                    self.current_lobby = lobby
                    return true
                }
            }
        }
        return false
    }

    fn leave_lobby(&self) {
        if let Some(lobby) = self.current_lobby {
            lobby.remove_player(self.local_player_id)
            self.current_lobby = null
            self.is_hosting = false
        }
    }

    fn start_game(&self): bool {
        if !self.is_hosting {
            return false
        }

        if let Some(lobby) = self.current_lobby {
            lobby.start_game()
            return true
        }

        return false
    }

    fn send_command(&self, command: PlayerCommand) {
        self.game_state.queue_command(command)

        let msg = NetworkMessage::init(MessageType::PLAYER_COMMAND, self.local_player_id)
        msg.frame_number = command.frame_number
        self.pending_messages.add(msg)
    }

    fn send_chat(&self, message: string, team_only: bool) {
        let chat = ChatMessage::init(self.local_player_id, "LocalPlayer", message)
        if team_only {
            chat.make_team_only()
        }

        self.chat_history.add(chat)

        let msg = NetworkMessage::init(MessageType::CHAT_MESSAGE, self.local_player_id)
        msg.set_data(message)
        self.pending_messages.add(msg)
    }

    fn update(&self, delta_time: f64) {
        // Process pending messages
        self.process_messages()

        // Update game state if in game
        if let Some(lobby) = self.current_lobby {
            if lobby.is_started {
                self.update_game_sync(delta_time)
            }
        }
    }

    fn process_messages(&self) {
        for msg in self.pending_messages {
            self.bytes_sent = self.bytes_sent + msg.get_size()
        }

        self.pending_messages.clear()
    }

    fn update_game_sync(&self, delta_time: f64) {
        if self.game_state.can_advance_frame() {
            self.game_state.advance_frame()
        }
    }

    fn get_current_frame(&self): i32 {
        return self.game_state.current_frame
    }

    fn get_connected_count(&self): i32 {
        let count = 0
        for player in self.players {
            if player.is_connected() {
                count = count + 1
            }
        }
        return count
    }

    fn get_chat_history_count(&self): i32 {
        return self.chat_history.count()
    }
}

// Helper structs
struct Vec3 {
    x: f64,
    y: f64,
    z: f64,

    fn init(x: f64, y: f64, z: f64): Vec3 {
        return Vec3 { x: x, y: y, z: z }
    }
}

// Tests
test "NetworkPlayer: init" {
    let player = NetworkPlayer::init(0, "Player1")

    assert player.name == "Player1"
    assert player.connection_status == ConnectionStatus::DISCONNECTED
    assert !player.is_host
    assert player.ping_ms == 0
}

test "NetworkPlayer: connection status" {
    let player = NetworkPlayer::init(0, "Player1")

    assert !player.is_connected()

    player.connection_status = ConnectionStatus::CONNECTED
    assert player.is_connected()
    assert !player.is_synced()

    player.connection_status = ConnectionStatus::IN_GAME
    assert player.is_synced()
}

test "NetworkPlayer: ping update" {
    let player = NetworkPlayer::init(0, "Player1")

    player.update_ping(50)
    assert player.ping_ms == 50
}

test "NetworkMessage: init and data" {
    let msg = NetworkMessage::init(MessageType::CHAT_MESSAGE, 5)

    assert msg.message_type == MessageType::CHAT_MESSAGE
    assert msg.sender_id == 5

    msg.set_data("Hello!")
    assert msg.data == "Hello!"
    assert msg.get_size() > 20
}

test "PlayerCommand: init" {
    let cmd = PlayerCommand::init(0, 100, CommandType::MOVE)

    assert cmd.player_id == 0
    assert cmd.frame_number == 100
    assert cmd.command_type == CommandType::MOVE
    assert cmd.object_ids.count() == 0
}

test "PlayerCommand: add objects" {
    let cmd = PlayerCommand::init(0, 100, CommandType::ATTACK)

    cmd.add_object(50)
    cmd.add_object(51)
    cmd.add_object(52)

    assert cmd.object_ids.count() == 3
}

test "PlayerCommand: target position" {
    let cmd = PlayerCommand::init(0, 100, CommandType::MOVE)

    let pos = Vec3::init(500.0, 0.0, 300.0)
    cmd.set_target_position(pos)

    assert cmd.target_position != null
    let target = cmd.target_position?
    assert target.x == 500.0
}

test "GameLobby: init" {
    let lobby = GameLobby::init(0, "Test Game", 1)

    assert lobby.name == "Test Game"
    assert lobby.host_id == 1
    assert lobby.get_player_count() == 0
    assert !lobby.is_started
    assert !lobby.is_locked
}

test "GameLobby: add and remove players" {
    let lobby = GameLobby::init(0, "Test", 1)

    let player1 = NetworkPlayer::init(1, "Host")
    let player2 = NetworkPlayer::init(2, "Player2")

    assert lobby.add_player(player1)
    assert lobby.add_player(player2)
    assert lobby.get_player_count() == 2

    assert lobby.remove_player(2)
    assert lobby.get_player_count() == 1
}

test "GameLobby: full check" {
    let lobby = GameLobby::init(0, "Test", 1)
    lobby.max_players = 2

    let player1 = NetworkPlayer::init(1, "P1")
    let player2 = NetworkPlayer::init(2, "P2")
    let player3 = NetworkPlayer::init(3, "P3")

    lobby.add_player(player1)
    assert !lobby.is_full()

    lobby.add_player(player2)
    assert lobby.is_full()

    assert !lobby.add_player(player3)  // Should fail
}

test "GameLobby: start game" {
    let lobby = GameLobby::init(0, "Test", 1)

    lobby.add_player(NetworkPlayer::init(1, "P1"))
    lobby.add_player(NetworkPlayer::init(2, "P2"))

    lobby.start_game()

    assert lobby.is_started
    assert lobby.is_locked
}

test "GameLobby: host check" {
    let lobby = GameLobby::init(0, "Test", 5)

    assert lobby.is_host(5)
    assert !lobby.is_host(10)
}

test "ChatMessage: init" {
    let chat = ChatMessage::init(1, "Alice", "Hello everyone!")

    assert chat.sender_name == "Alice"
    assert chat.message == "Hello everyone!"
    assert !chat.is_team_only
}

test "ChatMessage: team only" {
    let chat = ChatMessage::init(1, "Bob", "Attack now")

    chat.make_team_only()
    assert chat.is_team_only
}

test "NetworkGameState: init" {
    let state = NetworkGameState::init()

    assert state.current_frame == 0
    assert !state.is_paused
}

test "NetworkGameState: queue command" {
    let state = NetworkGameState::init()

    let cmd = PlayerCommand::init(0, 5, CommandType::MOVE)
    state.queue_command(cmd)

    let commands = state.get_commands_for_frame(5)?
    assert commands.count() == 1
}

test "NetworkGameState: advance frame" {
    let state = NetworkGameState::init()

    assert state.current_frame == 0

    state.advance_frame()
    assert state.current_frame == 1
}

test "NetworkGameState: wait for players" {
    let state = NetworkGameState::init()

    state.wait_for_player(1)
    state.wait_for_player(2)

    assert !state.can_advance_frame()

    state.player_ready(1)
    assert !state.can_advance_frame()

    state.player_ready(2)
    assert state.can_advance_frame()
}

test "NetworkManager: init" {
    let manager = NetworkManager::init(0)

    assert manager.local_player_id == 0
    assert !manager.is_hosting
    assert manager.bytes_sent == 0
}

test "NetworkManager: create lobby" {
    let manager = NetworkManager::init(0)

    let lobby_id = manager.create_lobby("My Game")

    assert lobby_id == 0
    assert manager.is_hosting
    assert manager.current_lobby != null
}

test "NetworkManager: join lobby" {
    let manager = NetworkManager::init(0)

    let lobby_id = manager.create_lobby("Host Game")

    let manager2 = NetworkManager::init(1)
    let joined = manager2.join_lobby(lobby_id, "Player2")

    // Would need proper lobby sharing for this to work
    // Just test the structure
    assert !manager2.is_hosting
}

test "NetworkManager: leave lobby" {
    let manager = NetworkManager::init(0)

    manager.create_lobby("Test")
    assert manager.current_lobby != null

    manager.leave_lobby()
    assert manager.current_lobby == null
    assert !manager.is_hosting
}

test "NetworkManager: send command" {
    let manager = NetworkManager::init(0)

    let cmd = PlayerCommand::init(0, 10, CommandType::ATTACK)
    manager.send_command(cmd)

    assert manager.pending_messages.count() == 1
}

test "NetworkManager: send chat" {
    let manager = NetworkManager::init(0)

    manager.send_chat("Hello!", false)

    assert manager.chat_history.count() == 1
    assert manager.pending_messages.count() == 1
}

test "NetworkManager: get frame" {
    let manager = NetworkManager::init(0)

    assert manager.get_current_frame() == 0

    manager.game_state.advance_frame()
    assert manager.get_current_frame() == 1
}

test "NetworkManager: process messages" {
    let manager = NetworkManager::init(0)

    let msg = NetworkMessage::init(MessageType::CHAT_MESSAGE, 0)
    msg.set_data("Test")
    manager.pending_messages.add(msg)

    manager.process_messages()

    assert manager.bytes_sent > 0
    assert manager.pending_messages.count() == 0
}
