// Create Module - Object Creation and Initialization
// Based on Thyme engine create module architecture
// Handles object spawning, initial state, and creation effects

from behavior_module import ModuleData, create_module_data, get_property, get_property_int, get_property_float, get_property_bool

// ============================================================================
// Create Types
// ============================================================================

enum CreateType {
    Default,        // Standard creation
    VeterancyGain,  // Created with veterancy
    SpawnFromDeath, // Spawned when another dies
    Production,     // Built by building
    Paradrop,       // Paradroped from aircraft
    Reinforcement,  // Called in reinforcements
    Upgrade,        // Created through upgrade
}

// Creation flags
const CREATE_FLAG_NONE: i32 = 0
const CREATE_FLAG_INHERIT_VETERANCY: i32 = 1
const CREATE_FLAG_START_HIDDEN: i32 = 2
const CREATE_FLAG_START_POWERED_DOWN: i32 = 4
const CREATE_FLAG_NO_ANNOUNCE: i32 = 8
const CREATE_FLAG_PLACE_AT_RALLY: i32 = 16

// ============================================================================
// Creation Data
// ============================================================================

struct CreationData {
    object_type: string,
    spawn_position_x: f64,
    spawn_position_y: f64,
    spawn_position_z: f64,
    spawn_angle: f64,
    team_id: i32,
    player_id: i32,
    initial_health: f64,
    initial_veterancy: i32,
    flags: i32,
    source_id: i32,
    creation_type: CreateType,
}

fn create_creation_data(object_type: string): CreationData {
    return CreationData {
        object_type: object_type,
        spawn_position_x: 0.0,
        spawn_position_y: 0.0,
        spawn_position_z: 0.0,
        spawn_angle: 0.0,
        team_id: 0,
        player_id: 0,
        initial_health: 100.0,
        initial_veterancy: 0,
        flags: CREATE_FLAG_NONE,
        source_id: 0,
        creation_type: CreateType::Default,
    }
}

// Set spawn position
fn set_spawn_position(data: CreationData, x: f64, y: f64, z: f64) {
    data.spawn_position_x = x
    data.spawn_position_y = y
    data.spawn_position_z = z
}

// Set spawn angle
fn set_spawn_angle(data: CreationData, angle: f64) {
    data.spawn_angle = angle
}

// Set ownership
fn set_ownership(data: CreationData, player_id: i32, team_id: i32) {
    data.player_id = player_id
    data.team_id = team_id
}

// ============================================================================
// Base Create Module
// ============================================================================

struct CreateModule {
    // Identity
    module_id: i32,
    tag: string,
    create_type: CreateType,

    // Owner
    owner_id: i32,

    // Configuration
    data: ModuleData,

    // Initial state
    initial_health_percent: f64,
    initial_veterancy_level: i32,
    start_animation: string,
    construction_complete_sound: string,

    // Spawn behavior
    spawn_offset_x: f64,
    spawn_offset_y: f64,
    spawn_offset_z: f64,
    random_offset_radius: f64,
    face_towards_target: bool,

    // OCL (Object Creation List)
    creation_list: Vec<string>,
}

// Create base create module
fn create_create_module(tag: string, create_type: CreateType): CreateModule {
    return CreateModule {
        module_id: 0,
        tag: tag,
        create_type: create_type,
        owner_id: 0,
        data: create_module_data("", tag),
        initial_health_percent: 100.0,
        initial_veterancy_level: 0,
        start_animation: "",
        construction_complete_sound: "",
        spawn_offset_x: 0.0,
        spawn_offset_y: 0.0,
        spawn_offset_z: 0.0,
        random_offset_radius: 0.0,
        face_towards_target: false,
        creation_list: Vec<string>{},
    }
}

// Initialize from data
fn init_create_module(module: CreateModule, data: ModuleData) {
    module.data = data
    module.tag = data.tag

    if (data.properties.has("InitialHealth")) {
        module.initial_health_percent = get_property_float(data, "InitialHealth")
    }
    if (data.properties.has("StartVeterancy")) {
        module.initial_veterancy_level = get_property_int(data, "StartVeterancy")
    }
    if (data.properties.has("StartAnimation")) {
        module.start_animation = get_property(data, "StartAnimation")
    }
    if (data.properties.has("SpawnOffsetX")) {
        module.spawn_offset_x = get_property_float(data, "SpawnOffsetX")
    }
    if (data.properties.has("SpawnOffsetY")) {
        module.spawn_offset_y = get_property_float(data, "SpawnOffsetY")
    }
    if (data.properties.has("SpawnOffsetZ")) {
        module.spawn_offset_z = get_property_float(data, "SpawnOffsetZ")
    }
    if (data.properties.has("RandomOffsetRadius")) {
        module.random_offset_radius = get_property_float(data, "RandomOffsetRadius")
    }
    if (data.properties.has("FaceTowardsTarget")) {
        module.face_towards_target = get_property_bool(data, "FaceTowardsTarget")
    }
}

// Calculate spawn position with offsets
fn calculate_spawn_position(module: CreateModule, base_x: f64, base_y: f64, base_z: f64, angle: f64, random_seed: i32): (Float, Float, Float) {
    let x = base_x + module.spawn_offset_x
    let y = base_y + module.spawn_offset_y
    let z = base_z + module.spawn_offset_z

    // Apply random offset
    if (module.random_offset_radius > 0.0) {
        let rand_angle = ((random_seed % 360) as Float) * 0.0174533  // deg to rad
        let rand_dist = ((random_seed % 100) as Float) / 100.0 * module.random_offset_radius
        x = x + cos_approx(rand_angle) * rand_dist
        y = y + sin_approx(rand_angle) * rand_dist
    }

    return (x, y, z)
}

// ============================================================================
// Specialized Create Modules
// ============================================================================

// Veterancy Gain Create
struct VeterancyGainCreateModule {
    base: CreateModule,
    veterancy_level: i32,
    science_points: i32,
    inherit_from_producer: bool,
}

fn create_veterancy_gain_create(tag: string): VeterancyGainCreateModule {
    let module = VeterancyGainCreateModule {
        base: create_create_module(tag, CreateType::VeterancyGain),
        veterancy_level: 0,
        science_points: 0,
        inherit_from_producer: false,
    }
    return module
}

// Get initial veterancy
fn get_initial_veterancy(module: VeterancyGainCreateModule, producer_vet: i32): i32 {
    if (module.inherit_from_producer) {
        return producer_vet
    }
    return module.veterancy_level
}

// Spawn From Death Create
struct SpawnFromDeathCreateModule {
    base: CreateModule,
    spawn_count: i32,
    spawn_type: string,
    spawn_radius: f64,
    inherit_team: bool,
}

fn create_spawn_from_death(tag: string): SpawnFromDeathCreateModule {
    return SpawnFromDeathCreateModule {
        base: create_create_module(tag, CreateType::SpawnFromDeath),
        spawn_count: 1,
        spawn_type: "",
        spawn_radius: 10.0,
        inherit_team: true,
    }
}

// Generate spawn positions
fn generate_spawn_positions(module: SpawnFromDeathCreateModule, center_x: f64, center_y: f64, center_z: f64): Vec<(Float, Float, Float)> {
    let positions = Vec<(Float, Float, Float)>{}

    for i in 0..module.spawn_count {
        let angle = ((i as Float) / (module.spawn_count as Float)) * 6.28318
        let x = center_x + cos_approx(angle) * module.spawn_radius
        let y = center_y + sin_approx(angle) * module.spawn_radius
        positions.add((x, y, center_z))
    }

    return positions
}

// Production Create (for buildings)
struct ProductionCreateModule {
    base: CreateModule,
    exit_bone: string,
    rally_point_x: f64,
    rally_point_y: f64,
    natural_rally_x: f64,
    natural_rally_y: f64,
    production_queue_max: i32,
}

fn create_production_create(tag: string): ProductionCreateModule {
    return ProductionCreateModule {
        base: create_create_module(tag, CreateType::Production),
        exit_bone: "YOURBONE01",
        rally_point_x: 0.0,
        rally_point_y: 0.0,
        natural_rally_x: 0.0,
        natural_rally_y: 50.0,
        production_queue_max: 10,
    }
}

// Set rally point
fn set_rally_point(module: ProductionCreateModule, x: f64, y: f64) {
    module.rally_point_x = x
    module.rally_point_y = y
}

// Get exit position
fn get_exit_position(module: ProductionCreateModule, building_x: f64, building_y: f64, building_z: f64): (Float, Float, Float) {
    // Would use bone position, fallback to offset
    return (building_x + module.natural_rally_x, building_y + module.natural_rally_y, building_z)
}

// Paradrop Create
struct ParadropCreateModule {
    base: CreateModule,
    drop_altitude: f64,
    parachute_open_height: f64,
    drop_velocity: f64,
    land_animation: string,
}

fn create_paradrop_create(tag: string): ParadropCreateModule {
    return ParadropCreateModule {
        base: create_create_module(tag, CreateType::Paradrop),
        drop_altitude: 200.0,
        parachute_open_height: 150.0,
        drop_velocity: -20.0,
        land_animation: "PARACHUTE_LAND",
    }
}

// Calculate drop start position
fn get_drop_start(module: ParadropCreateModule, x: f64, y: f64): (Float, Float, Float) {
    return (x, y, module.drop_altitude)
}

// Upgrade Create (object transformation)
struct UpgradeCreateModule {
    base: CreateModule,
    upgrade_name: string,
    replace_original: bool,
    copy_health_percent: bool,
    copy_veterancy: bool,
    fx_on_upgrade: string,
}

fn create_upgrade_create(tag: string): UpgradeCreateModule {
    return UpgradeCreateModule {
        base: create_create_module(tag, CreateType::Upgrade),
        upgrade_name: "",
        replace_original: true,
        copy_health_percent: true,
        copy_veterancy: true,
        fx_on_upgrade: "",
    }
}

// Get replacement data
fn get_replacement_data(module: UpgradeCreateModule, original_health: f64, original_max_health: f64, original_vet: i32): (Float, Int) {
    let health_percent = 100.0
    let vet = 0

    if (module.copy_health_percent) {
        if (original_max_health > 0.0) {
            health_percent = (original_health / original_max_health) * 100.0
        }
    }

    if (module.copy_veterancy) {
        vet = original_vet
    }

    return (health_percent, vet)
}

// ============================================================================
// Object Creation List (OCL)
// ============================================================================

struct OCLEntry {
    object_type: string,
    count: i32,
    offset_x: f64,
    offset_y: f64,
    offset_z: f64,
    inherit_velocity: bool,
    conditions: Vec<string>,
}

fn create_ocl_entry(object_type: string): OCLEntry {
    return OCLEntry {
        object_type: object_type,
        count: 1,
        offset_x: 0.0,
        offset_y: 0.0,
        offset_z: 0.0,
        inherit_velocity: false,
        conditions: Vec<string>{},
    }
}

struct ObjectCreationList {
    name: string,
    entries: Vec<OCLEntry>,
    spawn_delay: f64,
    at_bone: string,
}

fn create_ocl(name: string): ObjectCreationList {
    return ObjectCreationList {
        name: name,
        entries: Vec<OCLEntry>{},
        spawn_delay: 0.0,
        at_bone: "",
    }
}

// Add entry to OCL
fn add_ocl_entry(ocl: ObjectCreationList, entry: OCLEntry) {
    ocl.entries.add(entry)
}

// Get total spawn count
fn get_total_spawn_count(ocl: ObjectCreationList): i32 {
    let total = 0
    for entry in ocl.entries {
        total = total + entry.count
    }
    return total
}

// ============================================================================
// Create Module Manager
// ============================================================================

struct CreateModuleManager {
    modules: HashMap<Int, CreateModule>,
    ocls: HashMap<String, ObjectCreationList>,
    next_id: i32,
    creation_queue: Vec<CreationData>,
}

fn create_create_manager(): CreateModuleManager {
    return CreateModuleManager {
        modules: HashMap<Int, CreateModule>{},
        ocls: HashMap<String, ObjectCreationList>{},
        next_id: 1,
        creation_queue: Vec<CreationData>{},
    }
}

// Register create module
fn register_create(mgr: CreateModuleManager, module: CreateModule): i32 {
    let id = mgr.next_id
    mgr.next_id = mgr.next_id + 1
    module.module_id = id
    mgr.modules.set(id, module)
    return id
}

// Register OCL
fn register_ocl(mgr: CreateModuleManager, ocl: ObjectCreationList) {
    mgr.ocls.set(ocl.name, ocl)
}

// Get OCL by name
fn get_ocl(mgr: CreateModuleManager, name: string): ObjectCreationList {
    if (mgr.ocls.has(name)) {
        return mgr.ocls.get(name)
    }
    return create_ocl("")
}

// Queue creation
fn queue_creation(mgr: CreateModuleManager, data: CreationData) {
    mgr.creation_queue.add(data)
}

// Process creation queue
fn process_creation_queue(mgr: CreateModuleManager): Vec<CreationData> {
    let to_create = mgr.creation_queue
    mgr.creation_queue = Vec<CreationData>{}
    return to_create
}

// Execute OCL at position
fn execute_ocl(mgr: CreateModuleManager, ocl_name: string, x: f64, y: f64, z: f64, player_id: i32, team_id: i32) {
    if (!mgr.ocls.has(ocl_name)) {
        return
    }

    let ocl = mgr.ocls.get(ocl_name)
    for entry in ocl.entries {
        for i in 0..entry.count {
            let data = create_creation_data(entry.object_type)
            set_spawn_position(data, x + entry.offset_x, y + entry.offset_y, z + entry.offset_z)
            set_ownership(data, player_id, team_id)
            queue_creation(mgr, data)
        }
    }
}

// ============================================================================
// Math Helpers
// ============================================================================

fn cos_approx(angle: f64): f64 {
    let x = angle
    while (x > 3.14159) { x = x - 6.28318 }
    while (x < -3.14159) { x = x + 6.28318 }
    return 1.0 - x * x / 2.0 + x * x * x * x / 24.0
}

fn sin_approx(angle: f64): f64 {
    let x = angle
    while (x > 3.14159) { x = x - 6.28318 }
    while (x < -3.14159) { x = x + 6.28318 }
    return x - x * x * x / 6.0 + x * x * x * x * x / 120.0
}

// ============================================================================
// Tests
// ============================================================================

fn test_creation_data(): bool {
    let data = create_creation_data("AmericaTank")
    set_spawn_position(data, 100.0, 200.0, 0.0)
    set_ownership(data, 1, 0)

    assert(data.object_type == "AmericaTank", "Type should match")
    assert(data.spawn_position_x == 100.0, "X should be 100")
    assert(data.player_id == 1, "Player should be 1")

    return true
}

fn test_spawn_position(): bool {
    let module = create_create_module("Spawner", CreateType::Default)
    module.spawn_offset_x = 10.0
    module.spawn_offset_y = 20.0

    let (x, y, z) = calculate_spawn_position(module, 100.0, 100.0, 0.0, 0.0, 0)
    assert(x == 110.0, "X should include offset")
    assert(y == 120.0, "Y should include offset")

    return true
}

fn test_veterancy_create(): bool {
    let module = create_veterancy_gain_create("VetCreate")
    module.veterancy_level = 2
    module.inherit_from_producer = false

    assert(get_initial_veterancy(module, 3) == 2, "Should use module vet")

    module.inherit_from_producer = true
    assert(get_initial_veterancy(module, 3) == 3, "Should inherit producer vet")

    return true
}

fn test_spawn_from_death(): bool {
    let module = create_spawn_from_death("DeathSpawn")
    module.spawn_count = 4
    module.spawn_radius = 20.0

    let positions = generate_spawn_positions(module, 0.0, 0.0, 0.0)
    assert(positions.len() == 4, "Should have 4 positions")

    return true
}

fn test_ocl(): bool {
    let ocl = create_ocl("TestOCL")

    let entry1 = create_ocl_entry("Infantry")
    entry1.count = 3
    add_ocl_entry(ocl, entry1)

    let entry2 = create_ocl_entry("Tank")
    entry2.count = 2
    add_ocl_entry(ocl, entry2)

    assert(get_total_spawn_count(ocl) == 5, "Should spawn 5 total")

    return true
}

fn test_create_manager(): bool {
    let mgr = create_create_manager()

    let ocl = create_ocl("SpawnSquad")
    let entry = create_ocl_entry("Infantry")
    entry.count = 5
    add_ocl_entry(ocl, entry)
    register_ocl(mgr, ocl)

    execute_ocl(mgr, "SpawnSquad", 100.0, 100.0, 0.0, 1, 0)

    let to_create = process_creation_queue(mgr)
    assert(to_create.len() == 5, "Should queue 5 creations")

    return true
}

fn run_all_tests(): bool {
    assert(test_creation_data(), "Creation data test failed")
    assert(test_spawn_position(), "Spawn position test failed")
    assert(test_veterancy_create(), "Veterancy create test failed")
    assert(test_spawn_from_death(), "Spawn from death test failed")
    assert(test_ocl(), "OCL test failed")
    assert(test_create_manager(), "Create manager test failed")
    return true
}
