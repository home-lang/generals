// Upgrade Definition Parser - Parses upgrade INI files for C&C Generals
// Handles Upgrade blocks from Data/INI/Upgrade.ini

from basics import Map, Collection

// Upgrade types matching Thyme
enum UpgradeType {
    Player,      // Player-wide upgrades
    Object,      // Object-specific upgrades
}

// Upgrade status
enum UpgradeStatus {
    Invalid,
    Disabled,
    Available,
    InProgress,
    Complete,
}

// Single upgrade definition
struct UpgradeDefinition {
    name: String,
    display_name: String,
    upgrade_type: UpgradeType,

    // Cost and time
    build_cost: Int,
    build_time: Int,
    research_sound: String,

    // UI
    button_image: String,
    cursor_name: String,
    description: String,

    // Requirements
    prerequisite_upgrade: String,
    prerequisite_science: String,
    build_on_hold: Bool,

    // Granting
    granted_by: Collection<String>,
    researchable: Bool,
    persist_across_missions: Bool,

    // Triggers/effects
    triggered_by: Collection<String>,
    conflicting_upgrades: Collection<String>,

    is_valid: Bool,

    fn init() -> UpgradeDefinition {
        return UpgradeDefinition {
            name: "",
            display_name: "",
            upgrade_type: UpgradeType::Object,
            build_cost: 0,
            build_time: 0,
            research_sound: "",
            button_image: "",
            cursor_name: "",
            description: "",
            prerequisite_upgrade: "",
            prerequisite_science: "",
            build_on_hold: false,
            granted_by: Collection::new(),
            researchable: true,
            persist_across_missions: false,
            triggered_by: Collection::new(),
            conflicting_upgrades: Collection::new(),
            is_valid: false,
        }
    }
}

struct UpgradeDefinitionParser {
    upgrades: Collection<UpgradeDefinition>,
    upgrade_name_to_index: Map<String, Int>,

    // Parse state
    current_upgrade: Int,
    in_upgrade_block: Bool,

    // Error tracking
    parse_errors: Collection<String>,

    fn init() -> UpgradeDefinitionParser {
        return UpgradeDefinitionParser {
            upgrades: Collection::new(),
            upgrade_name_to_index: Map::new(),
            current_upgrade: 0,
            in_upgrade_block: false,
            parse_errors: Collection::new(),
        }
    }

    fn parse_file(self, file_path: String) -> Bool {
        let content = read_file(file_path)
        if content.is_empty() {
            self.add_error("Failed to read file: " + file_path)
            return false
        }

        let lines = content.split('\n')
        let line_num = 0

        for line in lines {
            line_num = line_num + 1
            let trimmed = line.trim()

            if trimmed.is_empty() || trimmed.starts_with(';') || trimmed.starts_with("//") {
                continue
            }

            if !self.parse_line(trimmed, line_num) {
                return false
            }
        }

        return true
    }

    fn parse_line(self, line: String, line_num: Int) -> Bool {
        if line.starts_with("Upgrade ") {
            return self.begin_upgrade_block(line)
        }

        if line == "End" {
            return self.end_upgrade_block()
        }

        if self.in_upgrade_block {
            return self.parse_upgrade_property(line)
        }

        return true
    }

    fn begin_upgrade_block(self, line: String) -> Bool {
        // Parse: "Upgrade UpgradeName" or "Upgrade UpgradeName : ParentUpgrade"
        let parts = line.split(' ')
        if parts.count() < 2 {
            self.add_error("Invalid upgrade declaration")
            return false
        }

        let upgrade_name = parts.get(1).trim()
        let parent_name = ""

        if line.contains(':') {
            let inherit_parts = line.split(':')
            if inherit_parts.count() >= 2 {
                upgrade_name = inherit_parts.get(0).split(' ').get(1).trim()
                parent_name = inherit_parts.get(1).trim()
            }
        }

        let upgrade = UpgradeDefinition::init()
        upgrade.name = upgrade_name
        upgrade.is_valid = true

        if parent_name.len() > 0 {
            self.inherit_from(upgrade, parent_name)
        }

        self.current_upgrade = self.upgrades.count()
        self.upgrades.add(upgrade)
        self.upgrade_name_to_index.set(upgrade_name, self.current_upgrade)
        self.in_upgrade_block = true

        return true
    }

    fn inherit_from(self, upgrade: UpgradeDefinition, parent_name: String) {
        let parent_idx = self.upgrade_name_to_index.get(parent_name)
        if parent_idx != -1 {
            let parent = self.upgrades.get(parent_idx)
            upgrade.upgrade_type = parent.upgrade_type
            upgrade.build_cost = parent.build_cost
            upgrade.build_time = parent.build_time
            upgrade.button_image = parent.button_image
            upgrade.description = parent.description
            upgrade.researchable = parent.researchable
        }
    }

    fn end_upgrade_block(self) -> Bool {
        self.in_upgrade_block = false
        return true
    }

    fn parse_upgrade_property(self, line: String) -> Bool {
        let parts = self.split_property(line)
        let key = parts.0
        let value = parts.1

        if key.is_empty() {
            return true
        }

        let upgrade = self.upgrades.get(self.current_upgrade)

        if key == "DisplayName" {
            upgrade.display_name = value
        } else if key == "Type" {
            upgrade.upgrade_type = self.parse_upgrade_type(value)
        } else if key == "BuildCost" {
            upgrade.build_cost = parse_int(value)
        } else if key == "BuildTime" {
            upgrade.build_time = parse_int(value)
        } else if key == "ResearchSound" {
            upgrade.research_sound = value
        } else if key == "ButtonImage" {
            upgrade.button_image = value
        } else if key == "Cursor" {
            upgrade.cursor_name = value
        } else if key == "Description" {
            upgrade.description = value
        } else if key == "RequiredUpgrade" {
            upgrade.prerequisite_upgrade = value
        } else if key == "RequiredScience" {
            upgrade.prerequisite_science = value
        } else if key == "BuildOnHold" {
            upgrade.build_on_hold = self.parse_bool(value)
        } else if key == "Researchable" {
            upgrade.researchable = self.parse_bool(value)
        } else if key == "PersistsAcrossMissions" {
            upgrade.persist_across_missions = self.parse_bool(value)
        } else if key == "GrantedBy" {
            upgrade.granted_by.add(value)
        } else if key == "TriggeredBy" {
            upgrade.triggered_by.add(value)
        } else if key == "ConflictsWith" {
            upgrade.conflicting_upgrades.add(value)
        }

        return true
    }

    fn parse_upgrade_type(self, value: String) -> UpgradeType {
        let v = value.to_uppercase()
        if v == "PLAYER" {
            return UpgradeType::Player
        }
        return UpgradeType::Object
    }

    fn split_property(self, line: String) -> (String, String) {
        let eq_pos = line.index_of('=')
        if eq_pos != -1 {
            return (line.substring(0, eq_pos).trim(), line.substring(eq_pos + 1, line.len()).trim())
        }

        let space_pos = line.index_of(' ')
        if space_pos != -1 {
            return (line.substring(0, space_pos).trim(), line.substring(space_pos + 1, line.len()).trim())
        }

        return (line, "")
    }

    fn parse_bool(self, value: String) -> Bool {
        let v = value.to_uppercase()
        return v == "YES" || v == "TRUE" || v == "1"
    }

    fn add_error(self, msg: String) {
        self.parse_errors.add(msg)
    }

    // Public API
    fn get_upgrade(self, name: String) -> UpgradeDefinition? {
        let idx = self.upgrade_name_to_index.get(name)
        if idx != -1 {
            return self.upgrades.get(idx)
        }
        return null
    }

    fn get_upgrade_by_index(self, index: Int) -> UpgradeDefinition? {
        if index >= 0 && index < self.upgrades.count() {
            return self.upgrades.get(index)
        }
        return null
    }

    fn get_upgrade_count(self) -> Int {
        return self.upgrades.count()
    }
}
