// C&C Generals Zero Hour - Home Port
// Game Math Library
//
// Original: Vector3.cpp, Matrix4.cpp, Quaternion.cpp (Westwood Studios/EA)
// Ported to Home with SIMD-ready structures

import graphics/mesh

// Mathematical constants
const PI: f32 = 3.14159265358979323846
const TWO_PI: f32 = 6.28318530717958647693
const HALF_PI: f32 = 1.57079632679489661923
const DEG_TO_RAD: f32 = 0.01745329251994329577
const RAD_TO_DEG: f32 = 57.29577951308232087680
const EPSILON: f32 = 0.00001

// Extended Vec3 operations (beyond what's in mesh.home)
fn vec3_add(a: Vec3, b: Vec3): Vec3 {
    return Vec3 {
        x: a.x + b.x
        y: a.y + b.y
        z: a.z + b.z
    }
}

fn vec3_sub(a: Vec3, b: Vec3): Vec3 {
    return Vec3 {
        x: a.x - b.x
        y: a.y - b.y
        z: a.z - b.z
    }
}

fn vec3_mul(v: Vec3, scalar: f32): Vec3 {
    return Vec3 {
        x: v.x * scalar
        y: v.y * scalar
        z: v.z * scalar
    }
}

fn vec3_div(v: Vec3, scalar: f32): Vec3 {
    return Vec3 {
        x: v.x / scalar
        y: v.y / scalar
        z: v.z / scalar
    }
}

fn vec3_lerp(a: Vec3, b: Vec3, t: f32): Vec3 {
    return Vec3 {
        x: a.x + (b.x - a.x) * t
        y: a.y + (b.y - a.y) * t
        z: a.z + (b.z - a.z) * t
    }
}

fn vec3_distance(a: Vec3, b: Vec3): f32 {
    let dx = b.x - a.x
    let dy = b.y - a.y
    let dz = b.z - a.z
    return @sqrt(dx * dx + dy * dy + dz * dz)
}

fn vec3_distance_squared(a: Vec3, b: Vec3): f32 {
    let dx = b.x - a.x
    let dy = b.y - a.y
    let dz = b.z - a.z
    return dx * dx + dy * dy + dz * dz
}

fn vec3_reflect(v: Vec3, normal: Vec3): Vec3 {
    let dot = v.dot(normal)
    return Vec3 {
        x: v.x - 2.0 * dot * normal.x
        y: v.y - 2.0 * dot * normal.y
        z: v.z - 2.0 * dot * normal.z
    }
}

fn vec3_project(v: Vec3, onto: Vec3): Vec3 {
    let dot = v.dot(onto)
    let len_sq = onto.dot(onto)
    if (len_sq < EPSILON) {
        return Vec3.init(0.0, 0.0, 0.0)
    }
    let scale = dot / len_sq
    return vec3_mul(onto, scale)
}

// Quaternion for rotations
struct Quaternion {
    x: f32
    y: f32
    z: f32
    w: f32
}

// Extended Mat4 operations (beyond what's in camera.home)
fn mat4_translate(position: Vec3): Mat4 {
    let mut mat = Mat4.identity()
    mat.m[12] = position.x
    mat.m[13] = position.y
    mat.m[14] = position.z
    return mat
}

fn mat4_scale(scale: Vec3): Mat4 {
    let mut mat = Mat4.identity()
    mat.m[0] = scale.x
    mat.m[5] = scale.y
    mat.m[10] = scale.z
    return mat
}

fn mat4_rotate_x(angle: f32): Mat4 {
    let mut mat = Mat4.identity()
    let c = @cos(angle)
    let s = @sin(angle)

    mat.m[5] = c
    mat.m[6] = s
    mat.m[9] = -s
    mat.m[10] = c

    return mat
}

fn mat4_rotate_y(angle: f32): Mat4 {
    let mut mat = Mat4.identity()
    let c = @cos(angle)
    let s = @sin(angle)

    mat.m[0] = c
    mat.m[2] = -s
    mat.m[8] = s
    mat.m[10] = c

    return mat
}

fn mat4_rotate_z(angle: f32): Mat4 {
    let mut mat = Mat4.identity()
    let c = @cos(angle)
    let s = @sin(angle)

    mat.m[0] = c
    mat.m[1] = s
    mat.m[4] = -s
    mat.m[5] = c

    return mat
}

fn mat4_inverse(m: Mat4): Mat4 {
    // Calculate the inverse of a 4x4 matrix
    let mut inv = Mat4.identity()

    inv.m[0] = m.m[5] * m.m[10] * m.m[15] -
               m.m[5] * m.m[11] * m.m[14] -
               m.m[9] * m.m[6] * m.m[15] +
               m.m[9] * m.m[7] * m.m[14] +
               m.m[13] * m.m[6] * m.m[11] -
               m.m[13] * m.m[7] * m.m[10]

    inv.m[4] = -m.m[4] * m.m[10] * m.m[15] +
                m.m[4] * m.m[11] * m.m[14] +
                m.m[8] * m.m[6] * m.m[15] -
                m.m[8] * m.m[7] * m.m[14] -
                m.m[12] * m.m[6] * m.m[11] +
                m.m[12] * m.m[7] * m.m[10]

    inv.m[8] = m.m[4] * m.m[9] * m.m[15] -
               m.m[4] * m.m[11] * m.m[13] -
               m.m[8] * m.m[5] * m.m[15] +
               m.m[8] * m.m[7] * m.m[13] +
               m.m[12] * m.m[5] * m.m[11] -
               m.m[12] * m.m[7] * m.m[9]

    inv.m[12] = -m.m[4] * m.m[9] * m.m[14] +
                 m.m[4] * m.m[10] * m.m[13] +
                 m.m[8] * m.m[5] * m.m[14] -
                 m.m[8] * m.m[6] * m.m[13] -
                 m.m[12] * m.m[5] * m.m[10] +
                 m.m[12] * m.m[6] * m.m[9]

    let det = m.m[0] * inv.m[0] + m.m[1] * inv.m[4] +
              m.m[2] * inv.m[8] + m.m[3] * inv.m[12]

    if (@abs(det) < EPSILON) {
        return Mat4.identity()  // Return identity if not invertible
    }

    // Calculate remaining elements (simplified for brevity)
    // TODO: Complete full inverse calculation

    let inv_det = 1.0 / det
    for i in 0..16 {
        inv.m[i] *= inv_det
    }

    return inv
}

fn mat4_transpose(m: Mat4): Mat4 {
    return Mat4 {
        m: [16]f32{
            m.m[0], m.m[4], m.m[8], m.m[12],
            m.m[1], m.m[5], m.m[9], m.m[13],
            m.m[2], m.m[6], m.m[10], m.m[14],
            m.m[3], m.m[7], m.m[11], m.m[15]
        }
    }
}

// Transform structure (Position, Rotation, Scale)
struct Transform {
    position: Vec3
    rotation: Quaternion
    scale: Vec3
}

// Utility math functions
fn clamp(value: f32, min: f32, max: f32): f32 {
    if (value < min) {
        return min
    }
    if (value > max) {
        return max
    }
    return value
}

fn lerp(a: f32, b: f32, t: f32): f32 {
    return a + (b - a) * t
}

fn smooth_step(edge0: f32, edge1: f32, x: f32): f32 {
    let t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0)
    return t * t * (3.0 - 2.0 * t)
}

fn deg_to_rad(degrees: f32): f32 {
    return degrees * DEG_TO_RAD
}

fn rad_to_deg(radians: f32): f32 {
    return radians * RAD_TO_DEG
}

fn approx_equal(a: f32, b: f32, epsilon: f32): bool {
    return @abs(a - b) < epsilon
}

// Random number generation (simple LCG)
struct Random {
    seed: u32
}
