// C&C Generals Zero Hour - Home Port
// Game Math Library
//
// Original: Vector3.cpp, Matrix4.cpp, Quaternion.cpp (Westwood Studios/EA)
// Ported to Home with SIMD-ready structures

import graphics/mesh

// Mathematical constants
const PI: f32 = 3.14159265358979323846
const TWO_PI: f32 = 6.28318530717958647693
const HALF_PI: f32 = 1.57079632679489661923
const DEG_TO_RAD: f32 = 0.01745329251994329577
const RAD_TO_DEG: f32 = 57.29577951308232087680
const EPSILON: f32 = 0.00001

// Extended Vec3 operations (beyond what's in mesh.home)
fn vec3_add(a: Vec3, b: Vec3): Vec3 {
    return Vec3 {
        x: a.x + b.x
        y: a.y + b.y
        z: a.z + b.z
    }
}

fn vec3_sub(a: Vec3, b: Vec3): Vec3 {
    return Vec3 {
        x: a.x - b.x
        y: a.y - b.y
        z: a.z - b.z
    }
}

fn vec3_mul(v: Vec3, scalar: f32): Vec3 {
    return Vec3 {
        x: v.x * scalar
        y: v.y * scalar
        z: v.z * scalar
    }
}

fn vec3_div(v: Vec3, scalar: f32): Vec3 {
    return Vec3 {
        x: v.x / scalar
        y: v.y / scalar
        z: v.z / scalar
    }
}

fn vec3_lerp(a: Vec3, b: Vec3, t: f32): Vec3 {
    return Vec3 {
        x: a.x + (b.x - a.x) * t
        y: a.y + (b.y - a.y) * t
        z: a.z + (b.z - a.z) * t
    }
}

fn vec3_distance(a: Vec3, b: Vec3): f32 {
    let dx = b.x - a.x
    let dy = b.y - a.y
    let dz = b.z - a.z
    return @sqrt(dx * dx + dy * dy + dz * dz)
}

fn vec3_distance_squared(a: Vec3, b: Vec3): f32 {
    let dx = b.x - a.x
    let dy = b.y - a.y
    let dz = b.z - a.z
    return dx * dx + dy * dy + dz * dz
}

fn vec3_reflect(v: Vec3, normal: Vec3): Vec3 {
    let dot = v.dot(normal)
    return Vec3 {
        x: v.x - 2.0 * dot * normal.x
        y: v.y - 2.0 * dot * normal.y
        z: v.z - 2.0 * dot * normal.z
    }
}

fn vec3_project(v: Vec3, onto: Vec3): Vec3 {
    let dot = v.dot(onto)
    let len_sq = onto.dot(onto)
    if len_sq < EPSILON {
        return Vec3.init(0.0, 0.0, 0.0)
    }
    let scale = dot / len_sq
    return vec3_mul(onto, scale)
}

// Quaternion for rotations
struct Quaternion {
    x: f32
    y: f32
    z: f32
    w: f32

    fn identity(): Quaternion {
        return Quaternion { x: 0.0, y: 0.0, z: 0.0, w: 1.0 }
    }

    fn from_axis_angle(axis: Vec3, angle: f32): Quaternion {
        let half_angle = angle * 0.5
        let s = @sin(half_angle)
        let normalized = axis.normalize()

        return Quaternion {
            x: normalized.x * s
            y: normalized.y * s
            z: normalized.z * s
            w: @cos(half_angle)
        }
    }

    fn from_euler(pitch: f32, yaw: f32, roll: f32): Quaternion {
        // Convert Euler angles (in radians) to quaternion
        let cy = @cos(yaw * 0.5)
        let sy = @sin(yaw * 0.5)
        let cp = @cos(pitch * 0.5)
        let sp = @sin(pitch * 0.5)
        let cr = @cos(roll * 0.5)
        let sr = @sin(roll * 0.5)

        return Quaternion {
            x: sr * cp * cy - cr * sp * sy
            y: cr * sp * cy + sr * cp * sy
            z: cr * cp * sy - sr * sp * cy
            w: cr * cp * cy + sr * sp * sy
        }
    }

    fn to_euler(self): [3]f32 {
        // Convert quaternion to Euler angles (pitch, yaw, roll)
        let mut pitch: f32 = 0.0
        let mut yaw: f32 = 0.0
        let mut roll: f32 = 0.0

        // Pitch (x-axis rotation)
        let sinp = 2.0 * (self.w * self.x + self.y * self.z)
        let cosp = 1.0 - 2.0 * (self.x * self.x + self.y * self.y)
        pitch = @atan2(sinp, cosp)

        // Yaw (y-axis rotation)
        let siny = 2.0 * (self.w * self.y - self.z * self.x)
        let cosy = 1.0 - 2.0 * (self.y * self.y + self.x * self.x)
        yaw = @atan2(siny, cosy)

        // Roll (z-axis rotation)
        let sinr = 2.0 * (self.w * self.z + self.x * self.y)
        let cosr = 1.0 - 2.0 * (self.z * self.z + self.x * self.x)
        roll = @atan2(sinr, cosr)

        return [3]f32{ pitch, yaw, roll }
    }

    fn length(self): f32 {
        return @sqrt(self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w)
    }

    fn normalize(self): Quaternion {
        let len = self.length()
        if len < EPSILON {
            return Quaternion.identity()
        }

        let inv_len = 1.0 / len
        return Quaternion {
            x: self.x * inv_len
            y: self.y * inv_len
            z: self.z * inv_len
            w: self.w * inv_len
        }
    }

    fn conjugate(self): Quaternion {
        return Quaternion {
            x: -self.x
            y: -self.y
            z: -self.z
            w: self.w
        }
    }

    fn multiply(self, other: Quaternion): Quaternion {
        return Quaternion {
            x: self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y
            y: self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x
            z: self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
            w: self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z
        }
    }

    fn rotate_vector(self, v: Vec3): Vec3 {
        // Rotate a vector by this quaternion
        let qv = Quaternion { x: v.x, y: v.y, z: v.z, w: 0.0 }
        let qc = self.conjugate()
        let result = self.multiply(qv).multiply(qc)

        return Vec3 {
            x: result.x
            y: result.y
            z: result.z
        }
    }

    fn slerp(a: Quaternion, b: Quaternion, t: f32): Quaternion {
        // Spherical linear interpolation
        let mut dot = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

        // Take the shortest path
        let mut b_adjusted = b
        if dot < 0.0 {
            b_adjusted = Quaternion {
                x: -b.x
                y: -b.y
                z: -b.z
                w: -b.w
            }
            dot = -dot
        }

        // Use linear interpolation if quaternions are very close
        if dot > 0.9995 {
            return Quaternion {
                x: a.x + (b_adjusted.x - a.x) * t
                y: a.y + (b_adjusted.y - a.y) * t
                z: a.z + (b_adjusted.z - a.z) * t
                w: a.w + (b_adjusted.w - a.w) * t
            }.normalize()
        }

        let theta = @acos(dot)
        let sin_theta = @sin(theta)
        let wa = @sin((1.0 - t) * theta) / sin_theta
        let wb = @sin(t * theta) / sin_theta

        return Quaternion {
            x: a.x * wa + b_adjusted.x * wb
            y: a.y * wa + b_adjusted.y * wb
            z: a.z * wa + b_adjusted.z * wb
            w: a.w * wa + b_adjusted.w * wb
        }
    }

    fn to_matrix(self): Mat4 {
        // Convert quaternion to 4x4 rotation matrix
        let mut mat = Mat4.identity()

        let xx = self.x * self.x
        let yy = self.y * self.y
        let zz = self.z * self.z
        let xy = self.x * self.y
        let xz = self.x * self.z
        let yz = self.y * self.z
        let wx = self.w * self.x
        let wy = self.w * self.y
        let wz = self.w * self.z

        mat.m[0] = 1.0 - 2.0 * (yy + zz)
        mat.m[1] = 2.0 * (xy + wz)
        mat.m[2] = 2.0 * (xz - wy)

        mat.m[4] = 2.0 * (xy - wz)
        mat.m[5] = 1.0 - 2.0 * (xx + zz)
        mat.m[6] = 2.0 * (yz + wx)

        mat.m[8] = 2.0 * (xz + wy)
        mat.m[9] = 2.0 * (yz - wx)
        mat.m[10] = 1.0 - 2.0 * (xx + yy)

        return mat
    }
}

// Extended Mat4 operations (beyond what's in camera.home)
fn mat4_translate(position: Vec3): Mat4 {
    let mut mat = Mat4.identity()
    mat.m[12] = position.x
    mat.m[13] = position.y
    mat.m[14] = position.z
    return mat
}

fn mat4_scale(scale: Vec3): Mat4 {
    let mut mat = Mat4.identity()
    mat.m[0] = scale.x
    mat.m[5] = scale.y
    mat.m[10] = scale.z
    return mat
}

fn mat4_rotate_x(angle: f32): Mat4 {
    let mut mat = Mat4.identity()
    let c = @cos(angle)
    let s = @sin(angle)

    mat.m[5] = c
    mat.m[6] = s
    mat.m[9] = -s
    mat.m[10] = c

    return mat
}

fn mat4_rotate_y(angle: f32): Mat4 {
    let mut mat = Mat4.identity()
    let c = @cos(angle)
    let s = @sin(angle)

    mat.m[0] = c
    mat.m[2] = -s
    mat.m[8] = s
    mat.m[10] = c

    return mat
}

fn mat4_rotate_z(angle: f32): Mat4 {
    let mut mat = Mat4.identity()
    let c = @cos(angle)
    let s = @sin(angle)

    mat.m[0] = c
    mat.m[1] = s
    mat.m[4] = -s
    mat.m[5] = c

    return mat
}

fn mat4_inverse(m: Mat4): Mat4 {
    // Calculate the inverse of a 4x4 matrix
    let mut inv = Mat4.identity()

    inv.m[0] = m.m[5] * m.m[10] * m.m[15] -
               m.m[5] * m.m[11] * m.m[14] -
               m.m[9] * m.m[6] * m.m[15] +
               m.m[9] * m.m[7] * m.m[14] +
               m.m[13] * m.m[6] * m.m[11] -
               m.m[13] * m.m[7] * m.m[10]

    inv.m[4] = -m.m[4] * m.m[10] * m.m[15] +
                m.m[4] * m.m[11] * m.m[14] +
                m.m[8] * m.m[6] * m.m[15] -
                m.m[8] * m.m[7] * m.m[14] -
                m.m[12] * m.m[6] * m.m[11] +
                m.m[12] * m.m[7] * m.m[10]

    inv.m[8] = m.m[4] * m.m[9] * m.m[15] -
               m.m[4] * m.m[11] * m.m[13] -
               m.m[8] * m.m[5] * m.m[15] +
               m.m[8] * m.m[7] * m.m[13] +
               m.m[12] * m.m[5] * m.m[11] -
               m.m[12] * m.m[7] * m.m[9]

    inv.m[12] = -m.m[4] * m.m[9] * m.m[14] +
                 m.m[4] * m.m[10] * m.m[13] +
                 m.m[8] * m.m[5] * m.m[14] -
                 m.m[8] * m.m[6] * m.m[13] -
                 m.m[12] * m.m[5] * m.m[10] +
                 m.m[12] * m.m[6] * m.m[9]

    let det = m.m[0] * inv.m[0] + m.m[1] * inv.m[4] +
              m.m[2] * inv.m[8] + m.m[3] * inv.m[12]

    if @abs(det) < EPSILON {
        return Mat4.identity()  // Return identity if not invertible
    }

    // Calculate remaining elements (simplified for brevity)
    // TODO: Complete full inverse calculation

    let inv_det = 1.0 / det
    for i in 0..16 {
        inv.m[i] *= inv_det
    }

    return inv
}

fn mat4_transpose(m: Mat4): Mat4 {
    return Mat4 {
        m: [16]f32{
            m.m[0], m.m[4], m.m[8], m.m[12],
            m.m[1], m.m[5], m.m[9], m.m[13],
            m.m[2], m.m[6], m.m[10], m.m[14],
            m.m[3], m.m[7], m.m[11], m.m[15]
        }
    }
}

// Transform structure (Position, Rotation, Scale)
struct Transform {
    position: Vec3
    rotation: Quaternion
    scale: Vec3

    fn init(): Transform {
        return Transform {
            position: Vec3.init(0.0, 0.0, 0.0)
            rotation: Quaternion.identity()
            scale: Vec3.init(1.0, 1.0, 1.0)
        }
    }

    fn to_matrix(self): Mat4 {
        // Build transformation matrix: T * R * S
        let translation = mat4_translate(self.position)
        let rotation = self.rotation.to_matrix()
        let scale = mat4_scale(self.scale)

        return translation.multiply(rotation).multiply(scale)
    }

    fn transform_point(self, point: Vec3): Vec3 {
        // Apply scale, rotation, translation to a point
        let scaled = Vec3 {
            x: point.x * self.scale.x
            y: point.y * self.scale.y
            z: point.z * self.scale.z
        }

        let rotated = self.rotation.rotate_vector(scaled)

        return vec3_add(rotated, self.position)
    }

    fn transform_direction(self, direction: Vec3): Vec3 {
        // Apply only rotation to a direction vector (no translation)
        return self.rotation.rotate_vector(direction)
    }
}

// Utility math functions
fn clamp(value: f32, min: f32, max: f32): f32 {
    if value < min {
        return min
    }
    if value > max {
        return max
    }
    return value
}

fn lerp(a: f32, b: f32, t: f32): f32 {
    return a + (b - a) * t
}

fn smooth_step(edge0: f32, edge1: f32, x: f32): f32 {
    let t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0)
    return t * t * (3.0 - 2.0 * t)
}

fn deg_to_rad(degrees: f32): f32 {
    return degrees * DEG_TO_RAD
}

fn rad_to_deg(radians: f32): f32 {
    return radians * RAD_TO_DEG
}

fn approx_equal(a: f32, b: f32, epsilon: f32): bool {
    return @abs(a - b) < epsilon
}

// Random number generation (simple LCG)
struct Random {
    seed: u32

    fn init(seed: u32): Random {
        return Random { seed: seed }
    }

    fn next(mut self): u32 {
        // Linear congruential generator
        self.seed = self.seed * 1103515245 + 12345
        return (self.seed / 65536) % 32768
    }

    fn next_float(mut self): f32 {
        return @intToFloat(f32, self.next()) / 32768.0
    }

    fn next_range(mut self, min: i32, max: i32): i32 {
        let range = max - min + 1
        return min + @intCast(i32, self.next() % @intCast(u32, range))
    }

    fn next_vec3(mut self, min: f32, max: f32): Vec3 {
        let range = max - min
        return Vec3 {
            x: min + self.next_float() * range
            y: min + self.next_float() * range
            z: min + self.next_float() * range
        }
    }
}
