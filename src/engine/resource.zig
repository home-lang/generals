// Resource System for Generals RTS
// Manages supply collection and player economy

const std = @import("std");
const Allocator = std.mem.Allocator;
const math = @import("math");
const Vec2 = math.Vec2(f32);
const EntityId = @import("entity.zig").EntityId;

/// Resource types in C&C Generals
pub const ResourceType = enum {
    supplies,  // Main resource in Generals
    power,     // Generated by power plants
};

/// Resource node - supply pile on the map
pub const ResourceNode = struct {
    id: u32,
    position: Vec2,
    resource_type: ResourceType,
    amount: f32,
    max_amount: f32,
    active: bool,

    pub fn init(id: u32, x: f32, y: f32, amount: f32) ResourceNode {
        return .{
            .id = id,
            .position = Vec2.init(x, y),
            .resource_type = .supplies,
            .amount = amount,
            .max_amount = amount,
            .active = true,
        };
    }

    pub fn collect(self: *ResourceNode, amount: f32) f32 {
        const collected = @min(amount, self.amount);
        self.amount -= collected;
        if (self.amount <= 0) {
            self.active = false;
        }
        return collected;
    }

    pub fn isEmpty(self: *const ResourceNode) bool {
        return self.amount <= 0;
    }
};

/// Player resources
pub const PlayerResources = struct {
    supplies: f32,
    power: f32,
    supply_limit: f32,

    pub fn init() PlayerResources {
        return .{
            .supplies = 0.0,
            .power = 0.0,
            .supply_limit = 100.0, // Starting supply limit
        };
    }

    pub fn addSupplies(self: *PlayerResources, amount: f32) void {
        self.supplies = @min(self.supplies + amount, self.supply_limit);
    }

    pub fn canAfford(self: *const PlayerResources, cost: f32) bool {
        return self.supplies >= cost;
    }

    pub fn spend(self: *PlayerResources, cost: f32) bool {
        if (self.canAfford(cost)) {
            self.supplies -= cost;
            return true;
        }
        return false;
    }
};

/// Resource collection component for worker units
pub const ResourceCollector = struct {
    collection_rate: f32,  // Resources per second
    carrying_capacity: f32,
    current_cargo: f32,
    target_node_id: ?u32,
    return_to_depot_id: ?EntityId,
    is_collecting: bool,
    is_returning: bool,

    pub fn init(collection_rate: f32, carrying_capacity: f32) ResourceCollector {
        return .{
            .collection_rate = collection_rate,
            .carrying_capacity = carrying_capacity,
            .current_cargo = 0.0,
            .target_node_id = null,
            .return_to_depot_id = null,
            .is_collecting = false,
            .is_returning = false,
        };
    }

    pub fn isFull(self: *const ResourceCollector) bool {
        return self.current_cargo >= self.carrying_capacity;
    }

    pub fn isEmpty(self: *const ResourceCollector) bool {
        return self.current_cargo <= 0;
    }

    pub fn collectResource(self: *ResourceCollector, dt: f32, node: *ResourceNode) void {
        const amount = self.collection_rate * dt;
        const collected = node.collect(amount);
        self.current_cargo = @min(self.current_cargo + collected, self.carrying_capacity);
    }

    pub fn depositResources(self: *ResourceCollector, player_resources: *PlayerResources) void {
        player_resources.addSupplies(self.current_cargo);
        self.current_cargo = 0.0;
    }
};

/// Resource Manager - manages all resource nodes and collection
pub const ResourceManager = struct {
    allocator: Allocator,
    resource_nodes: std.ArrayList(ResourceNode),
    next_node_id: u32,

    pub fn init(allocator: Allocator) !ResourceManager {
        return .{
            .allocator = allocator,
            .resource_nodes = try std.ArrayList(ResourceNode).initCapacity(allocator, 0),
            .next_node_id = 1,
        };
    }

    pub fn deinit(self: *ResourceManager) void {
        self.resource_nodes.deinit(self.allocator);
    }

    /// Create a new resource node (supply pile)
    pub fn createResourceNode(self: *ResourceManager, x: f32, y: f32, amount: f32) !u32 {
        const id = self.next_node_id;
        self.next_node_id += 1;

        const node = ResourceNode.init(id, x, y, amount);
        try self.resource_nodes.append(self.allocator, node);

        return id;
    }

    /// Get resource node by ID
    pub fn getNode(self: *ResourceManager, id: u32) ?*ResourceNode {
        for (self.resource_nodes.items) |*node| {
            if (node.id == id and node.active) {
                return node;
            }
        }
        return null;
    }

    /// Find nearest resource node to position
    pub fn findNearestNode(self: *ResourceManager, position: Vec2, max_distance: f32) ?u32 {
        var nearest_id: ?u32 = null;
        var nearest_dist_sq: f32 = max_distance * max_distance;

        for (self.resource_nodes.items) |*node| {
            if (!node.active or node.isEmpty()) continue;

            const dx = node.position.x - position.x;
            const dy = node.position.y - position.y;
            const dist_sq = dx * dx + dy * dy;

            if (dist_sq < nearest_dist_sq) {
                nearest_dist_sq = dist_sq;
                nearest_id = node.id;
            }
        }

        return nearest_id;
    }

    /// Get all active resource nodes
    pub fn getActiveNodes(self: *ResourceManager) []ResourceNode {
        return self.resource_nodes.items;
    }

    /// Update resource nodes (remove depleted ones periodically)
    pub fn update(self: *ResourceManager) void {
        _ = self;
        // Cleanup can be done here if needed
        // For now, nodes just become inactive when depleted
    }
};

// Tests
test "ResourceNode: collect resources" {
    var node = ResourceNode.init(1, 100, 200, 1000.0);

    try std.testing.expectEqual(@as(f32, 1000.0), node.amount);

    const collected = node.collect(100.0);
    try std.testing.expectEqual(@as(f32, 100.0), collected);
    try std.testing.expectEqual(@as(f32, 900.0), node.amount);
    try std.testing.expect(node.active);
}

test "ResourceNode: deplete" {
    var node = ResourceNode.init(1, 100, 200, 50.0);

    const collected = node.collect(100.0); // Try to collect more than available
    try std.testing.expectEqual(@as(f32, 50.0), collected);
    try std.testing.expectEqual(@as(f32, 0.0), node.amount);
    try std.testing.expect(!node.active);
    try std.testing.expect(node.isEmpty());
}

test "PlayerResources: add and spend" {
    var resources = PlayerResources.init();

    try std.testing.expectEqual(@as(f32, 0.0), resources.supplies);

    resources.addSupplies(500.0);
    try std.testing.expectEqual(@as(f32, 500.0), resources.supplies);

    try std.testing.expect(resources.canAfford(300.0));
    try std.testing.expect(resources.spend(300.0));
    try std.testing.expectEqual(@as(f32, 200.0), resources.supplies);

    try std.testing.expect(!resources.canAfford(300.0));
    try std.testing.expect(!resources.spend(300.0));
}

test "ResourceCollector: collect and deposit" {
    var collector = ResourceCollector.init(10.0, 100.0);
    var node = ResourceNode.init(1, 0, 0, 1000.0);
    var player_resources = PlayerResources.init();

    // Collect for 5 seconds
    collector.collectResource(5.0, &node);
    try std.testing.expectEqual(@as(f32, 50.0), collector.current_cargo);
    try std.testing.expectEqual(@as(f32, 950.0), node.amount);

    // Deposit
    collector.depositResources(&player_resources);
    try std.testing.expectEqual(@as(f32, 0.0), collector.current_cargo);
    try std.testing.expectEqual(@as(f32, 50.0), player_resources.supplies);
}
