// State Machine System - Generic State Machine Implementation
// Based on Thyme engine state machine architecture
// Used for AI behavior, game states, animations, and more


// ============================================================================
// State Types and Enums
// ============================================================================

// State machine execution result
enum StateResult {
    Continue,       // Stay in current state
    Success,        // State completed successfully
    Failure,        // State failed
    Transition,     // Request state transition
}

// Transition condition types
enum ConditionType {
    Always,         // Always true
    Never,          // Always false
    Flag,           // Check a flag
    Timer,          // Time elapsed
    Health,         // Health threshold
    Distance,       // Distance check
    Custom,         // Custom condition function
}

// ============================================================================
// State Definition
// ============================================================================

struct StateCondition {
    condition_type: ConditionType,
    flag_name: string,
    threshold: f64,
    comparison: string,  // "lt", "gt", "eq", "le", "ge"
    custom_id: i32,
}

struct StateTransition {
    target_state: string,
    conditions: Vec<StateCondition>,
    priority: i32,
}

struct StateAction {
    action_type: string,
    parameters: HashMap<String, String>,
}

struct State {
    name: string,
    enter_actions: Vec<StateAction>,
    update_actions: Vec<StateAction>,
    exit_actions: Vec<StateAction>,
    transitions: Vec<StateTransition>,
    is_initial: bool,
    is_final: bool,
}

// Create empty state
fn create_state(name: string): State {
    return State {
        name: name,
        enter_actions: Vec<StateAction>{},
        update_actions: Vec<StateAction>{},
        exit_actions: Vec<StateAction>{},
        transitions: Vec<StateTransition>{},
        is_initial: false,
        is_final: false,
    }
}

// Create state condition
fn create_condition(cond_type: ConditionType): StateCondition {
    return StateCondition {
        condition_type: cond_type,
        flag_name: "",
        threshold: 0.0,
        comparison: "eq",
        custom_id: 0,
    }
}

// Create state transition
fn create_transition(target: string): StateTransition {
    return StateTransition {
        target_state: target,
        conditions: Vec<StateCondition>{},
        priority: 0,
    }
}

// Create state action
fn create_action(action_type: string): StateAction {
    return StateAction {
        action_type: action_type,
        parameters: HashMap<String, String>{},
    }
}

// ============================================================================
// State Machine Context
// ============================================================================

struct StateMachineContext {
    flags: HashMap<String, Bool>,
    values: HashMap<String, Float>,
    timers: HashMap<String, Float>,
    owner_id: i32,
    target_id: i32,
    position_x: f64,
    position_y: f64,
    position_z: f64,
    target_x: f64,
    target_y: f64,
    target_z: f64,
}

// Create empty context
fn create_context(): StateMachineContext {
    return StateMachineContext {
        flags: HashMap<String, Bool>{},
        values: HashMap<String, Float>{},
        timers: HashMap<String, Float>{},
        owner_id: 0,
        target_id: 0,
        position_x: 0.0,
        position_y: 0.0,
        position_z: 0.0,
        target_x: 0.0,
        target_y: 0.0,
        target_z: 0.0,
    }
}

// Set flag in context
fn set_flag(ctx: StateMachineContext, name: string, value: bool) {
    ctx.flags.set(name, value)
}

// Get flag from context
fn get_flag(ctx: StateMachineContext, name: string): bool {
    if (ctx.flags.has(name)) {
        return ctx.flags.get(name)
    }
    return false
}

// Set value in context
fn set_value(ctx: StateMachineContext, name: string, value: f64) {
    ctx.values.set(name, value)
}

// Get value from context
fn get_value(ctx: StateMachineContext, name: string): f64 {
    if (ctx.values.has(name)) {
        return ctx.values.get(name)
    }
    return 0.0
}

// Update timer
fn update_timer(ctx: StateMachineContext, name: string, delta: f64) {
    let current = 0.0
    if (ctx.timers.has(name)) {
        current = ctx.timers.get(name)
    }
    ctx.timers.set(name, current + delta)
}

// Reset timer
fn reset_timer(ctx: StateMachineContext, name: string) {
    ctx.timers.set(name, 0.0)
}

// Get timer value
fn get_timer(ctx: StateMachineContext, name: string): f64 {
    if (ctx.timers.has(name)) {
        return ctx.timers.get(name)
    }
    return 0.0
}

// ============================================================================
// Condition Evaluation
// ============================================================================

// Compare values
fn compare_values(a: f64, b: f64, op: string): bool {
    if (op == "lt") {
        return a < b
    } else if (op == "gt") {
        return a > b
    } else if (op == "eq") {
        return a == b
    } else if (op == "le") {
        return a <= b
    } else if (op == "ge") {
        return a >= b
    } else if (op == "ne") {
        return a != b
    }
    return false
}

// Evaluate a single condition
fn evaluate_condition(cond: StateCondition, ctx: StateMachineContext): bool {
    if (cond.condition_type == ConditionType::Always) {
        return true
    } else if (cond.condition_type == ConditionType::Never) {
        return false
    } else if (cond.condition_type == ConditionType::Flag) {
        return get_flag(ctx, cond.flag_name)
    } else if (cond.condition_type == ConditionType::Timer) {
        let timer_val = get_timer(ctx, cond.flag_name)
        return compare_values(timer_val, cond.threshold, cond.comparison)
    } else if (cond.condition_type == ConditionType::Health) {
        let health = get_value(ctx, "health")
        return compare_values(health, cond.threshold, cond.comparison)
    } else if (cond.condition_type == ConditionType::Distance) {
        let dx = ctx.target_x - ctx.position_x
        let dy = ctx.target_y - ctx.position_y
        let dz = ctx.target_z - ctx.position_z
        let dist = sqrt(dx * dx + dy * dy + dz * dz)
        return compare_values(dist, cond.threshold, cond.comparison)
    }
    // Custom conditions need external evaluation
    return false
}

// Evaluate all conditions in a transition (AND logic)
fn evaluate_transition(trans: StateTransition, ctx: StateMachineContext): bool {
    for cond in trans.conditions {
        if (!evaluate_condition(cond, ctx)) {
            return false
        }
    }
    return true
}

// ============================================================================
// State Machine Definition
// ============================================================================

struct StateMachineDefinition {
    name: string,
    states: HashMap<String, State>,
    initial_state: string,
}

// Create empty state machine definition
fn create_definition(name: string): StateMachineDefinition {
    return StateMachineDefinition {
        name: name,
        states: HashMap<String, State>{},
        initial_state: "",
    }
}

// Add state to definition
fn add_state(def: StateMachineDefinition, state: State) {
    def.states.set(state.name, state)
    if (state.is_initial) {
        def.initial_state = state.name
    }
}

// Get state by name
fn get_state(def: StateMachineDefinition, name: string): State {
    if (def.states.has(name)) {
        return def.states.get(name)
    }
    return create_state("")
}

// Check if state exists
fn has_state(def: StateMachineDefinition, name: string): bool {
    return def.states.has(name)
}

// ============================================================================
// State Machine Instance
// ============================================================================

struct StateMachine {
    definition: StateMachineDefinition,
    current_state: string,
    previous_state: string,
    context: StateMachineContext,
    is_running: bool,
    state_time: f64,
    total_time: f64,
    pending_transition: string,
}

// Create state machine from definition
fn create_state_machine(def: StateMachineDefinition): StateMachine {
    return StateMachine {
        definition: def,
        current_state: def.initial_state,
        previous_state: "",
        context: create_context(),
        is_running: false,
        state_time: 0.0,
        total_time: 0.0,
        pending_transition: "",
    }
}

// Start state machine
fn start(sm: StateMachine) {
    sm.is_running = true
    sm.current_state = sm.definition.initial_state
    sm.state_time = 0.0
    sm.total_time = 0.0

    // Execute enter actions for initial state
    let state = get_state(sm.definition, sm.current_state)
    execute_actions(state.enter_actions, sm.context)
}

// Stop state machine
fn stop(sm: StateMachine) {
    // Execute exit actions for current state
    let state = get_state(sm.definition, sm.current_state)
    execute_actions(state.exit_actions, sm.context)

    sm.is_running = false
}

// Reset state machine
fn reset(sm: StateMachine) {
    sm.current_state = sm.definition.initial_state
    sm.previous_state = ""
    sm.context = create_context()
    sm.is_running = false
    sm.state_time = 0.0
    sm.total_time = 0.0
    sm.pending_transition = ""
}

// Request a state transition
fn request_transition(sm: StateMachine, target_state: string) {
    if (has_state(sm.definition, target_state)) {
        sm.pending_transition = target_state
    }
}

// Execute a transition to a new state
fn execute_transition(sm: StateMachine, target_state: string) {
    if (!has_state(sm.definition, target_state)) {
        return
    }

    // Exit current state
    let current = get_state(sm.definition, sm.current_state)
    execute_actions(current.exit_actions, sm.context)

    // Update state tracking
    sm.previous_state = sm.current_state
    sm.current_state = target_state
    sm.state_time = 0.0

    // Enter new state
    let new_state = get_state(sm.definition, sm.current_state)
    execute_actions(new_state.enter_actions, sm.context)

    // Clear pending transition
    sm.pending_transition = ""
}

// Execute actions (placeholder - actual implementation depends on action types)
fn execute_actions(actions: Vec<StateAction>, ctx: StateMachineContext) {
    for action in actions {
        execute_action(action, ctx)
    }
}

// Execute a single action
fn execute_action(action: StateAction, ctx: StateMachineContext) {
    // Built-in action types
    if (action.action_type == "set_flag") {
        let name = action.parameters.get("name")
        let value = action.parameters.get("value") == "true"
        set_flag(ctx, name, value)
    } else if (action.action_type == "set_value") {
        let name = action.parameters.get("name")
        let value = parse_float(action.parameters.get("value"))
        set_value(ctx, name, value)
    } else if (action.action_type == "reset_timer") {
        let name = action.parameters.get("name")
        reset_timer(ctx, name)
    }
    // Custom actions are handled externally
}

// Update state machine
fn update(sm: StateMachine, delta_time: f64): StateResult {
    if (!sm.is_running) {
        return StateResult::Continue
    }

    // Update timers
    sm.state_time = sm.state_time + delta_time
    sm.total_time = sm.total_time + delta_time
    update_timer(sm.context, "state_time", delta_time)

    // Handle pending transition
    if (sm.pending_transition.len() > 0) {
        execute_transition(sm, sm.pending_transition)
    }

    // Get current state
    let state = get_state(sm.definition, sm.current_state)
    if (state.name.len() == 0) {
        return StateResult::Failure
    }

    // Execute update actions
    execute_actions(state.update_actions, sm.context)

    // Check transitions (highest priority first)
    let best_transition = ""
    let best_priority = -999999

    for trans in state.transitions {
        if (trans.priority > best_priority) {
            if (evaluate_transition(trans, sm.context)) {
                best_transition = trans.target_state
                best_priority = trans.priority
            }
        }
    }

    // Execute transition if found
    if (best_transition.len() > 0) {
        execute_transition(sm, best_transition)
        return StateResult::Transition
    }

    // Check if in final state
    if (state.is_final) {
        return StateResult::Success
    }

    return StateResult::Continue
}

// Get current state name
fn get_current_state(sm: StateMachine): string {
    return sm.current_state
}

// Get previous state name
fn get_previous_state(sm: StateMachine): string {
    return sm.previous_state
}

// Get time in current state
fn get_state_time(sm: StateMachine): f64 {
    return sm.state_time
}

// Check if state machine is running
fn is_running(sm: StateMachine): bool {
    return sm.is_running
}

// ============================================================================
// Helper Functions
// ============================================================================

// Square root approximation
fn sqrt(x: f64): f64 {
    if (x <= 0.0) {
        return 0.0
    }
    // Newton's method
    let guess = x / 2.0
    for i in 0..10 {
        guess = (guess + x / guess) / 2.0
    }
    return guess
}

// Parse float from string
fn parse_float(s: string): f64 {
    let result = 0.0
    let negative = false
    let decimal_part = false
    let decimal_divisor = 1.0

    for i in 0..s.len() {
        let c = s.char_at(i)
        if (c == 45 && i == 0) {  // "-"
            negative = true
        } else if (c == 46) {  // "."
            decimal_part = true
        } else if (c >= 48 && c <= 57) {  // "0"-"9"
            let digit = (c - 48) as Float
            if (decimal_part) {
                decimal_divisor = decimal_divisor * 10.0
                result = result + digit / decimal_divisor
            } else {
                result = result * 10.0 + digit
            }
        }
    }

    if (negative) {
        return -result
    }
    return result
}

// ============================================================================
// State Machine Builder (Fluent API)
// ============================================================================

struct StateMachineBuilder {
    definition: StateMachineDefinition,
    current_state: State,
}

// Create new builder
fn builder(name: string): StateMachineBuilder {
    return StateMachineBuilder {
        definition: create_definition(name),
        current_state: create_state(""),
    }
}

// Add a new state
fn add_state_builder(b: StateMachineBuilder, name: string, is_initial: bool, is_final: bool): StateMachineBuilder {
    // Save previous state if exists
    if (b.current_state.name.len() > 0) {
        add_state(b.definition, b.current_state)
    }

    b.current_state = create_state(name)
    b.current_state.is_initial = is_initial
    b.current_state.is_final = is_final
    return b
}

// Add enter action to current state
fn on_enter(b: StateMachineBuilder, action_type: string): StateMachineBuilder {
    let action = create_action(action_type)
    b.current_state.enter_actions.add(action)
    return b
}

// Add update action to current state
fn on_update(b: StateMachineBuilder, action_type: string): StateMachineBuilder {
    let action = create_action(action_type)
    b.current_state.update_actions.add(action)
    return b
}

// Add exit action to current state
fn on_exit(b: StateMachineBuilder, action_type: string): StateMachineBuilder {
    let action = create_action(action_type)
    b.current_state.exit_actions.add(action)
    return b
}

// Add transition with condition
fn transition_to(b: StateMachineBuilder, target: string, condition_type: ConditionType): StateMachineBuilder {
    let trans = create_transition(target)
    let cond = create_condition(condition_type)
    trans.conditions.add(cond)
    b.current_state.transitions.add(trans)
    return b
}

// Build the state machine definition
fn build(b: StateMachineBuilder): StateMachineDefinition {
    // Save final state
    if (b.current_state.name.len() > 0) {
        add_state(b.definition, b.current_state)
    }
    return b.definition
}

// ============================================================================
// Pre-built State Machine Templates
// ============================================================================

// Create simple two-state toggle machine
fn create_toggle_machine(name: string, state_a: string, state_b: string): StateMachineDefinition {
    let def = create_definition(name)

    let s1 = create_state(state_a)
    s1.is_initial = true
    let t1 = create_transition(state_b)
    let c1 = create_condition(ConditionType::Flag)
    c1.flag_name = "toggle"
    t1.conditions.add(c1)
    s1.transitions.add(t1)
    add_state(def, s1)

    let s2 = create_state(state_b)
    let t2 = create_transition(state_a)
    let c2 = create_condition(ConditionType::Flag)
    c2.flag_name = "toggle"
    t2.conditions.add(c2)
    s2.transitions.add(t2)
    add_state(def, s2)

    return def
}

// Create timer-based sequence machine
fn create_sequence_machine(name: string, states: Vec<string>, durations: Vec<f64>): StateMachineDefinition {
    let def = create_definition(name)

    for i in 0..states.len() {
        let state_name = states.get(i)
        let state = create_state(state_name)

        if (i == 0) {
            state.is_initial = true
        }

        if (i < states.len() - 1) {
            // Add timer-based transition to next state
            let trans = create_transition(states.get(i + 1))
            let cond = create_condition(ConditionType::Timer)
            cond.flag_name = "state_time"
            cond.threshold = durations.get(i)
            cond.comparison = "ge"
            trans.conditions.add(cond)
            state.transitions.add(trans)
        } else {
            state.is_final = true
        }

        add_state(def, state)
    }

    return def
}

// ============================================================================
// Tests
// ============================================================================

fn test_basic_state_machine(): bool {
    let def = create_definition("test")

    let idle = create_state("idle")
    idle.is_initial = true
    let trans = create_transition("moving")
    let cond = create_condition(ConditionType::Flag)
    cond.flag_name = "should_move"
    trans.conditions.add(cond)
    idle.transitions.add(trans)
    add_state(def, idle)

    let moving = create_state("moving")
    moving.is_final = true
    add_state(def, moving)

    let sm = create_state_machine(def)
    start(sm)

    assert(get_current_state(sm) == "idle", "Should start in idle")

    // Update without flag - should stay in idle
    update(sm, 0.1)
    assert(get_current_state(sm) == "idle", "Should stay in idle")

    // Set flag and update - should transition
    set_flag(sm.context, "should_move", true)
    update(sm, 0.1)
    assert(get_current_state(sm) == "moving", "Should transition to moving")

    return true
}

fn test_timer_transition(): bool {
    let states = Vec<string>{}
    states.add("state1")
    states.add("state2")
    states.add("state3")

    let durations = Vec<f64>{}
    durations.add(1.0)
    durations.add(2.0)
    durations.add(0.0)  // Final state

    let def = create_sequence_machine("sequence", states, durations)
    let sm = create_state_machine(def)
    start(sm)

    assert(get_current_state(sm) == "state1", "Should start in state1")

    // Update for 0.5 seconds - should stay
    update(sm, 0.5)
    assert(get_current_state(sm) == "state1", "Should stay in state1")

    // Update for another 0.6 seconds - should transition
    update(sm, 0.6)
    assert(get_current_state(sm) == "state2", "Should transition to state2")

    return true
}

fn test_context(): bool {
    let ctx = create_context()

    set_flag(ctx, "test_flag", true)
    assert(get_flag(ctx, "test_flag") == true, "Flag should be true")
    assert(get_flag(ctx, "missing") == false, "Missing flag should be false")

    set_value(ctx, "health", 75.5)
    assert(get_value(ctx, "health") == 75.5, "Value should be 75.5")

    update_timer(ctx, "timer1", 1.5)
    assert(get_timer(ctx, "timer1") == 1.5, "Timer should be 1.5")

    update_timer(ctx, "timer1", 0.5)
    assert(get_timer(ctx, "timer1") == 2.0, "Timer should be 2.0")

    reset_timer(ctx, "timer1")
    assert(get_timer(ctx, "timer1") == 0.0, "Timer should be reset")

    return true
}

fn test_builder(): bool {
    let def = build(
        transition_to(
            on_update(
                add_state_builder(
                    on_exit(
                        on_enter(
                            add_state_builder(builder("test"), "start", true, false),
                            "log_enter"
                        ),
                        "log_exit"
                    ),
                    "end", false, true
                ),
                "process"
            ),
            "start", ConditionType::Always
        )
    )

    assert(has_state(def, "start"), "Should have start state")
    assert(has_state(def, "end"), "Should have end state")
    assert(def.initial_state == "start", "Initial should be start")

    return true
}

fn run_all_tests(): bool {
    assert(test_basic_state_machine(), "Basic state machine test failed")
    assert(test_timer_transition(), "Timer transition test failed")
    assert(test_context(), "Context test failed")
    assert(test_builder(), "Builder test failed")
    return true
}
