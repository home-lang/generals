// Mask Shader - Selection/highlight masks and outline rendering
// Handles unit selection, ability range indicators, and highlight effects

// ============================================================================
// Configuration
// ============================================================================

struct MaskShaderConfig {
    outline_width: f32 = 2.0,                 // Outline thickness in pixels
    outline_softness: f32 = 0.5,              // Edge softness
    selection_color: Vec4 = Vec4 { x: 0.2, y: 0.8, z: 0.2, w: 1.0 },    // Green
    enemy_color: Vec4 = Vec4 { x: 0.9, y: 0.2, z: 0.2, w: 1.0 },        // Red
    ally_color: Vec4 = Vec4 { x: 0.2, y: 0.5, z: 0.9, w: 1.0 },         // Blue
    neutral_color: Vec4 = Vec4 { x: 0.8, y: 0.8, z: 0.2, w: 1.0 },      // Yellow
    hover_color: Vec4 = Vec4 { x: 1.0, y: 1.0, z: 1.0, w: 0.5 },        // White
    pulse_speed: f32 = 2.0,                   // Pulse animation speed
    pulse_intensity: f32 = 0.3,               // Pulse brightness variation
    glow_radius: f32 = 4.0,                   // Glow effect radius
    glow_intensity: f32 = 0.5,                // Glow brightness
    silhouette_alpha: f32 = 0.3,              // Occluded silhouette alpha
}

// ============================================================================
// Mask Types
// ============================================================================

enum MaskType {
    Selection,                                // Unit selection outline
    Hover,                                    // Mouse hover highlight
    Silhouette,                               // Occluded unit silhouette
    RangeIndicator,                           // Ability/weapon range circle
    AreaEffect,                               // Area of effect indicator
    BuildPlacement,                           // Building placement preview
    Invalid,                                  // Invalid placement (red)
    Waypoint,                                 // Movement waypoint marker
    AttackMove,                               // Attack-move indicator
}

enum OwnershipType {
    Self,
    Ally,
    Enemy,
    Neutral,
}

// ============================================================================
// Mask Instance
// ============================================================================

struct MaskInstance {
    mask_type: MaskType,
    ownership: OwnershipType,
    position: Vec3,
    scale: Vec3,
    rotation: f32,
    color_override: Vec4,
    use_color_override: bool,
    alpha: f32,
    pulse_offset: f32,                        // Individual pulse phase
    is_pulsing: bool,
    inner_radius: f32,                        // For range indicators
    outer_radius: f32,
    fill_amount: f32,                         // For progress indicators
    is_valid: bool,                           // For placement validation
}

fn create_mask_instance(mask_type: MaskType, position: Vec3): MaskInstance {
    return MaskInstance {
        mask_type: mask_type,
        ownership: OwnershipType.Self,
        position: position,
        scale: Vec3 { x: 1.0, y: 1.0, z: 1.0 },
        rotation: 0.0,
        color_override: Vec4 { x: 1.0, y: 1.0, z: 1.0, w: 1.0 },
        use_color_override: false,
        alpha: 1.0,
        pulse_offset: 0.0,
        is_pulsing: true,
        inner_radius: 0.0,
        outer_radius: 10.0,
        fill_amount: 1.0,
        is_valid: true,
    };
}

// ============================================================================
// Shader Uniforms
// ============================================================================

struct MaskShaderUniforms {
    // Matrices
    view_projection: Mat4,
    model_matrix: Mat4,

    // Screen info
    screen_size: Vec2,
    pixel_size: Vec2,                         // 1.0 / screen_size

    // Mask parameters
    mask_color: Vec4,
    outline_width: f32,
    outline_softness: f32,
    glow_radius: f32,
    glow_intensity: f32,

    // Animation
    time: f32,
    pulse_speed: f32,
    pulse_intensity: f32,
    pulse_offset: f32,

    // Range indicator
    inner_radius: f32,
    outer_radius: f32,
    fill_amount: f32,

    // Flags
    is_silhouette: bool,
    silhouette_alpha: f32,
    is_valid: bool,
}

fn create_mask_uniforms(): MaskShaderUniforms {
    return MaskShaderUniforms {
        view_projection: mat4_identity(),
        model_matrix: mat4_identity(),
        screen_size: Vec2 { x: 1920.0, y: 1080.0 },
        pixel_size: Vec2 { x: 1.0 / 1920.0, y: 1.0 / 1080.0 },
        mask_color: Vec4 { x: 0.2, y: 0.8, z: 0.2, w: 1.0 },
        outline_width: 2.0,
        outline_softness: 0.5,
        glow_radius: 4.0,
        glow_intensity: 0.5,
        time: 0.0,
        pulse_speed: 2.0,
        pulse_intensity: 0.3,
        pulse_offset: 0.0,
        inner_radius: 0.0,
        outer_radius: 10.0,
        fill_amount: 1.0,
        is_silhouette: false,
        silhouette_alpha: 0.3,
        is_valid: true,
    };
}

// ============================================================================
// Outline Shader
// ============================================================================

struct OutlineVertex {
    position: Vec3,
    normal: Vec3,
    uv: Vec2,
}

fn outline_vertex_shader(vertex: &OutlineVertex, uniforms: &MaskShaderUniforms): OutlineVertexOutput {
    // Expand vertex along normal for outline
    let expand_amount = uniforms.outline_width * uniforms.pixel_size.x * 100.0;

    let expanded_pos = Vec3 {
        x: vertex.position.x + vertex.normal.x * expand_amount,
        y: vertex.position.y + vertex.normal.y * expand_amount,
        z: vertex.position.z + vertex.normal.z * expand_amount,
    };

    let world_pos = mat4_transform_point(&uniforms.model_matrix, &expanded_pos);
    let clip_pos = mat4_transform_point(&uniforms.view_projection, &world_pos);

    return OutlineVertexOutput {
        clip_position: clip_pos,
        world_position: world_pos,
        uv: vertex.uv,
        distance_from_edge: expand_amount,
    };
}

struct OutlineVertexOutput {
    clip_position: Vec3,
    world_position: Vec3,
    uv: Vec2,
    distance_from_edge: f32,
}

fn outline_fragment_shader(input: &OutlineVertexOutput, uniforms: &MaskShaderUniforms): Vec4 {
    let mut color = uniforms.mask_color;

    // Apply pulse animation
    let pulse = sin_approx(uniforms.time * uniforms.pulse_speed + uniforms.pulse_offset);
    let pulse_factor = 1.0 + pulse * uniforms.pulse_intensity;
    color.x *= pulse_factor;
    color.y *= pulse_factor;
    color.z *= pulse_factor;

    // Edge softness
    let edge_factor = clamp(input.distance_from_edge / uniforms.outline_softness, 0.0, 1.0);
    color.w *= edge_factor;

    // Invalid placement turns red
    if !uniforms.is_valid {
        color = Vec4 { x: 0.9, y: 0.1, z: 0.1, w: color.w };
    }

    return color;
}

// ============================================================================
// Silhouette Shader
// ============================================================================

fn silhouette_fragment_shader(uniforms: &MaskShaderUniforms): Vec4 {
    let mut color = uniforms.mask_color;
    color.w = uniforms.silhouette_alpha;

    // Pulse
    let pulse = sin_approx(uniforms.time * uniforms.pulse_speed * 0.5 + uniforms.pulse_offset);
    color.w *= 0.8 + pulse * 0.2;

    return color;
}

// ============================================================================
// Range Indicator Shader
// ============================================================================

struct RangeIndicatorVertex {
    position: Vec2,                           // Position in range indicator space
    uv: Vec2,
}

fn range_indicator_vertex_shader(vertex: &RangeIndicatorVertex, uniforms: &MaskShaderUniforms, center: &Vec3): RangeIndicatorOutput {
    // Transform from local range space to world
    let world_pos = Vec3 {
        x: center.x + vertex.position.x * uniforms.outer_radius,
        y: center.y + vertex.position.y * uniforms.outer_radius,
        z: center.z,
    };

    let clip_pos = mat4_transform_point(&uniforms.view_projection, &world_pos);

    return RangeIndicatorOutput {
        clip_position: clip_pos,
        local_position: vertex.position,
        uv: vertex.uv,
    };
}

struct RangeIndicatorOutput {
    clip_position: Vec3,
    local_position: Vec2,
    uv: Vec2,
}

fn range_indicator_fragment_shader(input: &RangeIndicatorOutput, uniforms: &MaskShaderUniforms): Vec4 {
    // Calculate distance from center (normalized)
    let dist = sqrt(input.local_position.x * input.local_position.x +
                   input.local_position.y * input.local_position.y);

    // Inner and outer radius ratios
    let inner_ratio = uniforms.inner_radius / uniforms.outer_radius;

    // Ring shape
    let inner_edge = smoothstep(inner_ratio - 0.02, inner_ratio + 0.02, dist);
    let outer_edge = smoothstep(1.02, 0.98, dist);
    let ring = inner_edge * outer_edge;

    // Dashed pattern
    let angle = atan2_approx(input.local_position.y, input.local_position.x);
    let dash_pattern = sin_approx(angle * 16.0 + uniforms.time * 2.0);
    let dash = smoothstep(-0.2, 0.2, dash_pattern);

    // Fill amount (for radial progress)
    let fill_angle = angle + 3.14159;
    let fill_threshold = uniforms.fill_amount * 6.28318;
    let fill_mask = smoothstep(fill_threshold - 0.1, fill_threshold, fill_angle);

    let mut color = uniforms.mask_color;

    // Apply ring and dash
    color.w *= ring * (0.5 + dash * 0.5);

    // Apply fill mask
    if uniforms.fill_amount < 1.0 {
        color.w *= (1.0 - fill_mask);
    }

    // Pulse on outer edge
    let pulse = sin_approx(uniforms.time * uniforms.pulse_speed);
    let outer_pulse = outer_edge * (1.0 - inner_edge) * pulse * 0.3;
    color.w += outer_pulse;

    // Invalid turns red
    if !uniforms.is_valid {
        color = Vec4 { x: 0.9, y: 0.1, z: 0.1, w: color.w };
    }

    return color;
}

// ============================================================================
// Glow Effect
// ============================================================================

fn apply_glow(color: &Vec4, uniforms: &MaskShaderUniforms, uv: &Vec2): Vec4 {
    // Multi-pass blur approximation
    let mut glow_color = *color;

    // Sample in circle pattern
    let samples: i32 = 8;
    let mut accumulated = Vec4 { x: 0.0, y: 0.0, z: 0.0, w: 0.0 };

    for i in 0..samples {
        let angle = (i as f32 / samples as f32) * 6.28318;
        let offset_x = cos_approx(angle) * uniforms.glow_radius * uniforms.pixel_size.x;
        let offset_y = sin_approx(angle) * uniforms.glow_radius * uniforms.pixel_size.y;

        // Simulated texture sample at offset
        accumulated.x += color.x;
        accumulated.y += color.y;
        accumulated.z += color.z;
        accumulated.w += color.w;
    }

    accumulated.x /= samples as f32;
    accumulated.y /= samples as f32;
    accumulated.z /= samples as f32;
    accumulated.w /= samples as f32;

    // Blend glow with original
    glow_color.x = color.x + accumulated.x * uniforms.glow_intensity;
    glow_color.y = color.y + accumulated.y * uniforms.glow_intensity;
    glow_color.z = color.z + accumulated.z * uniforms.glow_intensity;
    glow_color.w = max_f32(color.w, accumulated.w * uniforms.glow_intensity);

    return glow_color;
}

// ============================================================================
// Mask Shader Manager
// ============================================================================

struct MaskShaderManager {
    config: MaskShaderConfig,
    uniforms: MaskShaderUniforms,
    active_masks: [MaskInstance; 256],
    mask_count: i32,
    current_time: f32,
}

fn create_mask_shader_manager(config: MaskShaderConfig): MaskShaderManager {
    return MaskShaderManager {
        config: config,
        uniforms: create_mask_uniforms(),
        active_masks: [create_mask_instance(MaskType.Selection, Vec3 { x: 0.0, y: 0.0, z: 0.0 }); 256],
        mask_count: 0,
        current_time: 0.0,
    };
}

fn add_mask(manager: &mut MaskShaderManager, mask: MaskInstance): i32 {
    if manager.mask_count >= 256 {
        return -1;
    }

    manager.active_masks[manager.mask_count] = mask;
    let index = manager.mask_count;
    manager.mask_count += 1;
    return index;
}

fn remove_mask(manager: &mut MaskShaderManager, index: i32) {
    if index < 0 || index >= manager.mask_count {
        return;
    }

    // Shift remaining masks
    for i in index..(manager.mask_count - 1) {
        manager.active_masks[i] = manager.active_masks[i + 1];
    }
    manager.mask_count -= 1;
}

fn clear_masks(manager: &mut MaskShaderManager) {
    manager.mask_count = 0;
}

fn get_color_for_ownership(config: &MaskShaderConfig, ownership: OwnershipType): Vec4 {
    match ownership {
        OwnershipType.Self => config.selection_color,
        OwnershipType.Ally => config.ally_color,
        OwnershipType.Enemy => config.enemy_color,
        OwnershipType.Neutral => config.neutral_color,
    }
}

fn update_mask_shader(manager: &mut MaskShaderManager, delta_time: f32, view_proj: &Mat4) {
    manager.current_time += delta_time;
    manager.uniforms.time = manager.current_time;
    manager.uniforms.view_projection = *view_proj;
    manager.uniforms.pulse_speed = manager.config.pulse_speed;
    manager.uniforms.pulse_intensity = manager.config.pulse_intensity;
    manager.uniforms.outline_width = manager.config.outline_width;
    manager.uniforms.outline_softness = manager.config.outline_softness;
    manager.uniforms.glow_radius = manager.config.glow_radius;
    manager.uniforms.glow_intensity = manager.config.glow_intensity;
    manager.uniforms.silhouette_alpha = manager.config.silhouette_alpha;
}

fn render_masks(manager: &MaskShaderManager) {
    for i in 0..manager.mask_count {
        let mask = &manager.active_masks[i];
        render_single_mask(manager, mask);
    }
}

fn render_single_mask(manager: &MaskShaderManager, mask: &MaskInstance) {
    // Set up uniforms for this mask
    let mut uniforms = manager.uniforms;

    // Set color based on ownership or override
    if mask.use_color_override {
        uniforms.mask_color = mask.color_override;
    } else {
        uniforms.mask_color = get_color_for_ownership(&manager.config, mask.ownership);
    }

    uniforms.mask_color.w *= mask.alpha;
    uniforms.pulse_offset = mask.pulse_offset;
    uniforms.is_valid = mask.is_valid;
    uniforms.inner_radius = mask.inner_radius;
    uniforms.outer_radius = mask.outer_radius;
    uniforms.fill_amount = mask.fill_amount;
    uniforms.is_silhouette = mask.mask_type == MaskType.Silhouette;

    // Create model matrix from position/scale/rotation
    uniforms.model_matrix = create_transform_matrix(&mask.position, &mask.scale, mask.rotation);

    // Render based on mask type
    match mask.mask_type {
        MaskType.Selection => render_outline_mask(&uniforms),
        MaskType.Hover => render_hover_mask(&uniforms),
        MaskType.Silhouette => render_silhouette_mask(&uniforms),
        MaskType.RangeIndicator => render_range_indicator(&uniforms, &mask.position),
        MaskType.AreaEffect => render_area_effect(&uniforms, &mask.position),
        MaskType.BuildPlacement => render_build_placement(&uniforms),
        MaskType.Invalid => render_invalid_placement(&uniforms),
        MaskType.Waypoint => render_waypoint_marker(&uniforms, &mask.position),
        MaskType.AttackMove => render_attack_move_marker(&uniforms, &mask.position),
    }
}

fn render_outline_mask(uniforms: &MaskShaderUniforms) {
    // Would render outline geometry
}

fn render_hover_mask(uniforms: &MaskShaderUniforms) {
    // Would render hover highlight
}

fn render_silhouette_mask(uniforms: &MaskShaderUniforms) {
    // Would render occluded silhouette
}

fn render_range_indicator(uniforms: &MaskShaderUniforms, center: &Vec3) {
    // Would render range circle
}

fn render_area_effect(uniforms: &MaskShaderUniforms, center: &Vec3) {
    // Would render area effect indicator
}

fn render_build_placement(uniforms: &MaskShaderUniforms) {
    // Would render building placement preview
}

fn render_invalid_placement(uniforms: &MaskShaderUniforms) {
    // Would render invalid placement indicator
}

fn render_waypoint_marker(uniforms: &MaskShaderUniforms, position: &Vec3) {
    // Would render waypoint marker
}

fn render_attack_move_marker(uniforms: &MaskShaderUniforms, position: &Vec3) {
    // Would render attack-move marker
}

// ============================================================================
// Helper Functions
// ============================================================================

fn create_transform_matrix(position: &Vec3, scale: &Vec3, rotation: f32): Mat4 {
    let cos_r = cos_approx(rotation);
    let sin_r = sin_approx(rotation);

    return Mat4 {
        data: [
            scale.x * cos_r, scale.x * sin_r, 0.0, 0.0,
            -scale.y * sin_r, scale.y * cos_r, 0.0, 0.0,
            0.0, 0.0, scale.z, 0.0,
            position.x, position.y, position.z, 1.0,
        ]
    };
}

fn sin_approx(x: f32): f32 {
    let mut x2 = x;
    while x2 > 3.14159 { x2 -= 6.28318; }
    while x2 < -3.14159 { x2 += 6.28318; }
    let x3 = x2 * x2 * x2;
    let x5 = x3 * x2 * x2;
    return x2 - x3 / 6.0 + x5 / 120.0;
}

fn cos_approx(x: f32): f32 {
    return sin_approx(x + 1.5708);
}

fn atan2_approx(y: f32, x: f32): f32 {
    // Simple atan2 approximation
    if x == 0.0 {
        if y > 0.0 { return 1.5708; }
        if y < 0.0 { return -1.5708; }
        return 0.0;
    }

    let ratio = y / x;
    let mut angle = ratio / (1.0 + 0.28 * ratio * ratio);

    if x < 0.0 {
        if y >= 0.0 { angle += 3.14159; }
        else { angle -= 3.14159; }
    }

    return angle;
}

fn sqrt(x: f32): f32 {
    if x <= 0.0 { return 0.0; }
    let mut guess = x / 2.0;
    for _ in 0..10 {
        guess = (guess + x / guess) / 2.0;
    }
    return guess;
}

fn smoothstep(edge0: f32, edge1: f32, x: f32): f32 {
    let t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

fn clamp(x: f32, min_val: f32, max_val: f32): f32 {
    if x < min_val { return min_val; }
    if x > max_val { return max_val; }
    return x;
}

fn max_f32(a: f32, b: f32): f32 {
    if a > b { return a; }
    return b;
}

fn mat4_identity(): Mat4 {
    return Mat4 { data: [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0] };
}

fn mat4_transform_point(m: &Mat4, p: &Vec3): Vec3 {
    return Vec3 {
        x: m.data[0] * p.x + m.data[4] * p.y + m.data[8] * p.z + m.data[12],
        y: m.data[1] * p.x + m.data[5] * p.y + m.data[9] * p.z + m.data[13],
        z: m.data[2] * p.x + m.data[6] * p.y + m.data[10] * p.z + m.data[14],
    };
}

// ============================================================================
// Tests
// ============================================================================

fn test_mask_shader() {
    print("Testing Mask Shader...");

    // Create manager
    let config = MaskShaderConfig {};
    let mut manager = create_mask_shader_manager(config);
    print("  Created mask shader manager");

    // Add selection mask
    let mut selection = create_mask_instance(MaskType.Selection, Vec3 { x: 100.0, y: 100.0, z: 0.0 });
    selection.ownership = OwnershipType.Self;
    let idx1 = add_mask(&mut manager, selection);
    print("  Added selection mask: " + idx1 as string);

    // Add range indicator
    let mut range = create_mask_instance(MaskType.RangeIndicator, Vec3 { x: 200.0, y: 200.0, z: 0.0 });
    range.inner_radius = 5.0;
    range.outer_radius = 50.0;
    let idx2 = add_mask(&mut manager, range);
    print("  Added range indicator: " + idx2 as string);

    // Update
    let view_proj = mat4_identity();
    update_mask_shader(&mut manager, 0.016, &view_proj);
    print("  Updated shader");

    // Render
    render_masks(&manager);
    print("  Rendered " + manager.mask_count as string + " masks");

    // Test color for ownership
    let enemy_color = get_color_for_ownership(&config, OwnershipType.Enemy);
    print("  Enemy color: (" + enemy_color.x as string + ", " + enemy_color.y as string + ", " + enemy_color.z as string + ")");

    print("Mask Shader tests complete!");
}
