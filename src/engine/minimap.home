// Minimap System for Generals RTS
// Displays a small overview of the game world

import "basics/math"

struct Vec2 {
    x: Float,
    y: Float,
}

fn create_vec2(x: Float, y: Float) -> Vec2 {
    let v = Vec2 {}
    v.x = x
    v.y = y
    return v
}

/// Minimap configuration
struct MinimapConfig {
    x: Float,
    y: Float,
    width: Float,
    height: Float,
    world_width: Float,
    world_height: Float,
    background_color: Vec4,
    border_color: Vec4,
    border_width: Float,
}

struct Vec4 {
    r: Float,
    g: Float,
    b: Float,
    a: Float,
}

fn create_minimap_config(x: Float, y: Float, size: Float, world_width: Float, world_height: Float) -> MinimapConfig {
    let config = MinimapConfig {}
    config.x = x
    config.y = y
    config.width = size
    config.height = size
    config.world_width = world_width
    config.world_height = world_height

    // Very dark gray background
    config.background_color = Vec4 {}
    config.background_color.r = 0.05
    config.background_color.g = 0.05
    config.background_color.b = 0.05
    config.background_color.a = 0.9

    // Medium gray border
    config.border_color = Vec4 {}
    config.border_color.r = 0.3
    config.border_color.g = 0.3
    config.border_color.b = 0.3
    config.border_color.a = 1.0

    config.border_width = 2.0
    return config
}

/// Convert world position to minimap position
fn world_to_minimap(config: MinimapConfig, world_pos: Vec2) -> Vec2 {
    let normalized_x = (world_pos.x + config.world_width / 2.0) / config.world_width
    let normalized_y = (world_pos.y + config.world_height / 2.0) / config.world_height

    return create_vec2(
        config.x + normalized_x * config.width,
        config.y + normalized_y * config.height,
    )
}

/// Convert minimap position to world position
fn minimap_to_world(config: MinimapConfig, minimap_pos: Vec2) -> Vec2 {
    let normalized_x = (minimap_pos.x - config.x) / config.width
    let normalized_y = (minimap_pos.y - config.y) / config.height

    return create_vec2(
        normalized_x * config.world_width - config.world_width / 2.0,
        normalized_y * config.world_height - config.world_height / 2.0,
    )
}

/// Check if screen position is within minimap bounds
fn config_contains(config: MinimapConfig, screen_x: Float, screen_y: Float) -> Bool {
    return screen_x >= config.x && screen_x <= config.x + config.width &&
           screen_y >= config.y && screen_y <= config.y + config.height
}

/// Minimap icon types
enum MinimapIconType {
    UNIT_FRIENDLY,
    UNIT_ENEMY,
    UNIT_NEUTRAL,
    BUILDING_FRIENDLY,
    BUILDING_ENEMY,
    BUILDING_NEUTRAL,
    RESOURCE,
}

/// Minimap icon (represents an entity on the minimap)
struct MinimapIcon {
    position: Vec2,
    icon_type: MinimapIconType,
    size: Float,
}

fn create_minimap_icon(position: Vec2, icon_type: MinimapIconType) -> MinimapIcon {
    let size = 2.0
    if icon_type == MinimapIconType::BUILDING_FRIENDLY ||
       icon_type == MinimapIconType::BUILDING_ENEMY ||
       icon_type == MinimapIconType::BUILDING_NEUTRAL {
        size = 4.0
    } else if icon_type == MinimapIconType::UNIT_FRIENDLY ||
              icon_type == MinimapIconType::UNIT_ENEMY ||
              icon_type == MinimapIconType::UNIT_NEUTRAL {
        size = 2.0
    } else if icon_type == MinimapIconType::RESOURCE {
        size = 3.0
    }

    let icon = MinimapIcon {}
    icon.position = position
    icon.icon_type = icon_type
    icon.size = size
    return icon
}

fn get_icon_color(icon: MinimapIcon) -> Vec4 {
    let color = Vec4 {}

    if icon.icon_type == MinimapIconType::UNIT_FRIENDLY {
        // Green
        color.r = 0.0
        color.g = 0.8
        color.b = 0.0
        color.a = 1.0
    } else if icon.icon_type == MinimapIconType::UNIT_ENEMY {
        // Red
        color.r = 0.8
        color.g = 0.0
        color.b = 0.0
        color.a = 1.0
    } else if icon.icon_type == MinimapIconType::UNIT_NEUTRAL {
        // Yellow
        color.r = 0.8
        color.g = 0.8
        color.b = 0.0
        color.a = 1.0
    } else if icon.icon_type == MinimapIconType::BUILDING_FRIENDLY {
        // Bright green
        color.r = 0.0
        color.g = 1.0
        color.b = 0.0
        color.a = 1.0
    } else if icon.icon_type == MinimapIconType::BUILDING_ENEMY {
        // Bright red
        color.r = 1.0
        color.g = 0.0
        color.b = 0.0
        color.a = 1.0
    } else if icon.icon_type == MinimapIconType::BUILDING_NEUTRAL {
        // Bright yellow
        color.r = 1.0
        color.g = 1.0
        color.b = 0.0
        color.a = 1.0
    } else if icon.icon_type == MinimapIconType::RESOURCE {
        // Blue
        color.r = 0.0
        color.g = 0.5
        color.b = 1.0
        color.a = 1.0
    }

    return color
}

/// Camera viewport rectangle on minimap
struct MinimapViewport {
    x: Float,
    y: Float,
    width: Float,
    height: Float,
}

/// Simple camera for minimap viewport calculation
struct Camera {
    position: Vec2,
    viewport_width: Float,
    viewport_height: Float,
    zoom: Float,
}

/// Minimap manager
struct Minimap {
    config: MinimapConfig,
    visible: Bool,
    camera_viewport_color: Vec4,
}

fn create_minimap(screen_width: Float, screen_height: Float, world_width: Float, world_height: Float) -> Minimap {
    let minimap_size = 200.0
    let margin = 10.0
    let x = screen_width - minimap_size - margin
    let y = margin

    let minimap = Minimap {}
    minimap.config = create_minimap_config(x, y, minimap_size, world_width, world_height)
    minimap.visible = true

    // White, semi-transparent viewport indicator
    minimap.camera_viewport_color = Vec4 {}
    minimap.camera_viewport_color.r = 1.0
    minimap.camera_viewport_color.g = 1.0
    minimap.camera_viewport_color.b = 1.0
    minimap.camera_viewport_color.a = 0.5

    return minimap
}

fn update_minimap(minimap: Minimap, screen_width: Float) {
    let minimap_size = 200.0
    let margin = 10.0
    minimap.config.x = screen_width - minimap_size - margin
}

fn toggle_minimap(minimap: Minimap) {
    minimap.visible = !minimap.visible
}

/// Handle click on minimap (returns world position)
struct ClickResult {
    valid: Bool,
    position: Vec2,
}

fn handle_minimap_click(minimap: Minimap, screen_x: Float, screen_y: Float) -> ClickResult {
    let result = ClickResult {}
    result.valid = false
    result.position = create_vec2(0.0, 0.0)

    if !minimap.visible {
        return result
    }

    if !config_contains(minimap.config, screen_x, screen_y) {
        return result
    }

    let minimap_pos = create_vec2(screen_x, screen_y)
    result.position = minimap_to_world(minimap.config, minimap_pos)
    result.valid = true
    return result
}

/// Get camera viewport rectangle on minimap
fn get_camera_viewport(minimap: Minimap, camera: Camera) -> MinimapViewport {
    let camera_center = camera.position
    let half_view_width = (camera.viewport_width / camera.zoom) / 2.0
    let half_view_height = (camera.viewport_height / camera.zoom) / 2.0

    // Calculate world-space corners
    let top_left = create_vec2(
        camera_center.x - half_view_width,
        camera_center.y - half_view_height
    )
    let bottom_right = create_vec2(
        camera_center.x + half_view_width,
        camera_center.y + half_view_height
    )

    // Convert to minimap space
    let minimap_top_left = world_to_minimap(minimap.config, top_left)
    let minimap_bottom_right = world_to_minimap(minimap.config, bottom_right)

    let viewport = MinimapViewport {}
    viewport.x = minimap_top_left.x
    viewport.y = minimap_top_left.y
    viewport.width = minimap_bottom_right.x - minimap_top_left.x
    viewport.height = minimap_bottom_right.y - minimap_top_left.y
    return viewport
}

// ============================================================================
// Tests
// ============================================================================

fn test_minimap_config_world_to_minimap() -> Bool {
    let config = create_minimap_config(100.0, 100.0, 200.0, 2000.0, 2000.0)

    // Center of world (0, 0) should map to center of minimap (200, 200)
    let center_world = create_vec2(0.0, 0.0)
    let center_minimap = world_to_minimap(config, center_world)
    assert(center_minimap.x >= 199.0 && center_minimap.x <= 201.0, "Center X should be ~200")
    assert(center_minimap.y >= 199.0 && center_minimap.y <= 201.0, "Center Y should be ~200")

    // World bounds (-1000, -1000) should map to minimap (100, 100)
    let top_left_world = create_vec2(-1000.0, -1000.0)
    let top_left_minimap = world_to_minimap(config, top_left_world)
    assert(top_left_minimap.x >= 99.0 && top_left_minimap.x <= 101.0, "Top-left X should be ~100")
    assert(top_left_minimap.y >= 99.0 && top_left_minimap.y <= 101.0, "Top-left Y should be ~100")

    return true
}

fn test_minimap_config_minimap_to_world() -> Bool {
    let config = create_minimap_config(100.0, 100.0, 200.0, 2000.0, 2000.0)

    // Center of minimap (200, 200) should map to center of world (0, 0)
    let center_minimap = create_vec2(200.0, 200.0)
    let center_world = minimap_to_world(config, center_minimap)
    assert(center_world.x >= -1.0 && center_world.x <= 1.0, "Center X should be ~0")
    assert(center_world.y >= -1.0 && center_world.y <= 1.0, "Center Y should be ~0")

    return true
}

fn test_minimap_config_contains() -> Bool {
    let config = create_minimap_config(100.0, 100.0, 200.0, 2000.0, 2000.0)

    assert(config_contains(config, 200.0, 200.0), "Center should be inside")
    assert(config_contains(config, 100.0, 100.0), "Top-left should be inside")
    assert(config_contains(config, 300.0, 300.0), "Bottom-right should be inside")
    assert(!config_contains(config, 50.0, 200.0), "Left of minimap should be outside")
    assert(!config_contains(config, 350.0, 200.0), "Right of minimap should be outside")

    return true
}

fn test_minimap_handle_click() -> Bool {
    let minimap = create_minimap(1024.0, 768.0, 2000.0, 2000.0)

    // Click in center of minimap should return world (~0, ~0)
    let result = handle_minimap_click(minimap, 200.0, 200.0)
    assert(result.valid, "Click should be valid")
    assert(result.position.x >= -10.0 && result.position.x <= 10.0, "World X should be ~0")
    assert(result.position.y >= -10.0 && result.position.y <= 10.0, "World Y should be ~0")

    // Click outside minimap should return invalid
    let outside = handle_minimap_click(minimap, 50.0, 50.0)
    assert(!outside.valid, "Outside click should be invalid")

    return true
}

fn test_minimap_icon_colors() -> Bool {
    let pos = create_vec2(100.0, 100.0)

    let friendly_unit = create_minimap_icon(pos, MinimapIconType::UNIT_FRIENDLY)
    let color = get_icon_color(friendly_unit)
    assert(color.g > 0.5, "Friendly unit should be green")

    let enemy_building = create_minimap_icon(pos, MinimapIconType::BUILDING_ENEMY)
    let color2 = get_icon_color(enemy_building)
    assert(color2.r > 0.5, "Enemy building should be red")
    assert(enemy_building.size == 4.0, "Buildings should be size 4")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_minimap_config_world_to_minimap(), "World to minimap conversion test failed")
    assert(test_minimap_config_minimap_to_world(), "Minimap to world conversion test failed")
    assert(test_minimap_config_contains(), "Config contains test failed")
    assert(test_minimap_handle_click(), "Handle click test failed")
    assert(test_minimap_icon_colors(), "Icon colors test failed")
    return true
}
