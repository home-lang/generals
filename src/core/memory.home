// C&C Generals Zero Hour - Home Port
// Core Memory Management System
//
// Original: GameMemory.cpp (Westwood Studios/EA)
// Ported to Home with modern safety features

import basics/allocator

// Memory pool configuration
const POOL_SIZE_SMALL: usize = 32
const POOL_SIZE_MEDIUM: usize = 128
const POOL_SIZE_LARGE: usize = 512
const POOL_BLOCK_COUNT: usize = 1024

// Debug options (compile-time flags)
comptime const DEBUG_MEMORY: bool = true
comptime const TRACK_ALLOCATIONS: bool = true
comptime const FILL_ON_FREE: bool = true

// Memory statistics
struct MemoryStats {
    total_allocated: usize
    total_freed: usize
    current_usage: usize
    peak_usage: usize
    allocation_count: usize
    free_count: usize
}

// Memory pool for fixed-size allocations
struct MemoryPool<T> {
    blocks: []T
    free_list: []bool
    block_size: usize
    capacity: usize
    used_count: usize

    fn init(allocator: Allocator, capacity: usize): MemoryPool<T> {
        return MemoryPool {
            blocks: allocator.alloc(T, capacity)
            free_list: allocator.alloc(bool, capacity)
            block_size: @sizeOf(T)
            capacity: capacity
            used_count: 0
        }
    }

    fn allocate(mut self): ?*T {
        for i in 0..self.capacity {
            if (!self.free_list[i]) {
                self.free_list[i] = true
                self.used_count += 1
                return &self.blocks[i]
            }
        }
        return null
    }

    fn free(mut self, ptr: *T) {
        let index = (@ptrToInt(ptr) - @ptrToInt(&self.blocks[0])) / self.block_size

        comptime if FILL_ON_FREE {
            // Fill with debug pattern on free
            @memset(@ptrCast(*u8, ptr), 0xDE, self.block_size)
        }

        self.free_list[index] = false
        self.used_count -= 1
    }

    fn deinit(mut self, allocator: Allocator) {
        allocator.free(self.blocks)
        allocator.free(self.free_list)
    }
}

// Global memory allocator with pools
struct GameMemory {
    allocator: Allocator
    small_pool: MemoryPool<[u8; POOL_SIZE_SMALL]>
    medium_pool: MemoryPool<[u8; POOL_SIZE_MEDIUM]>
    large_pool: MemoryPool<[u8; POOL_SIZE_LARGE]>
    stats: MemoryStats
}

// Global memory manager instance
var g_memory: ?GameMemory = null

// Initialize global memory system
export fn init_memory(allocator: Allocator) {
    g_memory = GameMemory.init(allocator)
}

// Shutdown memory system
export fn shutdown_memory() {
    if (g_memory) {
        g_memory.?.deinit()
        g_memory = null
    }
}

// Allocate memory from global pool
export fn game_alloc(size: usize): ?*u8 {
    if (g_memory) {
        return g_memory.?.allocate(size)
    }
    return null
}

// Free memory to global pool
export fn game_free(ptr: *u8, size: usize) {
    if (g_memory) {
        g_memory.?.free(ptr, size)
    }
}

// Get memory statistics
export fn get_memory_stats(): MemoryStats {
    if (g_memory) {
        return g_memory.?.get_stats()
    }
    return MemoryStats {
        total_allocated: 0
        total_freed: 0
        current_usage: 0
        peak_usage: 0
        allocation_count: 0
        free_count: 0
    }
}
