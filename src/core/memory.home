// C&C Generals Zero Hour - Home Port
// Core Memory Management System
//
// Original: GameMemory.cpp (Westwood Studios/EA)
// Ported to Home with modern safety features

import basics/allocator

// Memory pool configuration
const POOL_SIZE_SMALL: usize = 32
const POOL_SIZE_MEDIUM: usize = 128
const POOL_SIZE_LARGE: usize = 512
const POOL_BLOCK_COUNT: usize = 1024

// Debug options (compile-time flags)
comptime const DEBUG_MEMORY: bool = true
comptime const TRACK_ALLOCATIONS: bool = true
comptime const FILL_ON_FREE: bool = true

// Memory statistics
struct MemoryStats {
    total_allocated: usize
    total_freed: usize
    current_usage: usize
    peak_usage: usize
    allocation_count: usize
    free_count: usize
}

// Memory pool for fixed-size allocations
struct MemoryPool<T> {
    blocks: []T
    free_list: []bool
    block_size: usize
    capacity: usize
    used_count: usize

    fn init(allocator: Allocator, capacity: usize): MemoryPool<T> {
        return MemoryPool {
            blocks: allocator.alloc(T, capacity)
            free_list: allocator.alloc(bool, capacity)
            block_size: @sizeOf(T)
            capacity: capacity
            used_count: 0
        }
    }

    fn allocate(mut self): ?*T {
        for i in 0..self.capacity {
            if !self.free_list[i] {
                self.free_list[i] = true
                self.used_count += 1
                return &self.blocks[i]
            }
        }
        return null
    }

    fn free(mut self, ptr: *T) {
        let index = (@ptrToInt(ptr) - @ptrToInt(&self.blocks[0])) / self.block_size

        comptime if FILL_ON_FREE {
            // Fill with debug pattern on free
            @memset(@ptrCast(*u8, ptr), 0xDE, self.block_size)
        }

        self.free_list[index] = false
        self.used_count -= 1
    }

    fn deinit(mut self, allocator: Allocator) {
        allocator.free(self.blocks)
        allocator.free(self.free_list)
    }
}

// Global memory allocator with pools
struct GameMemory {
    allocator: Allocator
    small_pool: MemoryPool<[u8; POOL_SIZE_SMALL]>
    medium_pool: MemoryPool<[u8; POOL_SIZE_MEDIUM]>
    large_pool: MemoryPool<[u8; POOL_SIZE_LARGE]>
    stats: MemoryStats

    fn init(allocator: Allocator): GameMemory {
        return GameMemory {
            allocator: allocator
            small_pool: MemoryPool.init(allocator, POOL_BLOCK_COUNT)
            medium_pool: MemoryPool.init(allocator, POOL_BLOCK_COUNT / 2)
            large_pool: MemoryPool.init(allocator, POOL_BLOCK_COUNT / 4)
            stats: MemoryStats {
                total_allocated: 0
                total_freed: 0
                current_usage: 0
                peak_usage: 0
                allocation_count: 0
                free_count: 0
            }
        }
    }

    fn allocate(mut self, size: usize): ?*u8 {
        comptime if TRACK_ALLOCATIONS {
            self.stats.allocation_count += 1
            self.stats.total_allocated += size
            self.stats.current_usage += size

            if self.stats.current_usage > self.stats.peak_usage {
                self.stats.peak_usage = self.stats.current_usage
            }
        }

        // Route to appropriate pool based on size
        if size <= POOL_SIZE_SMALL {
            return @ptrCast(?*u8, self.small_pool.allocate())
        } else if size <= POOL_SIZE_MEDIUM {
            return @ptrCast(?*u8, self.medium_pool.allocate())
        } else if size <= POOL_SIZE_LARGE {
            return @ptrCast(?*u8, self.large_pool.allocate())
        }

        // Fall back to system allocator for large allocations
        return self.allocator.alloc(u8, size)
    }

    fn free(mut self, ptr: *u8, size: usize) {
        comptime if TRACK_ALLOCATIONS {
            self.stats.free_count += 1
            self.stats.total_freed += size
            self.stats.current_usage -= size
        }

        // Return to appropriate pool or system allocator
        if size <= POOL_SIZE_SMALL {
            self.small_pool.free(@ptrCast(*[u8; POOL_SIZE_SMALL], ptr))
        } else if size <= POOL_SIZE_MEDIUM {
            self.medium_pool.free(@ptrCast(*[u8; POOL_SIZE_MEDIUM], ptr))
        } else if size <= POOL_SIZE_LARGE {
            self.large_pool.free(@ptrCast(*[u8; POOL_SIZE_LARGE], ptr))
        } else {
            self.allocator.free(@ptrCast([]u8, ptr)[0..size])
        }
    }

    fn get_stats(&self): MemoryStats {
        return self.stats
    }

    fn print_stats(&self) {
        comptime if DEBUG_MEMORY {
            print("=== Memory Statistics ===")
            print("Total Allocated: {} bytes", self.stats.total_allocated)
            print("Total Freed: {} bytes", self.stats.total_freed)
            print("Current Usage: {} bytes", self.stats.current_usage)
            print("Peak Usage: {} bytes", self.stats.peak_usage)
            print("Allocations: {}", self.stats.allocation_count)
            print("Frees: {}", self.stats.free_count)
            print("Small Pool Usage: {}/{}", self.small_pool.used_count, self.small_pool.capacity)
            print("Medium Pool Usage: {}/{}", self.medium_pool.used_count, self.medium_pool.capacity)
            print("Large Pool Usage: {}/{}", self.large_pool.used_count, self.large_pool.capacity)
        }
    }

    fn deinit(mut self) {
        comptime if DEBUG_MEMORY {
            self.print_stats()

            // Check for memory leaks
            if self.stats.current_usage > 0 {
                print("WARNING: Memory leak detected! {} bytes not freed", self.stats.current_usage)
            }
        }

        self.small_pool.deinit(self.allocator)
        self.medium_pool.deinit(self.allocator)
        self.large_pool.deinit(self.allocator)
    }
}

// Global memory manager instance
var g_memory: ?GameMemory = null

// Initialize global memory system
export fn init_memory(allocator: Allocator) {
    g_memory = GameMemory.init(allocator)
}

// Shutdown memory system
export fn shutdown_memory() {
    if g_memory {
        g_memory.?.deinit()
        g_memory = null
    }
}

// Allocate memory from global pool
export fn game_alloc(size: usize): ?*u8 {
    if g_memory {
        return g_memory.?.allocate(size)
    }
    return null
}

// Free memory to global pool
export fn game_free(ptr: *u8, size: usize) {
    if g_memory {
        g_memory.?.free(ptr, size)
    }
}

// Get memory statistics
export fn get_memory_stats(): MemoryStats {
    if g_memory {
        return g_memory.?.get_stats()
    }
    return MemoryStats {
        total_allocated: 0
        total_freed: 0
        current_usage: 0
        peak_usage: 0
        allocation_count: 0
        free_count: 0
    }
}
