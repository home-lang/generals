// C&C Generals Zero Hour - Home Port
// Archive File System (.big file format)
//
// Original: ArchiveFile.cpp (Westwood Studios/EA)
// Ported to Home with modern features

import basics/allocator
import core/string
import core/filesystem

// Archive file format constants
const ARCHIVE_SIGNATURE: u32 = 0x47494220  // "BIG " in hex
const ARCHIVE_VERSION: u32 = 0x00000001

// Archived file information
struct ArchivedFileInfo {
    filename: string
    offset: usize
    size: usize
    timestamp: i64
}

// Directory tree node for organizing archived files
struct ArchivedDirectory {
    name: string
    file_count: usize
    subdir_count: usize
    allocator: Allocator
}

// Archive file reader (.big format)
struct ArchiveFile {
    path: string
    name: string
    root_directory: ArchivedDirectory
    file_count: usize
    priority: i32
    allocator: Allocator
        pattern: string,
        recursive: bool,
                        name: dir.files[i].filename
                        is_directory: false
                        size: dir.files[i].size
}

// Utility functions

fn read_u32_be(data: []u8): u32 {
    // Read big-endian 32-bit integer
    return (@intCast(u32, data[0]) << 24) |
           (@intCast(u32, data[1]) << 16) |
           (@intCast(u32, data[2]) << 8) |
           (@intCast(u32, data[3]))
}

fn extract_filename(path: string): string {
    // Extract filename from full path
    let mut i = path.len
    while (i > 0) {
        i -= 1
        if (path[i] == "/" or path[i] == '\\') {
            return path[(i + 1)..path.len]
        }
    }
    return path
}

fn wildcard_match(str: string, pattern: string): bool {
    // Simple wildcard matching (* and ?)
    // TODO: Implement proper wildcard matching
    // For now, just check if pattern is "*" (match all)
    if (pattern.len == 1 and pattern[0] == "*") {
        return true
    }

    // Exact match
    return string_eq(str, pattern)
}

// Global archive manager
struct ArchiveManager {
    archive_count: usize
    allocator: Allocator
}

var g_archive_manager: ?ArchiveManager = null

export fn init_archive_system(allocator: Allocator) {
    g_archive_manager = ArchiveManager.init(allocator)
}

export fn shutdown_archive_system() {
    if (g_archive_manager) {
        g_archive_manager.?.deinit()
        g_archive_manager = null
    }
}

export fn load_archive(path: string, priority: i32): bool {
    if (g_archive_manager) {
        return g_archive_manager.?.load_archive(path, priority)
    }
    return false
}
