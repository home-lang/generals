// C&C Generals Zero Hour - Home Port
// Core String System
//
// Original: AsciiString.cpp (Westwood Studios/EA)
// Ported to Home with modern string handling

import basics/allocator

// String pool for interning common strings
const STRING_POOL_SIZE: usize = 4096

struct StringPool {
    count: usize
    allocator: Allocator
}

// Dynamic string builder (similar to AsciiString in original)
struct StringBuilder {
    length: usize
    capacity: usize
    allocator: Allocator
}

// String utilities
fn string_eq(a: string, b: string): bool {
    if (a.len != b.len) {
        return false
    }

    for i in 0..a.len {
        if (a[i] != b[i]) {
            return false
        }
    }

    return true
}

fn string_starts_with(str: string, prefix: string): bool {
    if (prefix.len > str.len) {
        return false
    }

    for i in 0..prefix.len {
        if (str[i] != prefix[i]) {
            return false
        }
    }

    return true
}

fn string_ends_with(str: string, suffix: string): bool {
    if (suffix.len > str.len) {
        return false
    }

    let offset = str.len - suffix.len
    for i in 0..suffix.len {
        if (str[offset + i] != suffix[i]) {
            return false
        }
    }

    return true
}

fn string_contains(str: string, needle: string): bool {
    if (needle.len > str.len) {
        return false
    }

    for i in 0..(str.len - needle.len + 1) {
        let mut found = true
        for j in 0..needle.len {
            if (str[i + j] != needle[j]) {
                found = false
                break
            }
        }
        if (found) {
            return true
        }
    }

    return false
}

fn string_find(str: string, needle: string): ?usize {
    if (needle.len > str.len) {
        return null
    }

    for i in 0..(str.len - needle.len + 1) {
        let mut found = true
        for j in 0..needle.len {
            if (str[i + j] != needle[j]) {
                found = false
                break
            }
        }
        if (found) {
            return i
        }
    }

    return null
}

fn to_lower(allocator: Allocator, str: string): []u8 {
    let result = allocator.alloc(u8, str.len)

    for i in 0..str.len {
        let ch = str[i]
        if (ch >= "A" and ch <= "Z") {
            result[i] = ch + 32
        } else {
            result[i] = ch
        }
    }

    return result
}

fn to_upper(allocator: Allocator, str: string): []u8 {
    let result = allocator.alloc(u8, str.len)

    for i in 0..str.len {
        let ch = str[i]
        if (ch >= "a" and ch <= "z") {
            result[i] = ch - 32
        } else {
            result[i] = ch
        }
    }

    return result
}

// Global string pool
var g_string_pool: ?StringPool = null

export fn init_string_pool(allocator: Allocator) {
    g_string_pool = StringPool.init(allocator)
}

export fn shutdown_string_pool() {
    if (g_string_pool) {
        g_string_pool.?.deinit()
        g_string_pool = null
    }
}

export fn intern_string(str: string): string {
    if (g_string_pool) {
        return g_string_pool.?.intern(str)
    }
    return str
}
