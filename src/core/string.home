// C&C Generals Zero Hour - Home Port
// Core String System
//
// Original: AsciiString.cpp (Westwood Studios/EA)
// Ported to Home with modern string handling

import basics/allocator

// String pool for interning common strings
const STRING_POOL_SIZE: usize = 4096

struct StringPool {
    strings: []*u8
    lengths: []usize
    count: usize
    allocator: Allocator

    fn init(allocator: Allocator): StringPool {
        return StringPool {
            strings: allocator.alloc(*u8, STRING_POOL_SIZE)
            lengths: allocator.alloc(usize, STRING_POOL_SIZE)
            count: 0
            allocator: allocator
        }
    }

    fn intern(mut self, str: string): string {
        // Check if string already exists in pool
        for i in 0..self.count {
            if self.lengths[i] == str.len {
                let pooled = @ptrCast([]u8, self.strings[i])[0..self.lengths[i]]
                if string_eq(pooled, str) {
                    return pooled
                }
            }
        }

        // Add new string to pool
        if self.count < STRING_POOL_SIZE {
            let copy = self.allocator.alloc(u8, str.len)
            @memcpy(copy.ptr, str.ptr, str.len)

            self.strings[self.count] = copy.ptr
            self.lengths[self.count] = str.len
            self.count += 1

            return copy
        }

        // Pool full, return original
        return str
    }

    fn deinit(mut self) {
        for i in 0..self.count {
            self.allocator.free(@ptrCast([]u8, self.strings[i])[0..self.lengths[i]])
        }
        self.allocator.free(self.strings)
        self.allocator.free(self.lengths)
    }
}

// Dynamic string builder (similar to AsciiString in original)
struct StringBuilder {
    buffer: []u8
    length: usize
    capacity: usize
    allocator: Allocator

    fn init(allocator: Allocator): StringBuilder {
        return StringBuilder.with_capacity(allocator, 64)
    }

    fn with_capacity(allocator: Allocator, capacity: usize): StringBuilder {
        return StringBuilder {
            buffer: allocator.alloc(u8, capacity)
            length: 0
            capacity: capacity
            allocator: allocator
        }
    }

    fn from_string(allocator: Allocator, str: string): StringBuilder {
        let mut sb = StringBuilder.with_capacity(allocator, str.len * 2)
        sb.append(str)
        return sb
    }

    fn ensure_capacity(mut self, additional: usize) {
        if self.length + additional > self.capacity {
            let new_capacity = (self.capacity * 2).max(self.length + additional)
            let new_buffer = self.allocator.alloc(u8, new_capacity)

            @memcpy(new_buffer.ptr, self.buffer.ptr, self.length)
            self.allocator.free(self.buffer)

            self.buffer = new_buffer
            self.capacity = new_capacity
        }
    }

    fn append(mut self, str: string) {
        self.ensure_capacity(str.len)
        @memcpy(&self.buffer[self.length], str.ptr, str.len)
        self.length += str.len
    }

    fn append_char(mut self, ch: u8) {
        self.ensure_capacity(1)
        self.buffer[self.length] = ch
        self.length += 1
    }

    fn append_int(mut self, value: i32) {
        // Simple integer to string conversion
        let mut temp: [32]u8
        let mut temp_len: usize = 0

        if value == 0 {
            self.append_char("0")
            return
        }

        let mut n = value
        let negative = n < 0

        if negative {
            n = -n
        }

        while n > 0 {
            temp[temp_len] = "0" + @intCast(u8, n % 10)
            temp_len += 1
            n /= 10
        }

        if negative {
            self.append_char("-")
        }

        // Reverse and append
        for i in 0..temp_len {
            self.append_char(temp[temp_len - 1 - i])
        }
    }

    fn clear(mut self) {
        self.length = 0
    }

    fn to_string(&self): string {
        return self.buffer[0..self.length]
    }

    fn to_owned(&self): []u8 {
        let result = self.allocator.alloc(u8, self.length)
        @memcpy(result.ptr, self.buffer.ptr, self.length)
        return result
    }

    fn deinit(mut self) {
        self.allocator.free(self.buffer)
    }
}

// String utilities
fn string_eq(a: string, b: string): bool {
    if a.len != b.len {
        return false
    }

    for i in 0..a.len {
        if a[i] != b[i] {
            return false
        }
    }

    return true
}

fn string_starts_with(str: string, prefix: string): bool {
    if prefix.len > str.len {
        return false
    }

    for i in 0..prefix.len {
        if str[i] != prefix[i] {
            return false
        }
    }

    return true
}

fn string_ends_with(str: string, suffix: string): bool {
    if suffix.len > str.len {
        return false
    }

    let offset = str.len - suffix.len
    for i in 0..suffix.len {
        if str[offset + i] != suffix[i] {
            return false
        }
    }

    return true
}

fn string_contains(str: string, needle: string): bool {
    if needle.len > str.len {
        return false
    }

    for i in 0..(str.len - needle.len + 1) {
        let mut found = true
        for j in 0..needle.len {
            if str[i + j] != needle[j] {
                found = false
                break
            }
        }
        if found {
            return true
        }
    }

    return false
}

fn string_find(str: string, needle: string): ?usize {
    if needle.len > str.len {
        return null
    }

    for i in 0..(str.len - needle.len + 1) {
        let mut found = true
        for j in 0..needle.len {
            if str[i + j] != needle[j] {
                found = false
                break
            }
        }
        if found {
            return i
        }
    }

    return null
}

fn to_lower(allocator: Allocator, str: string): []u8 {
    let result = allocator.alloc(u8, str.len)

    for i in 0..str.len {
        let ch = str[i]
        if ch >= "A" and ch <= "Z" {
            result[i] = ch + 32
        } else {
            result[i] = ch
        }
    }

    return result
}

fn to_upper(allocator: Allocator, str: string): []u8 {
    let result = allocator.alloc(u8, str.len)

    for i in 0..str.len {
        let ch = str[i]
        if ch >= "a" and ch <= "z" {
            result[i] = ch - 32
        } else {
            result[i] = ch
        }
    }

    return result
}

// Global string pool
var g_string_pool: ?StringPool = null

export fn init_string_pool(allocator: Allocator) {
    g_string_pool = StringPool.init(allocator)
}

export fn shutdown_string_pool() {
    if g_string_pool {
        g_string_pool.?.deinit()
        g_string_pool = null
    }
}

export fn intern_string(str: string): string {
    if g_string_pool {
        return g_string_pool.?.intern(str)
    }
    return str
}
