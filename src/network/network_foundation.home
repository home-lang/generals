// C&C Generals Zero Hour - Home Port
// Network Foundation (Base networking types and utilities)
//
// Original: NetworkDefs.h, networkutil.h (Westwood Studios/EA)
// Ported to Home with modern networking

import basics/allocator
import basics/string

// Network configuration constants
const MAX_PLAYERS: usize = 8
const MAX_PACKET_SIZE: usize = 1400  // MTU - headers
const DEFAULT_PORT: u16 = 8086
const PROTOCOL_VERSION: u32 = 1

// Network command types (from EA's NetCommandType enum)
enum NetCommandType {
    Invalid
    GameCommand          // Game logic command (move unit, build, etc.)
    Frame                // Frame synchronization message
    AckStage1            // Acknowledgment stage 1 (received by host)
    AckStage2            // Acknowledgment stage 2 (received by all players)
    AckBoth              // Combined ACK
    PlayerLeave          // Player disconnected
    KeepAlive            // Keep connection alive
    Chat                 // Chat message
    RunAhead             // Latency hiding configuration
    RunAheadMetrics      // Latency/FPS metrics
    DisconnectPlayer     // Request player disconnect
    DisconnectKeepAlive  // Disconnect keep alive
    DisconnectChat       // Disconnect with chat message
    DisconnectVote       // Vote to disconnect player
    DisconnectFrame      // Frame at which disconnect occurs
    Progress             // Loading progress
    FileTransfer         // File transfer (maps, mods)
    FileAnnounce         // Announce file availability
    FileProgress         // File transfer progress
    Wrapper              // Wrapper for chunked messages
    FrameResendRequest   // Request to resend a frame
}

// Player connection state
enum PlayerState {
    Disconnected
    Connecting
    Loading
    Ready
    Playing
    Disconnecting
}

// Network transport type
enum TransportType {
    UDP          // UDP for game data
    TCP          // TCP for reliable transfers
    LAN          // LAN discovery
}

// Player info
struct PlayerInfo {
    player_id: u8
    slot_id: u8
    name: string
    state: PlayerState
    port: u16
    latency: u32  // Milliseconds
    packet_loss: f32  // 0.0 to 1.0
    team: u8
    color: u8
    faction: string
    is_ready: bool
    is_host: bool
    is_observer: bool
}

// Packet header
struct PacketHeader {
    magic: u32  // Protocol identifier
    version: u32
    packet_type: NetCommandType
    sequence_number: u32
    timestamp: u32
    sender_id: u8
    payload_size: u16
    checksum: u32
}

// Network packet
struct NetworkPacket {
    header: PacketHeader
    payload_length: usize
}

// Connection info
struct Connection {
    remote_player_id: u8
    remote_port: u16
    is_connected: bool
    connection_time: f64
    last_received_time: f64
    last_sent_time: f64
    sequence_number: u32
    last_acked_sequence: u32
    pending_ack_count: usize
    packets_sent: u32
    packets_received: u32
    bytes_sent: u64
    bytes_received: u64
    rtt: f32  // Round-trip time in ms
}

// Network statistics
struct NetworkStats {
    total_packets_sent: u64
    total_packets_received: u64
    total_bytes_sent: u64
    total_bytes_received: u64
    average_latency: f32
    packet_loss_rate: f32
    bandwidth_usage: f32  // KB/s
    current_frame: u32
    frames_behind: i32  // Negative = ahead, positive = behind
}

// Network event types
enum NetworkEventType {
    PlayerJoined
    PlayerLeft
    PlayerReady
    ChatMessage
    ConnectionLost
    PacketReceived
    FileTransferStarted
    FileTransferComplete
}

// Network event
struct NetworkEvent {
    event_type: NetworkEventType
    player_id: u8
    timestamp: f64
    data: string
}

// Utility functions

fn get_current_time(): f64 {
    // TODO: Implement platform-specific time function
    return 0.0
}

fn serialize_u32(value: u32, buffer: []u8, offset: usize) {
    buffer[offset + 0] = @intCast(u8, (value >> 24) & 0xFF)
    buffer[offset + 1] = @intCast(u8, (value >> 16) & 0xFF)
    buffer[offset + 2] = @intCast(u8, (value >> 8) & 0xFF)
    buffer[offset + 3] = @intCast(u8, value & 0xFF)
}

fn deserialize_u32(buffer: []u8, offset: usize): u32 {
    let mut value: u32 = 0
    value |= @intCast(u32, buffer[offset + 0]) << 24
    value |= @intCast(u32, buffer[offset + 1]) << 16
    value |= @intCast(u32, buffer[offset + 2]) << 8
    value |= @intCast(u32, buffer[offset + 3])
    return value
}

fn serialize_u16(value: u16, buffer: []u8, offset: usize) {
    buffer[offset + 0] = @intCast(u8, (value >> 8) & 0xFF)
    buffer[offset + 1] = @intCast(u8, value & 0xFF)
}

fn deserialize_u16(buffer: []u8, offset: usize): u16 {
    let mut value: u16 = 0
    value |= @intCast(u16, buffer[offset + 0]) << 8
    value |= @intCast(u16, buffer[offset + 1])
    return value
}

fn serialize_f32(value: f32, buffer: []u8, offset: usize) {
    // TODO: Implement proper float serialization
    // For now, use bit cast
    let bits = @bitCast(u32, value)
    serialize_u32(bits, buffer, offset)
}

fn deserialize_f32(buffer: []u8, offset: usize): f32 {
    let bits = deserialize_u32(buffer, offset)
    return @bitCast(f32, bits)
}

// Export constants
export fn get_max_players(): usize {
    return MAX_PLAYERS
}

export fn get_default_port(): u16 {
    return DEFAULT_PORT
}

export fn get_protocol_version(): u32 {
    return PROTOCOL_VERSION
}
