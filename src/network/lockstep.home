// C&C Generals Zero Hour - Home Port
// Lockstep Networking (Deterministic frame synchronization)
//
// Original: FrameDataManager.cpp, FrameData.cpp (Westwood Studios/EA)
// Ported to Home with deterministic gameplay synchronization

import basics/allocator
import network/network_foundation

// Frame constants
const FRAMES_PER_SECOND: u32 = 30  // Game runs at 30 FPS for network games
const MAX_RUN_AHEAD_FRAMES: u32 = 8  // Maximum frames to run ahead of slowest player
const DEFAULT_RUN_AHEAD: u32 = 3
const FRAME_BUFFER_SIZE: usize = 256  // Circular buffer for frames

// Frame data return status (from EA's FrameDataReturnType)
enum FrameDataStatus {
    Ready           // All commands for this frame are ready
    NotReady        // Still waiting for commands
    MissingPlayer   // Missing commands from a player
    Timeout         // Frame timed out
}

// Game command (player action in the game)
struct GameCommand {
    command_id: u16
    player_id: u8
    execution_frame: u32
    timestamp: u32
    command_type: GameCommandType
    param_count: u8
}

// Game command types (from EA's GameMessage::Type)
enum GameCommandType {
    Invalid
    DoSelection          // Select units
    DoMove               // Move units to position
    DoAttack             // Attack target
    DoAttackMove         // Attack-move to position
    DoBuild              // Build structure
    DoProduceUnit        // Queue unit production
    DoCancelProduction   // Cancel production
    DoSell               // Sell structure
    DoRepair             // Repair structure
    DoSetStance          // Set unit stance
    DoSetRallyPoint      // Set rally point
    DoUseSpecialPower    // Activate special power
    DoUpgrade            // Research upgrade
    DoFormation          // Change formation
    DoGarrison           // Garrison units
    DoEvacuate           // Evacuate garrison
    DoStop               // Stop current action
    ChatMessage          // Chat message
    Surrender            // Player surrenders
}

// Frame command list
struct FrameCommandList {
    frame_number: u32
    command_count: usize
    max_commands: usize
    is_complete: bool
    missing_players: u8  // Bitmask of players we're waiting for
}

// Frame data manager (from EA's FrameDataManager)
struct FrameDataManager {
    buffer_size: usize
    current_frame: u32
    latest_complete_frame: u32
    execution_frame: u32  // Frame currently being executed
    run_ahead_frames: u32  // How many frames ahead we can run
    max_run_ahead: u32
    active_players: u8  // Bitmask of active players
    is_local: bool  // Are we the host?
    is_synchronized: bool
    sync_timeout: f32
    time_since_last_frame: f32
    allocator: Allocator
}

// Command builder (helper for creating commands)
struct CommandBuilder {
    next_command_id: u16
    local_player_id: u8
    current_frame: u32
}

// Synchronization checker (ensures all clients are in sync)
struct SyncChecker {
    crc_buffer_size: usize
    check_interval: u32  // Check sync every N frames
    last_check_frame: u32
    allocator: Allocator
}

// Global lockstep manager
var g_frame_manager: ?FrameDataManager = null
var g_command_builder: ?CommandBuilder = null
var g_sync_checker: ?SyncChecker = null

export fn init_lockstep(allocator: Allocator, is_local: bool, player_id: u8) {
    g_frame_manager = FrameDataManager.init(allocator, is_local)
    g_command_builder = CommandBuilder.init(player_id)
    g_sync_checker = SyncChecker.init(allocator)
}

export fn shutdown_lockstep() {
    if (g_frame_manager) {
        g_frame_manager.?.deinit()
        g_frame_manager = null
    }

    if (g_sync_checker) {
        g_sync_checker.?.deinit()
        g_sync_checker = null
    }

    g_command_builder = null
}

export fn update_lockstep(delta_time: f32) {
    if (g_frame_manager) {
        g_frame_manager.?.update(delta_time)
    }
}

export fn issue_move_command(entity_ids: []u32, count: usize, x: f32, y: f32, z: f32) {
    if (!g_command_builder or !g_frame_manager) {
        return
    }

    let cmd = g_command_builder.?.create_move_command(entity_ids, count, x, y, z)
    g_frame_manager.?.add_game_command(cmd)

    // TODO: Send command to other players over network
}

export fn get_current_execution_frame(): u32 {
    if (g_frame_manager) {
        return g_frame_manager.?.execution_frame
    }
    return 0
}
