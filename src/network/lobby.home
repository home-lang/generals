// C&C Generals Zero Hour - Home Port
// Lobby & Matchmaking System
//
// Original: LANAPI.cpp, LANGameInfo.cpp, Connection.cpp (Westwood Studios/EA)
// Ported to Home with modern lobby features

import basics/allocator
import basics/string
import network/network_foundation

// Lobby constants
const MAX_LOBBY_GAMES: usize = 100
const MAX_LOBBY_PLAYERS: usize = 32
const LOBBY_UPDATE_INTERVAL: f32 = 2.0  // Seconds between lobby refreshes

// Game hosting settings
struct GameSettings {
    game_name: string
    map_name: string
    max_players: u8
    is_ranked: bool
    is_password_protected: bool
    password_hash: u32

    // Game rules
    starting_credits: u32
    allow_superweapons: bool
    time_limit: u32  // Minutes (0 = no limit)
    game_speed: GameSpeed
    victory_condition: VictoryCondition

    // Map settings
    map_size: MapSize
    map_crc: u32  // CRC of map file for validation

    fn init(): GameSettings {
        return GameSettings {
            game_name: "New Game"
            map_name: "Tournament Desert"
            max_players: 8
            is_ranked: false
            is_password_protected: false
            password_hash: 0
            starting_credits: 10000
            allow_superweapons: true
            time_limit: 0
            game_speed: GameSpeed.Normal
            victory_condition: VictoryCondition.DestroyAll
            map_size: MapSize.Large
            map_crc: 0
        }
    }
}

// Game speed
enum GameSpeed {
    Slow        // 0.8x
    Normal      // 1.0x
    Fast        // 1.2x
    VeryFast    // 1.5x
}

// Victory condition
enum VictoryCondition {
    DestroyAll          // Destroy all enemy buildings
    CaptureFlag         // Hold flag for duration
    ControlPoints       // Control majority of points
    Timed               // Most points at time limit
}

// Map size
enum MapSize {
    Small       // 2v2
    Medium      // 3v3, 4v4
    Large       // 6v6, 8v8
    Huge        // Special maps
}

// Game lobby (visible game)
struct GameLobby {
    game_id: u32
    host_player_id: u8
    host_name: string
    host_ip: [4]u8
    host_port: u16

    // Game info
    settings: GameSettings
    status: LobbyStatus

    // Players
    players: []PlayerInfo
    player_count: usize

    // Timing
    created_time: f64
    last_update_time: f64

    // Ping
    ping: u32

    fn init(allocator: Allocator, game_id: u32): GameLobby {
        return GameLobby {
            game_id: game_id
            host_player_id: 0
            host_name: "Host"
            host_ip: [0, 0, 0, 0]
            host_port: 0
            settings: GameSettings.init()
            status: LobbyStatus.Open
            players: allocator.alloc(PlayerInfo, MAX_PLAYERS)
            player_count: 0
            created_time: 0.0
            last_update_time: 0.0
            ping: 0
        }
    }

    fn add_player(mut self, player: PlayerInfo): bool {
        if self.player_count >= self.settings.max_players {
            return false
        }

        if self.player_count >= self.players.len {
            return false
        }

        self.players[self.player_count] = player
        self.player_count += 1

        // Update lobby status
        if self.player_count >= self.settings.max_players {
            self.status = LobbyStatus.Full
        }

        return true
    }

    fn remove_player(mut self, player_id: u8): bool {
        let mut found_index: ?usize = null

        for i in 0..self.player_count {
            if self.players[i].player_id == player_id {
                found_index = i
                break
            }
        }

        if !found_index {
            return false
        }

        let index = found_index.?

        // Shift players down
        for i in index..(self.player_count - 1) {
            self.players[i] = self.players[i + 1]
        }

        self.player_count -= 1

        // Update status
        if self.status == LobbyStatus.Full {
            self.status = LobbyStatus.Open
        }

        return true
    }

    fn get_player(&self, player_id: u8): ?*PlayerInfo {
        for i in 0..self.player_count {
            if self.players[i].player_id == player_id {
                return &self.players[i]
            }
        }
        return null
    }

    fn is_full(&self): bool {
        return self.player_count >= self.settings.max_players
    }

    fn is_joinable(&self): bool {
        return self.status == LobbyStatus.Open and !self.is_full()
    }

    fn all_players_ready(&self): bool {
        for i in 0..self.player_count {
            if !self.players[i].is_ready and !self.players[i].is_observer {
                return false
            }
        }
        return true
    }

    fn can_start(&self): bool {
        if self.player_count < 2 {
            return false
        }

        return self.all_players_ready()
    }
}

// Lobby status
enum LobbyStatus {
    Open            // Accepting players
    Full            // Full but not started
    Starting        // Countdown to start
    InProgress      // Game started
    Closed          // Game finished
}

// Lobby browser (lists all available games)
struct LobbyBrowser {
    lobbies: []GameLobby
    lobby_count: usize

    // Filters
    filter_ranked_only: bool
    filter_has_slots: bool
    filter_map_name: string

    // LAN discovery
    is_scanning: bool
    last_scan_time: f64
    scan_interval: f32

    allocator: Allocator

    fn init(allocator: Allocator): LobbyBrowser {
        return LobbyBrowser {
            lobbies: allocator.alloc(GameLobby, MAX_LOBBY_GAMES)
            lobby_count: 0
            filter_ranked_only: false
            filter_has_slots: true
            filter_map_name: ""
            is_scanning: false
            last_scan_time: 0.0
            scan_interval: 5.0
            allocator: allocator
        }
    }

    fn refresh(mut self) {
        // TODO: Send discovery packets on LAN
        // TODO: Query online matchmaking server
        self.last_scan_time = get_current_time()
        self.is_scanning = true
    }

    fn add_or_update_lobby(mut self, lobby: GameLobby) {
        // Check if lobby already exists
        for i in 0..self.lobby_count {
            if self.lobbies[i].game_id == lobby.game_id {
                // Update existing lobby
                self.lobbies[i] = lobby
                self.lobbies[i].last_update_time = get_current_time()
                return
            }
        }

        // Add new lobby
        if self.lobby_count < self.lobbies.len {
            self.lobbies[self.lobby_count] = lobby
            self.lobbies[self.lobby_count].last_update_time = get_current_time()
            self.lobby_count += 1
        }
    }

    fn remove_lobby(mut self, game_id: u32) {
        let mut found_index: ?usize = null

        for i in 0..self.lobby_count {
            if self.lobbies[i].game_id == game_id {
                found_index = i
                break
            }
        }

        if !found_index {
            return
        }

        let index = found_index.?

        // Shift lobbies down
        for i in index..(self.lobby_count - 1) {
            self.lobbies[i] = self.lobbies[i + 1]
        }

        self.lobby_count -= 1
    }

    fn update(mut self, delta_time: f32) {
        let current_time = get_current_time()

        // Remove stale lobbies (no update in 30 seconds)
        let mut i: usize = 0
        while i < self.lobby_count {
            let time_since_update = current_time - self.lobbies[i].last_update_time

            if time_since_update > 30.0 {
                self.remove_lobby(self.lobbies[i].game_id)
            } else {
                i += 1
            }
        }

        // Auto-refresh if interval elapsed
        if current_time - self.last_scan_time > self.scan_interval {
            self.refresh()
        }
    }

    fn get_filtered_lobbies(&self): []GameLobby {
        // TODO: Apply filters and return matching lobbies
        return self.lobbies[0..self.lobby_count]
    }

    fn sort_by_ping(mut self) {
        // Bubble sort by ping (simple for now)
        for i in 0..self.lobby_count {
            for j in (i + 1)..self.lobby_count {
                if self.lobbies[j].ping < self.lobbies[i].ping {
                    let temp = self.lobbies[i]
                    self.lobbies[i] = self.lobbies[j]
                    self.lobbies[j] = temp
                }
            }
        }
    }

    fn deinit(mut self) {
        self.allocator.free(self.lobbies)
    }
}

// Player slot in lobby
struct PlayerSlot {
    slot_id: u8
    player: ?PlayerInfo
    is_occupied: bool
    is_closed: bool  // Slot disabled by host
    team_assignment: u8
    starting_position: u8

    fn init(slot_id: u8): PlayerSlot {
        return PlayerSlot {
            slot_id: slot_id
            player: null
            is_occupied: false
            is_closed: false
            team_assignment: 0
            starting_position: slot_id
        }
    }
}

// Lobby host manager
struct LobbyHost {
    my_lobby: GameLobby
    player_slots: []PlayerSlot

    // Host controls
    is_hosting: bool
    is_starting: bool
    countdown_time: f32

    // Chat
    chat_messages: []ChatMessage
    chat_count: usize

    allocator: Allocator

    fn init(allocator: Allocator, settings: GameSettings): LobbyHost {
        let mut host = LobbyHost {
            my_lobby: GameLobby.init(allocator, 1)  // TODO: Generate unique ID
            player_slots: allocator.alloc(PlayerSlot, MAX_PLAYERS)
            is_hosting: true
            is_starting: false
            countdown_time: 5.0
            chat_messages: allocator.alloc(ChatMessage, 100)
            chat_count: 0
            allocator: allocator
        }

        host.my_lobby.settings = settings

        // Initialize slots
        for i in 0..MAX_PLAYERS {
            host.player_slots[i] = PlayerSlot.init(@intCast(u8, i))
        }

        return host
    }

    fn update(mut self, delta_time: f32) {
        // Update countdown
        if self.is_starting {
            self.countdown_time -= delta_time

            if self.countdown_time <= 0.0 {
                self.start_game()
            }
        }
    }

    fn kick_player(mut self, player_id: u8) {
        self.my_lobby.remove_player(player_id)

        // Free up slot
        for i in 0..self.player_slots.len {
            if self.player_slots[i].is_occupied {
                if self.player_slots[i].player {
                    if self.player_slots[i].player.?.player_id == player_id {
                        self.player_slots[i].is_occupied = false
                        self.player_slots[i].player = null
                    }
                }
            }
        }

        // TODO: Send kick message to player
    }

    fn change_settings(mut self, new_settings: GameSettings) {
        self.my_lobby.settings = new_settings

        // TODO: Broadcast settings change to all players
    }

    fn assign_team(mut self, player_id: u8, team: u8) {
        // Find player slot
        for i in 0..self.player_slots.len {
            if self.player_slots[i].is_occupied {
                if self.player_slots[i].player {
                    if self.player_slots[i].player.?.player_id == player_id {
                        self.player_slots[i].team_assignment = team

                        if self.player_slots[i].player {
                            self.player_slots[i].player.?.team = team
                        }
                    }
                }
            }
        }
    }

    fn begin_countdown(mut self) {
        if !self.my_lobby.can_start() {
            return
        }

        self.is_starting = true
        self.countdown_time = 5.0

        // TODO: Broadcast countdown to all players
    }

    fn cancel_countdown(mut self) {
        self.is_starting = false
        self.countdown_time = 5.0
    }

    fn start_game(mut self) {
        // Transition to in-game
        self.my_lobby.status = LobbyStatus.InProgress

        // TODO: Initialize game session
        // TODO: Transition all players to loading screen
    }

    fn send_chat(mut self, message: string) {
        if self.chat_count >= self.chat_messages.len {
            return
        }

        self.chat_messages[self.chat_count] = ChatMessage {
            sender_id: 0  // Host
            sender_name: self.my_lobby.host_name
            message: message
            timestamp: get_current_time()
        }

        self.chat_count += 1

        // TODO: Broadcast chat to all players
    }

    fn deinit(mut self) {
        self.allocator.free(self.player_slots)
        self.allocator.free(self.chat_messages)
    }
}

// Chat message
struct ChatMessage {
    sender_id: u8
    sender_name: string
    message: string
    timestamp: f64
}

// Lobby client (player joining a game)
struct LobbyClient {
    joined_lobby: ?GameLobby
    my_player_info: PlayerInfo
    my_slot_id: u8

    // Connection
    is_connected: bool
    connection_status: string

    // Chat
    chat_messages: []ChatMessage
    chat_count: usize

    allocator: Allocator

    fn init(allocator: Allocator, player_name: string): LobbyClient {
        return LobbyClient {
            joined_lobby: null
            my_player_info: PlayerInfo.init(0, player_name)
            my_slot_id: 0
            is_connected: false
            connection_status: "Not connected"
            chat_messages: allocator.alloc(ChatMessage, 100)
            chat_count: 0
            allocator: allocator
        }
    }

    fn join_lobby(mut self, lobby: GameLobby): bool {
        if !lobby.is_joinable() {
            self.connection_status = "Lobby is full"
            return false
        }

        // TODO: Send join request to host
        self.joined_lobby = lobby
        self.connection_status = "Connecting..."

        return true
    }

    fn leave_lobby(mut self) {
        if !self.joined_lobby {
            return
        }

        // TODO: Send leave message to host
        self.joined_lobby = null
        self.is_connected = false
        self.connection_status = "Disconnected"
    }

    fn set_ready(mut self, is_ready: bool) {
        self.my_player_info.is_ready = is_ready

        // TODO: Send ready status to host
    }

    fn select_faction(mut self, faction: string) {
        self.my_player_info.faction = faction

        // TODO: Send faction choice to host
    }

    fn select_color(mut self, color: u8) {
        self.my_player_info.color = color

        // TODO: Send color choice to host
    }

    fn send_chat(mut self, message: string) {
        if !self.is_connected {
            return
        }

        // TODO: Send chat message to host/all players
    }

    fn deinit(mut self) {
        self.allocator.free(self.chat_messages)
    }
}

// Global lobby state
var g_lobby_browser: ?LobbyBrowser = null
var g_lobby_host: ?LobbyHost = null
var g_lobby_client: ?LobbyClient = null

export fn init_lobby_browser(allocator: Allocator) {
    g_lobby_browser = LobbyBrowser.init(allocator)
}

export fn create_lobby(allocator: Allocator, settings: GameSettings) {
    g_lobby_host = LobbyHost.init(allocator, settings)
}

export fn join_lobby_as_client(allocator: Allocator, player_name: string) {
    g_lobby_client = LobbyClient.init(allocator, player_name)
}

export fn shutdown_lobby() {
    if g_lobby_browser {
        g_lobby_browser.?.deinit()
        g_lobby_browser = null
    }

    if g_lobby_host {
        g_lobby_host.?.deinit()
        g_lobby_host = null
    }

    if g_lobby_client {
        g_lobby_client.?.deinit()
        g_lobby_client = null
    }
}

export fn update_lobby(delta_time: f32) {
    if g_lobby_browser {
        g_lobby_browser.?.update(delta_time)
    }

    if g_lobby_host {
        g_lobby_host.?.update(delta_time)
    }
}
