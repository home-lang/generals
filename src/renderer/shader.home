// Shader - GLSL shader compilation and management
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/w3d/renderer/shader.h

import std.collections.HashMap
import platform.file.File
import math.{Vec2, Vec3, Vec4, Mat4}

/// Shader type
enum ShaderType {
    Vertex,
    Fragment,
    Geometry,
}

/// Shader compilation result
struct ShaderHandle {
    id: u32,
    shader_type: ShaderType,
}

impl ShaderHandle {
    fn new(id: u32, shader_type: ShaderType) -> ShaderHandle {
        return ShaderHandle { id: id, shader_type: shader_type }
    }

    fn is_valid(self: &ShaderHandle) -> bool {
        return self.id != 0
    }
}

/// Compiled shader program
struct ShaderProgram {
    id: u32,
    vertex_shader: ShaderHandle,
    fragment_shader: ShaderHandle,
    geometry_shader: Option<ShaderHandle>,
    uniform_locations: HashMap<String, i32>,
    attribute_locations: HashMap<String, i32>,
}

impl ShaderProgram {
    /// Create empty shader program
    fn new() -> ShaderProgram {
        return ShaderProgram {
            id: 0,
            vertex_shader: ShaderHandle.new(0, ShaderType.Vertex),
            fragment_shader: ShaderHandle.new(0, ShaderType.Fragment),
            geometry_shader: None,
            uniform_locations: HashMap.new(),
            attribute_locations: HashMap.new()
        }
    }

    /// Compile shader from source
    fn compile_shader(source: String, shader_type: ShaderType) -> Result<ShaderHandle, String> {
        // Create shader object
        // let shader_id = gl.CreateShader(gl_shader_type)
        let shader_id: u32 = 1  // Placeholder

        // Compile shader
        // gl.ShaderSource(shader_id, 1, &source_ptr, null)
        // gl.CompileShader(shader_id)

        // Check compilation status
        // let mut success: i32 = 0
        // gl.GetShaderiv(shader_id, GL_COMPILE_STATUS, &success)
        // if success == 0 {
        //     let mut info_log = [0u8; 512]
        //     gl.GetShaderInfoLog(shader_id, 512, null, &info_log)
        //     return Err(String.from_utf8(info_log)?)
        // }

        println!("Compiled shader (type: {:?})", shader_type)
        return Ok(ShaderHandle.new(shader_id, shader_type))
    }

    /// Load shader from file
    fn load_shader(path: String, shader_type: ShaderType) -> Result<ShaderHandle, String> {
        let source = File.read_all_text(path.clone())?
        println!("Loading shader: {}", path)
        return ShaderProgram.compile_shader(source, shader_type)
    }

    /// Link shader program
    fn link(self: &mut ShaderProgram) -> Result<(), String> {
        // Create program
        // self.id = gl.CreateProgram()

        // Attach shaders
        // gl.AttachShader(self.id, self.vertex_shader.id)
        // gl.AttachShader(self.id, self.fragment_shader.id)
        // if let Some(geom) = &self.geometry_shader {
        //     gl.AttachShader(self.id, geom.id)
        // }

        // Link program
        // gl.LinkProgram(self.id)

        // Check link status
        // let mut success: i32 = 0
        // gl.GetProgramiv(self.id, GL_LINK_STATUS, &success)
        // if success == 0 {
        //     let mut info_log = [0u8; 512]
        //     gl.GetProgramInfoLog(self.id, 512, null, &info_log)
        //     return Err(String.from_utf8(info_log)?)
        // }

        println!("Shader program linked (id: {})", self.id)

        // Query uniforms and attributes
        self.query_uniforms()
        self.query_attributes()

        return Ok(())
    }

    /// Query all uniforms
    fn query_uniforms(self: &mut ShaderProgram) {
        // let mut count: i32 = 0
        // gl.GetProgramiv(self.id, GL_ACTIVE_UNIFORMS, &count)

        // for i in 0..count {
        //     let mut name = [0u8; 256]
        //     let mut size: i32 = 0
        //     let mut uniform_type: u32 = 0
        //     gl.GetActiveUniform(self.id, i as u32, 256, null, &size, &uniform_type, &name)
        //
        //     let uniform_name = String.from_utf8(name)?
        //     let location = gl.GetUniformLocation(self.id, &name)
        //     self.uniform_locations.insert(uniform_name, location)
        // }

        println!("Queried {} uniforms", 0)
    }

    /// Query all attributes
    fn query_attributes(self: &mut ShaderProgram) {
        // let mut count: i32 = 0
        // gl.GetProgramiv(self.id, GL_ACTIVE_ATTRIBUTES, &count)

        // for i in 0..count {
        //     let mut name = [0u8; 256]
        //     let mut size: i32 = 0
        //     let mut attr_type: u32 = 0
        //     gl.GetActiveAttrib(self.id, i as u32, 256, null, &size, &attr_type, &name)
        //
        //     let attr_name = String.from_utf8(name)?
        //     let location = gl.GetAttribLocation(self.id, &name)
        //     self.attribute_locations.insert(attr_name, location)
        // }

        println!("Queried {} attributes", 0)
    }

    /// Use this shader program
    fn use_program(self: &ShaderProgram) {
        // gl.UseProgram(self.id)
    }

    /// Get uniform location
    fn get_uniform_location(self: &ShaderProgram, name: &str) -> Option<i32> {
        return self.uniform_locations.get(name).map(|loc| *loc)
    }

    /// Set uniform mat4
    fn set_mat4(self: &ShaderProgram, name: &str, matrix: &Mat4) {
        match self.get_uniform_location(name) {
            Some(loc) => {
                // gl.UniformMatrix4fv(loc, 1, false, matrix.as_ptr())
            },
            None => {
                println!("Warning: Uniform not found: {}", name)
            }
        }
    }

    /// Set uniform vec4
    fn set_vec4(self: &ShaderProgram, name: &str, vec: &Vec4) {
        match self.get_uniform_location(name) {
            Some(loc) => {
                // gl.Uniform4f(loc, vec.x, vec.y, vec.z, vec.w)
            },
            None => {}
        }
    }

    /// Set uniform vec3
    fn set_vec3(self: &ShaderProgram, name: &str, vec: &Vec3) {
        match self.get_uniform_location(name) {
            Some(loc) => {
                // gl.Uniform3f(loc, vec.x, vec.y, vec.z)
            },
            None => {}
        }
    }

    /// Set uniform vec2
    fn set_vec2(self: &ShaderProgram, name: &str, vec: &Vec2) {
        match self.get_uniform_location(name) {
            Some(loc) => {
                // gl.Uniform2f(loc, vec.x, vec.y)
            },
            None => {}
        }
    }

    /// Set uniform float
    fn set_float(self: &ShaderProgram, name: &str, value: f32) {
        match self.get_uniform_location(name) {
            Some(loc) => {
                // gl.Uniform1f(loc, value)
            },
            None => {}
        }
    }

    /// Set uniform int
    fn set_int(self: &ShaderProgram, name: &str, value: i32) {
        match self.get_uniform_location(name) {
            Some(loc) => {
                // gl.Uniform1i(loc, value)
            },
            None => {}
        }
    }

    /// Delete shader program
    fn delete(self: &mut ShaderProgram) {
        if self.id != 0 {
            // gl.DeleteProgram(self.id)
            self.id = 0
        }

        // Delete individual shaders
        if self.vertex_shader.is_valid() {
            // gl.DeleteShader(self.vertex_shader.id)
        }
        if self.fragment_shader.is_valid() {
            // gl.DeleteShader(self.fragment_shader.id)
        }
        if let Some(geom) = &self.geometry_shader {
            if geom.is_valid() {
                // gl.DeleteShader(geom.id)
            }
        }

        println!("Deleted shader program")
    }
}

/// Shader builder for easy shader creation
struct ShaderBuilder {
    vertex_source: Option<String>,
    fragment_source: Option<String>,
    geometry_source: Option<String>,
}

impl ShaderBuilder {
    fn new() -> ShaderBuilder {
        return ShaderBuilder {
            vertex_source: None,
            fragment_source: None,
            geometry_source: None
        }
    }

    /// Set vertex shader from source
    fn vertex_source(self: &mut ShaderBuilder, source: String) -> &mut ShaderBuilder {
        self.vertex_source = Some(source)
        return self
    }

    /// Set fragment shader from source
    fn fragment_source(self: &mut ShaderBuilder, source: String) -> &mut ShaderBuilder {
        self.fragment_source = Some(source)
        return self
    }

    /// Set geometry shader from source
    fn geometry_source(self: &mut ShaderBuilder, source: String) -> &mut ShaderBuilder {
        self.geometry_source = Some(source)
        return self
    }

    /// Load vertex shader from file
    fn vertex_file(self: &mut ShaderBuilder, path: String) -> Result<&mut ShaderBuilder, String> {
        let source = File.read_all_text(path)?
        self.vertex_source = Some(source)
        return Ok(self)
    }

    /// Load fragment shader from file
    fn fragment_file(self: &mut ShaderBuilder, path: String) -> Result<&mut ShaderBuilder, String> {
        let source = File.read_all_text(path)?
        self.fragment_source = Some(source)
        return Ok(self)
    }

    /// Build shader program
    fn build(self: &ShaderBuilder) -> Result<ShaderProgram, String> {
        let mut program = ShaderProgram.new()

        // Compile vertex shader
        match &self.vertex_source {
            Some(source) => {
                program.vertex_shader = ShaderProgram.compile_shader(source.clone(), ShaderType.Vertex)?
            },
            None => return Err("No vertex shader source provided")
        }

        // Compile fragment shader
        match &self.fragment_source {
            Some(source) => {
                program.fragment_shader = ShaderProgram.compile_shader(source.clone(), ShaderType.Fragment)?
            },
            None => return Err("No fragment shader source provided")
        }

        // Compile geometry shader (optional)
        if let Some(source) = &self.geometry_source {
            program.geometry_shader = Some(ShaderProgram.compile_shader(source.clone(), ShaderType.Geometry)?)
        }

        // Link program
        program.link()?

        return Ok(program)
    }
}

/// Default shaders for basic rendering
struct DefaultShaders {
    /// Simple colored vertex shader
    fn basic_vertex() -> String {
        return "
#version 330 core

layout(location = 0) in vec3 aPosition;
layout(location = 1) in vec4 aColor;

uniform mat4 uModelViewProjection;

out vec4 vColor;

void main() {
    gl_Position = uModelViewProjection * vec4(aPosition, 1.0);
    vColor = aColor;
}
".to_string()
    }

    /// Simple colored fragment shader
    fn basic_fragment() -> String {
        return "
#version 330 core

in vec4 vColor;
out vec4 fragColor;

void main() {
    fragColor = vColor;
}
".to_string()
    }

    /// Textured vertex shader
    fn textured_vertex() -> String {
        return "
#version 330 core

layout(location = 0) in vec3 aPosition;
layout(location = 1) in vec2 aTexCoord;
layout(location = 2) in vec4 aColor;

uniform mat4 uModelViewProjection;

out vec2 vTexCoord;
out vec4 vColor;

void main() {
    gl_Position = uModelViewProjection * vec4(aPosition, 1.0);
    vTexCoord = aTexCoord;
    vColor = aColor;
}
".to_string()
    }

    /// Textured fragment shader
    fn textured_fragment() -> String {
        return "
#version 330 core

in vec2 vTexCoord;
in vec4 vColor;

uniform sampler2D uTexture;

out vec4 fragColor;

void main() {
    fragColor = texture(uTexture, vTexCoord) * vColor;
}
".to_string()
    }

    /// Create basic colored shader
    fn create_basic() -> Result<ShaderProgram, String> {
        return ShaderBuilder.new()
            .vertex_source(DefaultShaders.basic_vertex())
            .fragment_source(DefaultShaders.basic_fragment())
            .build()
    }

    /// Create textured shader
    fn create_textured() -> Result<ShaderProgram, String> {
        return ShaderBuilder.new()
            .vertex_source(DefaultShaders.textured_vertex())
            .fragment_source(DefaultShaders.textured_fragment())
            .build()
    }
}
