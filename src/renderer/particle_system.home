// Generals Game Engine - Particle System
// Metal-compatible particle effects for explosions, smoke, fire, etc.

from basics import Collection
import graphics::{Vec2}

// ============================================================================
// Vector Math Helpers
// ============================================================================

struct Vec2 {
    x: Float,
    y: Float,
}

fn create_vec2(x: Float, y: Float) -> Vec2 {
    let v = Vec2 {}
    v.x = x
    v.y = y
    return v
}

fn vec2_add(a: Vec2, b: Vec2) -> Vec2 {
    return create_vec2(a.x + b.x, a.y + b.y)
}

fn vec2_scale(v: Vec2, s: Float) -> Vec2 {
    return create_vec2(v.x * s, v.y * s)
}

fn vec2_length(v: Vec2) -> Float {
    return sqrt(v.x * v.x + v.y * v.y)
}

struct Vec3 {
    x: Float,
    y: Float,
    z: Float,
}

fn create_vec3(x: Float, y: Float, z: Float) -> Vec3 {
    let v = Vec3 {}
    v.x = x
    v.y = y
    v.z = z
    return v
}

fn vec3_add(a: Vec3, b: Vec3) -> Vec3 {
    return create_vec3(a.x + b.x, a.y + b.y, a.z + b.z)
}

fn vec3_scale(v: Vec3, s: Float) -> Vec3 {
    return create_vec3(v.x * s, v.y * s, v.z * s)
}

struct Color {
    r: Float,
    g: Float,
    b: Float,
    a: Float,
}

fn create_color(r: Float, g: Float, b: Float, a: Float) -> Color {
    let c = Color {}
    c.r = r
    c.g = g
    c.b = b
    c.a = a
    return c
}

fn color_lerp(start: Color, end: Color, t: Float) -> Color {
    return create_color(
        start.r + (end.r - start.r) * t,
        start.g + (end.g - start.g) * t,
        start.b + (end.b - start.b) * t,
        start.a + (end.a - start.a) * t
    )
}

fn sqrt(x: Float) -> Float {
    // Simplified - would use actual math library
    if x <= 0.0 {
        return 0.0
    }
    // Newton's method approximation
    let guess = x / 2.0
    for i in 0..10 {
        guess = (guess + x / guess) / 2.0
    }
    return guess
}

// ============================================================================
// Particle Types and Structures
// ============================================================================

enum ParticleType {
    SMOKE,
    FIRE,
    EXPLOSION,
    SPARK,
    DEBRIS,
    DUST,
    BLOOD,
}

struct Particle {
    position: Vec2,
    velocity: Vec2,
    acceleration: Vec2,
    color: Color,
    start_color: Color,
    end_color: Color,
    size: Float,
    start_size: Float,
    end_size: Float,
    rotation: Float,
    angular_velocity: Float,
    lifetime: Float,
    age: Float,
    active: Bool,
    particle_type: ParticleType,
}

fn create_particle() -> Particle {
    let p = Particle {}
    p.position = create_vec2(0.0, 0.0)
    p.velocity = create_vec2(0.0, 0.0)
    p.acceleration = create_vec2(0.0, 100.0)  // Gravity (downward in screen space)
    p.color = create_color(1.0, 1.0, 1.0, 1.0)
    p.start_color = create_color(1.0, 1.0, 1.0, 1.0)
    p.end_color = create_color(1.0, 1.0, 1.0, 0.0)
    p.size = 10.0
    p.start_size = 10.0
    p.end_size = 2.0
    p.rotation = 0.0
    p.angular_velocity = 0.0
    p.lifetime = 1.0
    p.age = 0.0
    p.active = false
    p.particle_type = ParticleType::SMOKE
    return p
}

fn update_particle(particle: Particle, dt: Float) {
    if !particle.active {
        return
    }

    particle.age = particle.age + dt

    // Kill particle if expired
    if particle.age >= particle.lifetime {
        particle.active = false
        return
    }

    // Update physics
    particle.velocity = vec2_add(particle.velocity, vec2_scale(particle.acceleration, dt))
    particle.position = vec2_add(particle.position, vec2_scale(particle.velocity, dt))
    particle.rotation = particle.rotation + particle.angular_velocity * dt

    // Interpolate color and size over lifetime
    let t = particle.age / particle.lifetime
    particle.color = color_lerp(particle.start_color, particle.end_color, t)
    particle.size = particle.start_size + (particle.end_size - particle.start_size) * t
}

// ============================================================================
// Emitter Configuration
// ============================================================================

struct EmitterConfig {
    position: Vec2,
    particle_type: ParticleType,
    spawn_rate: Float,  // Particles per second
    initial_velocity_min: Vec2,
    initial_velocity_max: Vec2,
    lifetime_min: Float,
    lifetime_max: Float,
    start_size_min: Float,
    start_size_max: Float,
    end_size_min: Float,
    end_size_max: Float,
    start_color: Color,
    end_color: Color,
    angular_velocity_min: Float,
    angular_velocity_max: Float,
    gravity: Float,
    duration: Float,  // How long emitter lasts (0 = infinite)
    burst_count: Int,  // Spawn this many particles immediately
}

fn create_explosion_config(pos: Vec2) -> EmitterConfig {
    let config = EmitterConfig {}
    config.position = pos
    config.particle_type = ParticleType::EXPLOSION
    config.spawn_rate = 0.0  // Burst only
    config.initial_velocity_min = create_vec2(-200.0, -200.0)
    config.initial_velocity_max = create_vec2(200.0, -100.0)
    config.lifetime_min = 0.5
    config.lifetime_max = 1.2
    config.start_size_min = 20.0
    config.start_size_max = 35.0
    config.end_size_min = 5.0
    config.end_size_max = 10.0
    config.start_color = create_color(1.0, 0.8, 0.2, 1.0)  // Bright yellow-orange
    config.end_color = create_color(0.3, 0.1, 0.0, 0.0)  // Dark red, fades out
    config.angular_velocity_min = -3.0
    config.angular_velocity_max = 3.0
    config.gravity = 50.0
    config.duration = 0.1
    config.burst_count = 30
    return config
}

fn create_smoke_config(pos: Vec2) -> EmitterConfig {
    let config = EmitterConfig {}
    config.position = pos
    config.particle_type = ParticleType::SMOKE
    config.spawn_rate = 20.0
    config.initial_velocity_min = create_vec2(-20.0, -50.0)
    config.initial_velocity_max = create_vec2(20.0, -30.0)
    config.lifetime_min = 1.5
    config.lifetime_max = 2.5
    config.start_size_min = 10.0
    config.start_size_max = 15.0
    config.end_size_min = 25.0
    config.end_size_max = 35.0
    config.start_color = create_color(0.5, 0.5, 0.5, 0.8)  // Gray
    config.end_color = create_color(0.3, 0.3, 0.3, 0.0)  // Darker gray, fades out
    config.angular_velocity_min = -1.0
    config.angular_velocity_max = 1.0
    config.gravity = -10.0  // Slight upward drift
    config.duration = 2.0
    config.burst_count = 0
    return config
}

fn create_fire_config(pos: Vec2) -> EmitterConfig {
    let config = EmitterConfig {}
    config.position = pos
    config.particle_type = ParticleType::FIRE
    config.spawn_rate = 50.0
    config.initial_velocity_min = create_vec2(-30.0, -80.0)
    config.initial_velocity_max = create_vec2(30.0, -50.0)
    config.lifetime_min = 0.3
    config.lifetime_max = 0.8
    config.start_size_min = 8.0
    config.start_size_max = 12.0
    config.end_size_min = 2.0
    config.end_size_max = 4.0
    config.start_color = create_color(1.0, 0.6, 0.1, 1.0)  // Bright orange
    config.end_color = create_color(0.8, 0.0, 0.0, 0.0)  // Red, fades out
    config.angular_velocity_min = -2.0
    config.angular_velocity_max = 2.0
    config.gravity = -20.0  // Upward
    config.duration = 0.0  // Infinite until stopped
    config.burst_count = 5
    return config
}

fn create_sparks_config(pos: Vec2) -> EmitterConfig {
    let config = EmitterConfig {}
    config.position = pos
    config.particle_type = ParticleType::SPARK
    config.spawn_rate = 0.0
    config.initial_velocity_min = create_vec2(-150.0, -200.0)
    config.initial_velocity_max = create_vec2(150.0, -50.0)
    config.lifetime_min = 0.3
    config.lifetime_max = 0.7
    config.start_size_min = 2.0
    config.start_size_max = 4.0
    config.end_size_min = 1.0
    config.end_size_max = 2.0
    config.start_color = create_color(1.0, 1.0, 0.5, 1.0)  // Bright yellow
    config.end_color = create_color(1.0, 0.3, 0.0, 0.0)  // Orange, fades out
    config.angular_velocity_min = 0.0
    config.angular_velocity_max = 0.0
    config.gravity = 200.0
    config.duration = 0.1
    config.burst_count = 20
    return config
}

// ============================================================================
// Particle Emitter
// ============================================================================

struct Emitter {
    config: EmitterConfig,
    active: Bool,
    age: Float,
    spawn_accumulator: Float,
}

fn create_emitter(config: EmitterConfig) -> Emitter {
    let emitter = Emitter {}
    emitter.config = config
    emitter.active = true
    emitter.age = 0.0
    emitter.spawn_accumulator = 0.0
    return emitter
}

fn update_emitter(emitter: Emitter, dt: Float) {
    if !emitter.active {
        return
    }

    emitter.age = emitter.age + dt

    // Check if emitter should die
    if emitter.config.duration > 0.0 && emitter.age >= emitter.config.duration {
        emitter.active = false
        return
    }

    // Accumulate spawn time
    if emitter.config.spawn_rate > 0.0 {
        emitter.spawn_accumulator = emitter.spawn_accumulator + dt
    }
}

fn emitter_should_spawn(emitter: Emitter) -> Bool {
    if !emitter.active {
        return false
    }
    if emitter.config.spawn_rate == 0.0 {
        return false
    }

    let spawn_interval = 1.0 / emitter.config.spawn_rate
    return emitter.spawn_accumulator >= spawn_interval
}

fn emitter_consume_spawn(emitter: Emitter) {
    let spawn_interval = 1.0 / emitter.config.spawn_rate
    emitter.spawn_accumulator = emitter.spawn_accumulator - spawn_interval
}

// ============================================================================
// Particle System
// ============================================================================

struct ParticleSystem {
    particles: Collection<Particle>,
    emitters: Collection<Emitter>,
    max_particles: Int,
    random_seed: Int,
}

fn create_particle_system(max_particles: Int) -> ParticleSystem {
    let system = ParticleSystem {}
    system.particles = Collection<Particle> {}
    system.emitters = Collection<Emitter> {}
    system.max_particles = max_particles
    system.random_seed = 12345  // Initial seed

    // Pre-allocate particles
    for i in 0..max_particles {
        system.particles.add(create_particle())
    }

    return system
}

fn particle_system_add_emitter(system: ParticleSystem, config: EmitterConfig) {
    let emitter = create_emitter(config)
    system.emitters.add(emitter)

    // Spawn burst particles immediately
    for i in 0..config.burst_count {
        particle_system_spawn_particle(system, config)
    }
}

fn particle_system_spawn_particle(system: ParticleSystem, config: EmitterConfig) {
    // Find inactive particle
    for i in 0..system.particles.len() {
        let particle = system.particles.get(i)
        if !particle.active {
            particle.active = true
            particle.position = config.position
            particle.age = 0.0
            particle.particle_type = config.particle_type

            // Random velocity
            particle.velocity = create_vec2(
                random_range(system, config.initial_velocity_min.x, config.initial_velocity_max.x),
                random_range(system, config.initial_velocity_min.y, config.initial_velocity_max.y)
            )

            // Random lifetime
            particle.lifetime = random_range(system, config.lifetime_min, config.lifetime_max)

            // Random size
            particle.start_size = random_range(system, config.start_size_min, config.start_size_max)
            particle.end_size = random_range(system, config.end_size_min, config.end_size_max)
            particle.size = particle.start_size

            // Colors
            particle.start_color = config.start_color
            particle.end_color = config.end_color
            particle.color = config.start_color

            // Random angular velocity
            particle.angular_velocity = random_range(system, config.angular_velocity_min, config.angular_velocity_max)

            // Gravity
            particle.acceleration = create_vec2(0.0, config.gravity)

            system.particles.set(i, particle)
            return
        }
    }
    // All particles are active - drop this one
}

fn random_range(system: ParticleSystem, min: Float, max: Float) -> Float {
    // Simple LCG random number generator
    system.random_seed = (system.random_seed * 1103515245 + 12345) % 2147483648
    let normalized = (system.random_seed as Float) / 2147483648.0
    return min + normalized * (max - min)
}

fn particle_system_update(system: ParticleSystem, dt: Float) {
    // Update all particles
    for i in 0..system.particles.len() {
        let particle = system.particles.get(i)
        update_particle(particle, dt)
        system.particles.set(i, particle)
    }

    // Update emitters and spawn particles
    let i = 0
    while i < system.emitters.len() {
        let emitter = system.emitters.get(i)
        update_emitter(emitter, dt)

        // Spawn particles from continuous emitters
        while emitter_should_spawn(emitter) {
            particle_system_spawn_particle(system, emitter.config)
            emitter_consume_spawn(emitter)
        }

        // Remove dead emitters
        if !emitter.active {
            system.emitters.remove_at(i)
        } else {
            system.emitters.set(i, emitter)
            i = i + 1
        }
    }
}

fn particle_system_get_active_particles(system: ParticleSystem) -> Collection<Particle> {
    return system.particles
}

fn particle_system_get_active_count(system: ParticleSystem) -> Int {
    let count = 0
    for i in 0..system.particles.len() {
        if system.particles.get(i).active {
            count = count + 1
        }
    }
    return count
}

fn particle_system_clear(system: ParticleSystem) {
    for i in 0..system.particles.len() {
        let particle = system.particles.get(i)
        particle.active = false
        system.particles.set(i, particle)
    }
    system.emitters.clear()
}

// ============================================================================
// Convenience Functions
// ============================================================================

fn spawn_explosion(system: ParticleSystem, x: Float, y: Float) {
    particle_system_add_emitter(system, create_explosion_config(create_vec2(x, y)))
    // Add sparks too
    particle_system_add_emitter(system, create_sparks_config(create_vec2(x, y)))
}

fn spawn_smoke(system: ParticleSystem, x: Float, y: Float) {
    particle_system_add_emitter(system, create_smoke_config(create_vec2(x, y)))
}

fn spawn_fire(system: ParticleSystem, x: Float, y: Float) {
    particle_system_add_emitter(system, create_fire_config(create_vec2(x, y)))
}

// ============================================================================
// Tests
// ============================================================================

fn test_particle_creation() -> Bool {
    let particle = create_particle()

    assert(!particle.active, "Particle should start inactive")
    assert(particle.lifetime == 1.0, "Lifetime should be 1.0")
    assert(particle.age == 0.0, "Age should be 0.0")

    return true
}

fn test_particle_update() -> Bool {
    let particle = create_particle()
    particle.active = true
    particle.lifetime = 2.0

    update_particle(particle, 0.5)
    assert(particle.age == 0.5, "Age should be 0.5")
    assert(particle.active, "Should still be active")

    update_particle(particle, 2.0)
    assert(!particle.active, "Should be inactive after lifetime")

    return true
}

fn test_emitter_creation() -> Bool {
    let config = create_explosion_config(create_vec2(100.0, 100.0))
    let emitter = create_emitter(config)

    assert(emitter.active, "Emitter should start active")
    assert(emitter.age == 0.0, "Age should be 0.0")

    return true
}

fn test_particle_system() -> Bool {
    let system = create_particle_system(100)

    assert(system.particles.len() == 100, "Should have 100 particles")
    assert(system.max_particles == 100, "Max particles should be 100")
    assert(particle_system_get_active_count(system) == 0, "Should have 0 active particles")

    return true
}

fn test_spawn_explosion() -> Bool {
    let system = create_particle_system(100)

    spawn_explosion(system, 50.0, 50.0)

    // Should have spawned burst particles (30 + 20 = 50)
    let count = particle_system_get_active_count(system)
    assert(count == 50, "Should have 50 active particles from burst")

    return true
}

fn test_particle_system_update() -> Bool {
    let system = create_particle_system(100)
    spawn_explosion(system, 0.0, 0.0)

    let initial_count = particle_system_get_active_count(system)
    assert(initial_count > 0, "Should have active particles")

    // Update for a long time to kill all particles
    particle_system_update(system, 10.0)

    let final_count = particle_system_get_active_count(system)
    assert(final_count == 0, "All particles should be dead")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_particle_creation(), "Particle creation test failed")
    assert(test_particle_update(), "Particle update test failed")
    assert(test_emitter_creation(), "Emitter creation test failed")
    assert(test_particle_system(), "Particle system test failed")
    assert(test_spawn_explosion(), "Spawn explosion test failed")
    assert(test_particle_system_update(), "Particle system update test failed")
    return true
}
