// Home Programming Language - Particle Effects System
// High-performance particle system for explosions, smoke, fire, etc.

from basics import Collection
import graphics::{Vec3, Vec4}

// ============================================================================
// Particle Types and Enums
// ============================================================================

enum ParticleType {
    SMOKE,
    FIRE,
    EXPLOSION,
    SPARK,
    DEBRIS,
    DUST,
    BLOOD,
    WATER,
    SNOW,
    MAGIC,
}

enum EmitterShape {
    POINT,      // Emit from single point
    SPHERE,     // Emit from sphere surface
    CONE,       // Emit in cone direction
    BOX,        // Emit from box volume
    CIRCLE,     // Emit from circle
}

enum BlendMode {
    ALPHA,      // Standard alpha blending
    ADDITIVE,   // Additive blending (for fire/explosions)
    MULTIPLY,   // Multiplicative blending (for smoke)
}

// ============================================================================
// Vector and Color Types
// ============================================================================

struct Vec3 {
    x: Float,
    y: Float,
    z: Float,
}

fn create_vec3(x: Float, y: Float, z: Float) -> Vec3 {
    let v = Vec3 {}
    v.x = x
    v.y = y
    v.z = z
    return v
}

fn vec3_add(a: Vec3, b: Vec3) -> Vec3 {
    return create_vec3(a.x + b.x, a.y + b.y, a.z + b.z)
}

fn vec3_sub(a: Vec3, b: Vec3) -> Vec3 {
    return create_vec3(a.x - b.x, a.y - b.y, a.z - b.z)
}

fn vec3_scale(v: Vec3, s: Float) -> Vec3 {
    return create_vec3(v.x * s, v.y * s, v.z * s)
}

fn vec3_length(v: Vec3) -> Float {
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
}

fn vec3_normalize(v: Vec3) -> Vec3 {
    let len = vec3_length(v)
    if len > 0.0 {
        return vec3_scale(v, 1.0 / len)
    }
    return v
}

struct Vec4 {
    x: Float,
    y: Float,
    z: Float,
    w: Float,
}

fn create_vec4(x: Float, y: Float, z: Float, w: Float) -> Vec4 {
    let v = Vec4 {}
    v.x = x
    v.y = y
    v.z = z
    v.w = w
    return v
}

fn vec4_lerp(a: Vec4, b: Vec4, t: Float) -> Vec4 {
    return create_vec4(
        a.x + (b.x - a.x) * t,
        a.y + (b.y - a.y) * t,
        a.z + (b.z - a.z) * t,
        a.w + (b.w - a.w) * t
    )
}

fn lerp(a: Float, b: Float, t: Float) -> Float {
    return a + (b - a) * t
}

fn sqrt(x: Float) -> Float {
    if x <= 0.0 {
        return 0.0
    }
    let guess = x / 2.0
    for i in 0..10 {
        guess = (guess + x / guess) / 2.0
    }
    return guess
}

// ============================================================================
// Particle Structure
// ============================================================================

struct Particle {
    position: Vec3,
    velocity: Vec3,
    acceleration: Vec3,
    color: Vec4,
    start_color: Vec4,
    end_color: Vec4,
    size: Float,
    start_size: Float,
    end_size: Float,
    rotation: Float,
    angular_velocity: Float,
    lifetime: Float,
    age: Float,
    active: Bool,
    texture_index: Int,
}

fn create_particle() -> Particle {
    let p = Particle {}
    p.position = create_vec3(0.0, 0.0, 0.0)
    p.velocity = create_vec3(0.0, 0.0, 0.0)
    p.acceleration = create_vec3(0.0, -9.8, 0.0)  // Gravity
    p.color = create_vec4(1.0, 1.0, 1.0, 1.0)
    p.start_color = create_vec4(1.0, 1.0, 1.0, 1.0)
    p.end_color = create_vec4(1.0, 1.0, 1.0, 0.0)
    p.size = 1.0
    p.start_size = 1.0
    p.end_size = 0.1
    p.rotation = 0.0
    p.angular_velocity = 0.0
    p.lifetime = 1.0
    p.age = 0.0
    p.active = false
    p.texture_index = 0
    return p
}

fn update_particle(particle: Particle, dt: Float) {
    if !particle.active {
        return
    }

    particle.age = particle.age + dt

    // Kill particle if expired
    if particle.age >= particle.lifetime {
        particle.active = false
        return
    }

    // Update physics
    particle.velocity = vec3_add(particle.velocity, vec3_scale(particle.acceleration, dt))
    particle.position = vec3_add(particle.position, vec3_scale(particle.velocity, dt))
    particle.rotation = particle.rotation + particle.angular_velocity * dt

    // Interpolate color and size over lifetime
    let t = particle.age / particle.lifetime
    particle.color = vec4_lerp(particle.start_color, particle.end_color, t)
    particle.size = lerp(particle.start_size, particle.end_size, t)
}

// ============================================================================
// Emitter Configuration
// ============================================================================

struct EmitterConfig {
    particle_type: ParticleType,
    shape: EmitterShape,
    blend_mode: BlendMode,

    // Emission properties
    emission_rate: Float,      // Particles per second
    burst_count: Int,          // Particles per burst (0 = continuous)
    max_particles: Int,        // Maximum active particles

    // Particle lifetime
    lifetime_min: Float,
    lifetime_max: Float,

    // Initial velocity
    velocity_min: Vec3,
    velocity_max: Vec3,

    // Size
    start_size_min: Float,
    start_size_max: Float,
    end_size_min: Float,
    end_size_max: Float,

    // Color
    start_color: Vec4,
    end_color: Vec4,

    // Physics
    gravity: Vec3,
    drag: Float,

    // Rotation
    angular_velocity_min: Float,
    angular_velocity_max: Float,

    // Emitter shape parameters
    radius: Float,              // For sphere/circle
    cone_angle: Float,          // For cone (radians)
    box_extents: Vec3,          // For box

    // Texture
    texture_atlas_rows: Int,
    texture_atlas_cols: Int,
    animate_texture: Bool,
}

fn create_default_emitter_config() -> EmitterConfig {
    let config = EmitterConfig {}
    config.particle_type = ParticleType::SMOKE
    config.shape = EmitterShape::POINT
    config.blend_mode = BlendMode::ALPHA
    config.emission_rate = 10.0
    config.burst_count = 0
    config.max_particles = 1000
    config.lifetime_min = 1.0
    config.lifetime_max = 2.0
    config.velocity_min = create_vec3(-1.0, 0.0, -1.0)
    config.velocity_max = create_vec3(1.0, 2.0, 1.0)
    config.start_size_min = 0.5
    config.start_size_max = 1.0
    config.end_size_min = 0.1
    config.end_size_max = 0.2
    config.start_color = create_vec4(1.0, 1.0, 1.0, 1.0)
    config.end_color = create_vec4(0.5, 0.5, 0.5, 0.0)
    config.gravity = create_vec3(0.0, -9.8, 0.0)
    config.drag = 0.1
    config.angular_velocity_min = -1.0
    config.angular_velocity_max = 1.0
    config.radius = 1.0
    config.cone_angle = 0.785  // pi/4
    config.box_extents = create_vec3(1.0, 1.0, 1.0)
    config.texture_atlas_rows = 1
    config.texture_atlas_cols = 1
    config.animate_texture = false
    return config
}

fn create_explosion_emitter_config() -> EmitterConfig {
    let config = create_default_emitter_config()
    config.particle_type = ParticleType::EXPLOSION
    config.blend_mode = BlendMode::ADDITIVE
    config.burst_count = 50
    config.lifetime_min = 0.5
    config.lifetime_max = 1.0
    config.velocity_min = create_vec3(-5.0, -5.0, -5.0)
    config.velocity_max = create_vec3(5.0, 5.0, 5.0)
    config.start_color = create_vec4(1.0, 0.8, 0.3, 1.0)
    config.end_color = create_vec4(0.5, 0.1, 0.0, 0.0)
    config.start_size_min = 1.0
    config.start_size_max = 2.0
    config.end_size_min = 3.0
    config.end_size_max = 5.0
    return config
}

fn create_fire_emitter_config() -> EmitterConfig {
    let config = create_default_emitter_config()
    config.particle_type = ParticleType::FIRE
    config.blend_mode = BlendMode::ADDITIVE
    config.emission_rate = 50.0
    config.lifetime_min = 0.5
    config.lifetime_max = 1.0
    config.velocity_min = create_vec3(-0.5, 2.0, -0.5)
    config.velocity_max = create_vec3(0.5, 4.0, 0.5)
    config.start_color = create_vec4(1.0, 0.5, 0.1, 1.0)
    config.end_color = create_vec4(0.3, 0.1, 0.0, 0.0)
    config.gravity = create_vec3(0.0, 1.0, 0.0)  // Rises up
    return config
}

fn create_smoke_emitter_config() -> EmitterConfig {
    let config = create_default_emitter_config()
    config.particle_type = ParticleType::SMOKE
    config.blend_mode = BlendMode::ALPHA
    config.emission_rate = 20.0
    config.lifetime_min = 2.0
    config.lifetime_max = 4.0
    config.velocity_min = create_vec3(-0.5, 1.0, -0.5)
    config.velocity_max = create_vec3(0.5, 2.0, 0.5)
    config.start_color = create_vec4(0.3, 0.3, 0.3, 0.8)
    config.end_color = create_vec4(0.5, 0.5, 0.5, 0.0)
    config.start_size_min = 1.0
    config.start_size_max = 1.5
    config.end_size_min = 3.0
    config.end_size_max = 5.0
    return config
}

// ============================================================================
// Particle Emitter
// ============================================================================

struct ParticleEmitter {
    config: EmitterConfig,
    particles: Collection<Particle>,
    position: Vec3,
    direction: Vec3,
    active: Bool,
    emission_accumulator: Float,
    random_seed: Int,
}

fn create_particle_emitter(config: EmitterConfig) -> ParticleEmitter {
    let emitter = ParticleEmitter {}
    emitter.config = config
    emitter.particles = Collection<Particle> {}

    // Pre-allocate particles
    for i in 0..config.max_particles {
        emitter.particles.add(create_particle())
    }

    emitter.position = create_vec3(0.0, 0.0, 0.0)
    emitter.direction = create_vec3(0.0, 1.0, 0.0)
    emitter.active = true
    emitter.emission_accumulator = 0.0
    emitter.random_seed = 12345
    return emitter
}

fn emitter_set_position(emitter: ParticleEmitter, pos: Vec3) {
    emitter.position = pos
}

fn emitter_set_direction(emitter: ParticleEmitter, dir: Vec3) {
    emitter.direction = vec3_normalize(dir)
}

fn emitter_emit(emitter: ParticleEmitter, count: Int) {
    let emitted = 0
    for i in 0..emitter.particles.len() {
        if emitted >= count {
            break
        }

        let particle = emitter.particles.get(i)
        if particle.active {
            continue
        }

        emitter_spawn_particle(emitter, particle)
        emitter.particles.set(i, particle)
        emitted = emitted + 1
    }
}

fn emitter_burst(emitter: ParticleEmitter) {
    if emitter.config.burst_count > 0 {
        emitter_emit(emitter, emitter.config.burst_count)
    }
}

fn emitter_update(emitter: ParticleEmitter, dt: Float) {
    if !emitter.active {
        return
    }

    // Continuous emission
    if emitter.config.burst_count == 0 {
        emitter.emission_accumulator = emitter.emission_accumulator + emitter.config.emission_rate * dt
        let to_emit = emitter.emission_accumulator as Int
        if to_emit > 0 {
            emitter_emit(emitter, to_emit)
            emitter.emission_accumulator = emitter.emission_accumulator - (to_emit as Float)
        }
    }

    // Update all active particles
    for i in 0..emitter.particles.len() {
        let particle = emitter.particles.get(i)
        update_particle(particle, dt)
        emitter.particles.set(i, particle)
    }
}

fn emitter_spawn_particle(emitter: ParticleEmitter, particle: Particle) {
    // Initialize particle
    particle.active = true
    particle.age = 0.0

    // Position based on emitter shape
    particle.position = vec3_add(emitter.position, emitter_get_shape_offset(emitter))

    // Velocity
    particle.velocity = emitter_get_random_velocity(emitter)

    // Lifetime
    particle.lifetime = random_range(emitter, emitter.config.lifetime_min, emitter.config.lifetime_max)

    // Size
    particle.start_size = random_range(emitter, emitter.config.start_size_min, emitter.config.start_size_max)
    particle.end_size = random_range(emitter, emitter.config.end_size_min, emitter.config.end_size_max)
    particle.size = particle.start_size

    // Color
    particle.start_color = emitter.config.start_color
    particle.end_color = emitter.config.end_color
    particle.color = particle.start_color

    // Rotation
    particle.angular_velocity = random_range(emitter, emitter.config.angular_velocity_min, emitter.config.angular_velocity_max)
    particle.rotation = random_float(emitter) * 6.283  // 2*PI

    // Physics
    particle.acceleration = emitter.config.gravity

    // Texture
    if emitter.config.animate_texture {
        let max_index = emitter.config.texture_atlas_rows * emitter.config.texture_atlas_cols - 1
        particle.texture_index = (random_float(emitter) * (max_index as Float)) as Int
    } else {
        particle.texture_index = 0
    }
}

fn emitter_get_shape_offset(emitter: ParticleEmitter) -> Vec3 {
    if emitter.config.shape == EmitterShape::POINT {
        return create_vec3(0.0, 0.0, 0.0)
    } else if emitter.config.shape == EmitterShape::SPHERE {
        return random_point_on_sphere(emitter, emitter.config.radius)
    } else if emitter.config.shape == EmitterShape::CIRCLE {
        return random_point_on_circle(emitter, emitter.config.radius)
    } else if emitter.config.shape == EmitterShape::BOX {
        return random_point_in_box(emitter, emitter.config.box_extents)
    } else if emitter.config.shape == EmitterShape::CONE {
        return random_point_in_cone(emitter, emitter.direction, emitter.config.cone_angle, emitter.config.radius)
    }
    return create_vec3(0.0, 0.0, 0.0)
}

fn emitter_get_random_velocity(emitter: ParticleEmitter) -> Vec3 {
    let tx = random_float(emitter)
    let ty = random_float(emitter)
    let tz = random_float(emitter)

    return create_vec3(
        emitter.config.velocity_min.x + (emitter.config.velocity_max.x - emitter.config.velocity_min.x) * tx,
        emitter.config.velocity_min.y + (emitter.config.velocity_max.y - emitter.config.velocity_min.y) * ty,
        emitter.config.velocity_min.z + (emitter.config.velocity_max.z - emitter.config.velocity_min.z) * tz
    )
}

fn emitter_get_active_count(emitter: ParticleEmitter) -> Int {
    let count = 0
    for i in 0..emitter.particles.len() {
        if emitter.particles.get(i).active {
            count = count + 1
        }
    }
    return count
}

// ============================================================================
// Random Number Generation
// ============================================================================

fn random_float(emitter: ParticleEmitter) -> Float {
    // Simple LCG
    emitter.random_seed = (emitter.random_seed * 1103515245 + 12345) % 2147483648
    return (emitter.random_seed as Float) / 2147483648.0
}

fn random_range(emitter: ParticleEmitter, min: Float, max: Float) -> Float {
    return min + random_float(emitter) * (max - min)
}

// ============================================================================
// Shape Sampling Functions
// ============================================================================

fn random_point_on_sphere(emitter: ParticleEmitter, radius: Float) -> Vec3 {
    let theta = random_float(emitter) * 6.283  // 2*PI
    let phi = acos(2.0 * random_float(emitter) - 1.0)

    let sin_phi = sin(phi)
    return create_vec3(
        radius * sin_phi * cos(theta),
        radius * sin_phi * sin(theta),
        radius * cos(phi)
    )
}

fn random_point_on_circle(emitter: ParticleEmitter, radius: Float) -> Vec3 {
    let theta = random_float(emitter) * 6.283  // 2*PI
    return create_vec3(
        radius * cos(theta),
        0.0,
        radius * sin(theta)
    )
}

fn random_point_in_box(emitter: ParticleEmitter, extents: Vec3) -> Vec3 {
    return create_vec3(
        (random_float(emitter) * 2.0 - 1.0) * extents.x,
        (random_float(emitter) * 2.0 - 1.0) * extents.y,
        (random_float(emitter) * 2.0 - 1.0) * extents.z
    )
}

fn random_point_in_cone(emitter: ParticleEmitter, direction: Vec3, angle: Float, length: Float) -> Vec3 {
    let theta = random_float(emitter) * 6.283  // 2*PI
    let phi = random_float(emitter) * angle

    let sin_phi = sin(phi)
    let offset = create_vec3(
        length * sin_phi * cos(theta),
        length * cos(phi),
        length * sin_phi * sin(theta)
    )

    // Simplified: assumes direction is normalized
    return vec3_add(offset, vec3_scale(direction, length))
}

// ============================================================================
// Math Helper Functions
// ============================================================================

fn sin(x: Float) -> Float {
    // Simple sine approximation using Taylor series
    let x_mod = x % 6.283
    let x2 = x_mod * x_mod
    return x_mod - (x_mod * x2) / 6.0 + (x_mod * x2 * x2) / 120.0
}

fn cos(x: Float) -> Float {
    return sin(x + 1.571)  // cos(x) = sin(x + PI/2)
}

fn acos(x: Float) -> Float {
    // Approximation of acos
    if x < -1.0 {
        return 3.14159  // PI
    }
    if x > 1.0 {
        return 0.0
    }
    return 1.571 - x * (1.0 + x * x * (0.167 + x * x * 0.075))
}

// ============================================================================
// Tests
// ============================================================================

fn test_particle_initialization() -> Bool {
    let particle = create_particle()

    assert(!particle.active, "Particle should start inactive")
    assert(particle.lifetime == 1.0, "Lifetime should be 1.0")

    return true
}

fn test_particle_update() -> Bool {
    let particle = create_particle()
    particle.active = true
    particle.lifetime = 1.0
    particle.velocity = create_vec3(1.0, 0.0, 0.0)

    update_particle(particle, 0.5)
    assert(particle.active, "Should still be active")
    assert(particle.age == 0.5, "Age should be 0.5")

    update_particle(particle, 0.6)
    assert(!particle.active, "Should be inactive after lifetime")

    return true
}

fn test_emitter_config_presets() -> Bool {
    let explosion = create_explosion_emitter_config()
    assert(explosion.particle_type == ParticleType::EXPLOSION, "Should be explosion type")
    assert(explosion.burst_count == 50, "Should have 50 burst count")

    let fire = create_fire_emitter_config()
    assert(fire.particle_type == ParticleType::FIRE, "Should be fire type")

    let smoke = create_smoke_emitter_config()
    assert(smoke.particle_type == ParticleType::SMOKE, "Should be smoke type")

    return true
}

fn test_emitter_creation() -> Bool {
    let config = create_default_emitter_config()
    let emitter = create_particle_emitter(config)

    assert(emitter.active, "Emitter should be active")
    assert(emitter.particles.len() == 1000, "Should have 1000 particles")

    return true
}

fn test_emitter_emit() -> Bool {
    let config = create_default_emitter_config()
    let emitter = create_particle_emitter(config)

    emitter_emit(emitter, 10)

    let count = emitter_get_active_count(emitter)
    assert(count == 10, "Should have 10 active particles")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_particle_initialization(), "Particle initialization test failed")
    assert(test_particle_update(), "Particle update test failed")
    assert(test_emitter_config_presets(), "Emitter config presets test failed")
    assert(test_emitter_creation(), "Emitter creation test failed")
    assert(test_emitter_emit(), "Emitter emit test failed")
    return true
}
