// Texture - OpenGL texture loading and management
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/w3d/renderer/texture.h

import std.collections.HashMap
import platform.file.File

/// Texture format
enum TextureFormat {
    RGB,        // 24-bit RGB
    RGBA,       // 32-bit RGBA
    R8,         // 8-bit grayscale
    DXT1,       // Compressed DXT1
    DXT3,       // Compressed DXT3
    DXT5,       // Compressed DXT5
}

/// Texture filtering mode
enum TextureFilter {
    Nearest,                // GL_NEAREST
    Linear,                 // GL_LINEAR
    NearestMipmapNearest,   // GL_NEAREST_MIPMAP_NEAREST
    LinearMipmapNearest,    // GL_LINEAR_MIPMAP_NEAREST
    NearestMipmapLinear,    // GL_NEAREST_MIPMAP_LINEAR
    LinearMipmapLinear,     // GL_LINEAR_MIPMAP_LINEAR (trilinear)
}

/// Texture wrap mode
enum TextureWrap {
    Repeat,         // GL_REPEAT
    Clamp,          // GL_CLAMP_TO_EDGE
    Mirror,         // GL_MIRRORED_REPEAT
    ClampBorder,    // GL_CLAMP_TO_BORDER
}

/// Texture parameters
struct TextureParams {
    min_filter: TextureFilter,
    mag_filter: TextureFilter,
    wrap_s: TextureWrap,
    wrap_t: TextureWrap,
    generate_mipmaps: bool,
    anisotropy: f32,  // 0.0 = off, 16.0 = max
}

impl TextureParams {
    /// Default texture parameters
    fn default() -> TextureParams {
        return TextureParams {
            min_filter: TextureFilter.LinearMipmapLinear,
            mag_filter: TextureFilter.Linear,
            wrap_s: TextureWrap.Repeat,
            wrap_t: TextureWrap.Repeat,
            generate_mipmaps: true,
            anisotropy: 4.0
        }
    }

    /// Nearest filtering (pixelated look)
    fn nearest() -> TextureParams {
        return TextureParams {
            min_filter: TextureFilter.Nearest,
            mag_filter: TextureFilter.Nearest,
            wrap_s: TextureWrap.Clamp,
            wrap_t: TextureWrap.Clamp,
            generate_mipmaps: false,
            anisotropy: 0.0
        }
    }

    /// UI texture (no mipmaps, clamped)
    fn ui() -> TextureParams {
        return TextureParams {
            min_filter: TextureFilter.Linear,
            mag_filter: TextureFilter.Linear,
            wrap_s: TextureWrap.Clamp,
            wrap_t: TextureWrap.Clamp,
            generate_mipmaps: false,
            anisotropy: 0.0
        }
    }
}

/// OpenGL texture
struct Texture {
    id: u32,
    width: u32,
    height: u32,
    format: TextureFormat,
    params: TextureParams,
}

impl Texture {
    /// Create empty texture
    fn new() -> Texture {
        return Texture {
            id: 0,
            width: 0,
            height: 0,
            format: TextureFormat.RGBA,
            params: TextureParams.default()
        }
    }

    /// Create texture from raw data
    fn from_data(width: u32, height: u32, format: TextureFormat, data: &[u8], params: TextureParams) -> Result<Texture, String> {
        let mut texture = Texture {
            id: 0,
            width: width,
            height: height,
            format: format,
            params: params
        }

        // Generate texture
        // gl.GenTextures(1, &texture.id)
        texture.id = 1  // Placeholder

        // Bind texture
        // gl.BindTexture(GL_TEXTURE_2D, texture.id)

        // Upload texture data
        // let (internal_format, pixel_format, pixel_type) = texture.get_gl_formats()
        // gl.TexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, pixel_format, pixel_type, data)

        // Set texture parameters
        texture.apply_params()

        // Generate mipmaps if requested
        if params.generate_mipmaps {
            // gl.GenerateMipmap(GL_TEXTURE_2D)
        }

        println!("Created texture {}x{} (format: {:?})", width, height, format)
        return Ok(texture)
    }

    /// Load texture from TGA file
    fn load_tga(path: String, params: TextureParams) -> Result<Texture, String> {
        let data = File.read_all_bytes(path.clone())?
        let tga = TGAImage.parse(data)?

        println!("Loaded TGA: {} ({}x{})", path, tga.width, tga.height)

        return Texture.from_data(tga.width, tga.height, tga.format, &tga.pixels, params)
    }

    /// Get OpenGL format constants
    fn get_gl_formats(self: &Texture) -> (i32, u32, u32) {
        // Returns (internal_format, pixel_format, pixel_type)
        match self.format {
            TextureFormat.RGB => {
                // (GL_RGB8, GL_RGB, GL_UNSIGNED_BYTE)
                return (0x8051, 0x1907, 0x1401)
            },
            TextureFormat.RGBA => {
                // (GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE)
                return (0x8058, 0x1908, 0x1401)
            },
            TextureFormat.R8 => {
                // (GL_R8, GL_RED, GL_UNSIGNED_BYTE)
                return (0x8229, 0x1903, 0x1401)
            },
            _ => {
                // Compressed formats
                return (0x8058, 0x1908, 0x1401)
            }
        }
    }

    /// Apply texture parameters to OpenGL
    fn apply_params(self: &Texture) {
        // Set filtering
        // gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, self.params.min_filter as i32)
        // gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, self.params.mag_filter as i32)

        // Set wrapping
        // gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, self.params.wrap_s as i32)
        // gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, self.params.wrap_t as i32)

        // Set anisotropic filtering
        if self.params.anisotropy > 0.0 {
            // gl.TexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, self.params.anisotropy)
        }
    }

    /// Bind texture to texture unit
    fn bind(self: &Texture, unit: u32) {
        // gl.ActiveTexture(GL_TEXTURE0 + unit)
        // gl.BindTexture(GL_TEXTURE_2D, self.id)
    }

    /// Unbind texture
    fn unbind() {
        // gl.BindTexture(GL_TEXTURE_2D, 0)
    }

    /// Update texture data
    fn update_data(self: &Texture, x: u32, y: u32, width: u32, height: u32, data: &[u8]) {
        // gl.BindTexture(GL_TEXTURE_2D, self.id)
        // let (_, pixel_format, pixel_type) = self.get_gl_formats()
        // gl.TexSubImage2D(GL_TEXTURE_2D, 0, x, y, width, height, pixel_format, pixel_type, data)
    }

    /// Delete texture
    fn delete(self: &mut Texture) {
        if self.id != 0 {
            // gl.DeleteTextures(1, &self.id)
            self.id = 0
            println!("Deleted texture")
        }
    }

    /// Check if valid
    fn is_valid(self: &Texture) -> bool {
        return self.id != 0
    }
}

/// TGA image file parser
/// Reference: Thyme uses TGA format for textures
struct TGAImage {
    width: u32,
    height: u32,
    format: TextureFormat,
    pixels: Vec<u8>,
}

impl TGAImage {
    /// Parse TGA file format
    fn parse(data: Vec<u8>) -> Result<TGAImage, String> {
        if data.len() < 18 {
            return Err("TGA file too small")
        }

        // TGA Header (18 bytes)
        let id_length = data[0]
        let color_map_type = data[1]
        let image_type = data[2]

        // Color map specification (5 bytes) - skip

        // Image specification
        let x_origin = u16.from_le_bytes([data[8], data[9]])
        let y_origin = u16.from_le_bytes([data[10], data[11]])
        let width = u16.from_le_bytes([data[12], data[13]]) as u32
        let height = u16.from_le_bytes([data[14], data[15]]) as u32
        let pixel_depth = data[16]
        let image_descriptor = data[17]

        // Skip image ID field
        let mut offset = 18 + (id_length as usize)

        // Determine format
        let format = match pixel_depth {
            24 => TextureFormat.RGB,
            32 => TextureFormat.RGBA,
            8 => TextureFormat.R8,
            _ => return Err(format!("Unsupported TGA bit depth: {}", pixel_depth))
        }

        let bytes_per_pixel = (pixel_depth / 8) as usize
        let pixel_count = (width * height) as usize
        let expected_size = pixel_count * bytes_per_pixel

        // Check image type
        match image_type {
            2 => {
                // Uncompressed RGB/RGBA
                if offset + expected_size > data.len() {
                    return Err("TGA file truncated")
                }

                // TGA stores pixels in BGR/BGRA format, need to swap R and B
                let mut pixels = Vec.with_capacity(expected_size)
                for i in 0..pixel_count {
                    let pixel_offset = offset + i * bytes_per_pixel

                    if bytes_per_pixel == 3 {
                        // BGR -> RGB
                        pixels.push(data[pixel_offset + 2])  // R
                        pixels.push(data[pixel_offset + 1])  // G
                        pixels.push(data[pixel_offset + 0])  // B
                    } else if bytes_per_pixel == 4 {
                        // BGRA -> RGBA
                        pixels.push(data[pixel_offset + 2])  // R
                        pixels.push(data[pixel_offset + 1])  // G
                        pixels.push(data[pixel_offset + 0])  // B
                        pixels.push(data[pixel_offset + 3])  // A
                    } else {
                        // Grayscale
                        pixels.push(data[pixel_offset])
                    }
                }

                return Ok(TGAImage {
                    width: width,
                    height: height,
                    format: format,
                    pixels: pixels
                })
            },
            10 => {
                // RLE compressed - TODO: Implement RLE decompression
                return Err("RLE compressed TGA not yet supported")
            },
            _ => {
                return Err(format!("Unsupported TGA image type: {}", image_type))
            }
        }
    }
}

/// Texture manager for loading and caching textures
struct TextureManager {
    textures: HashMap<String, Texture>,
    default_params: TextureParams,
}

impl TextureManager {
    fn new() -> TextureManager {
        return TextureManager {
            textures: HashMap.new(),
            default_params: TextureParams.default()
        }
    }

    /// Load texture from file (with caching)
    fn load(self: &mut TextureManager, path: String) -> Result<&Texture, String> {
        // Check cache
        if self.textures.contains_key(&path) {
            return Ok(self.textures.get(&path).unwrap())
        }

        // Load texture
        let texture = Texture.load_tga(path.clone(), self.default_params)?

        // Cache it
        self.textures.insert(path.clone(), texture)

        return Ok(self.textures.get(&path).unwrap())
    }

    /// Load texture with custom parameters
    fn load_with_params(self: &mut TextureManager, path: String, params: TextureParams) -> Result<&Texture, String> {
        // Check cache
        if self.textures.contains_key(&path) {
            return Ok(self.textures.get(&path).unwrap())
        }

        // Load texture
        let texture = Texture.load_tga(path.clone(), params)?

        // Cache it
        self.textures.insert(path.clone(), texture)

        return Ok(self.textures.get(&path).unwrap())
    }

    /// Get texture by name
    fn get(self: &TextureManager, path: &str) -> Option<&Texture> {
        return self.textures.get(path)
    }

    /// Unload texture
    fn unload(self: &mut TextureManager, path: &str) {
        if let Some(mut texture) = self.textures.remove(path) {
            texture.delete()
        }
    }

    /// Unload all textures
    fn unload_all(self: &mut TextureManager) {
        for (_, texture) in &mut self.textures {
            texture.delete()
        }
        self.textures.clear()
    }

    /// Get texture count
    fn count(self: &TextureManager) -> usize {
        return self.textures.len()
    }
}
