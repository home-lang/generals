// Mesh - 3D mesh rendering with vertex buffers
// Ported from Thyme Engine (GPL licensed)
// Reference: Thyme/src/w3d/renderer/mesh.h

import std.collections.Vec
import math.{Vec2, Vec3, Vec4}

/// Vertex attribute layout
struct Vertex {
    position: Vec3,
    normal: Vec3,
    tex_coord: Vec2,
    color: Vec4,
}

impl Vertex {
    fn new() -> Vertex {
        return Vertex {
            position: Vec3.new(0.0, 0.0, 0.0),
            normal: Vec3.new(0.0, 1.0, 0.0),
            tex_coord: Vec2.new(0.0, 0.0),
            color: Vec4.new(1.0, 1.0, 1.0, 1.0)
        }
    }

    fn with_position(position: Vec3) -> Vertex {
        let mut v = Vertex.new()
        v.position = position
        return v
    }

    fn with_all(position: Vec3, normal: Vec3, tex_coord: Vec2, color: Vec4) -> Vertex {
        return Vertex {
            position: position,
            normal: normal,
            tex_coord: tex_coord,
            color: color
        }
    }
}

/// Index type for index buffers
type Index = u32

/// Primitive topology
enum PrimitiveType {
    Triangles,
    TriangleStrip,
    TriangleFan,
    Lines,
    LineStrip,
    Points,
}

/// Vertex buffer object
struct VertexBuffer {
    vbo_id: u32,
    vertex_count: usize,
    capacity: usize,
}

impl VertexBuffer {
    /// Create empty vertex buffer
    fn new(capacity: usize) -> VertexBuffer {
        // gl.GenBuffers(1, &vbo_id)
        let vbo_id = 1  // Placeholder

        return VertexBuffer {
            vbo_id: vbo_id,
            vertex_count: 0,
            capacity: capacity
        }
    }

    /// Upload vertex data
    fn upload(self: &mut VertexBuffer, vertices: &[Vertex], usage: BufferUsage) {
        self.vertex_count = vertices.len()

        // gl.BindBuffer(GL_ARRAY_BUFFER, self.vbo_id)
        // gl.BufferData(GL_ARRAY_BUFFER, vertices.len() * sizeof(Vertex), vertices.as_ptr(), usage.to_gl())

        println!("Uploaded {} vertices to VBO", vertices.len())
    }

    /// Update vertex data (sub-range)
    fn update(self: &VertexBuffer, offset: usize, vertices: &[Vertex]) {
        // gl.BindBuffer(GL_ARRAY_BUFFER, self.vbo_id)
        // gl.BufferSubData(GL_ARRAY_BUFFER, offset * sizeof(Vertex), vertices.len() * sizeof(Vertex), vertices.as_ptr())
    }

    /// Bind vertex buffer
    fn bind(self: &VertexBuffer) {
        // gl.BindBuffer(GL_ARRAY_BUFFER, self.vbo_id)
    }

    /// Delete vertex buffer
    fn delete(self: &mut VertexBuffer) {
        if self.vbo_id != 0 {
            // gl.DeleteBuffers(1, &self.vbo_id)
            self.vbo_id = 0
        }
    }
}

/// Index buffer object
struct IndexBuffer {
    ibo_id: u32,
    index_count: usize,
    capacity: usize,
}

impl IndexBuffer {
    /// Create empty index buffer
    fn new(capacity: usize) -> IndexBuffer {
        // gl.GenBuffers(1, &ibo_id)
        let ibo_id = 1  // Placeholder

        return IndexBuffer {
            ibo_id: ibo_id,
            index_count: 0,
            capacity: capacity
        }
    }

    /// Upload index data
    fn upload(self: &mut IndexBuffer, indices: &[Index], usage: BufferUsage) {
        self.index_count = indices.len()

        // gl.BindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.ibo_id)
        // gl.BufferData(GL_ELEMENT_ARRAY_BUFFER, indices.len() * sizeof(Index), indices.as_ptr(), usage.to_gl())

        println!("Uploaded {} indices to IBO", indices.len())
    }

    /// Bind index buffer
    fn bind(self: &IndexBuffer) {
        // gl.BindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.ibo_id)
    }

    /// Delete index buffer
    fn delete(self: &mut IndexBuffer) {
        if self.ibo_id != 0 {
            // gl.DeleteBuffers(1, &self.ibo_id)
            self.ibo_id = 0
        }
    }
}

/// Buffer usage hint
enum BufferUsage {
    Static,   // GL_STATIC_DRAW - data won't change
    Dynamic,  // GL_DYNAMIC_DRAW - data changes occasionally
    Stream,   // GL_STREAM_DRAW - data changes every frame
}

impl BufferUsage {
    fn to_gl(self: &BufferUsage) -> u32 {
        match self {
            BufferUsage.Static => return 0x88E4,   // GL_STATIC_DRAW
            BufferUsage.Dynamic => return 0x88E8,  // GL_DYNAMIC_DRAW
            BufferUsage.Stream => return 0x88E0    // GL_STREAM_DRAW
        }
    }
}

/// Vertex Array Object (VAO)
struct VertexArray {
    vao_id: u32,
}

impl VertexArray {
    /// Create VAO
    fn new() -> VertexArray {
        // gl.GenVertexArrays(1, &vao_id)
        let vao_id = 1  // Placeholder

        return VertexArray { vao_id: vao_id }
    }

    /// Bind VAO
    fn bind(self: &VertexArray) {
        // gl.BindVertexArray(self.vao_id)
    }

    /// Unbind VAO
    fn unbind() {
        // gl.BindVertexArray(0)
    }

    /// Setup vertex attributes for standard Vertex layout
    fn setup_vertex_attributes(self: &VertexArray) {
        self.bind()

        // Position (location 0, 3 floats)
        // gl.EnableVertexAttribArray(0)
        // gl.VertexAttribPointer(0, 3, GL_FLOAT, false, sizeof(Vertex), offset 0)

        // Normal (location 1, 3 floats)
        // gl.EnableVertexAttribArray(1)
        // gl.VertexAttribPointer(1, 3, GL_FLOAT, false, sizeof(Vertex), offset 12)

        // TexCoord (location 2, 2 floats)
        // gl.EnableVertexAttribArray(2)
        // gl.VertexAttribPointer(2, 2, GL_FLOAT, false, sizeof(Vertex), offset 24)

        // Color (location 3, 4 floats)
        // gl.EnableVertexAttribArray(3)
        // gl.VertexAttribPointer(3, 4, GL_FLOAT, false, sizeof(Vertex), offset 32)

        println!("Setup vertex attributes")
    }

    /// Delete VAO
    fn delete(self: &mut VertexArray) {
        if self.vao_id != 0 {
            // gl.DeleteVertexArrays(1, &self.vao_id)
            self.vao_id = 0
        }
    }
}

/// Complete mesh with geometry and buffers
struct Mesh {
    vao: VertexArray,
    vbo: VertexBuffer,
    ibo: IndexBuffer,
    primitive_type: PrimitiveType,
    indexed: bool,
}

impl Mesh {
    /// Create mesh from vertices only
    fn from_vertices(vertices: Vec<Vertex>, primitive_type: PrimitiveType) -> Mesh {
        let mut vao = VertexArray.new()
        let mut vbo = VertexBuffer.new(vertices.len())
        let ibo = IndexBuffer.new(0)

        vao.bind()
        vbo.upload(&vertices, BufferUsage.Static)
        vao.setup_vertex_attributes()

        return Mesh {
            vao: vao,
            vbo: vbo,
            ibo: ibo,
            primitive_type: primitive_type,
            indexed: false
        }
    }

    /// Create mesh from vertices and indices
    fn from_indexed(vertices: Vec<Vertex>, indices: Vec<Index>, primitive_type: PrimitiveType) -> Mesh {
        let mut vao = VertexArray.new()
        let mut vbo = VertexBuffer.new(vertices.len())
        let mut ibo = IndexBuffer.new(indices.len())

        vao.bind()
        vbo.upload(&vertices, BufferUsage.Static)
        ibo.upload(&indices, BufferUsage.Static)
        vao.setup_vertex_attributes()

        return Mesh {
            vao: vao,
            vbo: vbo,
            ibo: ibo,
            primitive_type: primitive_type,
            indexed: true
        }
    }

    /// Draw mesh
    fn draw(self: &Mesh) {
        self.vao.bind()

        if self.indexed {
            // gl.DrawElements(self.primitive_type.to_gl(), self.ibo.index_count, GL_UNSIGNED_INT, null)
        } else {
            // gl.DrawArrays(self.primitive_type.to_gl(), 0, self.vbo.vertex_count)
        }
    }

    /// Delete mesh
    fn delete(self: &mut Mesh) {
        self.vao.delete()
        self.vbo.delete()
        self.ibo.delete()
    }
}

impl PrimitiveType {
    fn to_gl(self: &PrimitiveType) -> u32 {
        match self {
            PrimitiveType.Triangles => return 0x0004,      // GL_TRIANGLES
            PrimitiveType.TriangleStrip => return 0x0005,  // GL_TRIANGLE_STRIP
            PrimitiveType.TriangleFan => return 0x0006,    // GL_TRIANGLE_FAN
            PrimitiveType.Lines => return 0x0001,          // GL_LINES
            PrimitiveType.LineStrip => return 0x0003,      // GL_LINE_STRIP
            PrimitiveType.Points => return 0x0000          // GL_POINTS
        }
    }
}

/// Mesh builder utilities
struct MeshBuilder {
    /// Create cube mesh
    fn create_cube(size: f32) -> Mesh {
        let half = size * 0.5

        let vertices = vec![
            // Front face
            Vertex.with_all(Vec3.new(-half, -half,  half), Vec3.new(0.0, 0.0, 1.0), Vec2.new(0.0, 0.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new( half, -half,  half), Vec3.new(0.0, 0.0, 1.0), Vec2.new(1.0, 0.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new( half,  half,  half), Vec3.new(0.0, 0.0, 1.0), Vec2.new(1.0, 1.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new(-half,  half,  half), Vec3.new(0.0, 0.0, 1.0), Vec2.new(0.0, 1.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),

            // Back face
            Vertex.with_all(Vec3.new(-half, -half, -half), Vec3.new(0.0, 0.0, -1.0), Vec2.new(1.0, 0.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new(-half,  half, -half), Vec3.new(0.0, 0.0, -1.0), Vec2.new(1.0, 1.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new( half,  half, -half), Vec3.new(0.0, 0.0, -1.0), Vec2.new(0.0, 1.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new( half, -half, -half), Vec3.new(0.0, 0.0, -1.0), Vec2.new(0.0, 0.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),

            // Add top, bottom, left, right faces...
        ]

        let indices = vec![
            0, 1, 2,  0, 2, 3,  // Front
            4, 5, 6,  4, 6, 7,  // Back
            // Add remaining face indices...
        ]

        return Mesh.from_indexed(vertices, indices, PrimitiveType.Triangles)
    }

    /// Create quad mesh (for 2D rendering)
    fn create_quad(width: f32, height: f32) -> Mesh {
        let hw = width * 0.5
        let hh = height * 0.5

        let vertices = vec![
            Vertex.with_all(Vec3.new(-hw, -hh, 0.0), Vec3.new(0.0, 0.0, 1.0), Vec2.new(0.0, 0.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new( hw, -hh, 0.0), Vec3.new(0.0, 0.0, 1.0), Vec2.new(1.0, 0.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new( hw,  hh, 0.0), Vec3.new(0.0, 0.0, 1.0), Vec2.new(1.0, 1.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
            Vertex.with_all(Vec3.new(-hw,  hh, 0.0), Vec3.new(0.0, 0.0, 1.0), Vec2.new(0.0, 1.0), Vec4.new(1.0, 1.0, 1.0, 1.0)),
        ]

        let indices = vec![0, 1, 2,  0, 2, 3]

        return Mesh.from_indexed(vertices, indices, PrimitiveType.Triangles)
    }

    /// Create grid mesh (for terrain/debug)
    fn create_grid(width: f32, height: f32, subdivisions_x: u32, subdivisions_y: u32) -> Mesh {
        let mut vertices = Vec.new()

        let step_x = width / (subdivisions_x as f32)
        let step_y = height / (subdivisions_y as f32)
        let start_x = -width * 0.5
        let start_z = -height * 0.5

        // Generate grid vertices
        for y in 0..=subdivisions_y {
            for x in 0..=subdivisions_x {
                let pos_x = start_x + (x as f32) * step_x
                let pos_z = start_z + (y as f32) * step_y

                let u = (x as f32) / (subdivisions_x as f32)
                let v = (y as f32) / (subdivisions_y as f32)

                vertices.push(Vertex.with_all(
                    Vec3.new(pos_x, 0.0, pos_z),
                    Vec3.new(0.0, 1.0, 0.0),
                    Vec2.new(u, v),
                    Vec4.new(1.0, 1.0, 1.0, 1.0)
                ))
            }
        }

        // Generate indices
        let mut indices = Vec.new()
        for y in 0..subdivisions_y {
            for x in 0..subdivisions_x {
                let i0 = y * (subdivisions_x + 1) + x
                let i1 = i0 + 1
                let i2 = i0 + (subdivisions_x + 1)
                let i3 = i2 + 1

                // Two triangles per quad
                indices.push(i0)
                indices.push(i2)
                indices.push(i1)

                indices.push(i1)
                indices.push(i2)
                indices.push(i3)
            }
        }

        return Mesh.from_indexed(vertices, indices, PrimitiveType.Triangles)
    }
}
