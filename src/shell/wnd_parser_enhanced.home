// Enhanced WND Parser - Complete parsing of C&C Generals WND files
// Includes ENABLEDDRAWDATA, DISABLEDDRAWDATA, HILITEDRAWDATA parsing
// Based on Thyme engine's gamewindowmanagerscript.cpp

import shell/wnd_elements

// ============================================================================
// Draw Data State Types (9 states per element)
// ============================================================================

// WND files use 9 draw data slots for each state (enabled/disabled/hilite)
// These correspond to the 9-slice box model:
// [0] Top-Left     [1] Top       [2] Top-Right
// [3] Left         [4] Center    [5] Right
// [6] Bottom-Left  [7] Bottom    [8] Bottom-Right

enum DrawDataSlot {
    TOP_LEFT,
    TOP,
    TOP_RIGHT,
    LEFT,
    CENTER,
    RIGHT,
    BOTTOM_LEFT,
    BOTTOM,
    BOTTOM_RIGHT,
}

struct ParsedDrawData {
    image: String,
    color: WndColor,
    border_color: WndColor,
    is_tiled: Bool,
}

fn create_parsed_draw_data() -> ParsedDrawData {
    return ParsedDrawData {
        image: "NoImage",
        color: rgba(255, 255, 255, 255),
        border_color: rgba(255, 255, 255, 255),
        is_tiled: false,
    }
}

// Full draw data for a window state
struct WindowDrawData {
    slots: [ParsedDrawData],  // 9 slots
}

fn create_window_draw_data() -> WindowDrawData {
    let slots: [ParsedDrawData] = []
    for i in 0..9 {
        slots = slots + [create_parsed_draw_data()]
    }
    return WindowDrawData { slots: slots }
}

// ============================================================================
// WND Token Types
// ============================================================================

enum WndTokenType {
    IDENTIFIER,
    STRING,
    NUMBER,
    EQUALS,
    SEMICOLON,
    COLON,
    COMMA,
    PLUS,
    LBRACE,
    RBRACE,
    EOF,
}

struct WndToken {
    token_type: WndTokenType,
    text: String,
    int_value: i32,
    float_value: f32,
    line: i32,
    column: i32,
}

// ============================================================================
// WND Lexer
// ============================================================================

struct WndLexer {
    source: String,
    pos: i32,
    line: i32,
    column: i32,
}

fn create_wnd_lexer(source: String) -> WndLexer {
    return WndLexer {
        source: source,
        pos: 0,
        line: 1,
        column: 1,
    }
}

fn lexer_peek_char(lex: WndLexer) -> u8 {
    if lex.pos >= lex.source.length {
        return 0
    }
    return lex.source[lex.pos]
}

fn lexer_next_char(lex: WndLexer) -> u8 {
    let c = lexer_peek_char(lex)
    if c != 0 {
        lex.pos = lex.pos + 1
        if c == 10 {  // newline
            lex.line = lex.line + 1
            lex.column = 1
        } else {
            lex.column = lex.column + 1
        }
    }
    return c
}

fn lexer_skip_whitespace(lex: WndLexer) {
    while true {
        let c = lexer_peek_char(lex)
        if c == 32 || c == 9 || c == 13 || c == 10 {  // space, tab, cr, lf
            lexer_next_char(lex)
        } else if c == 47 {  // '/'
            // Check for comment
            if lex.pos + 1 < lex.source.length && lex.source[lex.pos + 1] == 47 {
                // Line comment
                while lexer_peek_char(lex) != 10 && lexer_peek_char(lex) != 0 {
                    lexer_next_char(lex)
                }
            } else {
                break
            }
        } else if c == 59 {  // ';' at start of line is comment in some WND files
            // Skip to end of line
            while lexer_peek_char(lex) != 10 && lexer_peek_char(lex) != 0 {
                lexer_next_char(lex)
            }
        } else {
            break
        }
    }
}

fn lexer_next_token(lex: WndLexer) -> WndToken {
    lexer_skip_whitespace(lex)

    let token = WndToken {
        token_type: WndTokenType::EOF,
        text: "",
        int_value: 0,
        float_value: 0.0,
        line: lex.line,
        column: lex.column,
    }

    let c = lexer_peek_char(lex)

    if c == 0 {
        return token
    }

    // Single character tokens
    if c == 61 {  // '='
        lexer_next_char(lex)
        token.token_type = WndTokenType::EQUALS
        token.text = "="
        return token
    }
    if c == 59 {  // ';'
        lexer_next_char(lex)
        token.token_type = WndTokenType::SEMICOLON
        token.text = ";"
        return token
    }
    if c == 58 {  // ':'
        lexer_next_char(lex)
        token.token_type = WndTokenType::COLON
        token.text = ":"
        return token
    }
    if c == 44 {  // ','
        lexer_next_char(lex)
        token.token_type = WndTokenType::COMMA
        token.text = ","
        return token
    }
    if c == 43 {  // '+'
        lexer_next_char(lex)
        token.token_type = WndTokenType::PLUS
        token.text = "+"
        return token
    }

    // String literal
    if c == 34 {  // '"'
        lexer_next_char(lex)
        let start = lex.pos
        while lexer_peek_char(lex) != 34 && lexer_peek_char(lex) != 0 {
            lexer_next_char(lex)
        }
        token.text = substring(lex.source, start, lex.pos)
        lexer_next_char(lex)  // Skip closing quote
        token.token_type = WndTokenType::STRING
        return token
    }

    // Number
    if is_digit(c) || (c == 45 && is_digit(lex.source[lex.pos + 1])) {  // digit or negative
        let start = lex.pos
        let is_negative = c == 45
        if is_negative {
            lexer_next_char(lex)
        }
        while is_digit(lexer_peek_char(lex)) {
            lexer_next_char(lex)
        }
        // Check for decimal point
        let is_float = false
        if lexer_peek_char(lex) == 46 {  // '.'
            is_float = true
            lexer_next_char(lex)
            while is_digit(lexer_peek_char(lex)) {
                lexer_next_char(lex)
            }
        }
        token.text = substring(lex.source, start, lex.pos)
        token.token_type = WndTokenType::NUMBER
        token.int_value = parse_int(token.text)
        token.float_value = parse_float(token.text)
        return token
    }

    // Identifier
    if is_alpha(c) || c == 95 {  // letter or underscore
        let start = lex.pos
        while is_alnum(lexer_peek_char(lex)) || lexer_peek_char(lex) == 95 {
            lexer_next_char(lex)
        }
        token.text = substring(lex.source, start, lex.pos)
        token.token_type = WndTokenType::IDENTIFIER
        return token
    }

    // Unknown character - skip it
    lexer_next_char(lex)
    return lexer_next_token(lex)
}

// ============================================================================
// Enhanced WND Parser
// ============================================================================

struct EnhancedWndParser {
    lexer: WndLexer,
    current_token: WndToken,
    peek_token: WndToken,
}

fn create_enhanced_parser(source: String) -> EnhancedWndParser {
    let lexer = create_wnd_lexer(source)
    let parser = EnhancedWndParser {
        lexer: lexer,
        current_token: lexer_next_token(lexer),
        peek_token: lexer_next_token(lexer),
    }
    return parser
}

fn parser_advance(parser: EnhancedWndParser) {
    parser.current_token = parser.peek_token
    parser.peek_token = lexer_next_token(parser.lexer)
}

fn parser_expect(parser: EnhancedWndParser, ttype: WndTokenType) -> Bool {
    if parser.current_token.token_type == ttype {
        parser_advance(parser)
        return true
    }
    return false
}

fn parser_match(parser: EnhancedWndParser, text: String) -> Bool {
    if parser.current_token.text == text {
        parser_advance(parser)
        return true
    }
    return false
}

// ============================================================================
// Parse Draw Data Blocks
// ============================================================================

fn parse_draw_data_block(parser: EnhancedWndParser) -> WindowDrawData {
    let draw_data = create_window_draw_data()

    // ENABLEDDRAWDATA = IMAGE: imagename, COLOR: r g b a, BORDERCOLOR: r g b a, ...;
    // Can have up to 9 entries separated by semicolons within the block

    parser_expect(parser, WndTokenType::EQUALS)

    let slot_index = 0
    while slot_index < 9 && parser.current_token.token_type != WndTokenType::SEMICOLON {
        let slot_data = create_parsed_draw_data()

        // Parse slot properties
        while parser.current_token.token_type == WndTokenType::IDENTIFIER {
            let prop_name = parser.current_token.text
            parser_advance(parser)

            if prop_name == "IMAGE" {
                parser_expect(parser, WndTokenType::COLON)
                slot_data.image = parser.current_token.text
                parser_advance(parser)
            } else if prop_name == "COLOR" {
                parser_expect(parser, WndTokenType::COLON)
                slot_data.color = parse_color(parser)
            } else if prop_name == "BORDERCOLOR" {
                parser_expect(parser, WndTokenType::COLON)
                slot_data.border_color = parse_color(parser)
            }

            // Skip comma between properties
            if parser.current_token.token_type == WndTokenType::COMMA {
                parser_advance(parser)
            }
        }

        draw_data.slots[slot_index] = slot_data
        slot_index = slot_index + 1

        // Check for semicolon ending this slot
        if parser.current_token.token_type == WndTokenType::SEMICOLON {
            // Check if there's more data (multiple semicolon-separated entries)
            parser_advance(parser)
            if parser.current_token.token_type != WndTokenType::IDENTIFIER {
                break
            }
            // Continue parsing if it's not a new property keyword
            if !is_wnd_keyword(parser.current_token.text) {
                break
            }
        }
    }

    return draw_data
}

fn parse_color(parser: EnhancedWndParser) -> WndColor {
    let r = parser.current_token.int_value
    parser_advance(parser)
    let g = parser.current_token.int_value
    parser_advance(parser)
    let b = parser.current_token.int_value
    parser_advance(parser)
    let a = 255
    if parser.current_token.token_type == WndTokenType::NUMBER {
        a = parser.current_token.int_value
        parser_advance(parser)
    }
    return rgba(r as u8, g as u8, b as u8, a as u8)
}

// ============================================================================
// Full Window Definition Parser
// ============================================================================

struct ParsedWindow {
    name: String,
    window_type: String,
    rect: WndRect,
    creation_resolution: [i32],  // [width, height]
    status_flags: [String],

    // Callbacks
    system_callback: String,
    input_callback: String,
    tooltip_callback: String,
    draw_callback: String,

    // Font
    font_name: String,
    font_size: i32,
    font_bold: Bool,

    // Text
    text: String,
    tooltip_text: String,
    header_template: String,

    // Draw data
    enabled_draw: WindowDrawData,
    disabled_draw: WindowDrawData,
    hilite_draw: WindowDrawData,

    // Text colors
    text_color_enabled: WndColor,
    text_color_disabled: WndColor,
    text_color_hilite: WndColor,
    text_border_enabled: WndColor,
    text_border_disabled: WndColor,
    text_border_hilite: WndColor,

    // Children
    children: [ParsedWindow],
}

fn create_parsed_window() -> ParsedWindow {
    return ParsedWindow {
        name: "",
        window_type: "USER",
        rect: create_rect(0, 0, 100, 100),
        creation_resolution: [800, 600],
        status_flags: [],
        system_callback: "[None]",
        input_callback: "[None]",
        tooltip_callback: "[None]",
        draw_callback: "[None]",
        font_name: "Arial",
        font_size: 12,
        font_bold: false,
        text: "",
        tooltip_text: "",
        header_template: "",
        enabled_draw: create_window_draw_data(),
        disabled_draw: create_window_draw_data(),
        hilite_draw: create_window_draw_data(),
        text_color_enabled: color_white(),
        text_color_disabled: color_gray(),
        text_color_hilite: color_gold(),
        text_border_enabled: color_black(),
        text_border_disabled: color_black(),
        text_border_hilite: color_black(),
        children: [],
    }
}

fn parse_window_block(parser: EnhancedWndParser) -> ParsedWindow {
    let window = create_parsed_window()

    while parser.current_token.token_type != WndTokenType::EOF {
        let keyword = parser.current_token.text

        if keyword == "END" {
            parser_advance(parser)
            break
        }

        parser_advance(parser)

        if keyword == "WINDOWTYPE" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.window_type = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "SCREENRECT" {
            window.rect = parse_screen_rect(parser)
        } else if keyword == "NAME" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.name = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "STATUS" {
            window.status_flags = parse_status_flags(parser)
        } else if keyword == "SYSTEMCALLBACK" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.system_callback = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "INPUTCALLBACK" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.input_callback = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "TOOLTIPCALLBACK" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.tooltip_callback = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "DRAWCALLBACK" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.draw_callback = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "FONT" {
            parse_font(parser, window)
        } else if keyword == "TEXT" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.text = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "TOOLTIPTEXT" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.tooltip_text = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "HEADERTEMPLATE" {
            parser_expect(parser, WndTokenType::EQUALS)
            window.header_template = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "ENABLEDDRAWDATA" {
            window.enabled_draw = parse_draw_data_block(parser)
        } else if keyword == "DISABLEDDRAWDATA" {
            window.disabled_draw = parse_draw_data_block(parser)
        } else if keyword == "HILITEDRAWDATA" {
            window.hilite_draw = parse_draw_data_block(parser)
        } else if keyword == "TEXTCOLOR" {
            parse_text_colors(parser, window)
        } else if keyword == "WINDOW" || keyword == "CHILD" {
            let child = parse_window_block(parser)
            window.children = window.children + [child]
        } else {
            // Skip unknown property to semicolon
            skip_to_semicolon(parser)
        }
    }

    return window
}

fn parse_screen_rect(parser: EnhancedWndParser) -> WndRect {
    let rect = create_rect(0, 0, 100, 100)

    parser_expect(parser, WndTokenType::EQUALS)

    // Parse: UPPERLEFT: x y, BOTTOMRIGHT: x2 y2, CREATIONRESOLUTION: w h;
    while parser.current_token.token_type != WndTokenType::SEMICOLON {
        let label = parser.current_token.text
        parser_advance(parser)

        if label == "UPPERLEFT" {
            parser_expect(parser, WndTokenType::COLON)
            rect.x = parser.current_token.int_value
            parser_advance(parser)
            rect.y = parser.current_token.int_value
            parser_advance(parser)
        } else if label == "BOTTOMRIGHT" {
            parser_expect(parser, WndTokenType::COLON)
            let x2 = parser.current_token.int_value
            parser_advance(parser)
            let y2 = parser.current_token.int_value
            parser_advance(parser)
            rect.width = x2 - rect.x
            rect.height = y2 - rect.y
        } else if label == "CREATIONRESOLUTION" {
            parser_expect(parser, WndTokenType::COLON)
            parser_advance(parser)  // width
            parser_advance(parser)  // height
        }

        // Skip comma
        if parser.current_token.token_type == WndTokenType::COMMA {
            parser_advance(parser)
        }
    }
    parser_advance(parser)  // Skip semicolon

    return rect
}

fn parse_status_flags(parser: EnhancedWndParser) -> [String] {
    let flags: [String] = []

    parser_expect(parser, WndTokenType::EQUALS)

    while parser.current_token.token_type != WndTokenType::SEMICOLON {
        if parser.current_token.token_type == WndTokenType::IDENTIFIER {
            flags = flags + [parser.current_token.text]
        }
        parser_advance(parser)
        // Skip plus signs between flags
        if parser.current_token.token_type == WndTokenType::PLUS {
            parser_advance(parser)
        }
    }
    parser_advance(parser)  // Skip semicolon

    return flags
}

fn parse_font(parser: EnhancedWndParser, window: ParsedWindow) {
    parser_expect(parser, WndTokenType::EQUALS)

    while parser.current_token.token_type != WndTokenType::SEMICOLON {
        let prop = parser.current_token.text
        parser_advance(parser)

        if prop == "NAME" {
            parser_expect(parser, WndTokenType::COLON)
            window.font_name = parser.current_token.text
            parser_advance(parser)
        } else if prop == "SIZE" {
            parser_expect(parser, WndTokenType::COLON)
            window.font_size = parser.current_token.int_value
            parser_advance(parser)
        } else if prop == "BOLD" {
            parser_expect(parser, WndTokenType::COLON)
            window.font_bold = parser.current_token.int_value != 0
            parser_advance(parser)
        }

        if parser.current_token.token_type == WndTokenType::COMMA {
            parser_advance(parser)
        }
    }
    parser_advance(parser)
}

fn parse_text_colors(parser: EnhancedWndParser, window: ParsedWindow) {
    parser_expect(parser, WndTokenType::EQUALS)

    // TEXTCOLOR = ENABLED: r g b a, ENABLEDBORDER: r g b a, DISABLED: r g b a, ...;
    while parser.current_token.token_type != WndTokenType::SEMICOLON {
        let label = parser.current_token.text
        parser_advance(parser)
        parser_expect(parser, WndTokenType::COLON)

        let color = parse_color(parser)

        if label == "ENABLED" {
            window.text_color_enabled = color
        } else if label == "ENABLEDBORDER" {
            window.text_border_enabled = color
        } else if label == "DISABLED" {
            window.text_color_disabled = color
        } else if label == "DISABLEDBORDER" {
            window.text_border_disabled = color
        } else if label == "HILITE" {
            window.text_color_hilite = color
        } else if label == "HILITEBORDER" {
            window.text_border_hilite = color
        }

        if parser.current_token.token_type == WndTokenType::COMMA {
            parser_advance(parser)
        }
    }
    parser_advance(parser)
}

fn skip_to_semicolon(parser: EnhancedWndParser) {
    while parser.current_token.token_type != WndTokenType::SEMICOLON &&
          parser.current_token.token_type != WndTokenType::EOF {
        parser_advance(parser)
    }
    if parser.current_token.token_type == WndTokenType::SEMICOLON {
        parser_advance(parser)
    }
}

// ============================================================================
// Full WND File Parser
// ============================================================================

struct ParsedWndFile {
    version: i32,
    layout_init: String,
    layout_update: String,
    layout_shutdown: String,
    root_window: ParsedWindow,
}

fn parse_wnd_file(source: String) -> ParsedWndFile {
    let parser = create_enhanced_parser(source)

    let wnd_file = ParsedWndFile {
        version: 2,
        layout_init: "[None]",
        layout_update: "[None]",
        layout_shutdown: "[None]",
        root_window: create_parsed_window(),
    }

    while parser.current_token.token_type != WndTokenType::EOF {
        let keyword = parser.current_token.text
        parser_advance(parser)

        if keyword == "FILE_VERSION" {
            parser_expect(parser, WndTokenType::EQUALS)
            wnd_file.version = parser.current_token.int_value
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "STARTLAYOUTBLOCK" {
            parse_layout_block(parser, wnd_file)
        } else if keyword == "WINDOW" {
            wnd_file.root_window = parse_window_block(parser)
        }
    }

    return wnd_file
}

fn parse_layout_block(parser: EnhancedWndParser, wnd_file: ParsedWndFile) {
    while parser.current_token.text != "ENDLAYOUTBLOCK" &&
          parser.current_token.token_type != WndTokenType::EOF {
        let keyword = parser.current_token.text
        parser_advance(parser)

        if keyword == "LAYOUTINIT" {
            parser_expect(parser, WndTokenType::EQUALS)
            wnd_file.layout_init = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "LAYOUTUPDATE" {
            parser_expect(parser, WndTokenType::EQUALS)
            wnd_file.layout_update = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        } else if keyword == "LAYOUTSHUTDOWN" {
            parser_expect(parser, WndTokenType::EQUALS)
            wnd_file.layout_shutdown = parser.current_token.text
            parser_advance(parser)
            parser_expect(parser, WndTokenType::SEMICOLON)
        }
    }
    parser_advance(parser)  // Skip ENDLAYOUTBLOCK
}

// ============================================================================
// Utility Functions
// ============================================================================

fn is_digit(c: u8) -> Bool {
    return c >= 48 && c <= 57
}

fn is_alpha(c: u8) -> Bool {
    return (c >= 65 && c <= 90) || (c >= 97 && c <= 122)
}

fn is_alnum(c: u8) -> Bool {
    return is_digit(c) || is_alpha(c)
}

fn is_wnd_keyword(text: String) -> Bool {
    let keywords = [
        "WINDOW", "END", "WINDOWTYPE", "SCREENRECT", "NAME", "STATUS",
        "SYSTEMCALLBACK", "INPUTCALLBACK", "TOOLTIPCALLBACK", "DRAWCALLBACK",
        "FONT", "TEXT", "TOOLTIPTEXT", "HEADERTEMPLATE",
        "ENABLEDDRAWDATA", "DISABLEDDRAWDATA", "HILITEDRAWDATA", "TEXTCOLOR",
        "CHILD", "STYLE", "LISTBOXDATA", "COMBOBOXDATA", "SLIDERDATA",
    ]
    for kw in keywords {
        if text == kw {
            return true
        }
    }
    return false
}

fn substring(s: String, start: i32, end: i32) -> String {
    // Placeholder - production would use actual string slicing
    return s
}

fn parse_int(s: String) -> i32 {
    // Placeholder - production would use actual integer parsing
    return 0
}

fn parse_float(s: String) -> f32 {
    // Placeholder - production would use actual float parsing
    return 0.0
}

// ============================================================================
// Tests
// ============================================================================

fn test_lexer() -> Bool {
    let source = "FILE_VERSION = 2;"
    let lexer = create_wnd_lexer(source)

    let t1 = lexer_next_token(lexer)
    assert(t1.text == "FILE_VERSION", "Should parse identifier")

    let t2 = lexer_next_token(lexer)
    assert(t2.token_type == WndTokenType::EQUALS, "Should parse equals")

    let t3 = lexer_next_token(lexer)
    assert(t3.text == "2", "Should parse number")

    let t4 = lexer_next_token(lexer)
    assert(t4.token_type == WndTokenType::SEMICOLON, "Should parse semicolon")

    return true
}

fn test_draw_data_parsing() -> Bool {
    let source = "ENABLEDDRAWDATA = IMAGE: Button_Normal, COLOR: 255 255 255 255, BORDERCOLOR: 0 0 0 255;"
    let parser = create_enhanced_parser(source)

    // Skip to ENABLEDDRAWDATA
    parser_advance(parser)

    let draw_data = parse_draw_data_block(parser)

    assert(draw_data.slots[0].image == "Button_Normal", "Image should be Button_Normal")
    assert(draw_data.slots[0].color.r == 255, "Red should be 255")

    return true
}

fn test_full_window_parsing() -> Bool {
    let source = "WINDOW WINDOWTYPE = USER; NAME = \"TestWindow\"; STATUS = ENABLED + IMAGE; END"
    let parser = create_enhanced_parser(source)

    parser_advance(parser)  // Skip WINDOW

    let window = parse_window_block(parser)

    assert(window.window_type == "USER", "Window type should be USER")
    assert(window.name == "TestWindow", "Name should be TestWindow")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_lexer(), "Lexer test failed")
    assert(test_draw_data_parsing(), "Draw data parsing test failed")
    assert(test_full_window_parsing(), "Full window parsing test failed")
    return true
}
