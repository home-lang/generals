// WND Element Types - Complete UI Widget System
// Implements all WND element types from original C&C Generals:
// STATICTEXT, ENTRYFIELD, LISTBOX, COMBOBOX, CHECKBOX, RADIOBUTTON, SLIDER, PROGRESSBAR

// ============================================================================
// Base WND Element
// ============================================================================

enum WndElementType {
    WINDOW,
    USER,
    STATICTEXT,
    ENTRYFIELD,
    LISTBOX,
    COMBOBOX,
    CHECKBOX,
    RADIOBUTTON,
    HORZSLIDER,
    VERTSLIDER,
    PROGRESSBAR,
    TABCONTROL,
    PUSHBUTTON,
}

struct WndRect {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}

fn create_rect(x: i32, y: i32, w: i32, h: i32) -> WndRect {
    return WndRect { x: x, y: y, width: w, height: h }
}

struct WndColor {
    r: u8,
    g: u8,
    b: u8,
    a: u8,
}

fn rgba(r: u8, g: u8, b: u8, a: u8) -> WndColor {
    return WndColor { r: r, g: g, b: b, a: a }
}

fn color_white() -> WndColor { return rgba(255, 255, 255, 255) }
fn color_black() -> WndColor { return rgba(0, 0, 0, 255) }
fn color_gray() -> WndColor { return rgba(128, 128, 128, 255) }
fn color_gold() -> WndColor { return rgba(255, 200, 50, 255) }
fn color_green() -> WndColor { return rgba(50, 200, 50, 255) }
fn color_red() -> WndColor { return rgba(200, 50, 50, 255) }

// Draw data for different element states
struct DrawData {
    image_name: String,
    color: WndColor,
    border_color: WndColor,
}

fn create_draw_data(image: String, color: WndColor, border: WndColor) -> DrawData {
    return DrawData {
        image_name: image,
        color: color,
        border_color: border,
    }
}

// Text styling
struct TextStyle {
    font_name: String,
    font_size: i32,
    bold: Bool,
    italic: Bool,
    color: WndColor,
    shadow_color: WndColor,
    alignment: TextAlignment,
}

enum TextAlignment {
    LEFT,
    CENTER,
    RIGHT,
}

fn default_text_style() -> TextStyle {
    return TextStyle {
        font_name: "Arial",
        font_size: 12,
        bold: false,
        italic: false,
        color: color_white(),
        shadow_color: color_black(),
        alignment: TextAlignment::LEFT,
    }
}

// Base element that all WND widgets inherit from
struct WndElement {
    element_type: WndElementType,
    name: String,
    rect: WndRect,
    is_visible: Bool,
    is_enabled: Bool,
    is_focused: Bool,
    is_hovered: Bool,
    tooltip: String,

    // Draw data for states
    enabled_draw: [DrawData],  // 9 states
    disabled_draw: [DrawData],
    hilite_draw: [DrawData],

    // Text styling
    text_style: TextStyle,

    // Callbacks
    on_click: fn(),
    on_hover: fn(),
    on_focus: fn(),

    // Parent/child relationships
    parent_id: i32,
    children: [i32],
}

fn create_base_element(etype: WndElementType, name: String, rect: WndRect) -> WndElement {
    return WndElement {
        element_type: etype,
        name: name,
        rect: rect,
        is_visible: true,
        is_enabled: true,
        is_focused: false,
        is_hovered: false,
        tooltip: "",
        enabled_draw: [],
        disabled_draw: [],
        hilite_draw: [],
        text_style: default_text_style(),
        on_click: null,
        on_hover: null,
        on_focus: null,
        parent_id: -1,
        children: [],
    }
}

// ============================================================================
// STATICTEXT - Non-interactive text display
// ============================================================================

struct StaticText {
    base: WndElement,
    text: String,
    word_wrap: Bool,
    vertical_centered: Bool,
}

fn create_static_text(name: String, rect: WndRect, text: String) -> StaticText {
    let base = create_base_element(WndElementType::STATICTEXT, name, rect)
    return StaticText {
        base: base,
        text: text,
        word_wrap: true,
        vertical_centered: false,
    }
}

fn set_static_text_content(st: StaticText, text: String) {
    st.text = text
}

fn render_static_text(st: StaticText) {
    if !st.base.is_visible {
        return
    }

    // Draw background if has draw data
    // Draw text with word wrapping if enabled
    // Apply text style (font, color, alignment)
}

// ============================================================================
// ENTRYFIELD - Text input field
// ============================================================================

struct EntryField {
    base: WndElement,
    text: String,
    placeholder: String,
    cursor_position: i32,
    selection_start: i32,
    selection_end: i32,
    max_length: i32,
    is_password: Bool,
    is_numeric_only: Bool,
    is_read_only: Bool,

    // Visual state
    cursor_blink_time: f32,
    cursor_visible: Bool,
}

fn create_entry_field(name: String, rect: WndRect) -> EntryField {
    let base = create_base_element(WndElementType::ENTRYFIELD, name, rect)
    return EntryField {
        base: base,
        text: "",
        placeholder: "",
        cursor_position: 0,
        selection_start: 0,
        selection_end: 0,
        max_length: 256,
        is_password: false,
        is_numeric_only: false,
        is_read_only: false,
        cursor_blink_time: 0.0,
        cursor_visible: true,
    }
}

fn entry_field_insert_char(ef: EntryField, c: u8) {
    if ef.is_read_only {
        return
    }
    if ef.is_numeric_only && (c < 48 || c > 57) {
        return  // Only allow 0-9
    }
    if ef.text.length >= ef.max_length {
        return
    }

    // Delete selection if any
    if ef.selection_start != ef.selection_end {
        entry_field_delete_selection(ef)
    }

    // Insert character at cursor
    let before = substring(ef.text, 0, ef.cursor_position)
    let after = substring(ef.text, ef.cursor_position, ef.text.length)
    ef.text = before + char_to_string(c) + after
    ef.cursor_position = ef.cursor_position + 1
}

fn entry_field_delete_selection(ef: EntryField) {
    let start = min_i32(ef.selection_start, ef.selection_end)
    let end = max_i32(ef.selection_start, ef.selection_end)

    let before = substring(ef.text, 0, start)
    let after = substring(ef.text, end, ef.text.length)
    ef.text = before + after

    ef.cursor_position = start
    ef.selection_start = start
    ef.selection_end = start
}

fn entry_field_backspace(ef: EntryField) {
    if ef.is_read_only {
        return
    }

    if ef.selection_start != ef.selection_end {
        entry_field_delete_selection(ef)
    } else if ef.cursor_position > 0 {
        let before = substring(ef.text, 0, ef.cursor_position - 1)
        let after = substring(ef.text, ef.cursor_position, ef.text.length)
        ef.text = before + after
        ef.cursor_position = ef.cursor_position - 1
    }
}

fn update_entry_field(ef: EntryField, delta_time: f32) {
    // Cursor blink
    ef.cursor_blink_time = ef.cursor_blink_time + delta_time
    if ef.cursor_blink_time >= 0.5 {
        ef.cursor_visible = !ef.cursor_visible
        ef.cursor_blink_time = 0.0
    }
}

fn render_entry_field(ef: EntryField) {
    if !ef.base.is_visible {
        return
    }

    // Draw background
    // Draw border (highlighted if focused)
    // Draw text (or placeholder if empty)
    // Draw cursor if focused and visible
    // Draw selection highlight
}

// ============================================================================
// LISTBOX - Scrollable list of items
// ============================================================================

struct ListBoxItem {
    text: String,
    data: i32,  // User data
    is_selected: Bool,
    icon_name: String,
}

struct ListBox {
    base: WndElement,
    items: [ListBoxItem],
    selected_index: i32,
    scroll_offset: i32,
    visible_items: i32,
    item_height: i32,
    multi_select: Bool,

    // Scrollbar state
    has_scrollbar: Bool,
    scrollbar_width: i32,
    scrollbar_dragging: Bool,
}

fn create_list_box(name: String, rect: WndRect) -> ListBox {
    let base = create_base_element(WndElementType::LISTBOX, name, rect)
    let item_h = 20
    return ListBox {
        base: base,
        items: [],
        selected_index: -1,
        scroll_offset: 0,
        visible_items: rect.height / item_h,
        item_height: item_h,
        multi_select: false,
        has_scrollbar: true,
        scrollbar_width: 16,
        scrollbar_dragging: false,
    }
}

fn list_box_add_item(lb: ListBox, text: String, data: i32) {
    let item = ListBoxItem {
        text: text,
        data: data,
        is_selected: false,
        icon_name: "",
    }
    lb.items = lb.items + [item]
}

fn list_box_remove_item(lb: ListBox, index: i32) {
    if index >= 0 && index < lb.items.length {
        let new_items: [ListBoxItem] = []
        for i in 0..lb.items.length {
            if i != index {
                new_items = new_items + [lb.items[i]]
            }
        }
        lb.items = new_items

        if lb.selected_index >= lb.items.length {
            lb.selected_index = lb.items.length - 1
        }
    }
}

fn list_box_clear(lb: ListBox) {
    lb.items = []
    lb.selected_index = -1
    lb.scroll_offset = 0
}

fn list_box_select(lb: ListBox, index: i32) {
    if lb.multi_select {
        if index >= 0 && index < lb.items.length {
            lb.items[index].is_selected = !lb.items[index].is_selected
        }
    } else {
        // Single select - clear others
        for item in lb.items {
            item.is_selected = false
        }
        if index >= 0 && index < lb.items.length {
            lb.items[index].is_selected = true
            lb.selected_index = index
        }
    }
}

fn list_box_scroll_to(lb: ListBox, index: i32) {
    if index < lb.scroll_offset {
        lb.scroll_offset = index
    } else if index >= lb.scroll_offset + lb.visible_items {
        lb.scroll_offset = index - lb.visible_items + 1
    }

    // Clamp scroll offset
    let max_scroll = max_i32(0, lb.items.length - lb.visible_items)
    lb.scroll_offset = clamp_i32(lb.scroll_offset, 0, max_scroll)
}

fn list_box_get_selected_items(lb: ListBox) -> [i32] {
    let selected: [i32] = []
    for i in 0..lb.items.length {
        if lb.items[i].is_selected {
            selected = selected + [i]
        }
    }
    return selected
}

fn render_list_box(lb: ListBox) {
    if !lb.base.is_visible {
        return
    }

    // Draw background
    // Draw visible items
    // Draw selection highlight
    // Draw scrollbar if needed
}

// ============================================================================
// COMBOBOX - Dropdown selection
// ============================================================================

struct ComboBox {
    base: WndElement,
    items: [String],
    selected_index: i32,
    is_open: Bool,
    max_visible_items: i32,
    dropdown_height: i32,
}

fn create_combo_box(name: String, rect: WndRect) -> ComboBox {
    let base = create_base_element(WndElementType::COMBOBOX, name, rect)
    return ComboBox {
        base: base,
        items: [],
        selected_index: -1,
        is_open: false,
        max_visible_items: 8,
        dropdown_height: 0,
    }
}

fn combo_box_add_item(cb: ComboBox, text: String) {
    cb.items = cb.items + [text]
    cb.dropdown_height = min_i32(cb.items.length, cb.max_visible_items) * 20
}

fn combo_box_select(cb: ComboBox, index: i32) {
    if index >= 0 && index < cb.items.length {
        cb.selected_index = index
        cb.is_open = false
    }
}

fn combo_box_toggle(cb: ComboBox) {
    cb.is_open = !cb.is_open
}

fn combo_box_get_selected(cb: ComboBox) -> String {
    if cb.selected_index >= 0 && cb.selected_index < cb.items.length {
        return cb.items[cb.selected_index]
    }
    return ""
}

fn render_combo_box(cb: ComboBox) {
    if !cb.base.is_visible {
        return
    }

    // Draw main button with selected text
    // Draw dropdown arrow
    // If open, draw dropdown list
}

// ============================================================================
// CHECKBOX - Toggle button with checkmark
// ============================================================================

struct CheckBox {
    base: WndElement,
    label: String,
    is_checked: Bool,
    check_size: i32,
}

fn create_check_box(name: String, rect: WndRect, label: String) -> CheckBox {
    let base = create_base_element(WndElementType::CHECKBOX, name, rect)
    return CheckBox {
        base: base,
        label: label,
        is_checked: false,
        check_size: 16,
    }
}

fn check_box_toggle(cb: CheckBox) {
    if cb.base.is_enabled {
        cb.is_checked = !cb.is_checked
    }
}

fn check_box_set(cb: CheckBox, checked: Bool) {
    cb.is_checked = checked
}

fn render_check_box(cb: CheckBox) {
    if !cb.base.is_visible {
        return
    }

    // Draw checkbox square
    // Draw checkmark if checked
    // Draw label text
}

// ============================================================================
// RADIOBUTTON - Mutually exclusive option
// ============================================================================

struct RadioButton {
    base: WndElement,
    label: String,
    is_selected: Bool,
    group_id: i32,  // Buttons in same group are mutually exclusive
    radio_size: i32,
}

fn create_radio_button(name: String, rect: WndRect, label: String, group: i32) -> RadioButton {
    let base = create_base_element(WndElementType::RADIOBUTTON, name, rect)
    return RadioButton {
        base: base,
        label: label,
        is_selected: false,
        group_id: group,
        radio_size: 16,
    }
}

fn radio_button_select(rb: RadioButton) {
    rb.is_selected = true
    // Other buttons in group should be deselected by the manager
}

fn render_radio_button(rb: RadioButton) {
    if !rb.base.is_visible {
        return
    }

    // Draw radio circle
    // Draw filled circle if selected
    // Draw label text
}

// ============================================================================
// SLIDER - Horizontal or vertical slider control
// ============================================================================

struct Slider {
    base: WndElement,
    min_value: f32,
    max_value: f32,
    current_value: f32,
    step: f32,
    is_vertical: Bool,
    thumb_size: i32,
    is_dragging: Bool,
}

fn create_slider(name: String, rect: WndRect, min_val: f32, max_val: f32, is_vert: Bool) -> Slider {
    let etype = if is_vert { WndElementType::VERTSLIDER } else { WndElementType::HORZSLIDER }
    let base = create_base_element(etype, name, rect)
    return Slider {
        base: base,
        min_value: min_val,
        max_value: max_val,
        current_value: min_val,
        step: (max_val - min_val) / 100.0,
        is_vertical: is_vert,
        thumb_size: 16,
        is_dragging: false,
    }
}

fn slider_set_value(slider: Slider, value: f32) {
    slider.current_value = clamp_f32(value, slider.min_value, slider.max_value)
}

fn slider_get_normalized(slider: Slider) -> f32 {
    let range = slider.max_value - slider.min_value
    if range <= 0.0 {
        return 0.0
    }
    return (slider.current_value - slider.min_value) / range
}

fn slider_set_from_position(slider: Slider, pos: i32) {
    let track_length: i32
    if slider.is_vertical {
        track_length = slider.base.rect.height - slider.thumb_size
    } else {
        track_length = slider.base.rect.width - slider.thumb_size
    }

    if track_length <= 0 {
        return
    }

    let normalized = (pos as f32) / (track_length as f32)
    let value = slider.min_value + normalized * (slider.max_value - slider.min_value)
    slider_set_value(slider, value)
}

fn render_slider(slider: Slider) {
    if !slider.base.is_visible {
        return
    }

    // Draw track background
    // Draw filled portion
    // Draw thumb at current position
}

// ============================================================================
// PROGRESSBAR - Progress indicator
// ============================================================================

struct ProgressBar {
    base: WndElement,
    min_value: f32,
    max_value: f32,
    current_value: f32,
    show_text: Bool,
    text_format: String,  // e.g., "{0}%" or "{0}/{1}"
    fill_color: WndColor,
    background_color: WndColor,
}

fn create_progress_bar(name: String, rect: WndRect) -> ProgressBar {
    let base = create_base_element(WndElementType::PROGRESSBAR, name, rect)
    return ProgressBar {
        base: base,
        min_value: 0.0,
        max_value: 100.0,
        current_value: 0.0,
        show_text: true,
        text_format: "{0}%",
        fill_color: color_green(),
        background_color: color_gray(),
    }
}

fn progress_bar_set_value(pb: ProgressBar, value: f32) {
    pb.current_value = clamp_f32(value, pb.min_value, pb.max_value)
}

fn progress_bar_get_percent(pb: ProgressBar) -> f32 {
    let range = pb.max_value - pb.min_value
    if range <= 0.0 {
        return 0.0
    }
    return (pb.current_value - pb.min_value) / range * 100.0
}

fn render_progress_bar(pb: ProgressBar) {
    if !pb.base.is_visible {
        return
    }

    // Draw background
    // Draw filled portion
    // Draw text if enabled
}

// ============================================================================
// TABCONTROL - Tabbed panel container
// ============================================================================

struct TabPage {
    title: String,
    content_id: i32,  // ID of the content window
    icon_name: String,
}

struct TabControl {
    base: WndElement,
    pages: [TabPage],
    selected_tab: i32,
    tab_height: i32,
    tab_width: i32,  // 0 = auto-size
}

fn create_tab_control(name: String, rect: WndRect) -> TabControl {
    let base = create_base_element(WndElementType::TABCONTROL, name, rect)
    return TabControl {
        base: base,
        pages: [],
        selected_tab: 0,
        tab_height: 25,
        tab_width: 0,
    }
}

fn tab_control_add_page(tc: TabControl, title: String, content_id: i32) {
    let page = TabPage {
        title: title,
        content_id: content_id,
        icon_name: "",
    }
    tc.pages = tc.pages + [page]
}

fn tab_control_select(tc: TabControl, index: i32) {
    if index >= 0 && index < tc.pages.length {
        tc.selected_tab = index
    }
}

fn render_tab_control(tc: TabControl) {
    if !tc.base.is_visible {
        return
    }

    // Draw tab bar background
    // Draw each tab (highlighted if selected)
    // Draw content area border
}

// ============================================================================
// PUSHBUTTON - Clickable button with states
// ============================================================================

struct PushButton {
    base: WndElement,
    text: String,
    icon_name: String,
    is_pressed: Bool,
    is_toggle: Bool,
    toggle_state: Bool,
}

fn create_push_button(name: String, rect: WndRect, text: String) -> PushButton {
    let base = create_base_element(WndElementType::PUSHBUTTON, name, rect)
    return PushButton {
        base: base,
        text: text,
        icon_name: "",
        is_pressed: false,
        is_toggle: false,
        toggle_state: false,
    }
}

fn push_button_press(btn: PushButton) {
    if btn.base.is_enabled {
        btn.is_pressed = true
    }
}

fn push_button_release(btn: PushButton) {
    if btn.is_pressed {
        btn.is_pressed = false
        if btn.is_toggle {
            btn.toggle_state = !btn.toggle_state
        }
        // Trigger click callback
        if btn.base.on_click != null {
            btn.base.on_click()
        }
    }
}

fn render_push_button(btn: PushButton) {
    if !btn.base.is_visible {
        return
    }

    // Determine which draw data to use
    // Draw background image/color
    // Draw border
    // Draw icon if present
    // Draw text
}

// ============================================================================
// Utility Functions
// ============================================================================

fn min_i32(a: i32, b: i32) -> i32 {
    if a < b { return a }
    return b
}

fn max_i32(a: i32, b: i32) -> i32 {
    if a > b { return a }
    return b
}

fn clamp_i32(x: i32, min_val: i32, max_val: i32) -> i32 {
    if x < min_val { return min_val }
    if x > max_val { return max_val }
    return x
}

fn clamp_f32(x: f32, min_val: f32, max_val: f32) -> f32 {
    if x < min_val { return min_val }
    if x > max_val { return max_val }
    return x
}

fn substring(s: String, start: i32, end: i32) -> String {
    // Placeholder - would use proper string slicing
    return s
}

fn char_to_string(c: u8) -> String {
    // Placeholder
    return ""
}

// ============================================================================
// Tests
// ============================================================================

fn test_static_text() -> Bool {
    let st = create_static_text("TestText", create_rect(0, 0, 100, 20), "Hello World")

    assert(st.text == "Hello World", "Text should be set")
    assert(st.base.is_visible, "Should be visible by default")

    set_static_text_content(st, "New Text")
    assert(st.text == "New Text", "Text should be updated")

    return true
}

fn test_entry_field() -> Bool {
    let ef = create_entry_field("TestEntry", create_rect(0, 0, 200, 24))

    assert(ef.text == "", "Should start empty")
    assert(ef.cursor_position == 0, "Cursor at start")

    entry_field_insert_char(ef, 65)  // 'A'
    assert(ef.cursor_position == 1, "Cursor should advance")

    entry_field_backspace(ef)
    assert(ef.cursor_position == 0, "Cursor should move back")

    return true
}

fn test_list_box() -> Bool {
    let lb = create_list_box("TestList", create_rect(0, 0, 150, 100))

    list_box_add_item(lb, "Item 1", 1)
    list_box_add_item(lb, "Item 2", 2)
    list_box_add_item(lb, "Item 3", 3)

    assert(lb.items.length == 3, "Should have 3 items")

    list_box_select(lb, 1)
    assert(lb.selected_index == 1, "Should select item 1")

    list_box_remove_item(lb, 0)
    assert(lb.items.length == 2, "Should have 2 items after removal")

    return true
}

fn test_combo_box() -> Bool {
    let cb = create_combo_box("TestCombo", create_rect(0, 0, 150, 24))

    combo_box_add_item(cb, "Option A")
    combo_box_add_item(cb, "Option B")

    combo_box_select(cb, 0)
    assert(combo_box_get_selected(cb) == "Option A", "Should select Option A")

    combo_box_toggle(cb)
    assert(cb.is_open, "Should be open")

    combo_box_toggle(cb)
    assert(!cb.is_open, "Should be closed")

    return true
}

fn test_check_box() -> Bool {
    let cb = create_check_box("TestCheck", create_rect(0, 0, 150, 20), "Enable Feature")

    assert(!cb.is_checked, "Should start unchecked")

    check_box_toggle(cb)
    assert(cb.is_checked, "Should be checked after toggle")

    check_box_set(cb, false)
    assert(!cb.is_checked, "Should be unchecked after set")

    return true
}

fn test_slider() -> Bool {
    let slider = create_slider("TestSlider", create_rect(0, 0, 200, 20), 0.0, 100.0, false)

    assert(slider.current_value == 0.0, "Should start at min")

    slider_set_value(slider, 50.0)
    assert(slider.current_value == 50.0, "Should be at 50")

    let norm = slider_get_normalized(slider)
    assert(norm == 0.5, "Normalized should be 0.5")

    return true
}

fn test_progress_bar() -> Bool {
    let pb = create_progress_bar("TestProgress", create_rect(0, 0, 200, 20))

    assert(pb.current_value == 0.0, "Should start at 0")

    progress_bar_set_value(pb, 75.0)
    let percent = progress_bar_get_percent(pb)
    assert(percent == 75.0, "Should be at 75%")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_static_text(), "StaticText test failed")
    assert(test_entry_field(), "EntryField test failed")
    assert(test_list_box(), "ListBox test failed")
    assert(test_combo_box(), "ComboBox test failed")
    assert(test_check_box(), "CheckBox test failed")
    assert(test_slider(), "Slider test failed")
    assert(test_progress_bar(), "ProgressBar test failed")
    return true
}
