// Menu Navigation System - Complete Main Menu Implementation
// Implements: SOLO PLAY, MULTIPLAYER, LOAD, OPTIONS, CREDITS, EXIT
// Based on original C&C Generals Zero Hour menu structure

import shell/wnd_elements
import shell/wnd_parser_enhanced

// ============================================================================
// Menu Screen Identifiers
// ============================================================================

enum MenuScreen {
    MAIN_MENU,
    SOLO_PLAY,
    CAMPAIGN_SELECT,
    SKIRMISH_SETUP,
    CHALLENGE_MODE,
    MULTIPLAYER,
    LAN_LOBBY,
    ONLINE_LOBBY,
    LOAD_GAME,
    OPTIONS,
    OPTIONS_GRAPHICS,
    OPTIONS_AUDIO,
    OPTIONS_CONTROLS,
    OPTIONS_GAME,
    CREDITS,
    EXIT_CONFIRM,
    MAP_SELECT,
    FACTION_SELECT,
    REPLAY_MENU,
}

// ============================================================================
// Menu Button Definitions
// ============================================================================

struct MenuButton {
    id: String,
    text: String,
    target_screen: MenuScreen,
    hotkey: u8,
    is_enabled: Bool,
    is_visible: Bool,
}

fn create_menu_button(id: String, text: String, target: MenuScreen, hotkey: u8) -> MenuButton {
    return MenuButton {
        id: id,
        text: text,
        target_screen: target,
        hotkey: hotkey,
        is_enabled: true,
        is_visible: true,
    }
}

// ============================================================================
// Main Menu Structure
// ============================================================================

struct MainMenuData {
    buttons: [MenuButton],
    selected_index: i32,
    animation_time: f32,
}

fn create_main_menu() -> MainMenuData {
    return MainMenuData {
        buttons: [
            create_menu_button("btn_solo", "SOLO PLAY", MenuScreen::SOLO_PLAY, 83),   // 'S'
            create_menu_button("btn_multi", "MULTIPLAYER", MenuScreen::MULTIPLAYER, 77),  // 'M'
            create_menu_button("btn_load", "LOAD GAME", MenuScreen::LOAD_GAME, 76),   // 'L'
            create_menu_button("btn_replay", "REPLAY", MenuScreen::REPLAY_MENU, 82),  // 'R'
            create_menu_button("btn_options", "OPTIONS", MenuScreen::OPTIONS, 79),    // 'O'
            create_menu_button("btn_credits", "CREDITS", MenuScreen::CREDITS, 67),    // 'C'
            create_menu_button("btn_exit", "EXIT GAME", MenuScreen::EXIT_CONFIRM, 27), // ESC
        ],
        selected_index: 0,
        animation_time: 0.0,
    }
}

// ============================================================================
// Solo Play Submenu
// ============================================================================

struct SoloPlayMenuData {
    buttons: [MenuButton],
    selected_index: i32,
}

fn create_solo_play_menu() -> SoloPlayMenuData {
    return SoloPlayMenuData {
        buttons: [
            create_menu_button("btn_campaign", "CAMPAIGN", MenuScreen::CAMPAIGN_SELECT, 67),  // 'C'
            create_menu_button("btn_skirmish", "SKIRMISH", MenuScreen::SKIRMISH_SETUP, 83),   // 'S'
            create_menu_button("btn_challenge", "GENERALS CHALLENGE", MenuScreen::CHALLENGE_MODE, 71), // 'G'
            create_menu_button("btn_back", "BACK", MenuScreen::MAIN_MENU, 27),  // ESC
        ],
        selected_index: 0,
    }
}

// ============================================================================
// Campaign Select
// ============================================================================

enum CampaignFaction {
    USA,
    CHINA,
    GLA,
}

struct CampaignData {
    faction: CampaignFaction,
    name: String,
    description: String,
    missions: [String],
    completed_missions: i32,
    is_unlocked: Bool,
}

fn create_usa_campaign() -> CampaignData {
    return CampaignData {
        faction: CampaignFaction::USA,
        name: "USA Campaign",
        description: "Defend freedom as the United States of America",
        missions: [
            "Mission 1: Guardian Angel",
            "Mission 2: Fire Base Phoenix",
            "Mission 3: Operation: Stormbringer",
            "Mission 4: Black Gold",
            "Mission 5: Blue Eagle",
            "Mission 6: Bitter Winter",
            "Mission 7: Desperate Union",
        ],
        completed_missions: 0,
        is_unlocked: true,
    }
}

fn create_china_campaign() -> CampaignData {
    return CampaignData {
        faction: CampaignFaction::CHINA,
        name: "China Campaign",
        description: "Crush the GLA menace as the People's Republic of China",
        missions: [
            "Mission 1: The Dragon Awakes",
            "Mission 2: Hong Kong Crisis",
            "Mission 3: A Flood of Violence",
            "Mission 4: Broken Alliances",
            "Mission 5: Scorched Earth",
            "Mission 6: Dead in Their Tracks",
            "Mission 7: Nuclear Winter",
        ],
        completed_missions: 0,
        is_unlocked: true,
    }
}

fn create_gla_campaign() -> CampaignData {
    return CampaignData {
        faction: CampaignFaction::GLA,
        name: "GLA Campaign",
        description: "Strike fear into the hearts of your enemies as the GLA",
        missions: [
            "Mission 1: Operation: Black Rain",
            "Mission 2: Lair of the Beast",
            "Mission 3: Jarmen Kell and the Forty Thieves",
            "Mission 4: Splinter Cell",
            "Mission 5: Toxic Waste",
            "Mission 6: Sneak Attack",
            "Mission 7: On the Waterfront",
        ],
        completed_missions: 0,
        is_unlocked: true,
    }
}

// ============================================================================
// Skirmish Setup
// ============================================================================

struct SkirmishPlayer {
    slot: i32,
    name: String,
    faction: String,
    color: i32,
    team: i32,
    start_position: i32,
    is_human: Bool,
    ai_difficulty: i32,  // 0=Easy, 1=Medium, 2=Hard, 3=Brutal
}

fn create_skirmish_player(slot: i32, name: String, is_human: Bool) -> SkirmishPlayer {
    return SkirmishPlayer {
        slot: slot,
        name: name,
        faction: "USA",
        color: slot,
        team: slot,
        start_position: slot,
        is_human: is_human,
        ai_difficulty: 1,
    }
}

struct SkirmishSettings {
    map_name: String,
    map_path: String,
    max_players: i32,
    starting_cash: i32,
    superweapons: Bool,
    unit_limit: i32,
    players: [SkirmishPlayer],
}

fn create_skirmish_settings() -> SkirmishSettings {
    return SkirmishSettings {
        map_name: "Desert Combat",
        map_path: "maps/skirmish/desertcombat.map",
        max_players: 8,
        starting_cash: 10000,
        superweapons: true,
        unit_limit: 1000,
        players: [
            create_skirmish_player(0, "Player 1", true),
            create_skirmish_player(1, "Easy AI", false),
        ],
    }
}

// ============================================================================
// Multiplayer Menu
// ============================================================================

struct MultiplayerMenuData {
    buttons: [MenuButton],
    selected_index: i32,
}

fn create_multiplayer_menu() -> MultiplayerMenuData {
    return MultiplayerMenuData {
        buttons: [
            create_menu_button("btn_lan", "NETWORK", MenuScreen::LAN_LOBBY, 78),     // 'N'
            create_menu_button("btn_online", "ONLINE", MenuScreen::ONLINE_LOBBY, 79), // 'O'
            create_menu_button("btn_back", "BACK", MenuScreen::MAIN_MENU, 27),       // ESC
        ],
        selected_index: 0,
    }
}

// ============================================================================
// Options Menu
// ============================================================================

struct OptionsMenuData {
    buttons: [MenuButton],
    selected_index: i32,
}

fn create_options_menu() -> OptionsMenuData {
    return OptionsMenuData {
        buttons: [
            create_menu_button("btn_graphics", "GRAPHICS", MenuScreen::OPTIONS_GRAPHICS, 71), // 'G'
            create_menu_button("btn_audio", "AUDIO", MenuScreen::OPTIONS_AUDIO, 65),          // 'A'
            create_menu_button("btn_controls", "CONTROLS", MenuScreen::OPTIONS_CONTROLS, 67), // 'C'
            create_menu_button("btn_game", "GAME", MenuScreen::OPTIONS_GAME, 71),             // 'G'
            create_menu_button("btn_back", "BACK", MenuScreen::MAIN_MENU, 27),                // ESC
        ],
        selected_index: 0,
    }
}

// ============================================================================
// Graphics Options
// ============================================================================

struct GraphicsOptions {
    resolution_index: i32,
    fullscreen: Bool,
    vsync: Bool,
    texture_quality: i32,      // 0=Low, 1=Medium, 2=High
    shader_quality: i32,       // 0=Low, 1=Medium, 2=High
    shadow_quality: i32,       // 0=Off, 1=Blob, 2=Full
    particle_density: i32,     // 0=Low, 1=Medium, 2=High
    tree_density: i32,         // 0=None, 1=Low, 2=Medium, 3=High
    terrain_detail: i32,       // 0=Low, 1=Medium, 2=High
    water_detail: i32,         // 0=Low, 1=High
    effects_detail: i32,       // 0=Low, 1=Medium, 2=High
    gamma: f32,
    brightness: f32,
}

fn default_graphics_options() -> GraphicsOptions {
    return GraphicsOptions {
        resolution_index: 1,   // 1024x768
        fullscreen: false,
        vsync: true,
        texture_quality: 2,
        shader_quality: 2,
        shadow_quality: 2,
        particle_density: 2,
        tree_density: 2,
        terrain_detail: 2,
        water_detail: 1,
        effects_detail: 2,
        gamma: 1.0,
        brightness: 1.0,
    }
}

// ============================================================================
// Audio Options
// ============================================================================

struct AudioOptions {
    master_volume: f32,
    music_volume: f32,
    effects_volume: f32,
    voice_volume: f32,
    ambient_volume: f32,
    movie_volume: f32,
    speaker_config: i32,  // 0=Stereo, 1=Headphones, 2=Surround, 3=5.1
    hw_acceleration: Bool,
    eax_effects: Bool,
}

fn default_audio_options() -> AudioOptions {
    return AudioOptions {
        master_volume: 0.8,
        music_volume: 0.7,
        effects_volume: 0.8,
        voice_volume: 0.9,
        ambient_volume: 0.6,
        movie_volume: 0.8,
        speaker_config: 0,
        hw_acceleration: true,
        eax_effects: false,
    }
}

// ============================================================================
// Control Options
// ============================================================================

struct KeyBinding {
    action: String,
    primary_key: i32,
    secondary_key: i32,
}

struct ControlOptions {
    scroll_speed: f32,
    mouse_sensitivity: f32,
    invert_middle_mouse: Bool,
    tooltips_enabled: Bool,
    alternate_mouse_setup: Bool,
    key_bindings: [KeyBinding],
}

fn default_control_options() -> ControlOptions {
    return ControlOptions {
        scroll_speed: 0.5,
        mouse_sensitivity: 0.5,
        invert_middle_mouse: false,
        tooltips_enabled: true,
        alternate_mouse_setup: false,
        key_bindings: [
            KeyBinding { action: "Select All Units", primary_key: 65, secondary_key: 0 },     // Ctrl+A
            KeyBinding { action: "Attack Move", primary_key: 65, secondary_key: 0 },          // A
            KeyBinding { action: "Stop", primary_key: 83, secondary_key: 0 },                 // S
            KeyBinding { action: "Guard", primary_key: 71, secondary_key: 0 },                // G
            KeyBinding { action: "Force Fire", primary_key: 70, secondary_key: 0 },           // F
            KeyBinding { action: "Scatter", primary_key: 88, secondary_key: 0 },              // X
            KeyBinding { action: "Reverse Move", primary_key: 68, secondary_key: 0 },         // D
            KeyBinding { action: "Create Group 1", primary_key: 49, secondary_key: 0 },       // Ctrl+1
            KeyBinding { action: "Select Group 1", primary_key: 49, secondary_key: 0 },       // 1
        ],
    }
}

// ============================================================================
// Game Options
// ============================================================================

struct GameOptions {
    difficulty: i32,           // 0=Easy, 1=Medium, 2=Hard, 3=Brutal
    auto_save: Bool,
    health_bars_mode: i32,     // 0=Selected, 1=Damaged, 2=Always
    building_occlusion: Bool,
    show_fog_of_war: Bool,
    cinematics_enabled: Bool,
    ideal_statistics: Bool,
}

fn default_game_options() -> GameOptions {
    return GameOptions {
        difficulty: 1,
        auto_save: true,
        health_bars_mode: 1,
        building_occlusion: true,
        show_fog_of_war: true,
        cinematics_enabled: true,
        ideal_statistics: false,
    }
}

// ============================================================================
// Save/Load Menu
// ============================================================================

struct SaveGameEntry {
    slot: i32,
    name: String,
    timestamp: String,
    mission_name: String,
    faction: String,
    difficulty: String,
    playtime: String,
    thumbnail_path: String,
    is_empty: Bool,
}

fn create_empty_save_slot(slot: i32) -> SaveGameEntry {
    return SaveGameEntry {
        slot: slot,
        name: "Empty Slot",
        timestamp: "",
        mission_name: "",
        faction: "",
        difficulty: "",
        playtime: "",
        thumbnail_path: "",
        is_empty: true,
    }
}

struct LoadGameMenuData {
    save_slots: [SaveGameEntry],
    selected_slot: i32,
    page: i32,
    slots_per_page: i32,
}

fn create_load_game_menu() -> LoadGameMenuData {
    let slots: [SaveGameEntry] = []
    for i in 0..10 {
        slots = slots + [create_empty_save_slot(i)]
    }
    return LoadGameMenuData {
        save_slots: slots,
        selected_slot: 0,
        page: 0,
        slots_per_page: 5,
    }
}

// ============================================================================
// Menu Manager
// ============================================================================

struct MenuManager {
    current_screen: MenuScreen,
    previous_screen: MenuScreen,
    screen_stack: [MenuScreen],
    stack_depth: i32,

    // Menu data
    main_menu: MainMenuData,
    solo_play_menu: SoloPlayMenuData,
    multiplayer_menu: MultiplayerMenuData,
    options_menu: OptionsMenuData,
    load_game_menu: LoadGameMenuData,

    // Settings
    graphics_options: GraphicsOptions,
    audio_options: AudioOptions,
    control_options: ControlOptions,
    game_options: GameOptions,

    // Skirmish state
    skirmish_settings: SkirmishSettings,

    // Campaign state
    campaigns: [CampaignData],

    // Callbacks
    on_start_game: fn(SkirmishSettings),
    on_start_campaign: fn(CampaignData, i32),
    on_load_game: fn(SaveGameEntry),
    on_exit: fn(),
}

fn create_menu_manager() -> MenuManager {
    return MenuManager {
        current_screen: MenuScreen::MAIN_MENU,
        previous_screen: MenuScreen::MAIN_MENU,
        screen_stack: [],
        stack_depth: 0,
        main_menu: create_main_menu(),
        solo_play_menu: create_solo_play_menu(),
        multiplayer_menu: create_multiplayer_menu(),
        options_menu: create_options_menu(),
        load_game_menu: create_load_game_menu(),
        graphics_options: default_graphics_options(),
        audio_options: default_audio_options(),
        control_options: default_control_options(),
        game_options: default_game_options(),
        skirmish_settings: create_skirmish_settings(),
        campaigns: [
            create_usa_campaign(),
            create_china_campaign(),
            create_gla_campaign(),
        ],
        on_start_game: null,
        on_start_campaign: null,
        on_load_game: null,
        on_exit: null,
    }
}

fn menu_navigate_to(mm: MenuManager, screen: MenuScreen) {
    mm.previous_screen = mm.current_screen
    mm.screen_stack = mm.screen_stack + [mm.current_screen]
    mm.stack_depth = mm.stack_depth + 1
    mm.current_screen = screen
}

fn menu_go_back(mm: MenuManager) {
    if mm.stack_depth > 0 {
        mm.stack_depth = mm.stack_depth - 1
        mm.current_screen = mm.screen_stack[mm.stack_depth]
        // Remove from stack
        let new_stack: [MenuScreen] = []
        for i in 0..mm.stack_depth {
            new_stack = new_stack + [mm.screen_stack[i]]
        }
        mm.screen_stack = new_stack
    }
}

fn menu_handle_input(mm: MenuManager, key: i32, is_mouse_click: Bool, mouse_x: i32, mouse_y: i32) {
    if mm.current_screen == MenuScreen::MAIN_MENU {
        handle_main_menu_input(mm, key, is_mouse_click)
    } else if mm.current_screen == MenuScreen::SOLO_PLAY {
        handle_solo_play_input(mm, key, is_mouse_click)
    } else if mm.current_screen == MenuScreen::MULTIPLAYER {
        handle_multiplayer_input(mm, key, is_mouse_click)
    } else if mm.current_screen == MenuScreen::OPTIONS {
        handle_options_input(mm, key, is_mouse_click)
    } else if mm.current_screen == MenuScreen::EXIT_CONFIRM {
        handle_exit_confirm_input(mm, key, is_mouse_click)
    }

    // Universal back key
    if key == 27 {  // ESC
        if mm.current_screen != MenuScreen::MAIN_MENU {
            menu_go_back(mm)
        }
    }
}

fn handle_main_menu_input(mm: MenuManager, key: i32, is_click: Bool) {
    let menu = mm.main_menu

    // Arrow key navigation
    if key == 38 {  // Up
        menu.selected_index = menu.selected_index - 1
        if menu.selected_index < 0 {
            menu.selected_index = menu.buttons.length - 1
        }
    } else if key == 40 {  // Down
        menu.selected_index = menu.selected_index + 1
        if menu.selected_index >= menu.buttons.length {
            menu.selected_index = 0
        }
    } else if key == 13 || is_click {  // Enter or click
        let button = menu.buttons[menu.selected_index]
        if button.is_enabled {
            menu_navigate_to(mm, button.target_screen)
        }
    }

    // Hotkey handling
    for i in 0..menu.buttons.length {
        if key == menu.buttons[i].hotkey && menu.buttons[i].is_enabled {
            menu_navigate_to(mm, menu.buttons[i].target_screen)
            break
        }
    }
}

fn handle_solo_play_input(mm: MenuManager, key: i32, is_click: Bool) {
    let menu = mm.solo_play_menu

    if key == 38 {
        menu.selected_index = menu.selected_index - 1
        if menu.selected_index < 0 {
            menu.selected_index = menu.buttons.length - 1
        }
    } else if key == 40 {
        menu.selected_index = menu.selected_index + 1
        if menu.selected_index >= menu.buttons.length {
            menu.selected_index = 0
        }
    } else if key == 13 || is_click {
        let button = menu.buttons[menu.selected_index]
        if button.is_enabled {
            if button.target_screen == MenuScreen::MAIN_MENU {
                menu_go_back(mm)
            } else {
                menu_navigate_to(mm, button.target_screen)
            }
        }
    }
}

fn handle_multiplayer_input(mm: MenuManager, key: i32, is_click: Bool) {
    let menu = mm.multiplayer_menu

    if key == 38 {
        menu.selected_index = menu.selected_index - 1
        if menu.selected_index < 0 {
            menu.selected_index = menu.buttons.length - 1
        }
    } else if key == 40 {
        menu.selected_index = menu.selected_index + 1
        if menu.selected_index >= menu.buttons.length {
            menu.selected_index = 0
        }
    } else if key == 13 || is_click {
        let button = menu.buttons[menu.selected_index]
        if button.is_enabled {
            if button.target_screen == MenuScreen::MAIN_MENU {
                menu_go_back(mm)
            } else {
                menu_navigate_to(mm, button.target_screen)
            }
        }
    }
}

fn handle_options_input(mm: MenuManager, key: i32, is_click: Bool) {
    let menu = mm.options_menu

    if key == 38 {
        menu.selected_index = menu.selected_index - 1
        if menu.selected_index < 0 {
            menu.selected_index = menu.buttons.length - 1
        }
    } else if key == 40 {
        menu.selected_index = menu.selected_index + 1
        if menu.selected_index >= menu.buttons.length {
            menu.selected_index = 0
        }
    } else if key == 13 || is_click {
        let button = menu.buttons[menu.selected_index]
        if button.is_enabled {
            if button.target_screen == MenuScreen::MAIN_MENU {
                menu_go_back(mm)
            } else {
                menu_navigate_to(mm, button.target_screen)
            }
        }
    }
}

fn handle_exit_confirm_input(mm: MenuManager, key: i32, is_click: Bool) {
    if key == 89 || key == 121 {  // 'Y' or 'y'
        if mm.on_exit != null {
            mm.on_exit()
        }
    } else if key == 78 || key == 110 || key == 27 {  // 'N' or 'n' or ESC
        menu_go_back(mm)
    }
}

fn get_current_screen_title(mm: MenuManager) -> String {
    if mm.current_screen == MenuScreen::MAIN_MENU {
        return "COMMAND & CONQUER: GENERALS - ZERO HOUR"
    } else if mm.current_screen == MenuScreen::SOLO_PLAY {
        return "SOLO PLAY"
    } else if mm.current_screen == MenuScreen::CAMPAIGN_SELECT {
        return "SELECT CAMPAIGN"
    } else if mm.current_screen == MenuScreen::SKIRMISH_SETUP {
        return "SKIRMISH SETUP"
    } else if mm.current_screen == MenuScreen::CHALLENGE_MODE {
        return "GENERALS CHALLENGE"
    } else if mm.current_screen == MenuScreen::MULTIPLAYER {
        return "MULTIPLAYER"
    } else if mm.current_screen == MenuScreen::LAN_LOBBY {
        return "NETWORK LOBBY"
    } else if mm.current_screen == MenuScreen::ONLINE_LOBBY {
        return "ONLINE LOBBY"
    } else if mm.current_screen == MenuScreen::LOAD_GAME {
        return "LOAD SAVED GAME"
    } else if mm.current_screen == MenuScreen::OPTIONS {
        return "OPTIONS"
    } else if mm.current_screen == MenuScreen::OPTIONS_GRAPHICS {
        return "GRAPHICS OPTIONS"
    } else if mm.current_screen == MenuScreen::OPTIONS_AUDIO {
        return "AUDIO OPTIONS"
    } else if mm.current_screen == MenuScreen::OPTIONS_CONTROLS {
        return "CONTROL OPTIONS"
    } else if mm.current_screen == MenuScreen::OPTIONS_GAME {
        return "GAME OPTIONS"
    } else if mm.current_screen == MenuScreen::CREDITS {
        return "CREDITS"
    } else if mm.current_screen == MenuScreen::EXIT_CONFIRM {
        return "EXIT GAME?"
    } else if mm.current_screen == MenuScreen::REPLAY_MENU {
        return "REPLAY VIEWER"
    }
    return ""
}

// ============================================================================
// Tests
// ============================================================================

fn test_menu_manager_creation() -> Bool {
    let mm = create_menu_manager()

    assert(mm.current_screen == MenuScreen::MAIN_MENU, "Should start at main menu")
    assert(mm.stack_depth == 0, "Stack should be empty")
    assert(mm.main_menu.buttons.length > 0, "Main menu should have buttons")

    return true
}

fn test_menu_navigation() -> Bool {
    let mm = create_menu_manager()

    menu_navigate_to(mm, MenuScreen::SOLO_PLAY)
    assert(mm.current_screen == MenuScreen::SOLO_PLAY, "Should be at solo play")
    assert(mm.stack_depth == 1, "Stack should have 1 item")

    menu_navigate_to(mm, MenuScreen::SKIRMISH_SETUP)
    assert(mm.current_screen == MenuScreen::SKIRMISH_SETUP, "Should be at skirmish")
    assert(mm.stack_depth == 2, "Stack should have 2 items")

    menu_go_back(mm)
    assert(mm.current_screen == MenuScreen::SOLO_PLAY, "Should be back at solo play")
    assert(mm.stack_depth == 1, "Stack should have 1 item")

    menu_go_back(mm)
    assert(mm.current_screen == MenuScreen::MAIN_MENU, "Should be back at main menu")
    assert(mm.stack_depth == 0, "Stack should be empty")

    return true
}

fn test_skirmish_settings() -> Bool {
    let settings = create_skirmish_settings()

    assert(settings.max_players == 8, "Max players should be 8")
    assert(settings.starting_cash == 10000, "Starting cash should be 10000")
    assert(settings.players.length == 2, "Should have 2 default players")
    assert(settings.players[0].is_human, "First player should be human")
    assert(!settings.players[1].is_human, "Second player should be AI")

    return true
}

fn test_campaign_data() -> Bool {
    let usa = create_usa_campaign()
    let china = create_china_campaign()
    let gla = create_gla_campaign()

    assert(usa.missions.length == 7, "USA should have 7 missions")
    assert(china.missions.length == 7, "China should have 7 missions")
    assert(gla.missions.length == 7, "GLA should have 7 missions")
    assert(usa.is_unlocked, "USA should be unlocked")

    return true
}

fn run_all_tests() -> Bool {
    assert(test_menu_manager_creation(), "Menu manager creation test failed")
    assert(test_menu_navigation(), "Menu navigation test failed")
    assert(test_skirmish_settings(), "Skirmish settings test failed")
    assert(test_campaign_data(), "Campaign data test failed")
    return true
}
