// C&C Generals Zero Hour - Home Port
// Main Entry Point
//
// Original: WinMain.cpp (Westwood Studios/EA)
// Ported to Home with cross-platform support

import basics/allocator
import core/memory
import core/string
import core/filesystem
import core/archive
import platform/window
import platform/input
import graphics/renderer
import graphics/w3d_loader

// Game configuration
const GAME_TITLE: string = "C&C Generals Zero Hour - Home Edition"
const WINDOW_WIDTH: u32 = 1920
const WINDOW_HEIGHT: u32 = 1080
const TARGET_FPS: u32 = 60

// Game state
struct GameState {
    is_running: bool
    is_paused: bool
    frame_count: u64
    delta_time: f32
    allocator: Allocator

    fn init(allocator: Allocator): GameState {
        return GameState {
            is_running: true
            is_paused: false
            frame_count: 0
            delta_time: 0.0
            allocator: allocator
        }
    }
}

// Initialize all game systems
fn init_systems(allocator: Allocator): bool {
    print("Initializing C&C Generals Zero Hour - Home Edition...")

    // Initialize core systems
    print("  - Initializing memory system...")
    init_memory(allocator)

    print("  - Initializing string pool...")
    init_string_pool(allocator)

    print("  - Initializing filesystem...")
    init_filesystem(allocator, "./")

    print("  - Initializing archive system...")
    init_archive_system(allocator)

    // Load game archives
    print("  - Loading game archives...")
    // load_archive("Data/Initial.big", 10)
    // load_archive("Data/Textures.big", 9)
    // load_archive("Data/W3D.big", 8)

    // Initialize platform layer
    print("  - Initializing window system...")
    init_window_system(allocator)

    print("  - Creating game window...")
    let window_config = WindowConfig {
        title: GAME_TITLE
        width: WINDOW_WIDTH
        height: WINDOW_HEIGHT
        x: -1  // Center on screen
        y: -1
        flags: WINDOW_VSYNC
        style: WindowStyle.Windowed
        monitor: null
    }

    if !create_window(allocator, window_config) {
        print("ERROR: Failed to create window!")
        return false
    }

    print("  - Initializing input system...")
    init_input(allocator)

    // Initialize graphics
    print("  - Initializing renderer...")
    // Detect best graphics API for platform
    let api = comptime if @import("builtin").os.tag == .windows {
        GraphicsAPI.DirectX12
    } else if @import("builtin").os.tag == .macos {
        GraphicsAPI.Metal
    } else {
        GraphicsAPI.Vulkan
    }

    if !init_renderer(allocator, api, WINDOW_WIDTH, WINDOW_HEIGHT) {
        print("ERROR: Failed to initialize renderer!")
        return false
    }

    print("  - Initializing W3D loader...")
    init_w3d_loader(allocator)

    print("All systems initialized successfully!")
    return true
}

// Shutdown all game systems
fn shutdown_systems() {
    print("Shutting down game systems...")

    shutdown_w3d_loader()
    shutdown_renderer()
    shutdown_input()
    close_window()
    shutdown_window_system()
    shutdown_archive_system()
    shutdown_filesystem()
    shutdown_string_pool()
    shutdown_memory()

    print("Shutdown complete.")
}

// Process input events
fn process_input(state: *GameState) {
    // Poll window events
    let window_events = poll_window_events()
    for event in window_events {
        match event {
            WindowEvent.Close => {
                state.is_running = false
            }
            WindowEvent.Resize { width, height } => {
                // Resize renderer
                print("Window resized: {}x{}", width, height)
            }
            WindowEvent.Focus { gained } => {
                if !gained {
                    state.is_paused = true
                } else {
                    state.is_paused = false
                }
            }
            _ => {}
        }
    }

    // Update input state
    update_input()

    // Process input events
    let input_events = get_input_events()
    for event in input_events {
        match event {
            InputEvent.KeyPress { key } => {
                // Handle key press
                if key == Key.Escape {
                    state.is_running = false
                }
                if key == Key.F11 {
                    // Toggle fullscreen
                }
                if key == Key.P {
                    state.is_paused = !state.is_paused
                }
            }
            InputEvent.MouseButtonPress { button, x, y } => {
                // Handle mouse click
            }
            _ => {}
        }
    }

    // Check keyboard state
    if is_key_down(Key.W) {
        // Move camera forward
    }
    if is_key_down(Key.S) {
        // Move camera backward
    }
    if is_key_down(Key.A) {
        // Move camera left
    }
    if is_key_down(Key.D) {
        // Move camera right
    }

    // Check mouse state
    let mouse_pos = get_mouse_position()
    let mouse_delta = get_mouse_delta()

    if is_mouse_button_down(MouseButton.Right) {
        // Rotate camera with mouse delta
    }

    let wheel = get_mouse_wheel()
    if wheel != 0 {
        // Zoom camera
    }

    // Check gamepad
    if is_gamepad_connected(0) {
        let left_stick = get_gamepad_left_stick(0)
        // Move with left stick

        let right_stick = get_gamepad_right_stick(0)
        // Rotate with right stick
    }
}

// Update game logic
fn update(state: *GameState, delta_time: f32) {
    if state.is_paused {
        return
    }

    state.delta_time = delta_time

    // TODO: Update game systems
    // - Update units
    // - Update AI
    // - Update physics
    // - Update particles
    // - Update audio
}

// Render frame
fn render(state: *GameState) {
    // Begin rendering
    begin_frame()

    // Clear screen
    // TODO: clear with color

    // Render game
    // TODO: Render terrain
    // TODO: Render units
    // TODO: Render buildings
    // TODO: Render effects
    // TODO: Render UI

    // End rendering and present
    end_frame()

    // Swap buffers
    swap_buffers()

    state.frame_count += 1
}

// Main game loop
fn game_loop(allocator: Allocator) {
    let mut state = GameState.init(allocator)
    let frame_time: f32 = 1.0 / @intToFloat(f32, TARGET_FPS)
    let mut last_time: f64 = 0.0  // TODO: Get current time

    print("Entering main game loop...")

    while state.is_running and is_window_open() {
        // Calculate delta time
        let current_time: f64 = 0.0  // TODO: Get current time
        let delta_time = @floatCast(f32, current_time - last_time)
        last_time = current_time

        // Process input
        process_input(&state)

        // Update game logic
        update(&state, delta_time)

        // Render frame
        render(&state)

        // Cap frame rate
        // TODO: Sleep if needed to maintain target FPS

        // Print stats every 60 frames
        if state.frame_count % 60 == 0 {
            let stats = get_render_stats()
            let memory_stats = get_memory_stats()

            print("Frame: {}, FPS: {:.1}, Triangles: {}, Draw Calls: {}",
                  state.frame_count,
                  1.0 / delta_time,
                  stats.triangle_count,
                  stats.draw_call_count)

            print("Memory: {} KB used, {} KB peak",
                  memory_stats.current_usage / 1024,
                  memory_stats.peak_usage / 1024)
        }
    }

    print("Exiting game loop.")
}

// Main entry point
export fn main(): i32 {
    print("===========================================")
    print("C&C Generals Zero Hour - Home Edition")
    print("===========================================")

    // Create allocator
    let allocator = Allocator.init()  // TODO: Use proper allocator

    // Initialize systems
    if !init_systems(allocator) {
        print("Failed to initialize game systems!")
        return 1
    }

    // Run game loop
    game_loop(allocator)

    // Shutdown systems
    shutdown_systems()

    print("Thanks for playing!")
    return 0
}
