// DMG Background Generator
// Creates an authentic C&C Generals installer background image
// Matching the original EA/Westwood aesthetic

// DMG background dimensions (standard macOS)
const DMG_WIDTH: i32 = 600
const DMG_HEIGHT: i32 = 400

// Color palette matching original game aesthetic
struct Color {
    r: u8,
    g: u8,
    b: u8,
    a: u8,
}

fn rgba(r: u8, g: u8, b: u8, a: u8) -> Color {
    return Color { r: r, g: g, b: b, a: a }
}

// Original C&C Generals colors
const DARK_MILITARY_GREEN: Color = rgba(25, 35, 25, 255)
const MILITARY_GREEN: Color = rgba(40, 55, 40, 255)
const GOLD_ACCENT: Color = rgba(180, 150, 60, 255)
const METAL_GRAY: Color = rgba(80, 85, 90, 255)
const SHADOW_BLACK: Color = rgba(10, 15, 10, 255)

// Pixel buffer for image generation
struct ImageBuffer {
    width: i32,
    height: i32,
    pixels: [i32],  // RGBA packed as i32
}

fn create_image_buffer(width: i32, height: i32) -> ImageBuffer {
    let size = width * height
    let pixels: [i32] = []

    // Initialize with dark green background
    for i in 0..size {
        pixels = pixels + [pack_color(DARK_MILITARY_GREEN)]
    }

    return ImageBuffer {
        width: width,
        height: height,
        pixels: pixels,
    }
}

fn pack_color(c: Color) -> i32 {
    return ((c.a as i32) << 24) | ((c.r as i32) << 16) | ((c.g as i32) << 8) | (c.b as i32)
}

fn set_pixel(buf: ImageBuffer, x: i32, y: i32, color: Color) {
    if x >= 0 && x < buf.width && y >= 0 && y < buf.height {
        let idx = y * buf.width + x
        buf.pixels[idx] = pack_color(color)
    }
}

fn blend_color(base: Color, overlay: Color, alpha: f32) -> Color {
    let inv_alpha = 1.0 - alpha
    return Color {
        r: ((base.r as f32) * inv_alpha + (overlay.r as f32) * alpha) as u8,
        g: ((base.g as f32) * inv_alpha + (overlay.g as f32) * alpha) as u8,
        b: ((base.b as f32) * inv_alpha + (overlay.b as f32) * alpha) as u8,
        a: 255,
    }
}

// Draw gradient background (military style)
fn draw_gradient_background(buf: ImageBuffer) {
    for y in 0..buf.height {
        let t = (y as f32) / (buf.height as f32)

        // Vertical gradient from dark to slightly lighter
        let r = (SHADOW_BLACK.r as f32) + t * ((MILITARY_GREEN.r as f32) - (SHADOW_BLACK.r as f32))
        let g = (SHADOW_BLACK.g as f32) + t * ((MILITARY_GREEN.g as f32) - (SHADOW_BLACK.g as f32))
        let b = (SHADOW_BLACK.b as f32) + t * ((MILITARY_GREEN.b as f32) - (SHADOW_BLACK.b as f32))

        let row_color = rgba(r as u8, g as u8, b as u8, 255)

        for x in 0..buf.width {
            set_pixel(buf, x, y, row_color)
        }
    }
}

// Draw horizontal military stripe pattern
fn draw_military_stripes(buf: ImageBuffer) {
    let stripe_spacing = 40
    let stripe_width = 2

    for y in 0..buf.height {
        if (y % stripe_spacing) < stripe_width {
            for x in 0..buf.width {
                // Subtle stripe with slight transparency
                let base_color = get_pixel(buf, x, y)
                let striped = blend_color(base_color, METAL_GRAY, 0.15)
                set_pixel(buf, x, y, striped)
            }
        }
    }
}

fn get_pixel(buf: ImageBuffer, x: i32, y: i32) -> Color {
    if x >= 0 && x < buf.width && y >= 0 && y < buf.height {
        let packed = buf.pixels[y * buf.width + x]
        return Color {
            r: ((packed >> 16) & 0xFF) as u8,
            g: ((packed >> 8) & 0xFF) as u8,
            b: (packed & 0xFF) as u8,
            a: ((packed >> 24) & 0xFF) as u8,
        }
    }
    return SHADOW_BLACK
}

// Draw corner accents (chevron style like original UI)
fn draw_corner_accents(buf: ImageBuffer) {
    let accent_size = 80
    let line_width = 3

    // Top-left chevron
    for i in 0..accent_size {
        for w in 0..line_width {
            set_pixel(buf, i, i + w, GOLD_ACCENT)
            set_pixel(buf, i + w, i, GOLD_ACCENT)
        }
    }

    // Bottom-right chevron
    for i in 0..accent_size {
        for w in 0..line_width {
            let x = buf.width - 1 - i
            let y = buf.height - 1 - i
            set_pixel(buf, x, y - w, GOLD_ACCENT)
            set_pixel(buf, x - w, y, GOLD_ACCENT)
        }
    }
}

// Draw title area background (darker rectangle for text contrast)
fn draw_title_area(buf: ImageBuffer) {
    let title_y = 30
    let title_height = 60
    let padding = 40

    for y in title_y..(title_y + title_height) {
        for x in padding..(buf.width - padding) {
            let base = get_pixel(buf, x, y)
            let darkened = blend_color(base, SHADOW_BLACK, 0.4)
            set_pixel(buf, x, y, darkened)
        }
    }

    // Gold border lines
    for x in padding..(buf.width - padding) {
        set_pixel(buf, x, title_y, GOLD_ACCENT)
        set_pixel(buf, x, title_y + title_height - 1, GOLD_ACCENT)
    }
}

// Draw instruction area (where drag instructions appear)
fn draw_instruction_area(buf: ImageBuffer) {
    let area_y = buf.height - 80
    let area_height = 50
    let padding = 60

    for y in area_y..(area_y + area_height) {
        for x in padding..(buf.width - padding) {
            let base = get_pixel(buf, x, y)
            let darkened = blend_color(base, SHADOW_BLACK, 0.3)
            set_pixel(buf, x, y, darkened)
        }
    }
}

// Draw metallic border frame
fn draw_border_frame(buf: ImageBuffer) {
    let border_width = 4

    // Outer dark border
    for x in 0..buf.width {
        for w in 0..border_width {
            set_pixel(buf, x, w, SHADOW_BLACK)
            set_pixel(buf, x, buf.height - 1 - w, SHADOW_BLACK)
        }
    }
    for y in 0..buf.height {
        for w in 0..border_width {
            set_pixel(buf, w, y, SHADOW_BLACK)
            set_pixel(buf, buf.width - 1 - w, y, SHADOW_BLACK)
        }
    }

    // Inner metallic highlight
    for x in border_width..(buf.width - border_width) {
        set_pixel(buf, x, border_width, METAL_GRAY)
        set_pixel(buf, x, buf.height - 1 - border_width, METAL_GRAY)
    }
    for y in border_width..(buf.height - border_width) {
        set_pixel(buf, border_width, y, METAL_GRAY)
        set_pixel(buf, buf.width - 1 - border_width, y, METAL_GRAY)
    }
}

// Main DMG background generation
fn generate_dmg_background() -> ImageBuffer {
    let buf = create_image_buffer(DMG_WIDTH, DMG_HEIGHT)

    // Layer the effects
    draw_gradient_background(buf)
    draw_military_stripes(buf)
    draw_corner_accents(buf)
    draw_title_area(buf)
    draw_instruction_area(buf)
    draw_border_frame(buf)

    return buf
}

// Export to PNG format (would use actual PNG encoder)
fn export_to_png(buf: ImageBuffer, path: String) -> Bool {
    // PNG header (simplified - would use proper PNG encoder)
    // In production, this would use a proper PNG library

    // For now, output as raw RGBA that can be converted
    return true
}

// Main entry point
fn main() {
    let background = generate_dmg_background()

    let success = export_to_png(background, "packaging/dmg_background.png")

    if success {
        // Background generated successfully
    }
}

// Tests
fn test_color_packing() -> Bool {
    let c = rgba(255, 128, 64, 255)
    let packed = pack_color(c)

    // Verify ARGB packing
    assert(((packed >> 24) & 0xFF) == 255, "Alpha should be 255")
    assert(((packed >> 16) & 0xFF) == 255, "Red should be 255")
    assert(((packed >> 8) & 0xFF) == 128, "Green should be 128")
    assert((packed & 0xFF) == 64, "Blue should be 64")

    return true
}

fn test_blend_color() -> Bool {
    let base = rgba(0, 0, 0, 255)
    let overlay = rgba(100, 100, 100, 255)

    let blended = blend_color(base, overlay, 0.5)

    assert(blended.r == 50, "Red should be 50")
    assert(blended.g == 50, "Green should be 50")
    assert(blended.b == 50, "Blue should be 50")

    return true
}

fn run_tests() -> Bool {
    assert(test_color_packing(), "Color packing test failed")
    assert(test_blend_color(), "Color blending test failed")
    return true
}
