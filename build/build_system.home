// C&C Generals Zero Hour - Home Port
// Build System
//
// Automated build system for compiling and packaging the game
// for all supported platforms (Windows, macOS, Linux).
//
// Build configurations:
// - Debug: Full debug symbols, no optimization, assertions enabled
// - Release: Optimized, minimal debug info, assertions disabled
// - Distribution: Release + packaging + installers
//
// Platform targets:
// - Windows (x64): .exe + DirectX 12/Vulkan
// - macOS (Apple Silicon + Intel): .app bundle + Metal
// - Linux (x64): ELF + Vulkan/OpenGL
//
// Output structure:
// ```
// dist/
// ├── windows/
// │   ├── generals.exe
// │   ├── Data/ (symlink to game assets)
// │   └── Setup.exe (installer)
// ├── macos/
// │   ├── Generals.app/
// │   └── Generals.dmg (installer)
// └── linux/
//     ├── generals
//     ├── Data/ (symlink)
//     └── generals.tar.gz (package)
// ```

import basics/allocator
import basics/string

// Build configuration
enum BuildConfig {
    Debug       // Debug symbols, no optimization
    Release     // Optimized, minimal debug
    Distribution // Release + installers
}

// Target platform
enum TargetPlatform {
    Windows
    MacOS
    Linux
    All
}

// Build options
struct BuildOptions {
    config: BuildConfig
    platform: TargetPlatform

    enable_tests: bool
    enable_benchmarks: bool

    output_dir: string

    fn init(): BuildOptions {
        return BuildOptions {
            config: BuildConfig.Release
            platform: TargetPlatform.All
            enable_tests: false
            enable_benchmarks: false
            output_dir: "dist"
        }
    }
}

// Build system
struct BuildSystem {
    options: BuildOptions
    allocator: Allocator

    fn init(allocator: Allocator, options: BuildOptions): BuildSystem {
        return BuildSystem {
            options: options
            allocator: allocator
        }
    }

    fn build(mut self): bool {
        println("\n" + "=".repeat(60))
        println("C&C GENERALS ZERO HOUR - BUILD SYSTEM")
        println("=".repeat(60))

        println("\nConfiguration: {self.options.config}")
        println("Platform: {self.options.platform}")
        println("Output Directory: {self.options.output_dir}")
        println("")

        // Create output directory
        if !self.create_output_directory() {
            return false
        }

        // Build for each platform
        let success = match self.options.platform {
            TargetPlatform.Windows => self.build_windows()
            TargetPlatform.MacOS => self.build_macos()
            TargetPlatform.Linux => self.build_linux()
            TargetPlatform.All => {
                self.build_windows() and
                self.build_macos() and
                self.build_linux()
            }
        }

        if success {
            println("\n✓ BUILD SUCCESSFUL")
        } else {
            println("\n✗ BUILD FAILED")
        }

        return success
    }

    fn create_output_directory(self): bool {
        println("Creating output directory: {self.options.output_dir}")

        // TODO: Create directory
        // create_directory(self.options.output_dir)

        return true
    }

    fn build_windows(self): bool {
        println("\n=== Building for Windows (x64) ===")

        // Compile flags
        let flags = self.get_compile_flags_windows()

        // Compile all modules
        println("Compiling modules...")
        // TODO: Run compiler
        // home build --target=windows-x64 {flags}

        // Copy executable to dist
        println("Copying executable...")
        // TODO: Copy file
        // copy_file("zig-out/bin/generals.exe", "{self.options.output_dir}/windows/generals.exe")

        // Create installer (if distribution build)
        if self.options.config == BuildConfig.Distribution {
            println("Creating Windows installer...")
            self.create_windows_installer()
        }

        println("✓ Windows build complete")
        return true
    }

    fn build_macos(self): bool {
        println("\n=== Building for macOS (Universal Binary) ===")

        // Compile flags
        let flags = self.get_compile_flags_macos()

        // Compile for Apple Silicon
        println("Compiling for Apple Silicon (arm64)...")
        // TODO: Run compiler
        // home build --target=macos-arm64 {flags}

        // Compile for Intel
        println("Compiling for Intel (x86_64)...")
        // TODO: Run compiler
        // home build --target=macos-x86_64 {flags}

        // Create universal binary
        println("Creating universal binary...")
        // TODO: Use lipo to combine
        // lipo -create generals-arm64 generals-x86_64 -output generals

        // Create .app bundle
        println("Creating .app bundle...")
        self.create_macos_app_bundle()

        // Create DMG installer (if distribution build)
        if self.options.config == BuildConfig.Distribution {
            println("Creating DMG installer...")
            self.create_macos_dmg()
        }

        println("✓ macOS build complete")
        return true
    }

    fn build_linux(self): bool {
        println("\n=== Building for Linux (x64) ===")

        // Compile flags
        let flags = self.get_compile_flags_linux()

        // Compile modules
        println("Compiling modules...")
        // TODO: Run compiler
        // home build --target=linux-x64 {flags}

        // Copy executable to dist
        println("Copying executable...")
        // TODO: Copy file
        // copy_file("zig-out/bin/generals", "{self.options.output_dir}/linux/generals")

        // Set executable permission
        // TODO: chmod +x
        // set_executable_permission("{self.options.output_dir}/linux/generals")

        // Create tar.gz package (if distribution build)
        if self.options.config == BuildConfig.Distribution {
            println("Creating tar.gz package...")
            self.create_linux_package()
        }

        println("✓ Linux build complete")
        return true
    }

    fn get_compile_flags_windows(self): string {
        let mut flags = ""

        match self.options.config {
            BuildConfig.Debug => {
                flags = "-O0 -g -DDEBUG"
            }
            BuildConfig.Release or BuildConfig.Distribution => {
                flags = "-O3 -DNDEBUG"
            }
        }

        return flags
    }

    fn get_compile_flags_macos(self): string {
        let mut flags = ""

        match self.options.config {
            BuildConfig.Debug => {
                flags = "-O0 -g -DDEBUG"
            }
            BuildConfig.Release or BuildConfig.Distribution => {
                flags = "-O3 -DNDEBUG"
            }
        }

        return flags
    }

    fn get_compile_flags_linux(self): string {
        let mut flags = ""

        match self.options.config {
            BuildConfig.Debug => {
                flags = "-O0 -g -DDEBUG"
            }
            BuildConfig.Release or BuildConfig.Distribution => {
                flags = "-O3 -DNDEBUG"
            }
        }

        return flags
    }

    fn create_windows_installer(self) {
        println("  Creating Windows installer (NSIS)...")

        // TODO: Generate NSIS script and compile
        // write_file("installer.nsi", nsis_script)
        // run_command("makensis installer.nsi")
    }

    fn create_macos_app_bundle(self) {
        println("  Creating .app bundle structure...")

        // TODO: Create .app bundle structure
        // create_directory("{self.options.output_dir}/macos/Generals.app/Contents/MacOS")
        // create_directory("{self.options.output_dir}/macos/Generals.app/Contents/Resources")

        // Copy executable
        // copy_file("generals", "{self.options.output_dir}/macos/Generals.app/Contents/MacOS/Generals")

        // Create Info.plist
        // write_file("{self.options.output_dir}/macos/Generals.app/Contents/Info.plist", plist_content)

        // Copy icon
        // copy_file("assets/icon.icns", "{self.options.output_dir}/macos/Generals.app/Contents/Resources/icon.icns")
    }

    fn create_macos_dmg(self) {
        println("  Creating DMG installer...")

        // TODO: Create DMG
        // run_command("hdiutil create -volname 'C&C Generals' -srcfolder {self.options.output_dir}/macos/Generals.app -ov -format UDZO Generals.dmg")
    }

    fn create_linux_package(self) {
        println("  Creating tar.gz package...")

        // TODO: Create tar.gz
        // run_command("tar -czf generals.tar.gz -C {self.options.output_dir}/linux .")
    }

    fn run_tests(self): bool {
        if !self.options.enable_tests {
            return true
        }

        println("\n=== Running Tests ===")

        // Run unit tests
        println("Running unit tests...")
        // TODO: Run tests
        // let unit_tests_passed = run_all_unit_tests()

        // Run integration tests
        println("Running integration tests...")
        // TODO: Run tests
        // let integration_tests_passed = run_all_integration_tests()

        // return unit_tests_passed and integration_tests_passed
        return true
    }

    fn run_benchmarks(self) {
        if !self.options.enable_benchmarks {
            return
        }

        println("\n=== Running Benchmarks ===")

        // TODO: Run benchmarks
        // run_all_benchmarks()
    }
}

// Build script entry point
export fn main() {
    let allocator = get_global_allocator()

    // Parse command line arguments
    let mut options = BuildOptions.init()

    // TODO: Parse args
    // let args = parse_args()
    // options.config = args.config
    // options.platform = args.platform

    // Create build system
    let build_system = BuildSystem.init(allocator, options)

    // Build
    let success = build_system.build()

    // Run tests (if enabled)
    if options.enable_tests {
        let tests_passed = build_system.run_tests()
        if !tests_passed {
            println("\n✗ TESTS FAILED")
            // Exit with error
        }
    }

    // Run benchmarks (if enabled)
    if options.enable_benchmarks {
        build_system.run_benchmarks()
    }

    if success {
        println("\n✓ ALL BUILD STEPS COMPLETE")
    } else {
        println("\n✗ BUILD FAILED")
    }
}

fn get_global_allocator(): Allocator {
    // TODO: Return global allocator
    return Allocator {}
}
